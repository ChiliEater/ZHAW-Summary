{"config":{"indexing":"full","lang":["en","de"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Summary In this repositories are all my summaries from ZHAW but also personal projects","title":"Summary"},{"location":"index.html#summary","text":"In this repositories are all my summaries from ZHAW but also personal projects","title":"Summary"},{"location":"21HS/AN1/01_funktionen.html","text":"Summenzeichen \\(\\sum\\limits_{k=1}^{5} 2\\cdot k\\) Das Summenzeichen ist eine Art For-Loop in Mathe. Folgendes Beispiel: \\(\\sum\\limits_{k=5}^{10} 2\\cdot k\\) kann zu folgendem Code \u00fcbersetzt werden: int sum = 0 for(int k = 5; k <= 10; k++) sum += 2*k; Wichtig: Die obere Limite ist inklusiv. Im oberen Beispiel wird \\(2\\cdot k\\) also 6x ausgef\u00fchrt. Recheregeln Mit den folgenden Recheregeln k\u00f6nnen Summen zusammengefasst oder aufgespalten werden \\(\\sum\\limits_{k=1}^5 (c\\cdot k) = c\\cdot \\sum\\limits_{k=1}^5 k\\) \\(\\sum\\limits_{k=1}^5 (2k + k^2) = \\sum\\limits_{k=1}^5 2k + \\sum\\limits_{k=1}^5 k^2\\) \\(\\sum\\limits_{k=1}^n k + \\sum\\limits_{k=n + 1}^m k = \\sum\\limits_{k=1}^m k\\) Achtung: \\(\\sum\\limits_{k=1}^5 (2k \\cdot k^2) \\neq (\\sum\\limits_{k=1}^5 2k) \\cdot (\\sum\\limits_{k=1}^5 k^2)\\) Ebenfalls ein n\u00fctzlicher Trick: \\(\\sum\\limits_{k=u}^n k = \\frac{(n-u+1)\\cdot (n + u)}{2}\\) In folgender Summe \\(\\sum\\limits_{k=2}^6 k\\) k\u00f6nnen wir feststellen, dass wenn wir die k der Reihe nach zusammen rechnen, dass es immer \\(2+6 = 8\\) gibt. Aufsteigende Reihe 2 3 4 5 6 Absteigende Reihe 6 5 4 3 2 Summe 8 8 8 8 8 Alls k\u00f6nnen wir auch 5-mal 8 rechnen und dies durch 2 teilen, da wir sonst zwei Reihen miteinander verrechnen.","title":"Summenzeichen"},{"location":"21HS/AN1/01_funktionen.html#summenzeichen","text":"\\(\\sum\\limits_{k=1}^{5} 2\\cdot k\\) Das Summenzeichen ist eine Art For-Loop in Mathe. Folgendes Beispiel: \\(\\sum\\limits_{k=5}^{10} 2\\cdot k\\) kann zu folgendem Code \u00fcbersetzt werden: int sum = 0 for(int k = 5; k <= 10; k++) sum += 2*k; Wichtig: Die obere Limite ist inklusiv. Im oberen Beispiel wird \\(2\\cdot k\\) also 6x ausgef\u00fchrt.","title":"Summenzeichen"},{"location":"21HS/AN1/01_funktionen.html#recheregeln","text":"Mit den folgenden Recheregeln k\u00f6nnen Summen zusammengefasst oder aufgespalten werden \\(\\sum\\limits_{k=1}^5 (c\\cdot k) = c\\cdot \\sum\\limits_{k=1}^5 k\\) \\(\\sum\\limits_{k=1}^5 (2k + k^2) = \\sum\\limits_{k=1}^5 2k + \\sum\\limits_{k=1}^5 k^2\\) \\(\\sum\\limits_{k=1}^n k + \\sum\\limits_{k=n + 1}^m k = \\sum\\limits_{k=1}^m k\\) Achtung: \\(\\sum\\limits_{k=1}^5 (2k \\cdot k^2) \\neq (\\sum\\limits_{k=1}^5 2k) \\cdot (\\sum\\limits_{k=1}^5 k^2)\\) Ebenfalls ein n\u00fctzlicher Trick: \\(\\sum\\limits_{k=u}^n k = \\frac{(n-u+1)\\cdot (n + u)}{2}\\) In folgender Summe \\(\\sum\\limits_{k=2}^6 k\\) k\u00f6nnen wir feststellen, dass wenn wir die k der Reihe nach zusammen rechnen, dass es immer \\(2+6 = 8\\) gibt. Aufsteigende Reihe 2 3 4 5 6 Absteigende Reihe 6 5 4 3 2 Summe 8 8 8 8 8 Alls k\u00f6nnen wir auch 5-mal 8 rechnen und dies durch 2 teilen, da wir sonst zwei Reihen miteinander verrechnen.","title":"Recheregeln"},{"location":"21HS/AN1/02_polynome.html","text":"Polynome Division Beispiel: \\((4x^5+6x^4-2x^3+x^2+5):(2x^2-x+3)\\) = ? Nun die f\u00fchrenden Potenzen dividieren: \\(4x^5:2x^2=2x^3\\) Dies ist nun der erste Term des resultats: Resultat: \\(2x^3+...\\) Nun muss das vom urspr\u00fcnglichen Polynom abgezogen werden. Daf\u00fcr \\(2x^3 \\cdot (2x^2-x+3)=4x^5-2x^3+6x^3\\) \\((4x^5+6x^4-2x^3+x^2+5) - (4x^5-2x^3+6x^3) = ()\\)","title":"Polynome Division"},{"location":"21HS/AN1/02_polynome.html#polynome-division","text":"Beispiel: \\((4x^5+6x^4-2x^3+x^2+5):(2x^2-x+3)\\) = ? Nun die f\u00fchrenden Potenzen dividieren: \\(4x^5:2x^2=2x^3\\) Dies ist nun der erste Term des resultats: Resultat: \\(2x^3+...\\) Nun muss das vom urspr\u00fcnglichen Polynom abgezogen werden. Daf\u00fcr \\(2x^3 \\cdot (2x^2-x+3)=4x^5-2x^3+6x^3\\) \\((4x^5+6x^4-2x^3+x^2+5) - (4x^5-2x^3+6x^3) = ()\\)","title":"Polynome Division"},{"location":"21HS/AN1/03_Ableiten.html","text":"Ableiten Fast an jede Funktion kann eine Tangente angelegt werden. Die Ableitung errechnet die Steilheit einer Tangente an jedem Ort.","title":"Ableiten"},{"location":"21HS/AN1/03_Ableiten.html#ableiten","text":"Fast an jede Funktion kann eine Tangente angelegt werden. Die Ableitung errechnet die Steilheit einer Tangente an jedem Ort.","title":"Ableiten"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html","tags":["summary","AN"],"text":"AN Summary 26.01.2022 AN Summary 26.01.2022 Ableiten Newton Verfahren Integrieren Reihen & Folgen Grenzwert Stetigkeit Nullstellen finden mit Stetigkeit Hornerschema Polynomdivision Extremwerte Wendepunkte und Sattelpunkte Fragen f\u00fcr die Kurvendiskussion Extremaufgaben Begriff Erkl\u00e4rung gerade Funktion Wenn der Graph achsensymmetrisch mit der y-Achse ist (wie bei \\(x^2\\) ) ungerade Funktion Wenn der Graph punktsymmetrisch mit dem Nullpunkt ist (wie bei \\(x^3\\) ) Komposition \\((g\\circ f)(x)=g(f(x))\\) Injektive Funktion Keine zwei \\(x\\) f\u00fchren zum selben \\(y\\) . Von einer injektiven Funktion gibt es eine Umkehrfunktion. \\(\\sum^5_{k=1}a_k\\) Addiert \\(a_k\\) bis (inklusiv) \\(5\\) : \\(a_1+a_2+a_3+a_4+a_5\\) \u00dcbliche Summenformeln \\(\\sum^n_{k=1}k=\\frac{n(n+1)}2\\) \\(\\sum^n_{k=1}k^2=\\frac{n(n+1)(2n+1)}6\\) Polynomfunktion \\(f(x)=a_n\\cdot x^n+a_{n-1}\\cdot x^{n-1}+..+a_1\\cdot x + a_0\\) Komposition \\((g\\circ f)(2)=g(f(2))\\) Funktion Mapt vom Definitionsbereich \\(D\\) zum Wertebereich \\(W\\) Mitternachtsformel \\(D=b^2-4ac\\) und \\(x=\\frac{-b\\pm \\sqrt D}{2a}\\) Ableiten Name Formel \\(x^k=k\\cdot x^{k-1}\\) Faktorregel \\((c\\cdot f)'(x)=c\\cdot f'(x)\\) Summenregel \\((f+g)'(x)=f'(x)+g'(x)\\) Produktregel \\((u\\cdot v)'(x)=u'(x)\\cdot v(x)+u(x)\\cdot v'(x)\\) Quotientenregel \\((\\frac u v)'(x)=\\frac{u'(x)\\cdot v(x)-u(x)\\cdot v'(x)}{v(x)^2}\\) Kettenregel \\((F\\circ u)'(x)=F'(x)\\cdot u'(x)\\) sin \\(sin(x)'=cos(x)\\) cos \\(cos(x)'=-sin(x)\\) \\(e^x\\) \\((e^x)'=e^x\\) \\((a^x)'\\) \\((a^x)'=a^x\\cdot \\ln(a)\\) \\(\\ln(x)'\\) \\(\\ln(x)'=\\frac 1 x\\) \\(\\log_a(x)'\\) \\(\\log_a(x)'=\\frac 1 {x\\cdot \\ln(a)}\\) Funktionsgleichung f\u00fcr Tangente \\(y(x)=f'(x_0)\\cdot (x-x_0)+f(x_0)\\) Achtung : Nicht jede Funktion ist differenzierbar. Die Ableitung einer Funktion darf keine pl\u00f6tzliche Spr\u00fcnge machen Newton Verfahren \\(x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\) Integrieren Ableiten: \\(a\\cdot x^n\\rightarrow \\frac{a}{n+1}\\cdot x^{n+1}\\) Schreibweise von Integral von der Fl\u00e4che zwischen \\([a;b]\\) : \\(\\int^b_a f(x) \\mathrm d x =F(b)-F(a)\\) $ \\(\\int a^x \\mathrm d x =\\frac {a^x}{\\ln(a)} + C\\) \\(\\int \\ln(x)\\mathrm dx=x\\cdot \\ln(x)-x + C\\) \\(\\int \\log_a(x)\\mathrm dx=\\frac 1 {\\ln(a)}\\cdot (x \\cdot \\ln(x) -x) + C\\) \\(\\int \\sin(x)\\mathrm dx=-\\cos(x)+C\\) \\(\\int \\cos(x)\\mathrm dx=\\sin(x)+C\\) \\(\\int \\tan(x)\\mathrm dx = -\\ln |\\cos(x)|+C\\) \\(\\int u^{-1}\\mathrm dx=\\ln(|u|)\\) Reihen & Folgen Name explizite Darstellung implizite Darstellung aufz\u00e4hlende Darstellung Arithmetische Folge \\(a_n=c+(n-1)\\cdot d\\) \\(a_1=c\\\\a_{n+1}=a_n+d\\) \\(c,c+d,c+2d,c+3d,...\\) Geometrische Folge \\(a_n=c\\cdot q^{n-1}\\) \\(a_1=c\\\\a_{n+1}=q\\cdot a_n\\) \\(c, c\\cdot q, c\\cdot q^2, c\\cdot q^3, ...\\) Harmonische Folge \\(a_n=\\frac 1 n\\) (nicht \u00fcblich) \\(1, \\frac 1 2, \\frac 1 3, \\frac 1 4, ...\\) Fibonacci-Folge (nicht elementar) \\(a_1=1, a_2=1\\\\a_{n+1}=a_n+a_{n+1}\\) \\(1, 1, 2, 3, 5, 8, ...\\) Arithmetische Reihee \\(a_k=a_1+(k-1)\\cdot d\\) \\(s_n=n\\cdot a_1+\\frac{n(n-1)}2 \\cdot d\\) \\(\\sum^n_{k=0}(k^2)=\\frac{n(n+1)(2n+1)}{6}\\) \\(\\sum^n_{k=0}k=\\frac{n(n+1)}{2}\\) Strebt immer geben \\(\\infty\\) oder \\(-\\infty\\) Geometrische Reihe \\(a_n=q^{(k-1)}\\cdot a_1\\) \\(s_n=\\frac{a_1(q^n-1)}{q-1}\\) Wenn \\(|q|<1\\) ist, dann ist der Grenzwert \\(\\frac {a_1}{1-q}\\) Grenzwert \\(\\lim_{n\\to\\infty}(c\\cdot a_n)=c\\cdot \\lim_{n\\to \\infty} a_n\\) \\(\\lim_{n\\to \\infty}(a_n+b_n)=\\lim_{n\\to \\infty}=\\lim_{n\\to \\infty}a_n + \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(a_b\\cdot b_n)=\\lim_{n\\to \\infty}a_b \\cdot \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(\\frac {a_n} {b_n})=\\lim_{n\\to \\infty} a_n : \\lim_{n\\to \\infty}b_n\\) \\(\\lim_{n\\to\\infty}(\\sqrt a - \\sqrt b)=\\lim_{n\\to\\infty}(\\frac{(\\sqrt a-\\sqrt b)(\\sqrt a + \\sqrt b)}{\\sqrt a + \\sqrt b})=\\lim_{n\\to\\infty}(\\frac{a-b}{\\sqrt a + \\sqrt b})\\) Wenn man einen Bruch in einem \\(\\lim\\) hat, dann kann mit dem h\u00f6chsten \\(n^k\\) mit dem h\u00f6chsten \\(k\\) gek\u00fcrzt werden Beispiel: $$ \\lim_{n\\to \\infty}=\\frac{3n^2+7n-3}{n^2+4n-11}=\\lim_{n\\to \\infty}\\frac{n^2(3+\\frac 7 n-\\frac 3 {n^2})}{n^2(1+\\frac 4 n - \\frac {11} {n^2})}\\rightarrow\\frac {3+0+0}{1+0+0}=\\frac 3 1 = 3 $$ Spezialfall: \\(\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\) $$ \\text{Speziallfall: }\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\ \\text{Beispiel: } \\lim_{n\\to\\infty}(1+\\frac{9}{4n})^{-5n}\\ (1+\\frac{9}{4n})^{-5n}=(1+\\frac{9}{4n}\\cdot\\frac{\\frac 1 9}{\\frac 1 9})^{-5n}=(1+\\frac 1 {\\frac {4n} 9})^{-5n}\\=(1+\\frac 1 {\\frac {4n} 9})^{-5n\\cdot\\frac{\\frac{4n} 9}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9\\cdot \\frac{-5n}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac {4n} 9\\cdot \\frac{-45} 4}\\=((1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9})^{\\frac{-45} 4}=e^{\\frac{-45} 4} $$ Typ Funktionswert Beispiel Typ 1 : Hebbare Definitionsl\u00fccke Das Z\u00e4hler- und Nennerpolynom haben dieselbe Nullstelle. Diese kann gek\u00fcrzt werden Strebt gegen den gek\u00fcrzten Bruch Typ 2: Polstelle Nur das Nennerpolynom hat die Nullstelle. Dies kann nicht gek\u00fcrzt werden Strebt gegen \\(\\infty\\) oder \\(-\\infty\\) Stetigkeit Eine Funktion ist stetig, wenn man sie zeichnen kann, ohne den Stift abzusetetzen. Eine stetige Funktion hat keine Spr\u00fcnge in der ersten Ableitung und keine Spr\u00fcnge in der eigentlichen Funktion. Nullstellen finden mit Stetigkeit Zwei Punkte, bei denen der Y-Wert ein verschiedenes Vorzeichen hat Den Mittelwert zischen den Punkten bilden Zu 1. gehen, aber diesem mit dem Mittelpunkt als Punkt, so dass die zwei P\u00fcnkte ein verschiedenes Vorzeichen haben Hornerschema Die Werte ( \\(b_n\\) ), welche unter dem Strich stehen, sind die Koeffizenten f\u00fcr das \\(q(x)\\) in \\(f(x)=(x-x_0)\\cdot q(x)\\) . In diesem fall also \\(q(x)=3x^3-8x^2+21x-49\\) . Daf\u00fcr muss das Resultat/Rest 0 sein! Polynomdivision Extremwerte 1. Ableitung 2. Ableitung Beschreibung Bild \\(f'(x)>0\\) \\(f''(x_0)>0\\) \\(f\\) macht eine Linkskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)>0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)>0\\) \\(f\\) nmacht eine Linkskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)<0\\) \\(f\\) hat ein lokales Maximum bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)>0\\) \\(f\\) hat ein lokales Minimum bei \\((x_0, y_0)\\) \\(x_0\\) heisst \\(f(x_0)\\) heisst \\((x_0, y_0)\\) heisst Maxiumum (relative) Maximalstelle (relatives) Maximum/Maximalwert (relativer) Hochpunkt Minimum (relative) Minimalstelle (relatives) Minimum/Minimalwert (relativer) Tiefpunkt Oberbegriff (relative) Extremalstelle (relatives) Extremum/Extremalwert (relativer) Extremalpunkt Wendepunkte und Sattelpunkte Eine Wendepunkt, ist wenn eine Rechtskurve in eine Linkskurve, oder umgekehrt, geht. Ein Spezialfall ist es, wenn \\(f'(x)=0\\) ist, dann spricht man von einem Sattelpunkt . Wenn \\(f''(x_0)=0\\) und \\(f'''(x_0)\\neq 0\\) ist, dann ist es sicherlich einen Wendepunkt . Wenn zus\u00e4tzlich noch \\(f'(x_0)=0\\) gilt, dann ist es ein Sattelpunkt Fragen f\u00fcr die Kurvendiskussion Definitionsbereich? Symmetrieeigenschaften (gerade/ungerade), Periode? Schnittpunkte mit Achsen, Polstellen? Randpunkte, bzw. Verhalten, wenn \\(x\\) gegen die Grenzen des Definitionsbereichs strebt? Kandidaten f\u00fcr Extrema bestimmen und untersuchen Wendepunkte suchen Tabelle von Werten aufstellen (falls noch n\u00f6tig) Extremaufgaben Zielgr\u00f6sse identifizieren Unabh\u00e4ngige Variable identifizieren Definitionsbereich bestimmen Zielgr\u00f6sse als Funktion mit unabh\u00e4ngigen Variabeln als Argument ausdr\u00fccken Relative Maxima/Minima bestimmen; Randpunkte auch ber\u00fcrcksichtigen! Welche relative Extrema sind auch absolute?","title":"AN Summary"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#an-summary-26012022","text":"AN Summary 26.01.2022 Ableiten Newton Verfahren Integrieren Reihen & Folgen Grenzwert Stetigkeit Nullstellen finden mit Stetigkeit Hornerschema Polynomdivision Extremwerte Wendepunkte und Sattelpunkte Fragen f\u00fcr die Kurvendiskussion Extremaufgaben Begriff Erkl\u00e4rung gerade Funktion Wenn der Graph achsensymmetrisch mit der y-Achse ist (wie bei \\(x^2\\) ) ungerade Funktion Wenn der Graph punktsymmetrisch mit dem Nullpunkt ist (wie bei \\(x^3\\) ) Komposition \\((g\\circ f)(x)=g(f(x))\\) Injektive Funktion Keine zwei \\(x\\) f\u00fchren zum selben \\(y\\) . Von einer injektiven Funktion gibt es eine Umkehrfunktion. \\(\\sum^5_{k=1}a_k\\) Addiert \\(a_k\\) bis (inklusiv) \\(5\\) : \\(a_1+a_2+a_3+a_4+a_5\\) \u00dcbliche Summenformeln \\(\\sum^n_{k=1}k=\\frac{n(n+1)}2\\) \\(\\sum^n_{k=1}k^2=\\frac{n(n+1)(2n+1)}6\\) Polynomfunktion \\(f(x)=a_n\\cdot x^n+a_{n-1}\\cdot x^{n-1}+..+a_1\\cdot x + a_0\\) Komposition \\((g\\circ f)(2)=g(f(2))\\) Funktion Mapt vom Definitionsbereich \\(D\\) zum Wertebereich \\(W\\) Mitternachtsformel \\(D=b^2-4ac\\) und \\(x=\\frac{-b\\pm \\sqrt D}{2a}\\)","title":"AN Summary 26.01.2022"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#ableiten","text":"Name Formel \\(x^k=k\\cdot x^{k-1}\\) Faktorregel \\((c\\cdot f)'(x)=c\\cdot f'(x)\\) Summenregel \\((f+g)'(x)=f'(x)+g'(x)\\) Produktregel \\((u\\cdot v)'(x)=u'(x)\\cdot v(x)+u(x)\\cdot v'(x)\\) Quotientenregel \\((\\frac u v)'(x)=\\frac{u'(x)\\cdot v(x)-u(x)\\cdot v'(x)}{v(x)^2}\\) Kettenregel \\((F\\circ u)'(x)=F'(x)\\cdot u'(x)\\) sin \\(sin(x)'=cos(x)\\) cos \\(cos(x)'=-sin(x)\\) \\(e^x\\) \\((e^x)'=e^x\\) \\((a^x)'\\) \\((a^x)'=a^x\\cdot \\ln(a)\\) \\(\\ln(x)'\\) \\(\\ln(x)'=\\frac 1 x\\) \\(\\log_a(x)'\\) \\(\\log_a(x)'=\\frac 1 {x\\cdot \\ln(a)}\\) Funktionsgleichung f\u00fcr Tangente \\(y(x)=f'(x_0)\\cdot (x-x_0)+f(x_0)\\) Achtung : Nicht jede Funktion ist differenzierbar. Die Ableitung einer Funktion darf keine pl\u00f6tzliche Spr\u00fcnge machen","title":"Ableiten"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#newton-verfahren","text":"\\(x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\)","title":"Newton Verfahren"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#integrieren","text":"Ableiten: \\(a\\cdot x^n\\rightarrow \\frac{a}{n+1}\\cdot x^{n+1}\\) Schreibweise von Integral von der Fl\u00e4che zwischen \\([a;b]\\) : \\(\\int^b_a f(x) \\mathrm d x =F(b)-F(a)\\) $ \\(\\int a^x \\mathrm d x =\\frac {a^x}{\\ln(a)} + C\\) \\(\\int \\ln(x)\\mathrm dx=x\\cdot \\ln(x)-x + C\\) \\(\\int \\log_a(x)\\mathrm dx=\\frac 1 {\\ln(a)}\\cdot (x \\cdot \\ln(x) -x) + C\\) \\(\\int \\sin(x)\\mathrm dx=-\\cos(x)+C\\) \\(\\int \\cos(x)\\mathrm dx=\\sin(x)+C\\) \\(\\int \\tan(x)\\mathrm dx = -\\ln |\\cos(x)|+C\\) \\(\\int u^{-1}\\mathrm dx=\\ln(|u|)\\)","title":"Integrieren"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#reihen-folgen","text":"Name explizite Darstellung implizite Darstellung aufz\u00e4hlende Darstellung Arithmetische Folge \\(a_n=c+(n-1)\\cdot d\\) \\(a_1=c\\\\a_{n+1}=a_n+d\\) \\(c,c+d,c+2d,c+3d,...\\) Geometrische Folge \\(a_n=c\\cdot q^{n-1}\\) \\(a_1=c\\\\a_{n+1}=q\\cdot a_n\\) \\(c, c\\cdot q, c\\cdot q^2, c\\cdot q^3, ...\\) Harmonische Folge \\(a_n=\\frac 1 n\\) (nicht \u00fcblich) \\(1, \\frac 1 2, \\frac 1 3, \\frac 1 4, ...\\) Fibonacci-Folge (nicht elementar) \\(a_1=1, a_2=1\\\\a_{n+1}=a_n+a_{n+1}\\) \\(1, 1, 2, 3, 5, 8, ...\\) Arithmetische Reihee \\(a_k=a_1+(k-1)\\cdot d\\) \\(s_n=n\\cdot a_1+\\frac{n(n-1)}2 \\cdot d\\) \\(\\sum^n_{k=0}(k^2)=\\frac{n(n+1)(2n+1)}{6}\\) \\(\\sum^n_{k=0}k=\\frac{n(n+1)}{2}\\) Strebt immer geben \\(\\infty\\) oder \\(-\\infty\\) Geometrische Reihe \\(a_n=q^{(k-1)}\\cdot a_1\\) \\(s_n=\\frac{a_1(q^n-1)}{q-1}\\) Wenn \\(|q|<1\\) ist, dann ist der Grenzwert \\(\\frac {a_1}{1-q}\\)","title":"Reihen &amp; Folgen"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#grenzwert","text":"\\(\\lim_{n\\to\\infty}(c\\cdot a_n)=c\\cdot \\lim_{n\\to \\infty} a_n\\) \\(\\lim_{n\\to \\infty}(a_n+b_n)=\\lim_{n\\to \\infty}=\\lim_{n\\to \\infty}a_n + \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(a_b\\cdot b_n)=\\lim_{n\\to \\infty}a_b \\cdot \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(\\frac {a_n} {b_n})=\\lim_{n\\to \\infty} a_n : \\lim_{n\\to \\infty}b_n\\) \\(\\lim_{n\\to\\infty}(\\sqrt a - \\sqrt b)=\\lim_{n\\to\\infty}(\\frac{(\\sqrt a-\\sqrt b)(\\sqrt a + \\sqrt b)}{\\sqrt a + \\sqrt b})=\\lim_{n\\to\\infty}(\\frac{a-b}{\\sqrt a + \\sqrt b})\\) Wenn man einen Bruch in einem \\(\\lim\\) hat, dann kann mit dem h\u00f6chsten \\(n^k\\) mit dem h\u00f6chsten \\(k\\) gek\u00fcrzt werden Beispiel: $$ \\lim_{n\\to \\infty}=\\frac{3n^2+7n-3}{n^2+4n-11}=\\lim_{n\\to \\infty}\\frac{n^2(3+\\frac 7 n-\\frac 3 {n^2})}{n^2(1+\\frac 4 n - \\frac {11} {n^2})}\\rightarrow\\frac {3+0+0}{1+0+0}=\\frac 3 1 = 3 $$ Spezialfall: \\(\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\) $$ \\text{Speziallfall: }\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\ \\text{Beispiel: } \\lim_{n\\to\\infty}(1+\\frac{9}{4n})^{-5n}\\ (1+\\frac{9}{4n})^{-5n}=(1+\\frac{9}{4n}\\cdot\\frac{\\frac 1 9}{\\frac 1 9})^{-5n}=(1+\\frac 1 {\\frac {4n} 9})^{-5n}\\=(1+\\frac 1 {\\frac {4n} 9})^{-5n\\cdot\\frac{\\frac{4n} 9}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9\\cdot \\frac{-5n}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac {4n} 9\\cdot \\frac{-45} 4}\\=((1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9})^{\\frac{-45} 4}=e^{\\frac{-45} 4} $$ Typ Funktionswert Beispiel Typ 1 : Hebbare Definitionsl\u00fccke Das Z\u00e4hler- und Nennerpolynom haben dieselbe Nullstelle. Diese kann gek\u00fcrzt werden Strebt gegen den gek\u00fcrzten Bruch Typ 2: Polstelle Nur das Nennerpolynom hat die Nullstelle. Dies kann nicht gek\u00fcrzt werden Strebt gegen \\(\\infty\\) oder \\(-\\infty\\)","title":"Grenzwert"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#stetigkeit","text":"Eine Funktion ist stetig, wenn man sie zeichnen kann, ohne den Stift abzusetetzen. Eine stetige Funktion hat keine Spr\u00fcnge in der ersten Ableitung und keine Spr\u00fcnge in der eigentlichen Funktion.","title":"Stetigkeit"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#nullstellen-finden-mit-stetigkeit","text":"Zwei Punkte, bei denen der Y-Wert ein verschiedenes Vorzeichen hat Den Mittelwert zischen den Punkten bilden Zu 1. gehen, aber diesem mit dem Mittelpunkt als Punkt, so dass die zwei P\u00fcnkte ein verschiedenes Vorzeichen haben","title":"Nullstellen finden mit Stetigkeit"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#hornerschema","text":"Die Werte ( \\(b_n\\) ), welche unter dem Strich stehen, sind die Koeffizenten f\u00fcr das \\(q(x)\\) in \\(f(x)=(x-x_0)\\cdot q(x)\\) . In diesem fall also \\(q(x)=3x^3-8x^2+21x-49\\) . Daf\u00fcr muss das Resultat/Rest 0 sein!","title":"Hornerschema"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#polynomdivision","text":"","title":"Polynomdivision"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#extremwerte","text":"1. Ableitung 2. Ableitung Beschreibung Bild \\(f'(x)>0\\) \\(f''(x_0)>0\\) \\(f\\) macht eine Linkskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)>0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)>0\\) \\(f\\) nmacht eine Linkskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)<0\\) \\(f\\) hat ein lokales Maximum bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)>0\\) \\(f\\) hat ein lokales Minimum bei \\((x_0, y_0)\\) \\(x_0\\) heisst \\(f(x_0)\\) heisst \\((x_0, y_0)\\) heisst Maxiumum (relative) Maximalstelle (relatives) Maximum/Maximalwert (relativer) Hochpunkt Minimum (relative) Minimalstelle (relatives) Minimum/Minimalwert (relativer) Tiefpunkt Oberbegriff (relative) Extremalstelle (relatives) Extremum/Extremalwert (relativer) Extremalpunkt","title":"Extremwerte"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#wendepunkte-und-sattelpunkte","text":"Eine Wendepunkt, ist wenn eine Rechtskurve in eine Linkskurve, oder umgekehrt, geht. Ein Spezialfall ist es, wenn \\(f'(x)=0\\) ist, dann spricht man von einem Sattelpunkt . Wenn \\(f''(x_0)=0\\) und \\(f'''(x_0)\\neq 0\\) ist, dann ist es sicherlich einen Wendepunkt . Wenn zus\u00e4tzlich noch \\(f'(x_0)=0\\) gilt, dann ist es ein Sattelpunkt","title":"Wendepunkte und Sattelpunkte"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#fragen-fur-die-kurvendiskussion","text":"Definitionsbereich? Symmetrieeigenschaften (gerade/ungerade), Periode? Schnittpunkte mit Achsen, Polstellen? Randpunkte, bzw. Verhalten, wenn \\(x\\) gegen die Grenzen des Definitionsbereichs strebt? Kandidaten f\u00fcr Extrema bestimmen und untersuchen Wendepunkte suchen Tabelle von Werten aufstellen (falls noch n\u00f6tig)","title":"Fragen f\u00fcr die Kurvendiskussion"},{"location":"21HS/AN1/summaries/summary_2022_01_26.html#extremaufgaben","text":"Zielgr\u00f6sse identifizieren Unabh\u00e4ngige Variable identifizieren Definitionsbereich bestimmen Zielgr\u00f6sse als Funktion mit unabh\u00e4ngigen Variabeln als Argument ausdr\u00fccken Relative Maxima/Minima bestimmen; Randpunkte auch ber\u00fcrcksichtigen! Welche relative Extrema sind auch absolute?","title":"Extremaufgaben"},{"location":"21HS/COM/01_Kernthemen-Austausch.html","text":"\\(i\\cdot 2\\) 1) Was sagen Ihnen die Begriffe Innovation und soziale Verantwortung spontan? Wie h\u00e4ngen diese Begriffe zusammen? Invotion: Neuartiges denken/Out of the Box Kreativiti\u00e4t soziale Verantwortung: Morale einhalten Gesselschaft ber\u00fccksichtigen Zusammenhang: Neue Ideen sollen moralisch vertretbar sein 2) Wie haben Sie Kommunikation im Berufsleben bzw. in Ihrer Ausbildung erlebt? Welchen Stellenwert hat(te) Kommunikation in Ihrem beruflichen/ schulischen Umfeld? Informatiker: Vortschritt abgleichen dokumentieren zwischenmenschlicher Austausch Mediamatiker: Viel Kommunikation erwartet Anderen Personen bei Problemen unterst\u00fctzten Interne-Abl\u00e4ufe diskutieren 3) Why is communication competence important in engineering? Engineering is almost never done alone. To be successful you have to comunicate with others and for that soft skills are vital 4) What role does social responsibility play in engineering? You have to rely on others to complete your goal, so it is important to respect your colleagues and your colleagues you","title":"01 Kernthemen Austausch"},{"location":"21HS/COM/02_Suchstrategien.html","text":"Suchbegriffe Von einem Thema sollten die Kernbegriffe extrahiert werden. Um die relevanten Suchergebnisse zu steigern, kann man zus\u00e4tzlich noch die folgenden Begriffe mit suchen: - Unterbegriffe - Oberbegriffe - Synonyme - Englische Begriffe Schneeballsystem Das Schneeballsystem kann zum Einstatz kommen, wenn man eine Quelle gefunden hat. In dieser sucht man referenzierte Quellen. Dies kann so lange wiederholt werden, bis man gen\u00fcgent Material hat. Ebenfalls k\u00f6nnte sich es lohnen eine vorw\u00e4rtsgerichtete Suche zu benutzen. In vielen Datenbank (unter anderem auch Google Scholar) kann man sehen, welche Artikel und B\u00fccher eine Quelle zitert haben. So findet man auch neuere Artikel. Suchinstrumente Folgendes ist eine Liste von m\u00f6glichen Suchinstrumenten: - https://scholar.google.ch/ - https://zhaw.swisscovery.slsp.ch/discovery/search?vid=41SLSP_ZAW:ZHAW - f\u00fcr E-Books VPN verwenden!!! - https://ieeexplore.ieee.org/Xplore/home.jsp - Hier sind noch mehr DBs aufgelistet: https://www.zhaw.ch/de/hochschulbibliothek/recherchehilfe-kurse/fachinformation-ingenieurwesen/","title":"Suchbegriffe"},{"location":"21HS/COM/02_Suchstrategien.html#suchbegriffe","text":"Von einem Thema sollten die Kernbegriffe extrahiert werden. Um die relevanten Suchergebnisse zu steigern, kann man zus\u00e4tzlich noch die folgenden Begriffe mit suchen: - Unterbegriffe - Oberbegriffe - Synonyme - Englische Begriffe","title":"Suchbegriffe"},{"location":"21HS/COM/02_Suchstrategien.html#schneeballsystem","text":"Das Schneeballsystem kann zum Einstatz kommen, wenn man eine Quelle gefunden hat. In dieser sucht man referenzierte Quellen. Dies kann so lange wiederholt werden, bis man gen\u00fcgent Material hat. Ebenfalls k\u00f6nnte sich es lohnen eine vorw\u00e4rtsgerichtete Suche zu benutzen. In vielen Datenbank (unter anderem auch Google Scholar) kann man sehen, welche Artikel und B\u00fccher eine Quelle zitert haben. So findet man auch neuere Artikel.","title":"Schneeballsystem"},{"location":"21HS/COM/02_Suchstrategien.html#suchinstrumente","text":"Folgendes ist eine Liste von m\u00f6glichen Suchinstrumenten: - https://scholar.google.ch/ - https://zhaw.swisscovery.slsp.ch/discovery/search?vid=41SLSP_ZAW:ZHAW - f\u00fcr E-Books VPN verwenden!!! - https://ieeexplore.ieee.org/Xplore/home.jsp - Hier sind noch mehr DBs aufgelistet: https://www.zhaw.ch/de/hochschulbibliothek/recherchehilfe-kurse/fachinformation-ingenieurwesen/","title":"Suchinstrumente"},{"location":"21HS/COM/03_Publikationstypen.html","text":"Monografie (eigenst\u00e4ndiges Buch) Das Buch wurde \"nur\" von den angegebenen Authoren geschrieben und befasst ein Thema umfassend. Quellenangabe D\u00f6ring, N., & Bortz, J. (2016). Forschungsmethoden und Evaluation in den Sozial- und Humanwissenschaften (5. Aufl.). Springer. https://doi.org/10.1007/978-3-642-41089-5 einzelne Kapitel eines Sammelbandes Ein Sammelband besteht aus mehreren Artikeln/Kapiteln von zum Teil unterschiedlichen Authoren. Der Herausgeber stellt die Kapitel zusammen. Es kann so mehrere Perspektiven auf ein Thema gegeben werden k\u00f6nnen. Quellenangabe Gieselmann, A. (2015). Auf dem Weg zu nutzergerechten internetbasierten Interventionen: Welche Bed\u00fcrfnisse haben unsere Patienten1? In A. Weisbecker, M. Burmester, & A. Schmidt (Hrsg.), Mensch und Computer 2015 \u2013 Workshopband (S. 133\u2013136). De Gruyter. https://doi.org/10.1515/9783110443905-018 Zeitschriftenartikel Zeitschriften erscheinen periodisch. Ihren Inhalt wird mit Hilfe von Peer-Reviews auf ihre Korrektheit \u00fcberpr\u00fcft. Quellenangabe Die Ausgabe muss erw\u00e4hnt sein (90(6)) Vlachakis, K., Beyer, A., & Vayas, I. (2021). Tragverhalten von Fachwerkmasten aus Winkelprofilen. Stahlbau, 90(6), 425\u2013440. https://doi.org/10.1002/stab.202000059","title":"Monografie (eigenst\u00e4ndiges Buch)"},{"location":"21HS/COM/03_Publikationstypen.html#monografie-eigenstandiges-buch","text":"Das Buch wurde \"nur\" von den angegebenen Authoren geschrieben und befasst ein Thema umfassend.","title":"Monografie (eigenst\u00e4ndiges Buch)"},{"location":"21HS/COM/03_Publikationstypen.html#quellenangabe","text":"D\u00f6ring, N., & Bortz, J. (2016). Forschungsmethoden und Evaluation in den Sozial- und Humanwissenschaften (5. Aufl.). Springer. https://doi.org/10.1007/978-3-642-41089-5","title":"Quellenangabe"},{"location":"21HS/COM/03_Publikationstypen.html#einzelne-kapitel-eines-sammelbandes","text":"Ein Sammelband besteht aus mehreren Artikeln/Kapiteln von zum Teil unterschiedlichen Authoren. Der Herausgeber stellt die Kapitel zusammen. Es kann so mehrere Perspektiven auf ein Thema gegeben werden k\u00f6nnen.","title":"einzelne Kapitel eines Sammelbandes"},{"location":"21HS/COM/03_Publikationstypen.html#quellenangabe_1","text":"Gieselmann, A. (2015). Auf dem Weg zu nutzergerechten internetbasierten Interventionen: Welche Bed\u00fcrfnisse haben unsere Patienten1? In A. Weisbecker, M. Burmester, & A. Schmidt (Hrsg.), Mensch und Computer 2015 \u2013 Workshopband (S. 133\u2013136). De Gruyter. https://doi.org/10.1515/9783110443905-018","title":"Quellenangabe"},{"location":"21HS/COM/03_Publikationstypen.html#zeitschriftenartikel","text":"Zeitschriften erscheinen periodisch. Ihren Inhalt wird mit Hilfe von Peer-Reviews auf ihre Korrektheit \u00fcberpr\u00fcft.","title":"Zeitschriftenartikel"},{"location":"21HS/COM/03_Publikationstypen.html#quellenangabe_2","text":"Die Ausgabe muss erw\u00e4hnt sein (90(6)) Vlachakis, K., Beyer, A., & Vayas, I. (2021). Tragverhalten von Fachwerkmasten aus Winkelprofilen. Stahlbau, 90(6), 425\u2013440. https://doi.org/10.1002/stab.202000059","title":"Quellenangabe"},{"location":"21HS/COM/04_Wissenschaftilichen%20Text.html","text":"Objektiv Quellen keine englische Abk\u00fcrzung (\"what is\" anstatt \"what's\", \"is not\" anstatt \"isn't\")","title":"04 Wissenschaftilichen Text"},{"location":"21HS/COM/05_pitch.html","text":"CCC Letter Meaning C Concise C Comprehensive (Umfassend) C Crisp (sharp, intresting, grabling) this is a tesr Tipps for Presentations/Pitch No: I think Do: Hands: keep them infront of the body don't do large movements don't cross the arms or keep the hands in the pockets do breaks (don't speak non stop) speak frealy","title":"CCC"},{"location":"21HS/COM/05_pitch.html#ccc","text":"Letter Meaning C Concise C Comprehensive (Umfassend) C Crisp (sharp, intresting, grabling) this is a tesr","title":"CCC"},{"location":"21HS/COM/05_pitch.html#tipps-for-presentationspitch","text":"No: I think Do: Hands: keep them infront of the body don't do large movements don't cross the arms or keep the hands in the pockets do breaks (don't speak non stop) speak frealy","title":"Tipps for Presentations/Pitch"},{"location":"21HS/COM/06_handout.html","text":"Kriterien Wer ist die Zielgruppe? Text soll: Informativ, Objektiv und Sachlich keine Emotionen keine Umgangssprache Sachlich (nicht \"ist enorm gewachsen\", sondern \"ist um 20% gewachsen\") hohe Informationsdichte Bild Quellenangabe Im Vortrag Bild referenzieren (Auf Abbildung 1 sieht man...)","title":"Kriterien"},{"location":"21HS/COM/06_handout.html#kriterien","text":"Wer ist die Zielgruppe? Text soll: Informativ, Objektiv und Sachlich keine Emotionen keine Umgangssprache Sachlich (nicht \"ist enorm gewachsen\", sondern \"ist um 20% gewachsen\") hohe Informationsdichte Bild Quellenangabe Im Vortrag Bild referenzieren (Auf Abbildung 1 sieht man...)","title":"Kriterien"},{"location":"21HS/COM/Presentation/Pitch%20v2.html","text":"Intro (Question and Hi) Hand-Off Hi, Having access to the internet is vital for any modern society. With its vast storage of knowledge, it is a blessing for learning new things. For what you needed, a cooperation with financial backing, can be done by a teenager from his bedroom. It can bring different people together to fight in a bigger war and help companies turn a profit. But still, countless people have no or poor access to the internet. In America, a country with a relative high standard of living, 19 million people [1] still don't have broadband internet and those people mostly live in rural areas. Looking at the world population, the numbers look even worst. ITU estimates that in the world, only 38% in rural areas are able to go online, almost half that who live in urban houses [2]. But this makes perfect sense. Building out the necessary infrastructure is a costly endevour and companies like a return on their investment. In big cities with a lot of customers, this is a fairly easy task, but tunneling an optical fiber for a couple of people on a remote settlement isn't cost-effective. For this reason, many people have to make due with just slow and expensive satellite internet. Our solution is to use low orbit satellites to provide fast, reliable and cheap internet to the masses. Because we use satellites, we don't have to build any large and costly structures on the ground from which only a few people can benefit. Instead, we'll launch a network of satellites which can provide internet to 7 billion people. You might ask, how this satellite internet differs from the previously mentioned slow and expensive ones. For one, we use satellites in low orbit. This brings the benefit that the connections can be much faster and more reliable due to the lower distance to the earth. Mr. Thalmann will now tell you more about our ground braking technology. We also use state-of-the-art technology in our satellites and antennas, like beam forming the signals to more easily reach the satellite from the antenna and waste less energy blasting unnecessary radiation in the sky. All this means is that you can buy an antenna, place it anywhere where it has unobstructed view of the sky and browse the World Wide Web to your heart's content. Sources [1] Eighth Broadband Progreszos Report | Federal Communications Commission [2] https://www.itu.int/en/ITU-D/Statistics/Dashboards/Pages/IFF.aspx [3] International Programs - Total Midyear Population for the World: 1950-2050 - U.S. Census Bureau [4] Web of Science - Digital Beam Forming in MRI [5] Web of Science - Digital Beam forming Algorithms for Radar Applications","title":"Pitch v2"},{"location":"21HS/COM/Presentation/Pitch%20v2.html#sources","text":"[1] Eighth Broadband Progreszos Report | Federal Communications Commission [2] https://www.itu.int/en/ITU-D/Statistics/Dashboards/Pages/IFF.aspx [3] International Programs - Total Midyear Population for the World: 1950-2050 - U.S. Census Bureau [4] Web of Science - Digital Beam Forming in MRI [5] Web of Science - Digital Beam forming Algorithms for Radar Applications","title":"Sources"},{"location":"21HS/COM/Presentation/Pitch.html","text":"Intro (Question and Hi) Hand-Off Having access to the internet is vital for any modern society. With its vast storage of knowledge, it is a blessing for learning new things. For what you needed, a cooperation with financial backing, can be done by a teenager from his bedroom. It can bring different people together to fight in a bigger war and help companies turn a profit. But still, countless people have no or poor access to the internet. In America, a country with a relative high standard of living, 19 million people [1] still don't have broadband internet and those people mostly live in rural areas. Looking at the world population, the numbers look even worst. ITU estimates that in the world, only 38% in rural areas are able to go online, almost half that who live in urban houses [2]. But this makes perfect sense. Building out the necessary infrastructure is a costly endevour and companies like a return on their investment. In big cities with a lot of customers, this is a fairly easy task, but tunneling an optical fiber for a couple of people on a remote settlement isn't cost-effective. For this reason, many people have to make due with just slow and expensive satellite internet. Our solution is to use low orbit satellites to provide fast, reliable and cheap internet to the masses. Because we use satellites, we don't have to build any large and costly structures on the ground from which only a few people can benefit. Instead, we'll launch a network of satellites which can provide internet to 7 billion people. You might ask, how this satellite internet differs from the previously mentioned slow and expensive ones. For one, we use satellites in low orbit. This brings the benefit that the connections can be much faster and more reliable due to the lower distance to the earth. We also use state-of-the-art technology in our satellites and antennas, like beam forming the signals to more easily reach the satellite from the antenna and waste less energy blasting unnecessary radiation in the sky. All this means is that you can buy an antenna, place it anywhere where it has unobstructed view of the sky and browse the World Wide Web to your heart's content. Sources [1] Eighth Broadband Progress Report | Federal Communications Commission [2] https://www.itu.int/en/ITU-D/Statistics/Dashboards/Pages/IFF.aspx [3] International Programs - Total Midyear Population for the World: 1950-2050 - U.S. Census Bureau [4] Web of Science - Digital Beam Forming in MRI [5] Web of Science - Digital Beam forming Algorithms for Radar Applications","title":"Pitch"},{"location":"21HS/COM/Presentation/Pitch.html#sources","text":"[1] Eighth Broadband Progress Report | Federal Communications Commission [2] https://www.itu.int/en/ITU-D/Statistics/Dashboards/Pages/IFF.aspx [3] International Programs - Total Midyear Population for the World: 1950-2050 - U.S. Census Bureau [4] Web of Science - Digital Beam Forming in MRI [5] Web of Science - Digital Beam forming Algorithms for Radar Applications","title":"Sources"},{"location":"21HS/DB/00_Pr%C3%BCfung.html","text":"Relationale Algebra (20 Punkte) (Umbedingt zwischen Resultate anschreiben) Anfrage erstelle von Text oder umgekehrt Bags vs Relationen ER-Model aus einem Text erstellen (20 Punkte) Die verschiedenen Beziehungstypen (1-1, 1-m, m-m, ISA, ID) und wie sich die Schl\u00fcssel zusammen settzen 3-gliedrige Beziehung Zusammen gesetzte Entit\u00e4t Relationen Modell Korrektes ER-Modell SQL Teil (20-30 Punkte) Beim Ausw\u00e4hlen, welche Insert Statements eingef\u00fcgt werden k\u00f6nnen --> Schauen, ob jedes Statement mit den Daten von den vorherigen INSERT Statements immer noch funktioniert! Wissens Fragen (10) Beispiel: was ist gut an einem Index? Was ist schlecht an einem Index? Was ist ACID? Lost Update, Dirty-Read... Welche Probleme (Dirty-Read, Non-Repeatable-Read, Phantom-Read) k\u00f6nnen tolliertiert werden? Was ist der Unterschied zwischen einem Trigger und einer Stored Proceedure? Fragen: Sind die technischen Details von Indexen relevant? (B-Baum, D\u00fcnn vs dichter Index, ...)","title":"00 Pr\u00fcfung"},{"location":"21HS/DB/01_Begriffe.html","text":"Begriffe in Tabelle formatieren Name Erkl\u00e4rung Beispiel Dom\u00e4ne Wertebereich Dom\u00e4ne von PLZ w\u00e4ren die Zahlen 0-9999 Attribute Eigenschaft / Spalte / besteht aus Name + Dom\u00e4ne Attributwert Feld z. B. der Ort Tupel eine Zeile/Eintrag ein 3-er Tupel ist ein Tupel bestehend aus 3 Attribute Format, Schema, Heading, Relationsvariable Relation -> mehrere Spalten (auch von mehreren Tabellen) Schl\u00fcssel -> Eindeutige M\u00f6glichkeit, einen Datensatz zu identifizieren Relation -> Relationsenformat (Menge von Namen von Attributen) & Auspr\u00e4gung Wichtig: In einem Modell gibt es NIE genau gleiche Zeilen In einem Format gibt es NIE zwei gleiche Attribute Die Reihenfolge der Zeilen (Tupel) und Spalten(Attribute(Attribute)) ist irrelevant Notation Tabellarisch {<1, Meier, 19.4.2001>, <2, M\u00fcller, 23.5.2302>} Schl\u00fcssel Prim\u00e4rschl\u00fcssel ein ausgew\u00e4hlter Schl\u00fcsselkandidat Fremdschl\u00fcssel Referenziert einen Prim\u00e4rschl\u00fcssel Prim\u00e4rschl\u00fcssel vs Unique-Key Es kann maximal ein Prim\u00e4rschl\u00fcssel pro Tabelle geben (einen zusammengesetzter Prim\u00e4rschl\u00fcssel ist immer noch ein Schl\u00fcssel). Zus\u00e4tzlich wird automatisch ein Index erstellt, so dass die DB eine Tupel schneller findet. ACID","title":"Begriffe"},{"location":"21HS/DB/01_Begriffe.html#begriffe","text":"in Tabelle formatieren Name Erkl\u00e4rung Beispiel Dom\u00e4ne Wertebereich Dom\u00e4ne von PLZ w\u00e4ren die Zahlen 0-9999 Attribute Eigenschaft / Spalte / besteht aus Name + Dom\u00e4ne Attributwert Feld z. B. der Ort Tupel eine Zeile/Eintrag ein 3-er Tupel ist ein Tupel bestehend aus 3 Attribute Format, Schema, Heading, Relationsvariable Relation -> mehrere Spalten (auch von mehreren Tabellen) Schl\u00fcssel -> Eindeutige M\u00f6glichkeit, einen Datensatz zu identifizieren Relation -> Relationsenformat (Menge von Namen von Attributen) & Auspr\u00e4gung Wichtig: In einem Modell gibt es NIE genau gleiche Zeilen In einem Format gibt es NIE zwei gleiche Attribute Die Reihenfolge der Zeilen (Tupel) und Spalten(Attribute(Attribute)) ist irrelevant","title":"Begriffe"},{"location":"21HS/DB/01_Begriffe.html#notation","text":"Tabellarisch {<1, Meier, 19.4.2001>, <2, M\u00fcller, 23.5.2302>}","title":"Notation"},{"location":"21HS/DB/01_Begriffe.html#schlussel","text":"Prim\u00e4rschl\u00fcssel ein ausgew\u00e4hlter Schl\u00fcsselkandidat Fremdschl\u00fcssel Referenziert einen Prim\u00e4rschl\u00fcssel","title":"Schl\u00fcssel"},{"location":"21HS/DB/01_Begriffe.html#primarschlussel-vs-unique-key","text":"Es kann maximal ein Prim\u00e4rschl\u00fcssel pro Tabelle geben (einen zusammengesetzter Prim\u00e4rschl\u00fcssel ist immer noch ein Schl\u00fcssel). Zus\u00e4tzlich wird automatisch ein Index erstellt, so dass die DB eine Tupel schneller findet.","title":"Prim\u00e4rschl\u00fcssel vs Unique-Key"},{"location":"21HS/DB/01_Begriffe.html#acid","text":"","title":"ACID"},{"location":"21HS/DB/01_Begriffe.html#_1","text":"","title":""},{"location":"21HS/DB/02_Grundoperation.html","text":"Notation f\u00fcr das Format einer Relation: \\(R(A_1, A_2, ..., A_n)\\) Wenn die Werte selbst dargestellt weden, soll folgendes Format verwenden werden: {<1, Meier, 19.4.2001>, <2, M\u00fcller, 23.5.2302>} \u00c4quivalenz Zwei Relationen sind \u00e4quivalent, wenn sich durch eine Umordnung beide Relationen darstellen lasst Die Reihenfolge der Tupeln ist irrelevant. Notation: \\(R_1 \\sim R_2\\) Operation In der Mengenlehre werden Duplikate immer gleich entfernt. Ein SQL-Server typischerweise nicht Entfernende Operatoren Selektion Symbol: \\(\\sigma\\) ; in SQL: WHERE \\(R' = \\sigma_{Selektionsbedingung}(R)\\) \\(\\sigma_A(\\sigma_B) = \\sigma_B(\\sigma_A)\\) Wenn die Bedinung immer falsch ist, wird eine leere Relation zur\u00fcck gegeben Wenn es ein Attribut in der Bedinung nicht gibt, ist der Ausdruck nicht berechenbar Entfernt Tupels, welche nicht dem Pr\u00e4dikat entsprechen Das Format der Relation \u00e4ndert sich nicht, ist aber eine neue Relation Beispiel: \\(\\sigma_{L\u00e4nge>100}(Filme)\\) -> Alle Filme, welche eine gr\u00f6ssere L\u00e4nge als 100 haben \\(\\sigma_{City = 'Z\u00fcrich' \\wedge Discount \\geq 0.15}(Customers)\\) -> Finde alle Z\u00fcricher Kunden, die einen Rabatt von 15% oder mehr erhalten Projektion Symbol: \\(\\pi\\) ; in SQL: SELECT \\(R'=\\pi_{Spalten}(R)\\) \\(\\pi_A(\\pi_B) \\neq \\pi_B(\\pi_A)\\) erzeugt eine neue Relation mit weniger Spalten !Duplikate in der neuen Relation werden entfernt! Gibt es das angegebenen Attribut nicht, ist dies ein Fehler und keine Relation wird zur\u00fcck gegeben Beispiel: \\(\\pi_{Titel, Jahr, L\u00e4nge}(Filme)\\) -> Gibt eine neue Relation zur\u00fcck, mit den Attributen Titel, Jahr und L\u00e4nge Die Projektion kann erweitert werden, dass man zus\u00e4tzlich zu Attribute, auch Ausdr\u00fccke (wie \\(\\pi_{2\\cdot R.A+4\\to Z}(R)\\) ) oder Konstante (wie \\(\\pi_{5 \\to S, A \\to B, C}(R)\\) ) angegeben. Dies kommt dem SELECT Syntax von SQL n\u00e4her. Umbenennung Symbol: \\(\\rho\\) ; in SQL: AS \\(\\rho_{S(C,D)}(R(A, B))=S(C, D)\\) Produkt-Operatoren F\u00fcgt Attribute zusammen Kartesisches Produkt (auch Cross-Join) Symbol \\(R \\times S\\) ; SQL: CROSS JOIN Kombiniert alle Tupples von R mit allen Tupples von S Natural Join Symbol: \\(\\bowtie\\) ; Latex: \\bowtie; SQL: NATURAL JOIN \\(R \\bowtie S\\) Die gleichen Attribute werden verglichen In SQL ist Join nicht kommuntativ (die Reihenfolge stimmt nicht) Wenn zwei Tabellen \"gejoint\" werden, welche keine gemeinsammen Attribute haben, wird das kartesische Produkt gebildet Theta-Join Symbol: \\(\\bowtie_P\\) Ist eine Verallgemeinerung von einem Natural-Join, da bei diesem Join eine Bedingung angegeben werden k\u00f6nnen Beispiele: \\(\\bowtie_{P (A > B \\wedge R.D = S.D)}\\) Semi-Join Ein Semi-Join ist ein Natural-Join, auf welchen danach eine Projektion angewendet wurde: \\(\\pi_{r_1,...,r_n}(R_1 \\bowtie R_2)\\) Left-Outer-Join Alle Resultate von der Relation auf der linken Seite werden \u00fcbernommen, selbst wenn es auf der rechten Seite kein Tuppel gibt, welches passt. In diesem Fall werden anstatt Werte NULL ausgegen. Right-Outer-Join Es werden Alle Resultate von der Relation auf er rechten Seite \u00fcbernommen. Wenn es kein Tupel aus der linken Relation gibt, wird anstelle NULL ausgeggeben. Full-Outer-Join Bei einem Full-Outer-Join werden alle Werte von beiden Relationen ausgegeben. Wenn auf der einen Seite kein passendes Tupel existiert, wird anstelle NULL ausgegeben. Mengen Operatoren F\u00fcgt Tupels zusammen Bei allen Mengen-Operatoren m\u00fcssen die Relationen das gleiche Schema haben. Zudem werden die Duplikate immer heraus gefilteret. Vereinigung ( \\(\\cup\\) ) Symbol: \\(\\cup\\) ; Latex: \\cup; SQL: UNION Gibt alle Eintr\u00e4ge von beiden Mengen zur\u00fcck. Duplikate werden entfernt Beide Relationen, welche vereinigt werden, m\u00fcssen dasselbe Schema haben Wenn die Vereinigung in Bag-Algebra durchgef\u00fchrt wird, werden die Duplikate einer Tupel-Art der linken und rechten Seite gez\u00e4hlt und alle Duplikate dieser Tupel-Art von der Seite mit mehr Duplikaten genommen. Die doppelten Tupels der anderen Seite werden verworfen. Bag Concatenation ( \\(\\sqcup\\) ) Ist ebenfalls eine Vereinigung, die Behandlung von Duplikaten ist allerdings anderst als beim \\(\\cup\\) Operator. Es werden die Duplikaten von beiden Seiten genommen. Durchschnitt ( \\(\\cap\\) ) Symbol: \\(\\cap\\) ; Latex: \\cap; SQL: INTERSECT Gibt alle Eintr\u00e4ge zur\u00fcck, welche in beiden Mengen vorhanden ist Beide Relationen, welche durchschnitten werden, m\u00fcssen dasselbe Schema haben Wenn der Durchschnitt in Bag-Algebra durchgef\u00fchrt wird, werden die duplikate Tupels \u00fcbernommen, von denen es weniger gibt. Differenz ( \\(\\setminus\\) ) Symbol: \\(R \\setminus S\\) ; SQL: EXCEPT Gibt alle Tupels zur\u00fcck, welche in R sind, aber nicht S Beide Relationen, welche differenziert werden, m\u00fcssen dasselbe Schema haben Wenn die Differenz in Bag-Algebra durchgef\u00fchrt wird, werden die Duplikate eines Tupels der rechten Seite von der linken Seite abgezogen. Duplikatelimitation ( \\(\\delta\\) ) Entfernt die Duplikate einer Relation. Dieser Operator wird nur verwendet, wenn mit Bags gerechnet werden. Aggregationen Gruppieren Bildet Gruppen, auf welche die Aggregations-Funktion angewandt wird","title":"02 Grundoperation"},{"location":"21HS/DB/02_Grundoperation.html#aquivalenz","text":"Zwei Relationen sind \u00e4quivalent, wenn sich durch eine Umordnung beide Relationen darstellen lasst Die Reihenfolge der Tupeln ist irrelevant. Notation: \\(R_1 \\sim R_2\\)","title":"\u00c4quivalenz"},{"location":"21HS/DB/02_Grundoperation.html#operation","text":"In der Mengenlehre werden Duplikate immer gleich entfernt. Ein SQL-Server typischerweise nicht","title":"Operation"},{"location":"21HS/DB/02_Grundoperation.html#entfernende-operatoren","text":"","title":"Entfernende Operatoren"},{"location":"21HS/DB/02_Grundoperation.html#selektion","text":"Symbol: \\(\\sigma\\) ; in SQL: WHERE \\(R' = \\sigma_{Selektionsbedingung}(R)\\) \\(\\sigma_A(\\sigma_B) = \\sigma_B(\\sigma_A)\\) Wenn die Bedinung immer falsch ist, wird eine leere Relation zur\u00fcck gegeben Wenn es ein Attribut in der Bedinung nicht gibt, ist der Ausdruck nicht berechenbar Entfernt Tupels, welche nicht dem Pr\u00e4dikat entsprechen Das Format der Relation \u00e4ndert sich nicht, ist aber eine neue Relation Beispiel: \\(\\sigma_{L\u00e4nge>100}(Filme)\\) -> Alle Filme, welche eine gr\u00f6ssere L\u00e4nge als 100 haben \\(\\sigma_{City = 'Z\u00fcrich' \\wedge Discount \\geq 0.15}(Customers)\\) -> Finde alle Z\u00fcricher Kunden, die einen Rabatt von 15% oder mehr erhalten","title":"Selektion"},{"location":"21HS/DB/02_Grundoperation.html#projektion","text":"Symbol: \\(\\pi\\) ; in SQL: SELECT \\(R'=\\pi_{Spalten}(R)\\) \\(\\pi_A(\\pi_B) \\neq \\pi_B(\\pi_A)\\) erzeugt eine neue Relation mit weniger Spalten !Duplikate in der neuen Relation werden entfernt! Gibt es das angegebenen Attribut nicht, ist dies ein Fehler und keine Relation wird zur\u00fcck gegeben Beispiel: \\(\\pi_{Titel, Jahr, L\u00e4nge}(Filme)\\) -> Gibt eine neue Relation zur\u00fcck, mit den Attributen Titel, Jahr und L\u00e4nge Die Projektion kann erweitert werden, dass man zus\u00e4tzlich zu Attribute, auch Ausdr\u00fccke (wie \\(\\pi_{2\\cdot R.A+4\\to Z}(R)\\) ) oder Konstante (wie \\(\\pi_{5 \\to S, A \\to B, C}(R)\\) ) angegeben. Dies kommt dem SELECT Syntax von SQL n\u00e4her.","title":"Projektion"},{"location":"21HS/DB/02_Grundoperation.html#umbenennung","text":"Symbol: \\(\\rho\\) ; in SQL: AS \\(\\rho_{S(C,D)}(R(A, B))=S(C, D)\\)","title":"Umbenennung"},{"location":"21HS/DB/02_Grundoperation.html#produkt-operatoren","text":"F\u00fcgt Attribute zusammen","title":"Produkt-Operatoren"},{"location":"21HS/DB/02_Grundoperation.html#kartesisches-produkt-auch-cross-join","text":"Symbol \\(R \\times S\\) ; SQL: CROSS JOIN Kombiniert alle Tupples von R mit allen Tupples von S","title":"Kartesisches Produkt (auch Cross-Join)"},{"location":"21HS/DB/02_Grundoperation.html#natural-join","text":"Symbol: \\(\\bowtie\\) ; Latex: \\bowtie; SQL: NATURAL JOIN \\(R \\bowtie S\\) Die gleichen Attribute werden verglichen In SQL ist Join nicht kommuntativ (die Reihenfolge stimmt nicht) Wenn zwei Tabellen \"gejoint\" werden, welche keine gemeinsammen Attribute haben, wird das kartesische Produkt gebildet","title":"Natural Join"},{"location":"21HS/DB/02_Grundoperation.html#theta-join","text":"Symbol: \\(\\bowtie_P\\) Ist eine Verallgemeinerung von einem Natural-Join, da bei diesem Join eine Bedingung angegeben werden k\u00f6nnen Beispiele: \\(\\bowtie_{P (A > B \\wedge R.D = S.D)}\\)","title":"Theta-Join"},{"location":"21HS/DB/02_Grundoperation.html#semi-join","text":"Ein Semi-Join ist ein Natural-Join, auf welchen danach eine Projektion angewendet wurde: \\(\\pi_{r_1,...,r_n}(R_1 \\bowtie R_2)\\)","title":"Semi-Join"},{"location":"21HS/DB/02_Grundoperation.html#left-outer-join","text":"Alle Resultate von der Relation auf der linken Seite werden \u00fcbernommen, selbst wenn es auf der rechten Seite kein Tuppel gibt, welches passt. In diesem Fall werden anstatt Werte NULL ausgegen.","title":"Left-Outer-Join"},{"location":"21HS/DB/02_Grundoperation.html#right-outer-join","text":"Es werden Alle Resultate von der Relation auf er rechten Seite \u00fcbernommen. Wenn es kein Tupel aus der linken Relation gibt, wird anstelle NULL ausgeggeben.","title":"Right-Outer-Join"},{"location":"21HS/DB/02_Grundoperation.html#full-outer-join","text":"Bei einem Full-Outer-Join werden alle Werte von beiden Relationen ausgegeben. Wenn auf der einen Seite kein passendes Tupel existiert, wird anstelle NULL ausgegeben.","title":"Full-Outer-Join"},{"location":"21HS/DB/02_Grundoperation.html#mengen-operatoren","text":"F\u00fcgt Tupels zusammen Bei allen Mengen-Operatoren m\u00fcssen die Relationen das gleiche Schema haben. Zudem werden die Duplikate immer heraus gefilteret.","title":"Mengen Operatoren"},{"location":"21HS/DB/02_Grundoperation.html#vereinigung-cup","text":"Symbol: \\(\\cup\\) ; Latex: \\cup; SQL: UNION Gibt alle Eintr\u00e4ge von beiden Mengen zur\u00fcck. Duplikate werden entfernt Beide Relationen, welche vereinigt werden, m\u00fcssen dasselbe Schema haben Wenn die Vereinigung in Bag-Algebra durchgef\u00fchrt wird, werden die Duplikate einer Tupel-Art der linken und rechten Seite gez\u00e4hlt und alle Duplikate dieser Tupel-Art von der Seite mit mehr Duplikaten genommen. Die doppelten Tupels der anderen Seite werden verworfen.","title":"Vereinigung (\\(\\cup\\))"},{"location":"21HS/DB/02_Grundoperation.html#bag-concatenation-sqcup","text":"Ist ebenfalls eine Vereinigung, die Behandlung von Duplikaten ist allerdings anderst als beim \\(\\cup\\) Operator. Es werden die Duplikaten von beiden Seiten genommen.","title":"Bag Concatenation (\\(\\sqcup\\))"},{"location":"21HS/DB/02_Grundoperation.html#durchschnitt-cap","text":"Symbol: \\(\\cap\\) ; Latex: \\cap; SQL: INTERSECT Gibt alle Eintr\u00e4ge zur\u00fcck, welche in beiden Mengen vorhanden ist Beide Relationen, welche durchschnitten werden, m\u00fcssen dasselbe Schema haben Wenn der Durchschnitt in Bag-Algebra durchgef\u00fchrt wird, werden die duplikate Tupels \u00fcbernommen, von denen es weniger gibt.","title":"Durchschnitt (\\(\\cap\\))"},{"location":"21HS/DB/02_Grundoperation.html#differenz-setminus","text":"Symbol: \\(R \\setminus S\\) ; SQL: EXCEPT Gibt alle Tupels zur\u00fcck, welche in R sind, aber nicht S Beide Relationen, welche differenziert werden, m\u00fcssen dasselbe Schema haben Wenn die Differenz in Bag-Algebra durchgef\u00fchrt wird, werden die Duplikate eines Tupels der rechten Seite von der linken Seite abgezogen.","title":"Differenz (\\(\\setminus\\))"},{"location":"21HS/DB/02_Grundoperation.html#duplikatelimitation-delta","text":"Entfernt die Duplikate einer Relation. Dieser Operator wird nur verwendet, wenn mit Bags gerechnet werden.","title":"Duplikatelimitation (\\(\\delta\\))"},{"location":"21HS/DB/02_Grundoperation.html#aggregationen","text":"","title":"Aggregationen"},{"location":"21HS/DB/02_Grundoperation.html#gruppieren","text":"Bildet Gruppen, auf welche die Aggregations-Funktion angewandt wird","title":"Gruppieren"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html","text":"ER-Diagram Ein Entit\u00e4ts-Typ (Tabelen-Schema) wird als Rechteck dargestellt. Die Entit\u00e4t davon w\u00e4re die Tabelle selbst, mit den eigentlichen Werten. Die Attribute werden in einem Oval dargestellt und mit dem Entit\u00e4ts-Typ verbunden. (Wie in einem Mindmap). Wenn ein Attribut ein Schl\u00fcssel ist, dann wird der Attributname unterstrichen. Ein Rombus wird zu einer Zwischentabelle. Es sollen umbedingt alle Null Werte vermieden werden Kardinalit\u00e4ten Zeichen Ausgeschrieben Erkl\u00e4rung m 0..m beliebig viele 1 0..1 Eine oder keine Im unterem Beispiel kann eine Person eine Firma haben (1 -> 0-1) und eine Firma kann mehrere Personen haben (m -> 0-beliebig viele) In der folgenden Tabelle sieht man, welche Schl\u00fcssel in die Zwischentabelle m\u00fcssen, damit die Kardinalit\u00e4t eingehaltet wird. Eine Schl\u00fcsselgruppe ist eine Gruppe von Schl\u00fcssel. Diese Gruppe muss eindeutig sein, da man mit einem Schl\u00fcssel ein Tupel identifizieren k\u00f6nnen muss. Bei einer 1-- <> --1 Beziehung, ist der Prim\u00e4rschl\u00fcssel die kleinste Menge von Attribute Diagramm Schl\u00fcssel Beschreibung E 1 -- <> -- 1 F Schl\u00fcssel von E und F in seperaten Schl\u00fcsselgruppen E 1 -- <> -- m F Schl\u00fcssel von F E m -- <> -- 1 F Schl\u00fcssel von E E m -- <> -- m F Schl\u00fcssel von E und F in einer Schl\u00fcsselgruppe Fname (Firma.Name) m\u00fcsste unterstrichen sein, da es ein Schl\u00fcssel sein muss. Folgende Fakten kann man \u00fcber das obere Beispiel schreiben: Jede Empfehlung kommt von einem Lehrer und kann mehrere Bucher beinhalten Eine Zuordung ordnet mehreren Empfehlungen ein Fach zu Nutzung kann mehrere Klassen mit mehreren Zuordnungen verbinden Die Rechteck-Romben sind Zwischentabellen, welche aber auch referenziert werden und daher auch noch Identit\u00e4ten sind. Sie werden Zusammengesetzte Entit\u00e4tstypen genannt. Terziere Beziehung x y z Schl\u00fcssel m m m {A1, A2, A3} m m 1 {A1, A2} m 1 m {A1, A3} m 1 1 {A1, A2}, 1 m m {A2, A3} 1 m 1 {A2, A1}, 1 1 m {A3, A1}, 1 1 1 {A1}, {A2}, Ein Beispiel, wie oben, kann interpretiert werden als, pro Klasse und Buch (da beide ein m haben) gibt es h\u00f6chstens 1 Lehrer und Fach. Abh\u00e4ngig und Unabh\u00e4ngige Typen Abh\u00e4ngig ist ein Identit\u00e4tstyp, wenn er auf eine andere Entit\u00e4t zeigt. Unabh\u00e4ngig ist er, wenn er f\u00fcr sich stehen k\u00f6nnte. ISA-Abh\u00e4ngig ISA = Is A = Ist ein Im Beispiel: Ein Kunde kann ein Gesch\u00e4ftspartner Ein Liferant kann ein Gesch\u00e4ftspartner sein Der Schl\u00fcssel muss bei ISA Beziehungen nicht erweitert werden. Kunde kann nur G# brauchen, da es nicht mehrere Kunden gibt, welche auf denselben Gesch\u00e4ftspartner referenzieren. ID-Abh\u00e4ngig Der Schl\u00fcssel von Physisches Buch muss erweitert werden und Ex# und ISBN beinhalten, da man sonst nicht auf ein einzelnes Physisches Buch referenzieren k\u00f6nnte, da es mehrere physische B\u00fccher auf ein logisches Buch geben k\u00f6nnen. Korrektes ER-Diagramm Mit folgenden Regeln, wird ein korrektes ER-Diagramm erstellt: Definiere die unabh\u00e4ngige Entit\u00e4ts-Typen (Tabellen, welche keine Fremdschl\u00fcssel besitzen) Definiere die Beziehungs-Typen (Rhomben), wenn mehr als eine unabh\u00e4ngige Entit\u00e4ts-Typen existiert. Definiere die Attribute und Schl\u00fcssel Wandle Beziehungstypen ind zusammengesetzte Entit\u00e4tstypen um, wenn n\u00f6tig Definiere die ID-Abh\u00e4nigen Entit\u00e4stypen (Pfeile mit ID) Definiere die ISA-Abh\u00e4nigen Entit\u00e4tstypen (Pfeile mit ISA) Relationales Modell Entit\u00e4ten werden im Format \"Name( Schl\u00fcssel1 , Attribute2)\" angegeben. Wenn ein Attribut unterstrichen ist, dann ist es ein Schl\u00fcssel. Die Reihenfolge sollte dieselbe sein, in welcher die Entit\u00e4ten erstellt wurden. BCNF (Boyce-Codd Normal-Form)","title":"ER-Diagram"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#er-diagram","text":"Ein Entit\u00e4ts-Typ (Tabelen-Schema) wird als Rechteck dargestellt. Die Entit\u00e4t davon w\u00e4re die Tabelle selbst, mit den eigentlichen Werten. Die Attribute werden in einem Oval dargestellt und mit dem Entit\u00e4ts-Typ verbunden. (Wie in einem Mindmap). Wenn ein Attribut ein Schl\u00fcssel ist, dann wird der Attributname unterstrichen. Ein Rombus wird zu einer Zwischentabelle. Es sollen umbedingt alle Null Werte vermieden werden","title":"ER-Diagram"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#kardinalitaten","text":"Zeichen Ausgeschrieben Erkl\u00e4rung m 0..m beliebig viele 1 0..1 Eine oder keine Im unterem Beispiel kann eine Person eine Firma haben (1 -> 0-1) und eine Firma kann mehrere Personen haben (m -> 0-beliebig viele) In der folgenden Tabelle sieht man, welche Schl\u00fcssel in die Zwischentabelle m\u00fcssen, damit die Kardinalit\u00e4t eingehaltet wird. Eine Schl\u00fcsselgruppe ist eine Gruppe von Schl\u00fcssel. Diese Gruppe muss eindeutig sein, da man mit einem Schl\u00fcssel ein Tupel identifizieren k\u00f6nnen muss. Bei einer 1-- <> --1 Beziehung, ist der Prim\u00e4rschl\u00fcssel die kleinste Menge von Attribute Diagramm Schl\u00fcssel Beschreibung E 1 -- <> -- 1 F Schl\u00fcssel von E und F in seperaten Schl\u00fcsselgruppen E 1 -- <> -- m F Schl\u00fcssel von F E m -- <> -- 1 F Schl\u00fcssel von E E m -- <> -- m F Schl\u00fcssel von E und F in einer Schl\u00fcsselgruppe Fname (Firma.Name) m\u00fcsste unterstrichen sein, da es ein Schl\u00fcssel sein muss. Folgende Fakten kann man \u00fcber das obere Beispiel schreiben: Jede Empfehlung kommt von einem Lehrer und kann mehrere Bucher beinhalten Eine Zuordung ordnet mehreren Empfehlungen ein Fach zu Nutzung kann mehrere Klassen mit mehreren Zuordnungen verbinden Die Rechteck-Romben sind Zwischentabellen, welche aber auch referenziert werden und daher auch noch Identit\u00e4ten sind. Sie werden Zusammengesetzte Entit\u00e4tstypen genannt.","title":"Kardinalit\u00e4ten"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#terziere-beziehung","text":"x y z Schl\u00fcssel m m m {A1, A2, A3} m m 1 {A1, A2} m 1 m {A1, A3} m 1 1 {A1, A2}, 1 m m {A2, A3} 1 m 1 {A2, A1}, 1 1 m {A3, A1}, 1 1 1 {A1}, {A2}, Ein Beispiel, wie oben, kann interpretiert werden als, pro Klasse und Buch (da beide ein m haben) gibt es h\u00f6chstens 1 Lehrer und Fach.","title":"Terziere Beziehung"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#abhangig-und-unabhangige-typen","text":"Abh\u00e4ngig ist ein Identit\u00e4tstyp, wenn er auf eine andere Entit\u00e4t zeigt. Unabh\u00e4ngig ist er, wenn er f\u00fcr sich stehen k\u00f6nnte.","title":"Abh\u00e4ngig und Unabh\u00e4ngige Typen"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#isa-abhangig","text":"ISA = Is A = Ist ein Im Beispiel: Ein Kunde kann ein Gesch\u00e4ftspartner Ein Liferant kann ein Gesch\u00e4ftspartner sein Der Schl\u00fcssel muss bei ISA Beziehungen nicht erweitert werden. Kunde kann nur G# brauchen, da es nicht mehrere Kunden gibt, welche auf denselben Gesch\u00e4ftspartner referenzieren.","title":"ISA-Abh\u00e4ngig"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#id-abhangig","text":"Der Schl\u00fcssel von Physisches Buch muss erweitert werden und Ex# und ISBN beinhalten, da man sonst nicht auf ein einzelnes Physisches Buch referenzieren k\u00f6nnte, da es mehrere physische B\u00fccher auf ein logisches Buch geben k\u00f6nnen.","title":"ID-Abh\u00e4ngig"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#korrektes-er-diagramm","text":"Mit folgenden Regeln, wird ein korrektes ER-Diagramm erstellt: Definiere die unabh\u00e4ngige Entit\u00e4ts-Typen (Tabellen, welche keine Fremdschl\u00fcssel besitzen) Definiere die Beziehungs-Typen (Rhomben), wenn mehr als eine unabh\u00e4ngige Entit\u00e4ts-Typen existiert. Definiere die Attribute und Schl\u00fcssel Wandle Beziehungstypen ind zusammengesetzte Entit\u00e4tstypen um, wenn n\u00f6tig Definiere die ID-Abh\u00e4nigen Entit\u00e4stypen (Pfeile mit ID) Definiere die ISA-Abh\u00e4nigen Entit\u00e4tstypen (Pfeile mit ISA)","title":"Korrektes ER-Diagramm"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#relationales-modell","text":"Entit\u00e4ten werden im Format \"Name( Schl\u00fcssel1 , Attribute2)\" angegeben. Wenn ein Attribut unterstrichen ist, dann ist es ein Schl\u00fcssel. Die Reihenfolge sollte dieselbe sein, in welcher die Entit\u00e4ten erstellt wurden.","title":"Relationales Modell"},{"location":"21HS/DB/03_Entity%20Relationship%20Diagram.html#bcnf-boyce-codd-normal-form","text":"","title":"BCNF (Boyce-Codd Normal-Form)"},{"location":"21HS/DB/04_SQL.html","text":"SQL Datentypen Datentyp Erkl\u00e4rung CHAR(n)/Character(n) String mit einer fixen L\u00e4nge Char Varying(n)/VARCHAR(n) String, welcher beliebig Lang sein kann . Kann aber ein Limit haben TEXT String, mit beliebiger L\u00e4nge Int/INTEGER Ganzzahl REAL Fliesskomazahl NUMERIC(p, s)/DECIMAL(p, s) Festkomazahl. p steht f\u00fcr die Stellen nach dem 0, s f\u00fcr die Stellen nach vor dem 0 INDEX Shortcut f\u00fcr Domains GENERATED BY DEFAULT AS IDENTITY Domains sind Typenalias. Domain erstellen create domain <name> as <datentyp> Der Name ist der Name, welcher zuk\u00fcnfigt als Typ verwendet werden k\u00f6nnen, der Datentyp ist ein Typ, wie \"CHAR(10)\". Domain L\u00f6schen L\u00f6scht eine Domain drop domain <name Schemas Schema Erstellen Um eine neues Schema zuerstellen zu k\u00f6nnen: create schema <name> [authorization <user>] In Postgressql ist ein Schema ein Teil einer Datenbank. In MySQL diese Terme kann man gleich setzten. Schema L\u00f6schen drop schema <name> [cascade] L\u00f6scht das angegebene Schema \"casecade\" l\u00f6scht ohne nach zu fragen. Schema ausw\u00e4hlen use schema <name> Mit diesem Befehl wird ein Schema ausgew\u00e4hlt, dass f\u00fcr zuk\u00fcnfigite Befehle, wie create table ben\u00fctzt werden soll. Tabellen Tabellen Erstellen Um eine neue Tabelle erstellen zu k\u00f6nnen: create table <tablename> (<columnName1> <columnTyp1> <optionen> | table constraint, ...) optionen NOT NULL - Attribut kann nicht null sein (kann nicht benannt werden) DEFAULT (<value>) - Setzt ein Default Wert CHECK (<condition>) - Das Attribut muss die Kondition erf\u00fcllen PRRIMARY KEY (impliziert NOT NULL ) - Definiert ein Attribut als Primary Key UNIQUE - Attribute muss einzigartig sein table constraint - Anstatt ein Attribut kann auch ein Table Constraint definiert werden: [CONSTRAINT <constraintName>] <optionen von oben> Tabelle Kopieren Wenn man das Schema (ohne Constraints) kopieren m\u00f6chte, kann man folgenden Befehl ben\u00fctzten: CREATE TABLE <tablename> LIKE <table_copy_from> [INCLUDING CONSTRAINTS] Mit INCLUDING CONSTRAINTS k\u00f6nnen auch die Constraints \u00fcbernommen werden. Um mit Daten eine neue Tabelle zu erstellen, kann man auch den folgenden Befehl ben\u00fctzten: CREATE TABLE <tablename> AS (<subquery>) . Dies erstellt eine neue Tabelle auf Basis der Subquery. Eine normale Tabelle kann nicht mit update materialized view geupdated werden. Tabellen L\u00f6schen drop table <tablename> [cascade] L\u00f6scht die angegebene Tabelle \"casecade\" l\u00f6scht ohne nach zu fragen. Tabellen \u00c4ndern ALTER TABLE <tableName> ADD <column|contraint> ALTER TABLE <tableName> DROP (<column>|CONSTRAINT <contraint>) [CASCADE] ALTER TABLE <tableName> ALTER <column>|<contraint> [SET DEFAULT <default_value>] Constraints Arten NOT NULL - Attribut kann nicht null sein (kann nicht benannt werden) DEFAULT (<value>) - Setzt ein Default Wert CHECK (<condition>) - Das Attribut muss die Kondition erf\u00fcllen PRRIMARY KEY [(<spalte1>, ...)] (impliziert NOT NULL und UNIQUE ) - Definiert ein oder mehrere Attribute als Primary Key. (max 1 pro Tabelle) FOREIGN KEY <spalte1> REFERENCES <table> [<spalte>] - erstellt ein Foreign Key UNIQUE [(<spalte1>, ...)] - Attribute muss einzigartig sein Bei FOREIGN KEY kann zus\u00e4tzlich noch folgendes angegeben werden: ON UPDATE CASCADE - wenn der Primary Key ge\u00e4ndert wird, werden die Foreign Keys auch ge\u00e4ndert. ON DELETE CASCADE - wenn der Primary Key gel\u00f6scht wird, werden Tupels, welche darauf referenzieren auch gel\u00f6scht. Beispiel: CREATE TABLE Player ( name VARCHAR ( 255 ), club_name VARCHAR ( 255 ), CONSTRAINT club_name_constraint FOREIGN KEY ( club_name ) REFERENCES Club ( name ) ON UPDATE CASCADE ON DELETE CASCADE ) Daten Hinzuf\u00fcgen INSERT INTO <tabelle> [(<attribut1>, ...)] VALUES (<value1>,...) INSERT INTO <tabelle> [(<attribut1>, ...)] (<query>) F\u00fcgt ein Tupel in eine Tabelle ein. Ebenfalls kann anstatt fixe Werte ein SELECT angegeben werden. In diesem Fall werden die Werte von der Query \u00fcbernommen Daten Updaten UPDATE <tableName> SET <attribut1> = <value1> , ... [WHERE <condition>] \u00c4ndert alle Tupels, bei welchen die Kondition zutrifft. Falls kein WHERE angegeben wurde, werden alle Tupels in der Spalte ge\u00e4ndert. Daten Abfragen SELECT <spalte1>, ... FROM <tabellen> [WHERE <condition>] [GROUP BY <spalte>, ... [HAVING <condition>]] [ORDER BY <column> [ASC|DESC]] [LIMIT <limit>] [OFFSET <start>] Als Spalte kann folgendes angegeben werden Spalten von Tabellen vom FROM-Teil Mathe/Funktionen mit spalten (z.B. saler * 1.2 + 1000 als spalte) DISTINCT <spalte> - dies eliminiert Duplikate in der angegebenen Spalte '*' steht f\u00fcr alle Spalten vom FROM-Teil Konstante (z.B. 1) Aggregate Funktionen, wie AVG(<spalte>) , SUM(<spalte>) . Daf\u00fcr sollte aber auch GROUP BY spezifiziert sein Jede \"Spalte\" von dieser Liste kann mit AS <name> umbenennt werden Mit EXTRACT (YEAR from <spalte>) kann z.B. das Jahr von einem Datum extrahiert werden Mit CASE WHEN <condition> THEN <value1> [WHEN <condition> THEN <vallue2>] ELSE <valueN> END kann eine \"If\"-Bedinung gestallten werden Mit COALESCE(<args1>, <argN>, ...) wird das erste Argument zur\u00fcck geben, welches nicht Null ist Als tabellen kann folgendes geschrieben werden: Eine oder mehrere Tabellen. Wenn mehrere Tabellen definiert werden, wird das Kreuzprodukt gebildet Nach einer Tabelle kann ein Name angegeben werden (z.B. BestellPosition BP BestellPostion k\u00f6nnte in der Query als BP benutzt werden) <tabelle> CROSS JOIN <tabelle> - bildet das Kreuzprodukt <tabelle> LEFT JOIN <tabelle> - Alle Eintr\u00e4ge von der linken Seite werden \u00fcbernommen. Wenn keine Eintrag auf der rechten Seite gefunden wird, sind die entsprechenden Spalten NULL <tabelle> RIGHT JOIN <tabelle> - Alle Eintr\u00e4ge von der rechten Seite werden \u00fcbernommen. Die Spalten der linken Seite werden NULL , wenn kein Eintrag zu der rechten Seite gefunden wurde. <tabelle> OUTER JOIN <tabelle> - LEFT und RIGHT JOIN kombiniert <tabelle> FULL OUTER JOIN <tabelle> - <tabelle NATURAL FULL OUTER JOIN <tabelle> - <tabelle> [INNER] JOIN <tabelle> - Liefert nur Resultate, welche auf beiden Tabellen einen Eintrag haben. Es gibt den alternativ Syntax SELECT * FROM a, b WHERE a.x = b.x <tabelle> NATURAL JOIN <tabelle> - Ist das Equivalente zu \\(\\bowtie\\) . Es werden gemeinsame Attribute benutzt. Falls es keine gibt, wird ein Kreuzprodukt gebildet Subqueries - <subquery> AS <variable> Das AS weisst der Subquery einen Namen zu, welchen man wie als Tabellennamen benutzten kann conditions <column> LIKE <likeStr> Like funktioniert \u00e4hlich, wie = , nur das % anstatt beliebiege Zeichen eingesetzt werden k\u00f6nnen und _ als ein bestimmtes Zeichen. Dies funktioniert nur f\u00fcr Strings <column> BETWEEN <start> AND <end> Findet alle Werte zwischen dem start und end (inklusiv start und end). Dies funktioniert auch mit Strings oder Daten <column> IS [NOT] NULL - pr\u00fcft, ob ein Wert NULL ist <> - steht f\u00fcr nicht gleich, wie != in den meisten Sprachen EXISTS (subquery) - \u00fcberpr\u00fcft, ob die subquery etwas zur\u00fcck geliefert hat <column> IN (<wert1>, ...) ODER <column> IN (<subquery>) - Stelltsicher, dass der Wert der Spalte in der Wertelist ist oder in der Subquery gefunden wird. Die Subquery muss eine Spalte zur\u00fcck geben oder der <column> -Teil muss ein Tupel sein (wie (<column1>, <column2>, ...) IN (select <column1>, <column2>, ...) from ... ). Die Reihenfolge wird beachtet, nicht die Namen selbst! <column> NOT IN (<wert1>, ...) oder <column> NOT IN (<subquery>) - Gleich wie IN nur, dass der Wert der Spalte nicht in der Werteliste oder Subquery vorkommen darf. ORDER BY ASC - Aufsteigend (default) DESC - Absteigend Reihenfolge In der folgenden Reihenfolge werden SQL Queries abgearbeitet. Speziell wo WHERE und HAVING steht. FROM WHERE GROUP BY HAVING SELECT ORDER BY Aggregatsfunktionen SQL kennt folgende Aggregationsfunktionen COUNT(<spalte>) , AVG(<spalte>) , SUM(<spalte>) , MIN(<spalte>) , MAX(<spalte>) ( AVG(<splate>) ist nicht dasselbe, wie SUM(<spalte>)/COUNT(<spalte>) , da COUNT auch NULL Werte z\u00e4hlt) Die Aggregationsfunktionen operieren auf den Gruppen, welche von GROUP BY erstellt wurde. Wichtig zu erw\u00e4hnen ist, dass HAVING auf dem aggregiertem Ergebniss filtert und WHERE vor dem Gruppieren. In einer Aggregationsfunktion kann DISTINCT verwendet werden (wie COUNT(DISTINCT <spalte>)) . Somit werden nur verschiedene Werte gez\u00e4hlt, summiert,... Subqueries Abfragen k\u00f6nnen miteinander verbunden werden: <query> (UNIION | INTERSECT | EXCEPT) [ALL|DISTINCT] <query> UNION ALL = Bag Concatenation INTERSECT ALL = \\(\\cap\\) EXCEPT ALL = \\ Ohne ALL wird automatisch DISTINCT gebraucht, was Duplikate entfernt. ALL und ANY where <column> <|>|<=|>= [NOT] ALL(<subquery>) where <column> <|>|<=|>= [NOT]ANY (<subquery>) WHERE alter > all(select alter from person) w\u00fcrde sicher stellen, dass das Alter gr\u00f6sser ist als alle Alter der Personen der Tabelle Person. WHERE alter > ANY(select alter from person) w\u00fcrde sicher stellen, dass das Alter gr\u00f6sser ist als mindestens ein Alter einer Person der Tabelle Person. EXISTS where [NOT] EXISTS(<subquery>) EXISTS wird true, wenn die Subquery kein leeres Resultat zur\u00fcck bringt. Beispiel: select * from person as P where exists (select 1 from angestellte as A where P.name=A.name) angestellte Common Table Expression (CTE) Mit dem Syntax: WITH <cte_name> AS (<select_query>)<select_query2> <select_query2> kann nun eine Tabelle <cte_name> ben\u00fctzten. Dies kann Abfragen vereinfachen, welche viele Subqueries haben. Views Materialized View Eine materialized View updaten nicht automatisch, sondern muss manuell geupdated werden mit REFRESH MATERIALIZED VIEW <name> . Dies kann auch mit Triggers erledigt werden. So k\u00f6nnte man z.B. nach einem Zeitintervall die Materialized View updaten. View erstellen CREATE [MATERIALIZED] VIEW <name> AS <abfrage> Damit wird eine View erstellt. Dies kann n\u00fctzlich sein, um die Schreibarbeit zu minimieren. Ebenfalls kann es dazu verwendet werden, Rechte auf nur einen Teil einer Tabelle zu verteilen. Views k\u00f6nnen auch von anderen Views abh\u00e4ngig sein. Wenn eine View von mehreren Tabellen abh\u00e4ngig ist (oder andere Speziallf\u00e4lle), k\u00f6nnen keine neue Daten eingef\u00fcgt werden. Wenn eine View mit AS select * from <tabelle> erstellt, dann k\u00f6nnen Daten ge\u00e4ndert werden. View \u00e4ndern ALTER VIEW <name> .. Kann dazu verwedet werden, um verschiedene Eigenschaften einer View zu \u00e4ndern. Um die Spalten einer View zu \u00e4ndern, ist es aber einfacher einfach die View zu l\u00f6schen und neu zu erstellen. View l\u00f6schen DROP VIEW <name> Damit wird eine View gel\u00f6scht. Stored Procedures/Funktion Vorteile Reduktion von Datenverkehr zwischen Client und DBMS Sehr komplexe Abfragen sind m\u00f6glich Sind verwendtbar von mehreren Applikationen Nachteile Syntax nicht standardisiert Fehlerbehandlung ist umst\u00e4ndlich Unkonfortable zum Entwickeln (Vermutlich noch ein Ort mehr, an dem dieselbe Logik implementiert wird (z.B. in HTML/JS, Java Server und noch DBMS)) CREATE PROCEDURE <name> ALTER PROCEDURE <name>... DROP PROCEDURE <name> CREATE FUNCTION <name> ALTER FUNCTION <name>... DROP FUNCTION <name> Die Grundstruktur einer Funktion sieht folgendermassen aus: CREATE OR REPLACE FUNCTION <name>() RETURNS <returnType> AS $body$ BEGIN <mainLogicBlock> EXCEPTION <exceptionBlock> END $body$ Mit SELECT <name>() kann man diese Funktion danach aufraufen. Variabeln <name> [CONSTANT] <type> [NOT NULL] <expression> <name> [CONSTANT] <type> [NOT NULL] DEFAULT <expression> Mit dem obigen SQL k\u00f6nnen Variabeln in einer Funktion erstellt werden. Cursor DECLARE < cursor_name > CURSOR FOR < select_expression > [ FOR UPDATE ] Mit OPEN <cursor_name> kann der Cursor ge\u00f6ffnet werden und mit CLOSE <cursor_name> wieder geschlossen. CREATE OR REPLACE FUNCTION Show_AlleBesuchernamen() RETURNS VOID AS $$ DECLARE rec_Besucher record; c_Namen CURSOR FOR SELECT Name,Vorname FROM Besucher; BEGIN OPEN c_Namen; LOOP FETCH c_Namen INTO rec_Besucher; EXIT WHEN NOT FOUND; RAISE NOTICE 'Name: % Vorname: % ',rec_Besucher.Name, rec_Besucher.Vorname; END LOOP; CLOSE c_Namen; END; $$ LANGUAGE plpgsql; Trigger Triggers werden ausgef\u00fchrt, wenn ein sich eine Tabelle \u00e4ndert. Einen Trigger kann f\u00fcr INSERT, UPDATE und DELETE definiert werden. Mit den typeschen SQL Statements k\u00f6nnen Triggers erstellt werden. CREATE TRIGGER <name> (BEFORE|AFTER|INSTEAD OF) ON <tabelle> FOR EACH ROW EXECUTE PROCEDURE <procedure/function>() ALTER TRIGGER <name> (DISABLE|ENABLE) DROP TRIGGER <name> Index Mit CREATE INDEX <name> on <table>(<column>, ...) kann ein Index erstelt werden und mit DROP INDEX <name> weder gel\u00f6scht werden. Ein Index hat einige Vorteile, aber auch Nachteille: Vorteil: Zugriffzeit Da die Daten nun eine Sortierung haben, kann die DB schneller auf die Daten zugreifen Nachteile: Speicherplatz Der Index b\u00f6ntigt platz Zeit Um den Index zu erstellen und nocht wichtiger beim Updaten , ben\u00f6tigt die DB Zeit, um den Index neu zu schreiben Wann lohnt sich ein Index? Attribute, welche oft Abgefragt werden Femdschl\u00fcssel sollten indexiert werden Generell, Attribute, \u00fcber die oft gejoint weden, sollten indexiert werden Attribute mit niedriger Kardinalit\u00e4t sollten nicht indexiert weden (daf\u00fcr gibt es spezielle Indexstrukturen, welche wir allerdings nicht behandeln) D\u00fcnn- vs. Dichtbesetzer Index Transaktionen Im folgenden Bild sind die verschiedenen Statis einer Transakti Lost-Update Es darf nicht gleizeitig aus zwei Transaktionen geschrieben werden. Dies verhindert ein Lost-Update Dirty Read Non-Repeatable Read Phantom-Read","title":"SQL"},{"location":"21HS/DB/04_SQL.html#sql","text":"","title":"SQL"},{"location":"21HS/DB/04_SQL.html#datentypen","text":"Datentyp Erkl\u00e4rung CHAR(n)/Character(n) String mit einer fixen L\u00e4nge Char Varying(n)/VARCHAR(n) String, welcher beliebig Lang sein kann . Kann aber ein Limit haben TEXT String, mit beliebiger L\u00e4nge Int/INTEGER Ganzzahl REAL Fliesskomazahl NUMERIC(p, s)/DECIMAL(p, s) Festkomazahl. p steht f\u00fcr die Stellen nach dem 0, s f\u00fcr die Stellen nach vor dem 0 INDEX Shortcut f\u00fcr","title":"Datentypen"},{"location":"21HS/DB/04_SQL.html#domains","text":"GENERATED BY DEFAULT AS IDENTITY Domains sind Typenalias.","title":"Domains"},{"location":"21HS/DB/04_SQL.html#domain-erstellen","text":"create domain <name> as <datentyp> Der Name ist der Name, welcher zuk\u00fcnfigt als Typ verwendet werden k\u00f6nnen, der Datentyp ist ein Typ, wie \"CHAR(10)\".","title":"Domain erstellen"},{"location":"21HS/DB/04_SQL.html#domain-loschen","text":"L\u00f6scht eine Domain drop domain <name","title":"Domain L\u00f6schen"},{"location":"21HS/DB/04_SQL.html#schemas","text":"","title":"Schemas"},{"location":"21HS/DB/04_SQL.html#schema-erstellen","text":"Um eine neues Schema zuerstellen zu k\u00f6nnen: create schema <name> [authorization <user>] In Postgressql ist ein Schema ein Teil einer Datenbank. In MySQL diese Terme kann man gleich setzten.","title":"Schema Erstellen"},{"location":"21HS/DB/04_SQL.html#schema-loschen","text":"drop schema <name> [cascade] L\u00f6scht das angegebene Schema \"casecade\" l\u00f6scht ohne nach zu fragen.","title":"Schema L\u00f6schen"},{"location":"21HS/DB/04_SQL.html#schema-auswahlen","text":"use schema <name> Mit diesem Befehl wird ein Schema ausgew\u00e4hlt, dass f\u00fcr zuk\u00fcnfigite Befehle, wie create table ben\u00fctzt werden soll.","title":"Schema ausw\u00e4hlen"},{"location":"21HS/DB/04_SQL.html#tabellen","text":"","title":"Tabellen"},{"location":"21HS/DB/04_SQL.html#tabellen-erstellen","text":"Um eine neue Tabelle erstellen zu k\u00f6nnen: create table <tablename> (<columnName1> <columnTyp1> <optionen> | table constraint, ...) optionen NOT NULL - Attribut kann nicht null sein (kann nicht benannt werden) DEFAULT (<value>) - Setzt ein Default Wert CHECK (<condition>) - Das Attribut muss die Kondition erf\u00fcllen PRRIMARY KEY (impliziert NOT NULL ) - Definiert ein Attribut als Primary Key UNIQUE - Attribute muss einzigartig sein table constraint - Anstatt ein Attribut kann auch ein Table Constraint definiert werden: [CONSTRAINT <constraintName>] <optionen von oben>","title":"Tabellen Erstellen"},{"location":"21HS/DB/04_SQL.html#tabelle-kopieren","text":"Wenn man das Schema (ohne Constraints) kopieren m\u00f6chte, kann man folgenden Befehl ben\u00fctzten: CREATE TABLE <tablename> LIKE <table_copy_from> [INCLUDING CONSTRAINTS] Mit INCLUDING CONSTRAINTS k\u00f6nnen auch die Constraints \u00fcbernommen werden. Um mit Daten eine neue Tabelle zu erstellen, kann man auch den folgenden Befehl ben\u00fctzten: CREATE TABLE <tablename> AS (<subquery>) . Dies erstellt eine neue Tabelle auf Basis der Subquery. Eine normale Tabelle kann nicht mit update materialized view geupdated werden.","title":"Tabelle Kopieren"},{"location":"21HS/DB/04_SQL.html#tabellen-loschen","text":"drop table <tablename> [cascade] L\u00f6scht die angegebene Tabelle \"casecade\" l\u00f6scht ohne nach zu fragen.","title":"Tabellen L\u00f6schen"},{"location":"21HS/DB/04_SQL.html#tabellen-andern","text":"ALTER TABLE <tableName> ADD <column|contraint> ALTER TABLE <tableName> DROP (<column>|CONSTRAINT <contraint>) [CASCADE] ALTER TABLE <tableName> ALTER <column>|<contraint> [SET DEFAULT <default_value>]","title":"Tabellen \u00c4ndern"},{"location":"21HS/DB/04_SQL.html#constraints","text":"","title":"Constraints"},{"location":"21HS/DB/04_SQL.html#arten","text":"NOT NULL - Attribut kann nicht null sein (kann nicht benannt werden) DEFAULT (<value>) - Setzt ein Default Wert CHECK (<condition>) - Das Attribut muss die Kondition erf\u00fcllen PRRIMARY KEY [(<spalte1>, ...)] (impliziert NOT NULL und UNIQUE ) - Definiert ein oder mehrere Attribute als Primary Key. (max 1 pro Tabelle) FOREIGN KEY <spalte1> REFERENCES <table> [<spalte>] - erstellt ein Foreign Key UNIQUE [(<spalte1>, ...)] - Attribute muss einzigartig sein Bei FOREIGN KEY kann zus\u00e4tzlich noch folgendes angegeben werden: ON UPDATE CASCADE - wenn der Primary Key ge\u00e4ndert wird, werden die Foreign Keys auch ge\u00e4ndert. ON DELETE CASCADE - wenn der Primary Key gel\u00f6scht wird, werden Tupels, welche darauf referenzieren auch gel\u00f6scht. Beispiel: CREATE TABLE Player ( name VARCHAR ( 255 ), club_name VARCHAR ( 255 ), CONSTRAINT club_name_constraint FOREIGN KEY ( club_name ) REFERENCES Club ( name ) ON UPDATE CASCADE ON DELETE CASCADE )","title":"Arten"},{"location":"21HS/DB/04_SQL.html#daten-hinzufugen","text":"INSERT INTO <tabelle> [(<attribut1>, ...)] VALUES (<value1>,...) INSERT INTO <tabelle> [(<attribut1>, ...)] (<query>) F\u00fcgt ein Tupel in eine Tabelle ein. Ebenfalls kann anstatt fixe Werte ein SELECT angegeben werden. In diesem Fall werden die Werte von der Query \u00fcbernommen","title":"Daten Hinzuf\u00fcgen"},{"location":"21HS/DB/04_SQL.html#daten-updaten","text":"UPDATE <tableName> SET <attribut1> = <value1> , ... [WHERE <condition>] \u00c4ndert alle Tupels, bei welchen die Kondition zutrifft. Falls kein WHERE angegeben wurde, werden alle Tupels in der Spalte ge\u00e4ndert.","title":"Daten Updaten"},{"location":"21HS/DB/04_SQL.html#daten-abfragen","text":"SELECT <spalte1>, ... FROM <tabellen> [WHERE <condition>] [GROUP BY <spalte>, ... [HAVING <condition>]] [ORDER BY <column> [ASC|DESC]] [LIMIT <limit>] [OFFSET <start>] Als Spalte kann folgendes angegeben werden Spalten von Tabellen vom FROM-Teil Mathe/Funktionen mit spalten (z.B. saler * 1.2 + 1000 als spalte) DISTINCT <spalte> - dies eliminiert Duplikate in der angegebenen Spalte '*' steht f\u00fcr alle Spalten vom FROM-Teil Konstante (z.B. 1) Aggregate Funktionen, wie AVG(<spalte>) , SUM(<spalte>) . Daf\u00fcr sollte aber auch GROUP BY spezifiziert sein Jede \"Spalte\" von dieser Liste kann mit AS <name> umbenennt werden Mit EXTRACT (YEAR from <spalte>) kann z.B. das Jahr von einem Datum extrahiert werden Mit CASE WHEN <condition> THEN <value1> [WHEN <condition> THEN <vallue2>] ELSE <valueN> END kann eine \"If\"-Bedinung gestallten werden Mit COALESCE(<args1>, <argN>, ...) wird das erste Argument zur\u00fcck geben, welches nicht Null ist Als tabellen kann folgendes geschrieben werden: Eine oder mehrere Tabellen. Wenn mehrere Tabellen definiert werden, wird das Kreuzprodukt gebildet Nach einer Tabelle kann ein Name angegeben werden (z.B. BestellPosition BP BestellPostion k\u00f6nnte in der Query als BP benutzt werden) <tabelle> CROSS JOIN <tabelle> - bildet das Kreuzprodukt <tabelle> LEFT JOIN <tabelle> - Alle Eintr\u00e4ge von der linken Seite werden \u00fcbernommen. Wenn keine Eintrag auf der rechten Seite gefunden wird, sind die entsprechenden Spalten NULL <tabelle> RIGHT JOIN <tabelle> - Alle Eintr\u00e4ge von der rechten Seite werden \u00fcbernommen. Die Spalten der linken Seite werden NULL , wenn kein Eintrag zu der rechten Seite gefunden wurde. <tabelle> OUTER JOIN <tabelle> - LEFT und RIGHT JOIN kombiniert <tabelle> FULL OUTER JOIN <tabelle> - <tabelle NATURAL FULL OUTER JOIN <tabelle> - <tabelle> [INNER] JOIN <tabelle> - Liefert nur Resultate, welche auf beiden Tabellen einen Eintrag haben. Es gibt den alternativ Syntax SELECT * FROM a, b WHERE a.x = b.x <tabelle> NATURAL JOIN <tabelle> - Ist das Equivalente zu \\(\\bowtie\\) . Es werden gemeinsame Attribute benutzt. Falls es keine gibt, wird ein Kreuzprodukt gebildet Subqueries - <subquery> AS <variable> Das AS weisst der Subquery einen Namen zu, welchen man wie als Tabellennamen benutzten kann conditions <column> LIKE <likeStr> Like funktioniert \u00e4hlich, wie = , nur das % anstatt beliebiege Zeichen eingesetzt werden k\u00f6nnen und _ als ein bestimmtes Zeichen. Dies funktioniert nur f\u00fcr Strings <column> BETWEEN <start> AND <end> Findet alle Werte zwischen dem start und end (inklusiv start und end). Dies funktioniert auch mit Strings oder Daten <column> IS [NOT] NULL - pr\u00fcft, ob ein Wert NULL ist <> - steht f\u00fcr nicht gleich, wie != in den meisten Sprachen EXISTS (subquery) - \u00fcberpr\u00fcft, ob die subquery etwas zur\u00fcck geliefert hat <column> IN (<wert1>, ...) ODER <column> IN (<subquery>) - Stelltsicher, dass der Wert der Spalte in der Wertelist ist oder in der Subquery gefunden wird. Die Subquery muss eine Spalte zur\u00fcck geben oder der <column> -Teil muss ein Tupel sein (wie (<column1>, <column2>, ...) IN (select <column1>, <column2>, ...) from ... ). Die Reihenfolge wird beachtet, nicht die Namen selbst! <column> NOT IN (<wert1>, ...) oder <column> NOT IN (<subquery>) - Gleich wie IN nur, dass der Wert der Spalte nicht in der Werteliste oder Subquery vorkommen darf. ORDER BY ASC - Aufsteigend (default) DESC - Absteigend","title":"Daten Abfragen"},{"location":"21HS/DB/04_SQL.html#reihenfolge","text":"In der folgenden Reihenfolge werden SQL Queries abgearbeitet. Speziell wo WHERE und HAVING steht. FROM WHERE GROUP BY HAVING SELECT ORDER BY","title":"Reihenfolge"},{"location":"21HS/DB/04_SQL.html#aggregatsfunktionen","text":"SQL kennt folgende Aggregationsfunktionen COUNT(<spalte>) , AVG(<spalte>) , SUM(<spalte>) , MIN(<spalte>) , MAX(<spalte>) ( AVG(<splate>) ist nicht dasselbe, wie SUM(<spalte>)/COUNT(<spalte>) , da COUNT auch NULL Werte z\u00e4hlt) Die Aggregationsfunktionen operieren auf den Gruppen, welche von GROUP BY erstellt wurde. Wichtig zu erw\u00e4hnen ist, dass HAVING auf dem aggregiertem Ergebniss filtert und WHERE vor dem Gruppieren. In einer Aggregationsfunktion kann DISTINCT verwendet werden (wie COUNT(DISTINCT <spalte>)) . Somit werden nur verschiedene Werte gez\u00e4hlt, summiert,...","title":"Aggregatsfunktionen"},{"location":"21HS/DB/04_SQL.html#subqueries","text":"Abfragen k\u00f6nnen miteinander verbunden werden: <query> (UNIION | INTERSECT | EXCEPT) [ALL|DISTINCT] <query> UNION ALL = Bag Concatenation INTERSECT ALL = \\(\\cap\\) EXCEPT ALL = \\ Ohne ALL wird automatisch DISTINCT gebraucht, was Duplikate entfernt.","title":"Subqueries"},{"location":"21HS/DB/04_SQL.html#all-und-any","text":"where <column> <|>|<=|>= [NOT] ALL(<subquery>) where <column> <|>|<=|>= [NOT]ANY (<subquery>) WHERE alter > all(select alter from person) w\u00fcrde sicher stellen, dass das Alter gr\u00f6sser ist als alle Alter der Personen der Tabelle Person. WHERE alter > ANY(select alter from person) w\u00fcrde sicher stellen, dass das Alter gr\u00f6sser ist als mindestens ein Alter einer Person der Tabelle Person.","title":"ALL und ANY"},{"location":"21HS/DB/04_SQL.html#exists","text":"where [NOT] EXISTS(<subquery>) EXISTS wird true, wenn die Subquery kein leeres Resultat zur\u00fcck bringt. Beispiel: select * from person as P where exists (select 1 from angestellte as A where P.name=A.name) angestellte","title":"EXISTS"},{"location":"21HS/DB/04_SQL.html#common-table-expression-cte","text":"Mit dem Syntax: WITH <cte_name> AS (<select_query>)<select_query2> <select_query2> kann nun eine Tabelle <cte_name> ben\u00fctzten. Dies kann Abfragen vereinfachen, welche viele Subqueries haben.","title":"Common Table Expression (CTE)"},{"location":"21HS/DB/04_SQL.html#views","text":"","title":"Views"},{"location":"21HS/DB/04_SQL.html#materialized-view","text":"Eine materialized View updaten nicht automatisch, sondern muss manuell geupdated werden mit REFRESH MATERIALIZED VIEW <name> . Dies kann auch mit Triggers erledigt werden. So k\u00f6nnte man z.B. nach einem Zeitintervall die Materialized View updaten.","title":"Materialized View"},{"location":"21HS/DB/04_SQL.html#view-erstellen","text":"CREATE [MATERIALIZED] VIEW <name> AS <abfrage> Damit wird eine View erstellt. Dies kann n\u00fctzlich sein, um die Schreibarbeit zu minimieren. Ebenfalls kann es dazu verwendet werden, Rechte auf nur einen Teil einer Tabelle zu verteilen. Views k\u00f6nnen auch von anderen Views abh\u00e4ngig sein. Wenn eine View von mehreren Tabellen abh\u00e4ngig ist (oder andere Speziallf\u00e4lle), k\u00f6nnen keine neue Daten eingef\u00fcgt werden. Wenn eine View mit AS select * from <tabelle> erstellt, dann k\u00f6nnen Daten ge\u00e4ndert werden.","title":"View erstellen"},{"location":"21HS/DB/04_SQL.html#view-andern","text":"ALTER VIEW <name> .. Kann dazu verwedet werden, um verschiedene Eigenschaften einer View zu \u00e4ndern. Um die Spalten einer View zu \u00e4ndern, ist es aber einfacher einfach die View zu l\u00f6schen und neu zu erstellen.","title":"View \u00e4ndern"},{"location":"21HS/DB/04_SQL.html#view-loschen","text":"DROP VIEW <name> Damit wird eine View gel\u00f6scht.","title":"View l\u00f6schen"},{"location":"21HS/DB/04_SQL.html#stored-proceduresfunktion","text":"Vorteile Reduktion von Datenverkehr zwischen Client und DBMS Sehr komplexe Abfragen sind m\u00f6glich Sind verwendtbar von mehreren Applikationen Nachteile Syntax nicht standardisiert Fehlerbehandlung ist umst\u00e4ndlich Unkonfortable zum Entwickeln (Vermutlich noch ein Ort mehr, an dem dieselbe Logik implementiert wird (z.B. in HTML/JS, Java Server und noch DBMS)) CREATE PROCEDURE <name> ALTER PROCEDURE <name>... DROP PROCEDURE <name> CREATE FUNCTION <name> ALTER FUNCTION <name>... DROP FUNCTION <name> Die Grundstruktur einer Funktion sieht folgendermassen aus: CREATE OR REPLACE FUNCTION <name>() RETURNS <returnType> AS $body$ BEGIN <mainLogicBlock> EXCEPTION <exceptionBlock> END $body$ Mit SELECT <name>() kann man diese Funktion danach aufraufen.","title":"Stored Procedures/Funktion"},{"location":"21HS/DB/04_SQL.html#variabeln","text":"<name> [CONSTANT] <type> [NOT NULL] <expression> <name> [CONSTANT] <type> [NOT NULL] DEFAULT <expression> Mit dem obigen SQL k\u00f6nnen Variabeln in einer Funktion erstellt werden.","title":"Variabeln"},{"location":"21HS/DB/04_SQL.html#cursor","text":"DECLARE < cursor_name > CURSOR FOR < select_expression > [ FOR UPDATE ] Mit OPEN <cursor_name> kann der Cursor ge\u00f6ffnet werden und mit CLOSE <cursor_name> wieder geschlossen. CREATE OR REPLACE FUNCTION Show_AlleBesuchernamen() RETURNS VOID AS $$ DECLARE rec_Besucher record; c_Namen CURSOR FOR SELECT Name,Vorname FROM Besucher; BEGIN OPEN c_Namen; LOOP FETCH c_Namen INTO rec_Besucher; EXIT WHEN NOT FOUND; RAISE NOTICE 'Name: % Vorname: % ',rec_Besucher.Name, rec_Besucher.Vorname; END LOOP; CLOSE c_Namen; END; $$ LANGUAGE plpgsql;","title":"Cursor"},{"location":"21HS/DB/04_SQL.html#trigger","text":"Triggers werden ausgef\u00fchrt, wenn ein sich eine Tabelle \u00e4ndert. Einen Trigger kann f\u00fcr INSERT, UPDATE und DELETE definiert werden. Mit den typeschen SQL Statements k\u00f6nnen Triggers erstellt werden. CREATE TRIGGER <name> (BEFORE|AFTER|INSTEAD OF) ON <tabelle> FOR EACH ROW EXECUTE PROCEDURE <procedure/function>() ALTER TRIGGER <name> (DISABLE|ENABLE) DROP TRIGGER <name>","title":"Trigger"},{"location":"21HS/DB/04_SQL.html#index","text":"Mit CREATE INDEX <name> on <table>(<column>, ...) kann ein Index erstelt werden und mit DROP INDEX <name> weder gel\u00f6scht werden. Ein Index hat einige Vorteile, aber auch Nachteille: Vorteil: Zugriffzeit Da die Daten nun eine Sortierung haben, kann die DB schneller auf die Daten zugreifen Nachteile: Speicherplatz Der Index b\u00f6ntigt platz Zeit Um den Index zu erstellen und nocht wichtiger beim Updaten , ben\u00f6tigt die DB Zeit, um den Index neu zu schreiben","title":"Index"},{"location":"21HS/DB/04_SQL.html#wann-lohnt-sich-ein-index","text":"Attribute, welche oft Abgefragt werden Femdschl\u00fcssel sollten indexiert werden Generell, Attribute, \u00fcber die oft gejoint weden, sollten indexiert werden Attribute mit niedriger Kardinalit\u00e4t sollten nicht indexiert weden (daf\u00fcr gibt es spezielle Indexstrukturen, welche wir allerdings nicht behandeln)","title":"Wann lohnt sich ein Index?"},{"location":"21HS/DB/04_SQL.html#dunn-vs-dichtbesetzer-index","text":"","title":"D\u00fcnn- vs. Dichtbesetzer Index"},{"location":"21HS/DB/04_SQL.html#transaktionen","text":"Im folgenden Bild sind die verschiedenen Statis einer Transakti","title":"Transaktionen"},{"location":"21HS/DB/04_SQL.html#lost-update","text":"Es darf nicht gleizeitig aus zwei Transaktionen geschrieben werden. Dies verhindert ein Lost-Update","title":"Lost-Update"},{"location":"21HS/DB/04_SQL.html#dirty-read","text":"","title":"Dirty Read"},{"location":"21HS/DB/04_SQL.html#non-repeatable-read","text":"","title":"Non-Repeatable Read"},{"location":"21HS/DB/04_SQL.html#phantom-read","text":"","title":"Phantom-Read"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html","text":"Integrit\u00e4tsregeln Wichtig anzumerken, nur weill die Datenbank konsistenz ist, heisst nicht, dass die Daten darin korrekt sind. \u00dcberpr\u00fcfbare Regeln Bereichintegrit\u00e4t Das DB-System stellt sicher, dass der Wert eines Attributes in einem Wertebereich ist. Daf\u00fcr k\u00f6nnen z.B. NULL und NOT NULL , wie auch Dom\u00e4nen verwendet werden Entit\u00e4tsintegrit\u00e4t Der Prim\u00e4tschl\u00fcssel kann nicht leer sein. Also nicht NULL Refentielle Integrit\u00e4t Der Wert eines Fremdschl\u00fcssel muss NULL sein oder genau einen Prim\u00e4rschl\u00fcssel referezieren Constraints Zus\u00e4tzlich k\u00f6nnen Constraints geschrieben werden, um weitere Bedingungen zu \u00fcberpr\u00fcfen. Siehe SQL ACID ACID steht f\u00fcr Atomicity, Consistency, Isolation und Durability. Dies sind Eigenschaften, welche von einer Transaktion eingehalten werden soll. Atomicity Entweder funktioniert alle Statements in einer Transaktion oder kein Statement. Wenn ein Fehler auftritt, m\u00fcssen alle \u00c4nderungen davor r\u00fcckg\u00e4ngig gemacht werden (Rollback). Consistency Nach einer Operation muss die DB wieder in einem Konsistenten Zustand hinterlassen werden. Isolation Zwei parallel-laufende Transaktionen d\u00fcrfen sich nicht beinflussen. Durability Die DB muss erfolgreiche Statements speichern, so dass selbst im Fall eines Absturz diese wieder geladen werden k\u00f6nnten. Falls dies nicht m\u00f6glich ist, muss auf einen vorg\u00e4ngigen konsistenten Zustand zur\u00fcck gesetzt werden k\u00f6nnen (Rollback). Probleme beim nicht-einhalten von ACID Folgende Probleme k\u00f6nnen auftreten, wenn die ACID Eigenschaften nicht eingehalten werden. Manchmal kann man mit diesen Problemen leben, da das Einhalten der ACID-Eigeschaften Performance kostet. Lost-Update kann fast nie toleriert werden. Die anderen Probleme k\u00f6nnen zum teil toleriert werden. Lost-Update Ein bereits geschriebenes Update wird wieder \u00fcberschrieben. Dies kann eintreffen, wenn keine Isolation zwischen den Transaktionen herscht und eine Transaktion den zu schreibenden Bereich nicht sperrt. Dieses Problem wird gel\u00f6st, in dem eine Transaktion Daten, welche von einer zweiten Transaktion gelesen werden, nicht ver\u00e4ndern darf. Beispiel: Transaktion 1 Transaktion 2 1 SEECT wert INTO W FROM tbl 2 SEECT wert INTO W FROM tbl 3 UPDATE tbl SET wert=100 4 UPDATE tbl SET wert=200 5 SEECT wert INTO W FROM tbl 6 SEECT wert INTO W FROM tbl Dirty-Read-Problem Ein Dirty-Read passiert, wenn Daten von einer noch nicht fertigen Transaktion gelesen werden. Transaktion 1 Transaktion 2 1 UPDATE tbl SET Wert = 5 2 SELECT wert INTO w FROM tbl 3 ROLLBACK 4 UPDATE tbl SET wert=w+1 5 SELECT wert FROM tbl (Resultat 6) Dies wird dadurch verursacht, dass die Transaktion 2 bereits Daten von der noch nicht fertigen Transaktion 1 lesen kann und somit die Isolation-Eigenschaft von ACID verletzt ist. Zus\u00e4tzlich d\u00fcrfte dies nicht m\u00f6glich sein, da die Transaktion 1 die Tabelle tbl sperren m\u00fcsste, um zu schreiben zu k\u00f6nnen. Non-Repeatable-Read Zwei verschiedene Lese-Zugriff auf den selben Wert lieftert unterschiedliche Resultate. Transaktion 1 Transaktion 2 1 SELECT wert INTO W FROM tbl 2 UPDATE tbl SET wert=6 3 COMMIT 4 SELECT wert INTO W FROM tbl Das SELECT bei 1 w\u00fcrde ein anderes Resultat zur\u00fcck liefern als das bei 4. Dies kommt davon, da Transaktion 1 sieht was Transaktion 2 ver\u00e4ndert hat. Die Transaktion 1 d\u00fcrfte nur den Zustand der DB sehen, welche am Anfang der Transaktion vorhanden war. Phantom-Read Ein Phatom-Read entsteht, wenn ein Tupel eingef\u00fcgt oder gel\u00f6scht wird, w\u00e4hrend einer anderen Transaktion und die das sieht. Dies kann in Aggregationsfunktionen auftreten Transaktion 1 Transaktion 2 1 SELECT COUNT(*) INTO ctn FROM tbl 2 INSERT INTO tbl VALUES (...) 3 COMMIT 4 SELECT COUNT(*) INTO ctn FROM tbl Das Problem ist dasselbe, wie beim Non-Repeatable-Read, dass die Transaktion 1 sieht, was Transaktion 2 commitet hat. Der Unterschied ist, dass sich keine Attributwerte sich ver\u00e4ndern, sondern eines Tupel hinzugef\u00fcgt oder entfernt wird. Dies kann gel\u00f6st werden, in dem Transaktion 1 nur sieht, was zu Beginn der Transaktion sichtbar war. Isolationsebenen Mit SET TRANSACTION ISOLATION LEVEL {READ UNCOMMITED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} kann die Isolationsebenen ver\u00e4ndert werden. (In Postgresql ist READ UNCOMMITTED das selbe, wie READ COMMITTED ) Defered Constraint Checking Schedules Der vollst\u00e4ndige Schedule beinhaltet alle Schritte, inklusive COMMIT und ROLLBACK Befehle. Ebenfalls ist f\u00fcr jede Transaktion festgehalten, ob sie erfolgreich war oder nicht. Wenn eine neue Abfrage an den DB-Server gesendet wird, landet diese zuerst im vollst\u00e4ndigen Schedule bevor die Befehle auf einen Schedule geplant werden konnten. Ein Schedule ( nicht ein vollst\u00e4ndiger Schedule) wird von der DB geplant anhand des vollst\u00e4ndigen Schedule. Die Planung kann w\u00e4hrend des Ausf\u00fchrens eines Schedules laufen, so bald dieser fertig ist, wird der n\u00e4chste ausgef\u00fchrt. Darstellung konfliktserialisierbar Ein Schedule ist konfliktserialisierbar, wenn: d Anders ausgedr\u00fcckt, ein Schedule ist serialisierbar, wenn dieser keine Zyklen enth\u00e4lt. Scheduler / Transaktionsmanager Der Scheduler erstellt ein serialisierbaren Schedule f\u00fcr parallel auszuf\u00fchrende Transaktionen. Aggresiver Scheduler L\u00e4sst Konflikte zu und probiert wenn diese auftreten, die zu l\u00f6sen. Dies f\u00fchrt zu einer h\u00f6hreren Parallelit\u00e4t Konservative Scheduler Verscuht m\u00f6glichst Konflikte zu vermeiden. Dies f\u00fchrt zu einer niedrigen Parallelit\u00e4t Sperrverfahre Generell gillt, dass nach einem Unlock, darf eine Transaktion keine weiteren Locks erstellen und alle Sperren werden beim Transaktionsende (COMMIT/ROLLBACK) aufgehoben. Wenn keine Sperre erstellt werden kann, dann muss die Transaktion warten, bis diese Sperre aufgehoben ist und der Bereich wieder frei ist. Das kann zu Livelocking, bzw. Verhunger f\u00fchren, wenn eine Transaktion wiederholt nicht daran kommt, weil eine andere Transaktion immer den Bereich sperrt, wenn er wieder frei wird. Die DBMS versucht dies zu vermeiden, in dem \"faire\" Algorithmen eingesetzt werden. Lese-Sperre (Share Lock) Bei einer Lese sperre k\u00f6nnen andere Transaktionen immer noch vom gelockten Bereich lesen, aber nicht mehr Schreiben. Diese Sperre kann nur gesetzt werden, wenn keine Schreib-Sperre existiert (eine Lese-Sperre ist kein Problem). Ein Lesezugriff kann nur get\u00e4tigt werden, wenn eine Lese-Sperre (oder Schreib-Sperre) auf dem zu lesenden Bereich existiert. Schreib-Sperre (Exclusive Lock) Bei einer Schreib-Sperre kann der gesperrte Breich nur von dieser Transaktion gelesen und geschrieben werden. Diese Sperre kann nur gesetzt werden, wenn keine andere Spere auf diesem Bereich aktiv ist. Ein Schreibzugriff kan nur get\u00e4tigt werden, wenn eine Schreib-Sperre auf dem zu schreibewnden Bereich aktiv ist. Regeln Bei einem Commit oder Rollback werden alle Sperren aufgehoben Probleme Block : Eine gesperrte Resource zwingt einen anderen Prozess zu warten, bis die Sperre wieder entfernt wurde Verhungern , Livelock: Eine Transaktion kommt nie daran, weil immer wieder andere Transaktionen vor der Transaktion abgearbeitet werden. Deadlock : Dies passiert, wenn sich mehrere Transaktionen gegenseitig Sperren. Das RDBms erkennt solche Deadlocks. Wenn dies passiert, wird eine Transaktion ausgew\u00e4hlt und zur\u00fcck gesetzt, um den Deadlock zu behben. Phantom-Read/Non-Repeatable-Read : L\u00f6sungen: Sperren und/oder Transaktionen isolieren Recovery Wenn die DB nicht ordnungsgem\u00e4ss herunter gefahren wurde (z.B. mit pkill im Terminal), wird eine Recovery eingeleitet, um wieder auf einen konsistenten Zustand zu kommen Der Recovery-Manager kann aus den Transaktionslogs einen vorherigen Zustand wieder herstellen ... Fehlerklassifikation Transaktionsfehler Dies f\u00fchrt zu einem Transaktionsabbruch und einem ROLLBACK . Da alle \u00c4nderungen r\u00fcckg\u00e4ngig gemacht werden, hat dies keinen Einfluss auf den Speicher Systemfehler Die Daten im Arbeitsspeicher wurden (zum Teil) zerst\u00f6rt. Dies kann eine Folge von einem Fehler in der DBMS, vom OS oder auf der Hardware sein. Eventuell wurde das System nicht sauber neugestartet. In diesem Fall wird zuerst versucht die erfolgreichabgeschlossenen Transaktionen anhand des Transaktionslogs wieder herzustellen. Wenn dies fehlschl\u00e4gt wird auf den letzten konsistenten Zustand zur\u00fcckgesetzt. Mediafehler Die Daten auf dem Speichermedium sind korrupt. In diesem Fall kann versucht werden manuell ein Backup einzuspielen. Ev. kann die DB aus den bestehenden Daten wieder auf einen konsistenten Zustand kommen.","title":"Integrit\u00e4tsregeln"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#integritatsregeln","text":"Wichtig anzumerken, nur weill die Datenbank konsistenz ist, heisst nicht, dass die Daten darin korrekt sind.","title":"Integrit\u00e4tsregeln"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#uberprufbare-regeln","text":"Bereichintegrit\u00e4t Das DB-System stellt sicher, dass der Wert eines Attributes in einem Wertebereich ist. Daf\u00fcr k\u00f6nnen z.B. NULL und NOT NULL , wie auch Dom\u00e4nen verwendet werden Entit\u00e4tsintegrit\u00e4t Der Prim\u00e4tschl\u00fcssel kann nicht leer sein. Also nicht NULL Refentielle Integrit\u00e4t Der Wert eines Fremdschl\u00fcssel muss NULL sein oder genau einen Prim\u00e4rschl\u00fcssel referezieren Constraints Zus\u00e4tzlich k\u00f6nnen Constraints geschrieben werden, um weitere Bedingungen zu \u00fcberpr\u00fcfen. Siehe SQL","title":"\u00dcberpr\u00fcfbare Regeln"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#acid","text":"ACID steht f\u00fcr Atomicity, Consistency, Isolation und Durability. Dies sind Eigenschaften, welche von einer Transaktion eingehalten werden soll.","title":"ACID"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#atomicity","text":"Entweder funktioniert alle Statements in einer Transaktion oder kein Statement. Wenn ein Fehler auftritt, m\u00fcssen alle \u00c4nderungen davor r\u00fcckg\u00e4ngig gemacht werden (Rollback).","title":"Atomicity"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#consistency","text":"Nach einer Operation muss die DB wieder in einem Konsistenten Zustand hinterlassen werden.","title":"Consistency"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#isolation","text":"Zwei parallel-laufende Transaktionen d\u00fcrfen sich nicht beinflussen.","title":"Isolation"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#durability","text":"Die DB muss erfolgreiche Statements speichern, so dass selbst im Fall eines Absturz diese wieder geladen werden k\u00f6nnten. Falls dies nicht m\u00f6glich ist, muss auf einen vorg\u00e4ngigen konsistenten Zustand zur\u00fcck gesetzt werden k\u00f6nnen (Rollback).","title":"Durability"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#probleme-beim-nicht-einhalten-von-acid","text":"Folgende Probleme k\u00f6nnen auftreten, wenn die ACID Eigenschaften nicht eingehalten werden. Manchmal kann man mit diesen Problemen leben, da das Einhalten der ACID-Eigeschaften Performance kostet. Lost-Update kann fast nie toleriert werden. Die anderen Probleme k\u00f6nnen zum teil toleriert werden.","title":"Probleme beim nicht-einhalten von ACID"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#lost-update","text":"Ein bereits geschriebenes Update wird wieder \u00fcberschrieben. Dies kann eintreffen, wenn keine Isolation zwischen den Transaktionen herscht und eine Transaktion den zu schreibenden Bereich nicht sperrt. Dieses Problem wird gel\u00f6st, in dem eine Transaktion Daten, welche von einer zweiten Transaktion gelesen werden, nicht ver\u00e4ndern darf. Beispiel: Transaktion 1 Transaktion 2 1 SEECT wert INTO W FROM tbl 2 SEECT wert INTO W FROM tbl 3 UPDATE tbl SET wert=100 4 UPDATE tbl SET wert=200 5 SEECT wert INTO W FROM tbl 6 SEECT wert INTO W FROM tbl","title":"Lost-Update"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#dirty-read-problem","text":"Ein Dirty-Read passiert, wenn Daten von einer noch nicht fertigen Transaktion gelesen werden. Transaktion 1 Transaktion 2 1 UPDATE tbl SET Wert = 5 2 SELECT wert INTO w FROM tbl 3 ROLLBACK 4 UPDATE tbl SET wert=w+1 5 SELECT wert FROM tbl (Resultat 6) Dies wird dadurch verursacht, dass die Transaktion 2 bereits Daten von der noch nicht fertigen Transaktion 1 lesen kann und somit die Isolation-Eigenschaft von ACID verletzt ist. Zus\u00e4tzlich d\u00fcrfte dies nicht m\u00f6glich sein, da die Transaktion 1 die Tabelle tbl sperren m\u00fcsste, um zu schreiben zu k\u00f6nnen.","title":"Dirty-Read-Problem"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#non-repeatable-read","text":"Zwei verschiedene Lese-Zugriff auf den selben Wert lieftert unterschiedliche Resultate. Transaktion 1 Transaktion 2 1 SELECT wert INTO W FROM tbl 2 UPDATE tbl SET wert=6 3 COMMIT 4 SELECT wert INTO W FROM tbl Das SELECT bei 1 w\u00fcrde ein anderes Resultat zur\u00fcck liefern als das bei 4. Dies kommt davon, da Transaktion 1 sieht was Transaktion 2 ver\u00e4ndert hat. Die Transaktion 1 d\u00fcrfte nur den Zustand der DB sehen, welche am Anfang der Transaktion vorhanden war.","title":"Non-Repeatable-Read"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#phantom-read","text":"Ein Phatom-Read entsteht, wenn ein Tupel eingef\u00fcgt oder gel\u00f6scht wird, w\u00e4hrend einer anderen Transaktion und die das sieht. Dies kann in Aggregationsfunktionen auftreten Transaktion 1 Transaktion 2 1 SELECT COUNT(*) INTO ctn FROM tbl 2 INSERT INTO tbl VALUES (...) 3 COMMIT 4 SELECT COUNT(*) INTO ctn FROM tbl Das Problem ist dasselbe, wie beim Non-Repeatable-Read, dass die Transaktion 1 sieht, was Transaktion 2 commitet hat. Der Unterschied ist, dass sich keine Attributwerte sich ver\u00e4ndern, sondern eines Tupel hinzugef\u00fcgt oder entfernt wird. Dies kann gel\u00f6st werden, in dem Transaktion 1 nur sieht, was zu Beginn der Transaktion sichtbar war.","title":"Phantom-Read"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#isolationsebenen","text":"Mit SET TRANSACTION ISOLATION LEVEL {READ UNCOMMITED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} kann die Isolationsebenen ver\u00e4ndert werden. (In Postgresql ist READ UNCOMMITTED das selbe, wie READ COMMITTED )","title":"Isolationsebenen"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#defered-constraint-checking","text":"","title":"Defered Constraint Checking"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#schedules","text":"Der vollst\u00e4ndige Schedule beinhaltet alle Schritte, inklusive COMMIT und ROLLBACK Befehle. Ebenfalls ist f\u00fcr jede Transaktion festgehalten, ob sie erfolgreich war oder nicht. Wenn eine neue Abfrage an den DB-Server gesendet wird, landet diese zuerst im vollst\u00e4ndigen Schedule bevor die Befehle auf einen Schedule geplant werden konnten. Ein Schedule ( nicht ein vollst\u00e4ndiger Schedule) wird von der DB geplant anhand des vollst\u00e4ndigen Schedule. Die Planung kann w\u00e4hrend des Ausf\u00fchrens eines Schedules laufen, so bald dieser fertig ist, wird der n\u00e4chste ausgef\u00fchrt.","title":"Schedules"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#darstellung","text":"","title":"Darstellung"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#konfliktserialisierbar","text":"Ein Schedule ist konfliktserialisierbar, wenn: d Anders ausgedr\u00fcckt, ein Schedule ist serialisierbar, wenn dieser keine Zyklen enth\u00e4lt.","title":"konfliktserialisierbar"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#scheduler-transaktionsmanager","text":"Der Scheduler erstellt ein serialisierbaren Schedule f\u00fcr parallel auszuf\u00fchrende Transaktionen. Aggresiver Scheduler L\u00e4sst Konflikte zu und probiert wenn diese auftreten, die zu l\u00f6sen. Dies f\u00fchrt zu einer h\u00f6hreren Parallelit\u00e4t Konservative Scheduler Verscuht m\u00f6glichst Konflikte zu vermeiden. Dies f\u00fchrt zu einer niedrigen Parallelit\u00e4t","title":"Scheduler / Transaktionsmanager"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#sperrverfahre","text":"Generell gillt, dass nach einem Unlock, darf eine Transaktion keine weiteren Locks erstellen und alle Sperren werden beim Transaktionsende (COMMIT/ROLLBACK) aufgehoben. Wenn keine Sperre erstellt werden kann, dann muss die Transaktion warten, bis diese Sperre aufgehoben ist und der Bereich wieder frei ist. Das kann zu Livelocking, bzw. Verhunger f\u00fchren, wenn eine Transaktion wiederholt nicht daran kommt, weil eine andere Transaktion immer den Bereich sperrt, wenn er wieder frei wird. Die DBMS versucht dies zu vermeiden, in dem \"faire\" Algorithmen eingesetzt werden.","title":"Sperrverfahre"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#lese-sperre-share-lock","text":"Bei einer Lese sperre k\u00f6nnen andere Transaktionen immer noch vom gelockten Bereich lesen, aber nicht mehr Schreiben. Diese Sperre kann nur gesetzt werden, wenn keine Schreib-Sperre existiert (eine Lese-Sperre ist kein Problem). Ein Lesezugriff kann nur get\u00e4tigt werden, wenn eine Lese-Sperre (oder Schreib-Sperre) auf dem zu lesenden Bereich existiert.","title":"Lese-Sperre (Share Lock)"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#schreib-sperre-exclusive-lock","text":"Bei einer Schreib-Sperre kann der gesperrte Breich nur von dieser Transaktion gelesen und geschrieben werden. Diese Sperre kann nur gesetzt werden, wenn keine andere Spere auf diesem Bereich aktiv ist. Ein Schreibzugriff kan nur get\u00e4tigt werden, wenn eine Schreib-Sperre auf dem zu schreibewnden Bereich aktiv ist.","title":"Schreib-Sperre (Exclusive Lock)"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#regeln","text":"Bei einem Commit oder Rollback werden alle Sperren aufgehoben","title":"Regeln"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#probleme","text":"Block : Eine gesperrte Resource zwingt einen anderen Prozess zu warten, bis die Sperre wieder entfernt wurde Verhungern , Livelock: Eine Transaktion kommt nie daran, weil immer wieder andere Transaktionen vor der Transaktion abgearbeitet werden. Deadlock : Dies passiert, wenn sich mehrere Transaktionen gegenseitig Sperren. Das RDBms erkennt solche Deadlocks. Wenn dies passiert, wird eine Transaktion ausgew\u00e4hlt und zur\u00fcck gesetzt, um den Deadlock zu behben. Phantom-Read/Non-Repeatable-Read : L\u00f6sungen: Sperren und/oder Transaktionen isolieren","title":"Probleme"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#recovery","text":"Wenn die DB nicht ordnungsgem\u00e4ss herunter gefahren wurde (z.B. mit pkill im Terminal), wird eine Recovery eingeleitet, um wieder auf einen konsistenten Zustand zu kommen Der Recovery-Manager kann aus den Transaktionslogs einen vorherigen Zustand wieder herstellen ...","title":"Recovery"},{"location":"21HS/DB/05_Integrit%C3%A4tsregeln.html#fehlerklassifikation","text":"Transaktionsfehler Dies f\u00fchrt zu einem Transaktionsabbruch und einem ROLLBACK . Da alle \u00c4nderungen r\u00fcckg\u00e4ngig gemacht werden, hat dies keinen Einfluss auf den Speicher Systemfehler Die Daten im Arbeitsspeicher wurden (zum Teil) zerst\u00f6rt. Dies kann eine Folge von einem Fehler in der DBMS, vom OS oder auf der Hardware sein. Eventuell wurde das System nicht sauber neugestartet. In diesem Fall wird zuerst versucht die erfolgreichabgeschlossenen Transaktionen anhand des Transaktionslogs wieder herzustellen. Wenn dies fehlschl\u00e4gt wird auf den letzten konsistenten Zustand zur\u00fcckgesetzt. Mediafehler Die Daten auf dem Speichermedium sind korrupt. In diesem Fall kann versucht werden manuell ein Backup einzuspielen. Ev. kann die DB aus den bestehenden Daten wieder auf einen konsistenten Zustand kommen.","title":"Fehlerklassifikation"},{"location":"21HS/DB/summaries/summary-2022-01-25.html","tags":["summary","DB"],"text":"DB Summary 25.01.2022 Relationale Algebra Operation Erkl\u00e4rung Beispiel \\(\\sigma\\) Selektion/ WHERE \\(\\sigma_{L\u00e4nge>3}(R)\\) \\(\\pi\\) Projektion/ SELECT \\(\\pi_{}\\) \\(\\bowtie\\) NATURAL JOIN ERD Korrektes ER-Diagramm Mit folgenden Regeln, wird ein korrektes ER-Diagramm erstellt: Definiere die unabh\u00e4ngige Entit\u00e4ts-Typen (Tabellen, welche keine Fremdschl\u00fcssel besitzen) Definiere die Beziehungs-Typen (Rhomben), wenn mehr als eine unabh\u00e4ngige Entit\u00e4ts-Typen existiert. Definiere die Attribute und Schl\u00fcssel Wandle Beziehungstypen ind zusammengesetzte Entit\u00e4tstypen um, wenn n\u00f6tig Definiere die ID-Abh\u00e4nigen Entit\u00e4stypen (Pfeile mit ID) Definiere die ISA-Abh\u00e4nigen Entit\u00e4tstypen (Pfeile mit ISA) Schl\u00fcssel Gruppen Diagramm Schl\u00fcssel Beschreibung E 1 -- <> -- 1 F Schl\u00fcssel von E und F in seperaten Schl\u00fcsselgruppen E 1 -- <> -- m F Schl\u00fcssel von F E m -- <> -- 1 F Schl\u00fcssel von E E m -- <> -- m F Schl\u00fcssel von E und F in einer Schl\u00fcsselgruppe | x | y | z | Schl\u00fcssel | | ---- | ---- | ---- | ------------------ | | m | m | m | {A1, A2, A3} | | m | m | 1 | {A1, A2} | | m | 1 | m | {A1, A3} | | m | 1 | 1 | {A1, A2}, {A1, A3} | | 1 | m | m | {A2, A3} | | 1 | m | 1 | {A2, A1}, {A2, A3} | | 1 | 1 | m | {A3, A1}, {A3, A2} | | 1 | 1 | 1 | {A1}, {A2}, {A3} | ID und ISA Bezihungen ISA - \u00dcbernimmt den Schl\u00fcssel ID - Erweirtert den Schl\u00fcssel SQL Reihenfolge In der folgenden Reihenfolge werden SQL Queries abgearbeitet. Speziell wo WHERE und HAVING steht. FROM WHERE GROUP BY HAVING SELECT ORDER BY Stuff Datenarten Name Erkl\u00e4rung Beispiel Strukturierte Daten Daten mit fest vorgegebenen Struktur DBs Semi-strukturierte Daten Daten, mit unvollst\u00f6ndigen Struktur JSON, XML,... Unstrukturierte Daten Daten, ohne explizite Struktur Text, Bilder, Film, ... Eine Dom\u00e4ne ist ein Wertebereich Dom\u00e4ne : Ein Wertebereich, bzw. Datentyp Attribute : Eigenschaften von Tabellen Attributwerte : Die eigentlichen Werte eines Attributes n-Tupel : Eine Reihe in einer Relation, eine Menge von Attributwerten Relationsschema, Format, Heading, Relationsvariable : Menge von Attributen Relation : Relationsschema und Menge von Tupeln zusammen Sind ungeordnet Schl\u00fcssel : Identifiziert ein Tupel eindeutig Surrogatschl\u00fcssel : K\u00fcnstlicher Schl\u00fcssel (zB. eine ID) Prim\u00e4rschl\u00fcssel : Ein Schl\u00fcssel, auf welchen ein Fremdschl\u00fcssel zeigt","title":"DB Summary"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#db-summary-25012022","text":"","title":"DB Summary 25.01.2022"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#relationale-algebra","text":"Operation Erkl\u00e4rung Beispiel \\(\\sigma\\) Selektion/ WHERE \\(\\sigma_{L\u00e4nge>3}(R)\\) \\(\\pi\\) Projektion/ SELECT \\(\\pi_{}\\) \\(\\bowtie\\) NATURAL JOIN","title":"Relationale Algebra"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#erd","text":"","title":"ERD"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#korrektes-er-diagramm","text":"Mit folgenden Regeln, wird ein korrektes ER-Diagramm erstellt: Definiere die unabh\u00e4ngige Entit\u00e4ts-Typen (Tabellen, welche keine Fremdschl\u00fcssel besitzen) Definiere die Beziehungs-Typen (Rhomben), wenn mehr als eine unabh\u00e4ngige Entit\u00e4ts-Typen existiert. Definiere die Attribute und Schl\u00fcssel Wandle Beziehungstypen ind zusammengesetzte Entit\u00e4tstypen um, wenn n\u00f6tig Definiere die ID-Abh\u00e4nigen Entit\u00e4stypen (Pfeile mit ID) Definiere die ISA-Abh\u00e4nigen Entit\u00e4tstypen (Pfeile mit ISA)","title":"Korrektes ER-Diagramm"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#schlussel-gruppen","text":"Diagramm Schl\u00fcssel Beschreibung E 1 -- <> -- 1 F Schl\u00fcssel von E und F in seperaten Schl\u00fcsselgruppen E 1 -- <> -- m F Schl\u00fcssel von F E m -- <> -- 1 F Schl\u00fcssel von E E m -- <> -- m F Schl\u00fcssel von E und F in einer Schl\u00fcsselgruppe | x | y | z | Schl\u00fcssel | | ---- | ---- | ---- | ------------------ | | m | m | m | {A1, A2, A3} | | m | m | 1 | {A1, A2} | | m | 1 | m | {A1, A3} | | m | 1 | 1 | {A1, A2}, {A1, A3} | | 1 | m | m | {A2, A3} | | 1 | m | 1 | {A2, A1}, {A2, A3} | | 1 | 1 | m | {A3, A1}, {A3, A2} | | 1 | 1 | 1 | {A1}, {A2}, {A3} |","title":"Schl\u00fcssel Gruppen"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#id-und-isa-bezihungen","text":"ISA - \u00dcbernimmt den Schl\u00fcssel ID - Erweirtert den Schl\u00fcssel","title":"ID und ISA Bezihungen"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#sql","text":"","title":"SQL"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#reihenfolge","text":"In der folgenden Reihenfolge werden SQL Queries abgearbeitet. Speziell wo WHERE und HAVING steht. FROM WHERE GROUP BY HAVING SELECT ORDER BY","title":"Reihenfolge"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#stuff","text":"","title":"Stuff"},{"location":"21HS/DB/summaries/summary-2022-01-25.html#datenarten","text":"Name Erkl\u00e4rung Beispiel Strukturierte Daten Daten mit fest vorgegebenen Struktur DBs Semi-strukturierte Daten Daten, mit unvollst\u00f6ndigen Struktur JSON, XML,... Unstrukturierte Daten Daten, ohne explizite Struktur Text, Bilder, Film, ... Eine Dom\u00e4ne ist ein Wertebereich Dom\u00e4ne : Ein Wertebereich, bzw. Datentyp Attribute : Eigenschaften von Tabellen Attributwerte : Die eigentlichen Werte eines Attributes n-Tupel : Eine Reihe in einer Relation, eine Menge von Attributwerten Relationsschema, Format, Heading, Relationsvariable : Menge von Attributen Relation : Relationsschema und Menge von Tupeln zusammen Sind ungeordnet Schl\u00fcssel : Identifiziert ein Tupel eindeutig Surrogatschl\u00fcssel : K\u00fcnstlicher Schl\u00fcssel (zB. eine ID) Prim\u00e4rschl\u00fcssel : Ein Schl\u00fcssel, auf welchen ein Fremdschl\u00fcssel zeigt","title":"Datenarten"},{"location":"21HS/DM/01_Aussaglogik.html","text":"Aussaglogik Sprachliche S\u00e4tze sind nicht eindeutig! T ( \\(\\top\\) ) = Tautologie = immer wahr W ( \\(\\bot\\) )= Wiederspruch = immer falsch Was ist eine Aussage Ein Satz, welchem ein \"wahr\" oder \"falsch\" Wert zugeordnet werden kann Darf nicht abh\u00e4ngig von einer freien Variable sein zB. x > 0 ist keine Aussage, da abh\u00e4ngig von x \"alle x, wenn man sie durch 2 teilt, sind gerade\", ist eine Aussage, da alle x eingesetzt werden k\u00f6nnen Ein Pr\u00e4dikat wird zu einer Aussage, wenn man die freie Variable bindet (zB. \"A(2)\") Eine Aussage ist ein 0-stelliges Pr\u00e4dikat Pr\u00e4dikat A(x): einstelliges Pr\u00e4dikat (zB: A(x):=\"x<3\") A(x, y): zweistelliges Pr\u00e4dikat (zB. A(x, y):= \"x < y\") Bsp: P(p) := \"p is teine Primzahl\" Q(x, y) := \"wenn x < y, dann gilt x\u00b2 + 14x - 15 = 0\" Junktoren Verkn\u00fcpfen Aussagen, um so komplexere Junkoren zu kreieren. Definitionen: Elementaraussagen: Eine Aussage, die nicht weiter Zerlegt werden kann. Zusamengesetzte Aussagen: Aussagen, die aus Elementaraussagen bestehen, die durch Junktoren verknp\u00fcft werden Bsp: A := \"78 ist keine Primzahl\" (Elementaraussage) B := \"15 ist keine Primzahl\" (Elementaraussage) C := \"78 ist keine Primzahl und 15 ist keine Primzahl\" (Zusammengesetzte Aussage) 0: falsch = W (Wiederspruch) 1: wahr = T (Tautologie) Negation Negation: \\(\\neg A\\) Bsp: A:= \"Hans studiert an der ZHAW\" \\neg A:= (\"Hans studiert nicht an der ZHAW\") = \"Es trifft nicht zu, dass Hans an der ZHAW studiert.\" \\(\\neg\\) -> \"Es trifft nicht zu\" Konjunktion (und) \\wedge -> \\(\\wedge\\) Beispiel: A := \"6 ist durch 2 teilbar\" -> wahr B := \"8 ist durch 5 teilbar\" -> falsch \\(A \\wedge B\\) : \"6 ist durch 2 teilbar und 8 ist durch 5 teilbar\" -> falsch A B \\(A \\wedge B\\) 0 0 0 1 0 0 0 1 0 1 1 1 Disjunktion (oder) \\vee -> \\(\\vee\\) Beispiel: A := \"9 ist durch 3 teilbar\" -> wahr B := \"9 ist eine Quadratzahl\" -> wahr \\(A \\vee \\neg B\\) = \"9 ist durch 3 teilbar oder 9 ist keine Quadratzahl\" ->wahr A B \\(A \\vee B\\) 0 0 0 0 1 1 1 0 1 1 1 1 Implikation (wenn..., dann...) \\Rightarrow -> \\(\\Rightarrow\\) Bsp: A := \"Es regnet\" B := \"Die Wiese ist nass\" \\(A \\Rightarrow B\\) := Wenn es regnet, dann ist die wiese nass\" \"Alle Fische leben im Ozean\" => \"Haie leben im Ozean\" = wahr \"Alle Fische leben im Ozean\" => \"Forellen leben im Ozean\" = wahr A B \\(A \\Rightarrow B\\) Erkl\u00e4rung 0 0 1 Da A, die Bedinungen falsch ist, kann B falsch sein. 0 1 1 Da A falsch ist, kann B aber auch wahr sein. 1 0 0 Wenn A wahr ist, muss B auch wahr sein 1 1 1 Wenn A wahr ist, muss B auch wahr sein \u00c4quivalenz ( \\(\\Leftrightarrow\\) ) Zwei Aussagen sind \u00e4quivalenz, wenn gilt: \\(A \\Rightarrow B \\wedge B \\Rightarrow A\\) A B \\(A \\Leftrightarrow B\\) 0 0 1 0 1 0 1 0 0 1 1 1 Bsp: A(x) := \" \\(x^2=4\\) \" B(x) := \"x=2\" in \\(\\mathbb Z: B(x) \\Rightarrow A(x)\\) -> wahr in \\(\\mathbb N: B(x) \\Rightarrow A(x)\\) -> wahr in \\(\\mathbb N: A(x) \\Rightarrow B(x)\\) -> wahr in \\(\\mathbb N: A(x) \\Leftrightarrow B(x)\\) -> wahr Reihenfolge Reihenfolge der Bildung \\(\\neg\\) , \\(\\wedge\\) , \\(\\vee\\) , \\(\\Rightarrow\\) , \\(\\Leftrightarrow\\) Bsp: \\(((A \\vee (B \\wedge C)) \\Rightarrow D)\\) \\((\\neg A) \\Rightarrow (C \\vee ((\\neg B) \\wedge D))\\) Junktoren Regeln Mit den folgenden Regeln, kann man \u00c4quivalente-Aussagen umformen Doppel Negation: \\(\\neg \\neg A \\Leftrightarrow A\\) Kummutativt\u00e4t \\(A \\wedge B \\Leftrightarrow B \\wedge A\\) \\(A \\vee B \\Leftrightarrow B \\vee A\\) Assoziativit\u00e4t: \\((A \\wedge B) \\wedge C \\Leftrightarrow A \\wedge (B \\wedge C)\\) \\((A \\vee B) \\vee C \\Leftrightarrow A \\vee (B \\vee C)\\) Distributivit\u00e4t: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) \\(A \\vee (B \\wedge C) \\Leftrightarrow (A \\vee B) \\wedge (A \\vee C)\\) \\((A \\wedge B) \\vee (C \\wedge D) \\Leftrightarrow ((A \\wedge B) \\vee C) \\wedge ((A \\wedge B) \\vee D) \\Leftrightarrow (A \\vee C) \\wedge (B \\vee C) \\wedge (A \\vee D) \\wedge (B \\vee D)\\) als vergleich: \\(A \\cdot (B + C) = A \\cdot B + A \\cdot C\\) Regeln von de Morgan: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) \\(\\neg(A\\wedge B) \\Leftrightarrow \\neg A \\vee \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\) Indepotenz: \\(A \\vee A \\Leftrightarrow A\\) \\(A \\wedge A \\Leftrightarrow A\\) ausgeschlossene Dritte: \\(A \\vee \\neg A \\Leftrightarrow T\\) \\(A \\wedge \\neg A \\Leftrightarrow W\\) Identit\u00e4t: \\(A \\vee T \\Leftrightarrow T\\) \\(A \\wedge T \\Leftrightarrow A\\) \\(A \\vee F \\Leftrightarrow A\\) \\(A \\wedge F \\Leftrightarrow F\\) Beweiss, dass \\((A \\Rightarrow B) \\Leftrightarrow (\\neg B \\Leftrightarrow \\neg A)\\) ist \\(A \\Rightarrow B\\) \\(\\Leftrightarrow \\neg A \\vee B\\) \\(\\Leftrightarrow \\neg \\neg (\\neg A \\vee B)\\) \\(\\Leftrightarrow \\neg (\\neg \\neg A \\wedge \\neg B)\\) \\(\\Leftrightarrow \\neg (A \\wedge \\neg B)\\) \\(\\Leftrightarrow \\neg A \\vee \\neg \\neg B\\) \\(\\Leftrightarrow \\neg \\neg B \\vee \\neg A\\) \\(\\Leftrightarrow \\neg (\\neg B) \\vee (\\neg A)\\) \\(\\Leftrightarrow \\neg B \\Leftrightarrow \\neg A\\) Bsp: \\(A \\Rightarrow B\\) -> Wenn es regnet, ist die Wiese nass \\(\\neg B \\Rightarrow \\neg A\\) -> Wenn die Wiese nicht nass ist, regnet es nicht \\(\\neg (A \\Rightarrow B)\\) \\(\\neg (A \\Rightarrow B)\\) \\(\\neg (\\neg A \\vee B)\\) \\(\\neg \\neg A \\wedge \\neg B\\) \\(A \\wedge \\neg B\\) Implikations-Wahrheitstabelle: A B \\(A \\Rightarrow B\\) \\(\\neg A \\vee B\\) 0 0 1 1 0 1 1 1 1 0 0 0 1 1 1 1 Quantore Motivation: \u00dcbergang von Pr\u00e4dikat zu Aussage zu formulieren P(X) := \"x ist eine nat\u00fcrliche Zahl\" => Pr\u00e4dikat P(5) := \"5 ist eine nat\u00fcrliche Zahl\" => Aussage (wahr) \"Es gibt mindestens eine \\(x \\in \\mathbb{Z}\\) , so dass P(x) gilt\" => Aussage \"F\u00fcr alle \\(x \\in \\mathbb{Z}\\) gillt P(x)\" => Aussage Liste von Quantoren Zeichen Name Beschreibung \\(\\forall\\) Allquantor F\u00fcr alle \\(\\exists\\) Existenzquantor \"f\u00fcr mindestens ein\" Beispiele Beispiel gesprochen Erkl\u00e4rung \\(\\forall x A(x)\\) F\u00fcr alle x gilt A(x) Alle x in dem Pr\u00e4dikat, werden auf alle Zahlen gebunden \\(\\forall x \\in M A(x)\\) F\u00fcr alle x aus M gillt A(x) Alle x in dem Pr\u00e4dikat, werden auf alle Werte von M gebunden \\(\\exists x A(x)\\) Es gibt (mind.) ein x mit A(x) Es gibt mindestens eine Zahl, bei welcher A(x) zutrifft \\(\\exists x \\in M A(x)\\) Es gibt (mind.) ein x aus M miz A(x) Es gibt mindestes einen Wert von M, bei welcher A(x) zutrifft Jeder Quantor bindet eine Variable Umformungen: \\(\\forall x \\in I B(x) \\Leftrightarrow \\forall x (x \\in I \\Rightarrow B(x))\\) Klammern Quantoren binden st\u00e4rker als Junktoren \\(\\forall x \\in \\mathbb M B(x) \\wedge C(x) \\Leftrightarrow (\\forall x \\in \\mathbb M B(x)) \\wedge C(x)\\) Abk\u00fcrzungen \\(\\forall x \\in \\mathbb M (\\forall y \\in \\mathbb M A(x, y)) \\Leftrightarrow \\forall x,y \\in \\mathbb M A(x, y)\\) \\(\\exists x \\in \\mathbb M (\\exists y \\in \\mathbb M A(x, y)) \\Leftrightarrow \\forall x,y \\in \\mathbb M A(x, y)\\) Falls die Menge aus dem Kontext klar ist, k\u00f6nnen wir schreiben: \\(\\forall x A(x)\\) (ohne \\(\\in \\mathbb M\\) ) \\(\\exists x A(x)\\) (ohne \\(\\in \\mathbb M\\) ) Negation: \\(\\neg \\exists x \\in M A(x) \\Leftrightarrow \\forall x \\in M \\neg A(x)\\) \\(\\neg \\forall x \\in M A(x) \\Leftrightarrow \\exists x \\in M \\neg A(x)\\) \\(\\forall x A(x) \\Leftrightarrow \\neg \\exist x \\neg A(x)\\) Distributiv-Gesetzt Keine Distributiv-Gesetzt mit Quantoren und Junktoren Beispiel A(x) := \"x ist eine gerade nat\u00fcrliche Zahl\" B(x) := \"x ist eine ungerade nat\u00fcrliche Zahl\" \\(\\forall x A(x) \\vee B(x) \\Leftrightarrow W \\nLeftrightarrow \\forall x (A(x) \\vee B(x)) \\Leftrightarrow T\\) \\(\\exists x (A(x) \\wedge B(x)) \\nLeftrightarrow \\exists x A(x) \\wedge \\exists x B(x)\\) \\(\\exists x (A(x) \\vee B(x)) \\nLeftrightarrow \\exists x A(x) \\vee \\exists x B(x)\\) Reihenfolge von Quantoren: \\(P(x, y) := x + y = 17\\) \\(\\forall x \\in \\mathbb Z (\\exists x \\in \\mathbb Z P(x, y)) : wahr\\) \\(\\exists x \\in \\mathbb Z (\\forall x \\in \\mathbb Z P(x, y)): falsc h\\) Beispiel: A(x, y) := \"x < y\" -> 2-stelliges Pr\u00e4dikat, frei: x, y \\(\\forall x \\in \\mathbb{R} A(x, y)\\) : 1-stelliges Pr\u00e4dikat, frei: x \u00dcbungungen Quantoren 2) a) \\(\\exists x P(x) \\wedge \\forall y,z (P(y) \\wedge P(z) \\Rightarrow y = z)\\) b) \\(\\exists y,z (P(y) \\wedge P(z) \\wedge y \\neq z)\\) c) \\(\\neg (\\exists x,y (P(x) \\wedge P(y) \\wedge x \\neq y)) -> negation von b)\\) d) \\(\\forall x, y (P(x) \\wedge P(y) \\Rightarrow Q(x, y))\\) e) \\(\\neg(\\exists x Q(x, x)) \\Leftrightarrow \\forall x (\\neg Q(x, x))\\) \\(\\neg(\\forall x Q(x, x))\\) -> das w\u00e4re: \"nicht alle x sind Q(x, x)\", aber eines x, bei welchem Q(x, x) stimmt, w\u00e4re ok 3) a) Alle Pr\u00fcfungen sind einfach \\(\\Leftrightarrow \\forall x \\in P E(x)\\) b) Eine Pr\u00fcfung ist einfach \\(\\Leftrightarrow \\exists x \\in P E(x)\\) c) Keine Pr\u00fcfung ist einfach \\(\\Leftrightarrow \\neg \\exists x \\in P E(x)\\) d) Alle Pr\u00fcfungen sind einfach \\(\\Leftrightarrow \\forall x \\in P (\\neg E(x))\\) e) Nur eine Pr\u00fcfung ist einfach \\(\\Leftrightarrow (\\exist x \\in P E(x)) \\wedge \\forall y,z \\in P (E(y) \\wedge E(z))\\) f) Nur eine Pr\u00fcfung ist nicht einfach \\(\\Leftrightarrow (\\exist x \\in P \\neg E(x)) \\wedge \\forall y,z \\in P (\\neg E(y) \\wedge \\neg E(z))\\) g) Nicht alle Pr\u00fcfung sind einfach \\(\\Leftrightarrow \\neg \\forall x \\in P E(x)\\) h) Eine Pr\u00fcfung ist nicht einfach \\(\\Leftrightarrow \\exists x \\in P \\neg E(x)\\) g) und h) sind \u00e4quivalent Beweisstechnik \\(\\forall\\) : wahr: f\u00fcr alle Elemente aus der Grundmenge Verallgemeinern mit Variablen falsch: Ein Element, bei dem es nicht funktioniert \\(\\exists\\) wahr: Ein Element finden, bei dem es stimmt falsch: Alle Elemente aus der Grundmenge allgemein zeigen, dass das Pr\u00e4dikat nicht gilt Direkten Beweis Implikation zu zeigen \\(\\forall x,y \\in \\mathbb N (\\text{x ist gerade} \\wedge \\text{y ist gerade} \\Rightarrow x\\cdot y \\text{ ist gerade})\\) \\(\\Leftrightarrow \\forall x,y \\in \\mathbb N \\exists n_x,n_y,n_z \\in \\mathbb N (x = 2 \\cdot n_x \\wedge y = 2\\cdot n_y \\Rightarrow x\\cdot y = 2\\cdot n_z)\\) Beweise: A: wahr \\((x=2n_x \\wedge y=2n_y) = T \\text{ } n_x,n_y \\in \\mathbb N\\) B: wahr \\((x\\cdot y = 2n_z) = T\\) \\(A \\Rightarrow B: x \\cdot y = 2n_x \\cdot 2n_y = 2(2n_xn_y) = 2n_z\\) Beweis durch Widerspruch Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. zu beweisen: \\(A:= \\text{\"Es gibt keine gr\u00f6sste nat\u00fcrliche zahl\"} = \\neg \\exists n \\in \\mathbb N G(n)\\) \\(G(x) := \\text{\"x ist gr\u00f6sste Zahl\"}\\) \\(\\neg A := \\text{\"Es gibt mindestens eine gr\u00f6sste nat\u00fcrliche Zahl\"} = \\exists n \\in \\mathbb N G(n)\\) Beweis: Annahme: n ist gr\u00f6sste nat\u00fcrliche Zahl Jedoch f\u00fcr jede nat\u00fcrliche Zahl n, existiert n + 1 Daher ist n+1 > n und n ist nicht die gr\u00f6sste Zahl \\(\\Rightarrow \\neg A = W \\Rightarrow A = T\\) Beweis durch (Gegen-) Beispiel zu beweisen \"Nicht jede nat\u00fcrliche Zahl ist eine Quadratzahl\" \\(A:= \\neg\\forall n \\in \\mathbb N Q(n)\\Leftrightarrow \\exists n \\in \\mathbb N \\neg Q(n)\\) \\(Q(x)=\\text{x ist Quadradzahl} )\\) Beweis: \\(n = 7\\) , denn \\(f(x)=x^2\\) mit \\(f(x) \\in \\mathbb N\\) in diesem Fall w\u00fcrde 7 niemals als Funktionswert f\u00fcr f(x) herausgekommen, da \\(2\\cdot 2 < 7 < 3 \\cdot 3\\) \\(\\Rightarrow\\) 7 ist keine Quadratzahl \\(\\Rightarrow\\) A ist wahr Beweis durch Kontraposition Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) Beispiel: zu beweisen: \\(\\forall n \\in \\mathbb N ((n^2 + 1 = 1) \\Rightarrow (n = 0))\\) anstatt dies, beweissen wir \\(\\Leftrightarrow \\forall n \\in \\mathbb N (\\neg (n = 0) \\Rightarrow \\neg(n^2 + 1 = 1))\\) \\(\\Leftrightarrow \\forall n \\in \\mathbb N (n \\neq 0 \\Rightarrow n^2 + 1 \\neq 1))\\) Beweis: Wenn \\(n \\neq 0 \\Rightarrow n^2\\neq 0 \\Rightarrow n^2 + m \\neq m\\) F\u00fcr \\(m=1 \\Rightarrow n^2 + 1 \\neq 1\\) \\(\\Rightarrow \\forall n \\in \\mathbb N ((n \\neq 0) \\Rightarrow (n^2 + 1 \\neq 1)) : T\\) \u00c4quivalenz Um eine \u00c4quivalenz zu beweissen muss \\(A \\Rightarrow B \\wedge B \\Rightarrow A\\) Beispiel: \\(B \\Rightarrow A: \\forall n \\in \\mathbb N ((n = 0) \\Rightarrow (n^2+1=1))\\) \\(n=0\\) (wenn n=0 wahr ist, dann muss auch die n\u00e4chste Linie wahr sein) \\(n^2+1=0^2 + 1 = 1\\) (was sie ist) und da \\(A \\Rightarrow B\\) und \\(B \\Rightarrow A\\) wahr waren, ist auch \\(A \\Leftrightarrow B\\) wahr Biespiel #2: zu zeigen: \\(\\forall n \\in \\mathbb N \\exists k,j \\in \\mathbb N ((n = 2k) \\Leftrightarrow n^2=2j)\\) bzw. \\(\\forall n \\in \\mathbb N \\exists k,j \\in N (n = 2k \\Rightarrow n^2 = j2) \\wedge (n^2 = 2j \\Rightarrow n = 2k)\\) Beweis: \\(A(n) \\Rightarrow B(n)\\) n = 2k : wahr \\(n^2=(2k)^2\\)","title":"01 Aussaglogik"},{"location":"21HS/DM/01_Aussaglogik.html#aussaglogik","text":"Sprachliche S\u00e4tze sind nicht eindeutig! T ( \\(\\top\\) ) = Tautologie = immer wahr W ( \\(\\bot\\) )= Wiederspruch = immer falsch","title":"Aussaglogik"},{"location":"21HS/DM/01_Aussaglogik.html#was-ist-eine-aussage","text":"Ein Satz, welchem ein \"wahr\" oder \"falsch\" Wert zugeordnet werden kann Darf nicht abh\u00e4ngig von einer freien Variable sein zB. x > 0 ist keine Aussage, da abh\u00e4ngig von x \"alle x, wenn man sie durch 2 teilt, sind gerade\", ist eine Aussage, da alle x eingesetzt werden k\u00f6nnen Ein Pr\u00e4dikat wird zu einer Aussage, wenn man die freie Variable bindet (zB. \"A(2)\") Eine Aussage ist ein 0-stelliges Pr\u00e4dikat","title":"Was ist eine Aussage"},{"location":"21HS/DM/01_Aussaglogik.html#pradikat","text":"A(x): einstelliges Pr\u00e4dikat (zB: A(x):=\"x<3\") A(x, y): zweistelliges Pr\u00e4dikat (zB. A(x, y):= \"x < y\") Bsp: P(p) := \"p is teine Primzahl\" Q(x, y) := \"wenn x < y, dann gilt x\u00b2 + 14x - 15 = 0\"","title":"Pr\u00e4dikat"},{"location":"21HS/DM/01_Aussaglogik.html#junktoren","text":"Verkn\u00fcpfen Aussagen, um so komplexere Junkoren zu kreieren. Definitionen: Elementaraussagen: Eine Aussage, die nicht weiter Zerlegt werden kann. Zusamengesetzte Aussagen: Aussagen, die aus Elementaraussagen bestehen, die durch Junktoren verknp\u00fcft werden Bsp: A := \"78 ist keine Primzahl\" (Elementaraussage) B := \"15 ist keine Primzahl\" (Elementaraussage) C := \"78 ist keine Primzahl und 15 ist keine Primzahl\" (Zusammengesetzte Aussage) 0: falsch = W (Wiederspruch) 1: wahr = T (Tautologie)","title":"Junktoren"},{"location":"21HS/DM/01_Aussaglogik.html#negation","text":"Negation: \\(\\neg A\\) Bsp: A:= \"Hans studiert an der ZHAW\" \\neg A:= (\"Hans studiert nicht an der ZHAW\") = \"Es trifft nicht zu, dass Hans an der ZHAW studiert.\" \\(\\neg\\) -> \"Es trifft nicht zu\"","title":"Negation"},{"location":"21HS/DM/01_Aussaglogik.html#konjunktion-und","text":"\\wedge -> \\(\\wedge\\) Beispiel: A := \"6 ist durch 2 teilbar\" -> wahr B := \"8 ist durch 5 teilbar\" -> falsch \\(A \\wedge B\\) : \"6 ist durch 2 teilbar und 8 ist durch 5 teilbar\" -> falsch A B \\(A \\wedge B\\) 0 0 0 1 0 0 0 1 0 1 1 1","title":"Konjunktion (und)"},{"location":"21HS/DM/01_Aussaglogik.html#disjunktion-oder","text":"\\vee -> \\(\\vee\\) Beispiel: A := \"9 ist durch 3 teilbar\" -> wahr B := \"9 ist eine Quadratzahl\" -> wahr \\(A \\vee \\neg B\\) = \"9 ist durch 3 teilbar oder 9 ist keine Quadratzahl\" ->wahr A B \\(A \\vee B\\) 0 0 0 0 1 1 1 0 1 1 1 1","title":"Disjunktion (oder)"},{"location":"21HS/DM/01_Aussaglogik.html#implikation-wenn-dann","text":"\\Rightarrow -> \\(\\Rightarrow\\) Bsp: A := \"Es regnet\" B := \"Die Wiese ist nass\" \\(A \\Rightarrow B\\) := Wenn es regnet, dann ist die wiese nass\" \"Alle Fische leben im Ozean\" => \"Haie leben im Ozean\" = wahr \"Alle Fische leben im Ozean\" => \"Forellen leben im Ozean\" = wahr A B \\(A \\Rightarrow B\\) Erkl\u00e4rung 0 0 1 Da A, die Bedinungen falsch ist, kann B falsch sein. 0 1 1 Da A falsch ist, kann B aber auch wahr sein. 1 0 0 Wenn A wahr ist, muss B auch wahr sein 1 1 1 Wenn A wahr ist, muss B auch wahr sein","title":"Implikation (wenn..., dann...)"},{"location":"21HS/DM/01_Aussaglogik.html#aquivalenz-leftrightarrow","text":"Zwei Aussagen sind \u00e4quivalenz, wenn gilt: \\(A \\Rightarrow B \\wedge B \\Rightarrow A\\) A B \\(A \\Leftrightarrow B\\) 0 0 1 0 1 0 1 0 0 1 1 1 Bsp: A(x) := \" \\(x^2=4\\) \" B(x) := \"x=2\" in \\(\\mathbb Z: B(x) \\Rightarrow A(x)\\) -> wahr in \\(\\mathbb N: B(x) \\Rightarrow A(x)\\) -> wahr in \\(\\mathbb N: A(x) \\Rightarrow B(x)\\) -> wahr in \\(\\mathbb N: A(x) \\Leftrightarrow B(x)\\) -> wahr","title":"\u00c4quivalenz (\\(\\Leftrightarrow\\))"},{"location":"21HS/DM/01_Aussaglogik.html#reihenfolge","text":"Reihenfolge der Bildung \\(\\neg\\) , \\(\\wedge\\) , \\(\\vee\\) , \\(\\Rightarrow\\) , \\(\\Leftrightarrow\\) Bsp: \\(((A \\vee (B \\wedge C)) \\Rightarrow D)\\) \\((\\neg A) \\Rightarrow (C \\vee ((\\neg B) \\wedge D))\\)","title":"Reihenfolge"},{"location":"21HS/DM/01_Aussaglogik.html#junktoren-regeln","text":"Mit den folgenden Regeln, kann man \u00c4quivalente-Aussagen umformen Doppel Negation: \\(\\neg \\neg A \\Leftrightarrow A\\) Kummutativt\u00e4t \\(A \\wedge B \\Leftrightarrow B \\wedge A\\) \\(A \\vee B \\Leftrightarrow B \\vee A\\) Assoziativit\u00e4t: \\((A \\wedge B) \\wedge C \\Leftrightarrow A \\wedge (B \\wedge C)\\) \\((A \\vee B) \\vee C \\Leftrightarrow A \\vee (B \\vee C)\\) Distributivit\u00e4t: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) \\(A \\vee (B \\wedge C) \\Leftrightarrow (A \\vee B) \\wedge (A \\vee C)\\) \\((A \\wedge B) \\vee (C \\wedge D) \\Leftrightarrow ((A \\wedge B) \\vee C) \\wedge ((A \\wedge B) \\vee D) \\Leftrightarrow (A \\vee C) \\wedge (B \\vee C) \\wedge (A \\vee D) \\wedge (B \\vee D)\\) als vergleich: \\(A \\cdot (B + C) = A \\cdot B + A \\cdot C\\) Regeln von de Morgan: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) \\(\\neg(A\\wedge B) \\Leftrightarrow \\neg A \\vee \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\) Indepotenz: \\(A \\vee A \\Leftrightarrow A\\) \\(A \\wedge A \\Leftrightarrow A\\) ausgeschlossene Dritte: \\(A \\vee \\neg A \\Leftrightarrow T\\) \\(A \\wedge \\neg A \\Leftrightarrow W\\) Identit\u00e4t: \\(A \\vee T \\Leftrightarrow T\\) \\(A \\wedge T \\Leftrightarrow A\\) \\(A \\vee F \\Leftrightarrow A\\) \\(A \\wedge F \\Leftrightarrow F\\) Beweiss, dass \\((A \\Rightarrow B) \\Leftrightarrow (\\neg B \\Leftrightarrow \\neg A)\\) ist \\(A \\Rightarrow B\\) \\(\\Leftrightarrow \\neg A \\vee B\\) \\(\\Leftrightarrow \\neg \\neg (\\neg A \\vee B)\\) \\(\\Leftrightarrow \\neg (\\neg \\neg A \\wedge \\neg B)\\) \\(\\Leftrightarrow \\neg (A \\wedge \\neg B)\\) \\(\\Leftrightarrow \\neg A \\vee \\neg \\neg B\\) \\(\\Leftrightarrow \\neg \\neg B \\vee \\neg A\\) \\(\\Leftrightarrow \\neg (\\neg B) \\vee (\\neg A)\\) \\(\\Leftrightarrow \\neg B \\Leftrightarrow \\neg A\\) Bsp: \\(A \\Rightarrow B\\) -> Wenn es regnet, ist die Wiese nass \\(\\neg B \\Rightarrow \\neg A\\) -> Wenn die Wiese nicht nass ist, regnet es nicht \\(\\neg (A \\Rightarrow B)\\) \\(\\neg (A \\Rightarrow B)\\) \\(\\neg (\\neg A \\vee B)\\) \\(\\neg \\neg A \\wedge \\neg B\\) \\(A \\wedge \\neg B\\) Implikations-Wahrheitstabelle: A B \\(A \\Rightarrow B\\) \\(\\neg A \\vee B\\) 0 0 1 1 0 1 1 1 1 0 0 0 1 1 1 1","title":"Junktoren Regeln"},{"location":"21HS/DM/01_Aussaglogik.html#quantore","text":"Motivation: \u00dcbergang von Pr\u00e4dikat zu Aussage zu formulieren P(X) := \"x ist eine nat\u00fcrliche Zahl\" => Pr\u00e4dikat P(5) := \"5 ist eine nat\u00fcrliche Zahl\" => Aussage (wahr) \"Es gibt mindestens eine \\(x \\in \\mathbb{Z}\\) , so dass P(x) gilt\" => Aussage \"F\u00fcr alle \\(x \\in \\mathbb{Z}\\) gillt P(x)\" => Aussage","title":"Quantore"},{"location":"21HS/DM/01_Aussaglogik.html#liste-von-quantoren","text":"Zeichen Name Beschreibung \\(\\forall\\) Allquantor F\u00fcr alle \\(\\exists\\) Existenzquantor \"f\u00fcr mindestens ein\" Beispiele Beispiel gesprochen Erkl\u00e4rung \\(\\forall x A(x)\\) F\u00fcr alle x gilt A(x) Alle x in dem Pr\u00e4dikat, werden auf alle Zahlen gebunden \\(\\forall x \\in M A(x)\\) F\u00fcr alle x aus M gillt A(x) Alle x in dem Pr\u00e4dikat, werden auf alle Werte von M gebunden \\(\\exists x A(x)\\) Es gibt (mind.) ein x mit A(x) Es gibt mindestens eine Zahl, bei welcher A(x) zutrifft \\(\\exists x \\in M A(x)\\) Es gibt (mind.) ein x aus M miz A(x) Es gibt mindestes einen Wert von M, bei welcher A(x) zutrifft Jeder Quantor bindet eine Variable Umformungen: \\(\\forall x \\in I B(x) \\Leftrightarrow \\forall x (x \\in I \\Rightarrow B(x))\\) Klammern Quantoren binden st\u00e4rker als Junktoren \\(\\forall x \\in \\mathbb M B(x) \\wedge C(x) \\Leftrightarrow (\\forall x \\in \\mathbb M B(x)) \\wedge C(x)\\) Abk\u00fcrzungen \\(\\forall x \\in \\mathbb M (\\forall y \\in \\mathbb M A(x, y)) \\Leftrightarrow \\forall x,y \\in \\mathbb M A(x, y)\\) \\(\\exists x \\in \\mathbb M (\\exists y \\in \\mathbb M A(x, y)) \\Leftrightarrow \\forall x,y \\in \\mathbb M A(x, y)\\) Falls die Menge aus dem Kontext klar ist, k\u00f6nnen wir schreiben: \\(\\forall x A(x)\\) (ohne \\(\\in \\mathbb M\\) ) \\(\\exists x A(x)\\) (ohne \\(\\in \\mathbb M\\) ) Negation: \\(\\neg \\exists x \\in M A(x) \\Leftrightarrow \\forall x \\in M \\neg A(x)\\) \\(\\neg \\forall x \\in M A(x) \\Leftrightarrow \\exists x \\in M \\neg A(x)\\) \\(\\forall x A(x) \\Leftrightarrow \\neg \\exist x \\neg A(x)\\) Distributiv-Gesetzt Keine Distributiv-Gesetzt mit Quantoren und Junktoren Beispiel A(x) := \"x ist eine gerade nat\u00fcrliche Zahl\" B(x) := \"x ist eine ungerade nat\u00fcrliche Zahl\" \\(\\forall x A(x) \\vee B(x) \\Leftrightarrow W \\nLeftrightarrow \\forall x (A(x) \\vee B(x)) \\Leftrightarrow T\\) \\(\\exists x (A(x) \\wedge B(x)) \\nLeftrightarrow \\exists x A(x) \\wedge \\exists x B(x)\\) \\(\\exists x (A(x) \\vee B(x)) \\nLeftrightarrow \\exists x A(x) \\vee \\exists x B(x)\\) Reihenfolge von Quantoren: \\(P(x, y) := x + y = 17\\) \\(\\forall x \\in \\mathbb Z (\\exists x \\in \\mathbb Z P(x, y)) : wahr\\) \\(\\exists x \\in \\mathbb Z (\\forall x \\in \\mathbb Z P(x, y)): falsc h\\) Beispiel: A(x, y) := \"x < y\" -> 2-stelliges Pr\u00e4dikat, frei: x, y \\(\\forall x \\in \\mathbb{R} A(x, y)\\) : 1-stelliges Pr\u00e4dikat, frei: x","title":"Liste von Quantoren"},{"location":"21HS/DM/01_Aussaglogik.html#ubungungen-quantoren","text":"2) a) \\(\\exists x P(x) \\wedge \\forall y,z (P(y) \\wedge P(z) \\Rightarrow y = z)\\) b) \\(\\exists y,z (P(y) \\wedge P(z) \\wedge y \\neq z)\\) c) \\(\\neg (\\exists x,y (P(x) \\wedge P(y) \\wedge x \\neq y)) -> negation von b)\\) d) \\(\\forall x, y (P(x) \\wedge P(y) \\Rightarrow Q(x, y))\\) e) \\(\\neg(\\exists x Q(x, x)) \\Leftrightarrow \\forall x (\\neg Q(x, x))\\) \\(\\neg(\\forall x Q(x, x))\\) -> das w\u00e4re: \"nicht alle x sind Q(x, x)\", aber eines x, bei welchem Q(x, x) stimmt, w\u00e4re ok 3) a) Alle Pr\u00fcfungen sind einfach \\(\\Leftrightarrow \\forall x \\in P E(x)\\) b) Eine Pr\u00fcfung ist einfach \\(\\Leftrightarrow \\exists x \\in P E(x)\\) c) Keine Pr\u00fcfung ist einfach \\(\\Leftrightarrow \\neg \\exists x \\in P E(x)\\) d) Alle Pr\u00fcfungen sind einfach \\(\\Leftrightarrow \\forall x \\in P (\\neg E(x))\\) e) Nur eine Pr\u00fcfung ist einfach \\(\\Leftrightarrow (\\exist x \\in P E(x)) \\wedge \\forall y,z \\in P (E(y) \\wedge E(z))\\) f) Nur eine Pr\u00fcfung ist nicht einfach \\(\\Leftrightarrow (\\exist x \\in P \\neg E(x)) \\wedge \\forall y,z \\in P (\\neg E(y) \\wedge \\neg E(z))\\) g) Nicht alle Pr\u00fcfung sind einfach \\(\\Leftrightarrow \\neg \\forall x \\in P E(x)\\) h) Eine Pr\u00fcfung ist nicht einfach \\(\\Leftrightarrow \\exists x \\in P \\neg E(x)\\) g) und h) sind \u00e4quivalent","title":"\u00dcbungungen Quantoren"},{"location":"21HS/DM/01_Aussaglogik.html#beweisstechnik","text":"\\(\\forall\\) : wahr: f\u00fcr alle Elemente aus der Grundmenge Verallgemeinern mit Variablen falsch: Ein Element, bei dem es nicht funktioniert \\(\\exists\\) wahr: Ein Element finden, bei dem es stimmt falsch: Alle Elemente aus der Grundmenge allgemein zeigen, dass das Pr\u00e4dikat nicht gilt","title":"Beweisstechnik"},{"location":"21HS/DM/01_Aussaglogik.html#direkten-beweis","text":"Implikation zu zeigen \\(\\forall x,y \\in \\mathbb N (\\text{x ist gerade} \\wedge \\text{y ist gerade} \\Rightarrow x\\cdot y \\text{ ist gerade})\\) \\(\\Leftrightarrow \\forall x,y \\in \\mathbb N \\exists n_x,n_y,n_z \\in \\mathbb N (x = 2 \\cdot n_x \\wedge y = 2\\cdot n_y \\Rightarrow x\\cdot y = 2\\cdot n_z)\\) Beweise: A: wahr \\((x=2n_x \\wedge y=2n_y) = T \\text{ } n_x,n_y \\in \\mathbb N\\) B: wahr \\((x\\cdot y = 2n_z) = T\\) \\(A \\Rightarrow B: x \\cdot y = 2n_x \\cdot 2n_y = 2(2n_xn_y) = 2n_z\\)","title":"Direkten Beweis"},{"location":"21HS/DM/01_Aussaglogik.html#beweis-durch-widerspruch","text":"Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. zu beweisen: \\(A:= \\text{\"Es gibt keine gr\u00f6sste nat\u00fcrliche zahl\"} = \\neg \\exists n \\in \\mathbb N G(n)\\) \\(G(x) := \\text{\"x ist gr\u00f6sste Zahl\"}\\) \\(\\neg A := \\text{\"Es gibt mindestens eine gr\u00f6sste nat\u00fcrliche Zahl\"} = \\exists n \\in \\mathbb N G(n)\\) Beweis: Annahme: n ist gr\u00f6sste nat\u00fcrliche Zahl Jedoch f\u00fcr jede nat\u00fcrliche Zahl n, existiert n + 1 Daher ist n+1 > n und n ist nicht die gr\u00f6sste Zahl \\(\\Rightarrow \\neg A = W \\Rightarrow A = T\\)","title":"Beweis durch Widerspruch"},{"location":"21HS/DM/01_Aussaglogik.html#beweis-durch-gegen-beispiel","text":"zu beweisen \"Nicht jede nat\u00fcrliche Zahl ist eine Quadratzahl\" \\(A:= \\neg\\forall n \\in \\mathbb N Q(n)\\Leftrightarrow \\exists n \\in \\mathbb N \\neg Q(n)\\) \\(Q(x)=\\text{x ist Quadradzahl} )\\) Beweis: \\(n = 7\\) , denn \\(f(x)=x^2\\) mit \\(f(x) \\in \\mathbb N\\) in diesem Fall w\u00fcrde 7 niemals als Funktionswert f\u00fcr f(x) herausgekommen, da \\(2\\cdot 2 < 7 < 3 \\cdot 3\\) \\(\\Rightarrow\\) 7 ist keine Quadratzahl \\(\\Rightarrow\\) A ist wahr","title":"Beweis durch (Gegen-) Beispiel"},{"location":"21HS/DM/01_Aussaglogik.html#beweis-durch-kontraposition","text":"Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) Beispiel: zu beweisen: \\(\\forall n \\in \\mathbb N ((n^2 + 1 = 1) \\Rightarrow (n = 0))\\) anstatt dies, beweissen wir \\(\\Leftrightarrow \\forall n \\in \\mathbb N (\\neg (n = 0) \\Rightarrow \\neg(n^2 + 1 = 1))\\) \\(\\Leftrightarrow \\forall n \\in \\mathbb N (n \\neq 0 \\Rightarrow n^2 + 1 \\neq 1))\\) Beweis: Wenn \\(n \\neq 0 \\Rightarrow n^2\\neq 0 \\Rightarrow n^2 + m \\neq m\\) F\u00fcr \\(m=1 \\Rightarrow n^2 + 1 \\neq 1\\) \\(\\Rightarrow \\forall n \\in \\mathbb N ((n \\neq 0) \\Rightarrow (n^2 + 1 \\neq 1)) : T\\)","title":"Beweis durch Kontraposition"},{"location":"21HS/DM/01_Aussaglogik.html#aquivalenz","text":"Um eine \u00c4quivalenz zu beweissen muss \\(A \\Rightarrow B \\wedge B \\Rightarrow A\\) Beispiel: \\(B \\Rightarrow A: \\forall n \\in \\mathbb N ((n = 0) \\Rightarrow (n^2+1=1))\\) \\(n=0\\) (wenn n=0 wahr ist, dann muss auch die n\u00e4chste Linie wahr sein) \\(n^2+1=0^2 + 1 = 1\\) (was sie ist) und da \\(A \\Rightarrow B\\) und \\(B \\Rightarrow A\\) wahr waren, ist auch \\(A \\Leftrightarrow B\\) wahr Biespiel #2: zu zeigen: \\(\\forall n \\in \\mathbb N \\exists k,j \\in \\mathbb N ((n = 2k) \\Leftrightarrow n^2=2j)\\) bzw. \\(\\forall n \\in \\mathbb N \\exists k,j \\in N (n = 2k \\Rightarrow n^2 = j2) \\wedge (n^2 = 2j \\Rightarrow n = 2k)\\) Beweis: \\(A(n) \\Rightarrow B(n)\\) n = 2k : wahr \\(n^2=(2k)^2\\)","title":"\u00c4quivalenz"},{"location":"21HS/DM/02_Semantik.html","text":"Semantik = Bedeutung Konstante \\(\\top\\) = Wahr (\\top) \\(\\bot\\) = Falsch (\\bot) Variabeln Klammern Junktoren Ableitungsb\u00e4ume (ein Syntaxbaum / AST) kann genutzt werden, um die Struktur von Termen eindeutig zu zeigen Beispiel: \\(f = (((a \\wedge b) \\vee (\\neg c)) \\wedge (a \\vee b))\\) Belegungen von Variabeln f\u00fcr atomare Formeln (z.B. a, b, oder eine andere Variabel) \\(B: \\mathbb V \\rightarrow \\{1, 0\\}\\) Beispiel: \\(B(a)=1\\) f\u00fcr komplexe Formeln \\(\\hat B (formel)\\) Beispiel \\(\\hat B (a \\vee b)=false\\) Wahrheitstabelle In einer Wahrheitstabelle werden alle Teilformeln in Spalten aufgelistet f\u00fcr alle m\u00f6glichen Inputs. Teilformeln sind Teile einer gr\u00f6sseren Formeln. Beispiel: Teilformeln f\u00fcr \\(((a \\wedge b) \\vee (\\neg c)) \\wedge (a \\vee c)\\) die Inputs: a, b ,c \\(a \\wedge b\\) \\(\\neg c\\) \\((a \\wedge b) \\vee (\\neg c)\\) \\(a \\vee c\\) \\(((a \\wedge b) \\vee (\\neg c)) \\wedge (a \\vee c)\\) Semantische Eigenschaften Begriff Erkl\u00e4rung Bei Wahrheitstabellen G\u00fcltig oder wahr Bei einer spezifischen Belegung wahr (f\u00fcr eine Spezifische Belegung) Allgemeing\u00fclltig Bei allen Belegungen wahr alle Zeilen sind wahr (Tautologie/ \\(\\top\\) ) Erf\u00fclltbar mind. eine Belegung wahr mind. eine Zeile mit wahr Unerf\u00fclltbar immer falsch alle Zeilen sind falsch (Wiederspruch/ \\(\\bot\\) ) Wiederlegbar mind. einmal falsch, nicht unbedingt immer mind. eine Zeile mit 0 Begriff L\u00f6sungsart G\u00fcltig oder wahr Allgemeing\u00fcltig Wahrheitstabelle, Vereinfachung, Beweis durch Widerspruch Erf\u00fcllbar Ein Beispiel mit Ergebnis \"wahr\" Unerf\u00fcllbar Wahrheitstabelle, Vereinfachung, Beweis durch Widerspruch Wiederlegbar Ein Beispiel mit Ergebnis \"falsch\" \u00c4quivalent ( \\(\\equiv\\) ) \\(\\equiv\\) ; latex: \\equiv Dieses Zeichen wird ben\u00fctzt, wenn zwei aussagenlogische Formel unter jeden Bedingung denselben Wert ergeben Bei Aussagen kann man auch \" \\(\\Leftrightarrow\\) \" bent\u00fctzen Achtung: folgendes ist korrekt: \\(F \\vee (G \\vee H) \\equiv (F \\vee (G \\vee H)\\) , da jede folgendes nicht: \\(\\hat B(F \\vee (G \\vee H)) \\equiv \\hat B((F \\vee (G \\vee H))\\) , da man hier eine bestimmte Belegung rechnet und somit einen wirkklichen Wahrheitswert hat. Hier w\u00fcrde man ein = ben\u00fctzen. Konsequenz F ist genau dann von G, fall F in jeder m\u00f6glichen Belegung wahr ist, in welcher auch G wahr ist Mit logischen Aussagen ausgedr\u00fcckt: \\(\\forall B (\\hat B(F \\rightarrow G)=true)\\) Normalformen Literale Literale sind atomare Formeln oder negierte atomare Formel (a oder \\(\\neg a\\) ) Negotions Normalform (NNF) Wenn alle Negationen in Literale und keine Implikationen vorkommen Disjunktive Normalform (DNF) Wenn die folgende Formel eingehaltet wird: \\((L_1 \\wedge L_2 \\wedge ...)\\vee(L_3 \\wedge L_4 \\wedge ...) \\vee ...\\) Konjunktive Normalform (KNF) Wenn die folgende Formel eingehaltet wird: \\((L_1 \\vee L_2 \\vee ...)\\wedge(L_3 \\vee L_4 \\vee ...) \\wedge ...\\) Umformen - Rechnerisch Vorgehen: Implikationen eliminieren: \\(F \\rightarrow G \\equiv \\neg F \\vee G\\) DeMorgan, falls negationen vor Klammern stehen: \\(\\neg(p\\vee q) \\equiv (\\neg p \\wedge \\neg q)\\) bzw. \\(\\neg (p\\wedge q) \\equiv (\\neg p \\vee \\neg q)\\) \\(\\Rightarrow\\) NNF erreicht Distributivgesetzt anwenden bis gewollte Form erreicht \\(\\Rightarrow\\) KNF oder DNF erreicht Umformen - mit Wahrheitstabelle Nach dem man die Wahrheitstabelle gebildet haben kann man folgende Verfahren anwenden: Minterm: Bei jeder Belegung, welche 1 als Resultat gibt, eine Formel aufschreiben, welche diese Belegung abbildet (Parameter welche 0 ergeben, negieren, Parameter welche 1 geben, direkt \u00fcbernehmen, zusammenf\u00fcgen mit und \\(\\wedge\\) ) Alle Terme mit oder/ \\(\\vee\\) verkn\u00fcpfen Maxterm Bei jeder Belegung, welche 0 als Resultat gibt, eine Form aufschreiben, welche diese Belegung abbildet (Paramter, welche 0 geben, direkt \u00fcbernehmen; Parameter, welche 1 geben, negieren; alle Terme mit und/ \\(\\vee\\) verbinden) Alle Terme mit und/ \\(\\wedge\\) verkn\u00fcpfen","title":"02 Semantik"},{"location":"21HS/DM/02_Semantik.html#belegungen-von-variabeln","text":"f\u00fcr atomare Formeln (z.B. a, b, oder eine andere Variabel) \\(B: \\mathbb V \\rightarrow \\{1, 0\\}\\) Beispiel: \\(B(a)=1\\) f\u00fcr komplexe Formeln \\(\\hat B (formel)\\) Beispiel \\(\\hat B (a \\vee b)=false\\)","title":"Belegungen von Variabeln"},{"location":"21HS/DM/02_Semantik.html#wahrheitstabelle","text":"In einer Wahrheitstabelle werden alle Teilformeln in Spalten aufgelistet f\u00fcr alle m\u00f6glichen Inputs. Teilformeln sind Teile einer gr\u00f6sseren Formeln. Beispiel: Teilformeln f\u00fcr \\(((a \\wedge b) \\vee (\\neg c)) \\wedge (a \\vee c)\\) die Inputs: a, b ,c \\(a \\wedge b\\) \\(\\neg c\\) \\((a \\wedge b) \\vee (\\neg c)\\) \\(a \\vee c\\) \\(((a \\wedge b) \\vee (\\neg c)) \\wedge (a \\vee c)\\)","title":"Wahrheitstabelle"},{"location":"21HS/DM/02_Semantik.html#semantische-eigenschaften","text":"Begriff Erkl\u00e4rung Bei Wahrheitstabellen G\u00fcltig oder wahr Bei einer spezifischen Belegung wahr (f\u00fcr eine Spezifische Belegung) Allgemeing\u00fclltig Bei allen Belegungen wahr alle Zeilen sind wahr (Tautologie/ \\(\\top\\) ) Erf\u00fclltbar mind. eine Belegung wahr mind. eine Zeile mit wahr Unerf\u00fclltbar immer falsch alle Zeilen sind falsch (Wiederspruch/ \\(\\bot\\) ) Wiederlegbar mind. einmal falsch, nicht unbedingt immer mind. eine Zeile mit 0 Begriff L\u00f6sungsart G\u00fcltig oder wahr Allgemeing\u00fcltig Wahrheitstabelle, Vereinfachung, Beweis durch Widerspruch Erf\u00fcllbar Ein Beispiel mit Ergebnis \"wahr\" Unerf\u00fcllbar Wahrheitstabelle, Vereinfachung, Beweis durch Widerspruch Wiederlegbar Ein Beispiel mit Ergebnis \"falsch\"","title":"Semantische Eigenschaften"},{"location":"21HS/DM/02_Semantik.html#aquivalent-equiv","text":"\\(\\equiv\\) ; latex: \\equiv Dieses Zeichen wird ben\u00fctzt, wenn zwei aussagenlogische Formel unter jeden Bedingung denselben Wert ergeben Bei Aussagen kann man auch \" \\(\\Leftrightarrow\\) \" bent\u00fctzen Achtung: folgendes ist korrekt: \\(F \\vee (G \\vee H) \\equiv (F \\vee (G \\vee H)\\) , da jede folgendes nicht: \\(\\hat B(F \\vee (G \\vee H)) \\equiv \\hat B((F \\vee (G \\vee H))\\) , da man hier eine bestimmte Belegung rechnet und somit einen wirkklichen Wahrheitswert hat. Hier w\u00fcrde man ein = ben\u00fctzen.","title":"\u00c4quivalent (\\(\\equiv\\))"},{"location":"21HS/DM/02_Semantik.html#konsequenz","text":"F ist genau dann von G, fall F in jeder m\u00f6glichen Belegung wahr ist, in welcher auch G wahr ist Mit logischen Aussagen ausgedr\u00fcckt: \\(\\forall B (\\hat B(F \\rightarrow G)=true)\\)","title":"Konsequenz"},{"location":"21HS/DM/02_Semantik.html#normalformen","text":"","title":"Normalformen"},{"location":"21HS/DM/02_Semantik.html#literale","text":"Literale sind atomare Formeln oder negierte atomare Formel (a oder \\(\\neg a\\) )","title":"Literale"},{"location":"21HS/DM/02_Semantik.html#negotions-normalform-nnf","text":"Wenn alle Negationen in Literale und keine Implikationen vorkommen","title":"Negotions Normalform (NNF)"},{"location":"21HS/DM/02_Semantik.html#disjunktive-normalform-dnf","text":"Wenn die folgende Formel eingehaltet wird: \\((L_1 \\wedge L_2 \\wedge ...)\\vee(L_3 \\wedge L_4 \\wedge ...) \\vee ...\\)","title":"Disjunktive Normalform (DNF)"},{"location":"21HS/DM/02_Semantik.html#konjunktive-normalform-knf","text":"Wenn die folgende Formel eingehaltet wird: \\((L_1 \\vee L_2 \\vee ...)\\wedge(L_3 \\vee L_4 \\vee ...) \\wedge ...\\)","title":"Konjunktive Normalform (KNF)"},{"location":"21HS/DM/02_Semantik.html#umformen-rechnerisch","text":"Vorgehen: Implikationen eliminieren: \\(F \\rightarrow G \\equiv \\neg F \\vee G\\) DeMorgan, falls negationen vor Klammern stehen: \\(\\neg(p\\vee q) \\equiv (\\neg p \\wedge \\neg q)\\) bzw. \\(\\neg (p\\wedge q) \\equiv (\\neg p \\vee \\neg q)\\) \\(\\Rightarrow\\) NNF erreicht Distributivgesetzt anwenden bis gewollte Form erreicht \\(\\Rightarrow\\) KNF oder DNF erreicht","title":"Umformen - Rechnerisch"},{"location":"21HS/DM/02_Semantik.html#umformen-mit-wahrheitstabelle","text":"Nach dem man die Wahrheitstabelle gebildet haben kann man folgende Verfahren anwenden: Minterm: Bei jeder Belegung, welche 1 als Resultat gibt, eine Formel aufschreiben, welche diese Belegung abbildet (Parameter welche 0 ergeben, negieren, Parameter welche 1 geben, direkt \u00fcbernehmen, zusammenf\u00fcgen mit und \\(\\wedge\\) ) Alle Terme mit oder/ \\(\\vee\\) verkn\u00fcpfen Maxterm Bei jeder Belegung, welche 0 als Resultat gibt, eine Form aufschreiben, welche diese Belegung abbildet (Paramter, welche 0 geben, direkt \u00fcbernehmen; Parameter, welche 1 geben, negieren; alle Terme mit und/ \\(\\vee\\) verbinden) Alle Terme mit und/ \\(\\wedge\\) verkn\u00fcpfen","title":"Umformen - mit Wahrheitstabelle"},{"location":"21HS/DM/03_Mengen.html","text":"Mengen Menge: Zusammenfassung wohlunterscheidbarer unsortierten Objekte (keine Duplikate sind erlaubt) Mengen Darstellung (Echte) Teilmengen Operationen Gleichheit Potenzmengen Partitionen Kardinalit\u00e4t Schnittmenge Vereinigung Komplement Kartesisches Produkt Disjunkte Mengen Faktormengen \u00c4quivalenzklasse Komplement (ohne) Rechneregeln Relationen Komposition Inverse Relationen Gerichtete Graphen Relationen und Funktionen Injektiv und Surjektiv Homogene und heterogene Relation Reflexiit\u00e4t Symmetrisch Antisymmetrisch Transitiv Heterogene Relation Unendliche Mengen Begriffe der Unendlichkeit Erste Diagonal Argument Zweite Diagonal Argument Ordnungsrelationen Begriffe Hasse Diagram Graph DAG topologische Sortierung Darstellung Explizite Darstellung (Aufz\u00e4hlung) Beispiel: {2, 3, 4} Leere Menge Beispiel: {} Beispiel: \\(\\emptyset\\) Spezielle Zahlenmenge: nat\u00fcrliche Zahlen \\(\\mathbb N_0 =\\mathbb N = [0; \\infty[\\) ganze Zahlen: \\(\\mathbb Z = ]\\infty: \\infty[\\) rationale Zahlen: \\(\\mathbb Q\\) (Alle Zahlen, welche durch einen Bruch darstellbar sind (1/3 ja, \\(\\pi\\) nein)) reelle zahlen: \\(\\mathbb R\\) (Alle Zahlen mit einem Komma \\(\\sqrt 2, \\pi, e\\) ) komplexe Zahlen Intervallchreibweisse \\([a,b] := \\{x \\in \\mathbb R | a \\leq x \\leq b \\}\\) \\(]a,b] := \\{x \\in \\mathbb R | a < x \\leq b \\}\\) Pr\u00e4dikatschreibweisse \\(\\{z | z < 10\\}\\) \\(\\{n \\in \\mathbb N | \\text{n ist gerade}\\} = \\{n \\in \\mathbb N | \\exist z \\in \\mathbb N (n = 2\\cdot z)\\}\\) Ersetzungsschreibweisse \\(\\{F(x) | x \\in X\\} = \\{y | \\exists x \\in X (y = F(x))\\}\\) Grafische Darstellung (Echte) Teilmengen \\(X \\subseteq Y \\Leftrightarrow \\forall x(x \\in X \\Rightarrow x \\in Y)\\) X ist eine Teilmenge von Y. X kann auch Y sein \\(X \\subsetneq Y \\Leftrightarrow X \\subseteq Y \\wedge X \\neq Y\\) Dies ist die echte Teilmenge , was nichts anderst heisst, dass X eine Teilmenge von Y ist, aber X nicht Y ist. Operationen Gleichheit Mengen sind gleich, wenn alle Elemente gleich sind: \\(X = Y \\Leftrightarrow \\forall z(z \\in X \\Leftrightarrow z \\in Y)\\) F\u00fcr das Mengen aber gleich sind, muss die Reihenfolge nicht \u00fcbereinstimmen, da Mengen nicht sortiert sind. Potenzmengen Menge aller Teilmengen Beispiele: \\(\\mathcal P(\\emptyset)=\\{\\emptyset\\}\\) \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) \\(\\mathcal P(\\{a, \\{c\\}\\}=\\{\\emptyset, \\{a\\}, \\{\\{c\\}\\}, \\{a, \\{c\\}\\}\\})\\) Die M\u00e4chtigkeit einer Potenzmenge ist zwei hoch die M\u00e4chtigkeit der urspr\u00fcnglichen Menge \\(|P(A)|=2^{|A|}\\) Partitionen Eine Partition von A ist eine Menge von Teilmengen von A, welche nicht leer sind und welche zusammen wieder A ergeben ( \\(\\bigcup_{i \\in I}P_i = A\\) ) Beispiel: \\(A=\\{1, 2, 3\\}\\) \\(P=\\{\\{1\\}, \\{2\\}, \\{3\\}\\}\\) \\(P=\\{\\{1\\}, \\{2, 3\\}\\}\\) Kardinalit\u00e4t \\[ X=\\{1, 2, 3\\}\\\\ |X|=3 \\] Der Betrag von Mengen ist die Anzahl Elemente der Menge. \\(|A \\cup B| = |A| + |B| - |A\\cap B|\\) F\u00fcr disjunkte mengen gillt: \\(|A \\cup B | = |A| + |B|\\) F\u00fcr drei Mengen: \\(|A \\cup B \\cup C| = |A| + |B| + |C| - |A\\cap B| - |B \\cap C| - |A \\cap C| + |A \\cap B \\cap C|\\) Schnittmenge \\(X \\cap Y\\) In der Schnittmenge von zwei Meingen sind alle Elemente, welche in beiden Mengen enthalten sind. ![](/res/2021-11-06-14-05-00-image.png Vereinigung \\(X \\cup Y\\) Die vereinigte Menge zweier Menge sind die Elemente von beiden Mengen in einer, nat\u00fcrlich ohne Duplikate. Komplement \\(X \\setminus Y = X \\cap \\bar Y\\) Kartesisches Produkt \\(A \\times B=\\{a, b\\} \\times \\{1, 2, 3\\} = \\{(a, 1), (a, 2), (a, 3), (b, 1), (b, 2), (b, 3), (c, 1), (c, 2), (c, 3)\\}\\) \\(A\\times B=\\{(a, b) | a \\in A \\wedge b \\in B\\}\\) M\u00e4chtigkeit: \\(|A \\times B| = |A| \\cdot |B|\\) \\(A\\times B \\neq B \\times A\\) Dies liegt daran, dass das Kartesisches Produkt Tupels ergibt und diese sortiert sind. Somit gillt \\((x, 1) \\neq (1, x)\\) Wenn man mehr als zwei Mengen hat, kann man es auch folgendermassen schreiben: \\(\\prod ^n_{A_i}=A\\times A_2\\times A_n\\) Disjunkte Mengen X und Y heissen diskunkt, falls sie keine Elemente teilen \\(X \\cap Y\\cap Z=\\emptyset\\) Paarweise Disjunkte Menge ist eine Menge, wenn sie untereinander keine Elemente Teilen. Faktormengen \\(^X/_R=\\{[x]_R | x \\in X\\}\\) Die Faktormenge besteht aus allen \u00c4quivalenzkalssen. Der Sytanx, wie er oben steht, bedeutet, dass alle \u00c4quivalenzklassen von der Relation R, welche von der Menge X gebildet wurde, in der Faktormenge sind. Beispiel: \\[ xRy \\Leftrightarrow (x - y) \\text{ durch 5 Teilbar ist} = x\\equiv_5 y \\\\ \\text{}^{\\mathbb Z}/_{R_{\\equiv_5}} = \\{[0]_{\\equiv_5},[1]_{\\equiv_5}, [2]_{\\equiv_5}, [3]_{\\equiv_5}, [4]_{\\equiv_5}\\} \\] \u00c4quivalenzklasse Eine \u00c4quivalenzklasse eines Element beschreibt, welche Elemente damit in verbindng stehen in einer Relation. \\([x]_R={y \\in R | xRy}\\) graph LR 3((3)) 4((4)) 11((11)) 12((12)) 3 --> 3 4 --> 4 3 --> 4 --> 3 11 --> 11 --> 12 --> 12 --> 11 In der oberen Relation g\u00e4be es zwei Relationsklassen: \\([3]_R = [4]_R\\) und \\([11]_R = [12]_R\\) Die Relationsklasse \\([11]_R\\) ist dieselbe, wie \\([12]_R\\) , da in den Klammern ein Vertreter der Relationsklasse steht. Komplement (ohne) \\(\\bar X=\\{x | x \\in G \\wedge x \\not \\in X\\}\\) Rechneregeln De Morgan: \\(\\overline{A\\cup B} = \\bar A \\cap \\bar B\\) Komplementgesetzt Relationen Relationen sind das Kartesischeprodukt zweier Mengen: \\(R \\subseteq X \\times Y\\) Dies ergibt eine Liste von Tupels. Daher kann folgenedes ausgesagt werden: \\((x, y) \\in R\\) was auch als \\(xRy\\) geschrieben werden kann. Man kann sie folgendermassen Darstellen: TODO Beschreibend: \\(xRy\\Leftrightarrow \\text{\"y ist doppelt so gross wie x\"}\\) Wahrheitstabelle Graph im Koordinatensystem Bipartifer Graph Gerichter Graphen Dieser funktioniert nur mit heterogenen Relationen. Hier ist ein Beispiel: Komposition Mit \\(S\\circ R\\) wird R mit S gejoint ( Achtung mit der Reihenfolge!! ) \\(S\\circ R = {(x, z) \\in A \\times C | \\exists y \\in B (xRy \\wedge y \\in Z)}\\) Inverse Relationen Ist das Pandon von Umkehrfunktionen. Achtung: \\((S\\circ R)^{-1}=R^{-1} \\circ S^{-1}\\) Gerichtete Graphen Der folgende gerichtete Graph zeigt die Teilbarkeit von Zahlen in der Menge \\(\\{1, 2, 3, 4\\}\\) . Ein gerichteten Graph kann man nur mit homogenen Relationen erstellen k\u00f6nnen. Die Relation w\u00e4re folgendes: {(1, 1), (1, 2), (1, 3), (1,4), (2, 2), (2, 3), (2,4), (3, 3), (3, 4), (4, 4)} Relationen und Funktionen Eine bin\u00e4re Relation ist eine Funktion, falls f\u00fcr jedes \\(x \\in A\\) genau ein \\(y \\in B\\) mit \\(xRy\\) existiert. In diesem Fall kann man schreiben: \\(f: A\\rightarrow B \\text{ mit } f(x)=y\\) Mathematischer ausgedr\u00fcckt: Eine Relation \\(f\\subseteq A \\times B\\) ist eine Funktion von A nach B, falls: \\(\\forall x \\in A\\exists!y \\in B((x, y) \\in f)\\) In anderen Worte muss die Funktion muss linkseindeutig (alle Elemente der linken Menge m\u00fcssen einen Pfeil haben) und Rechtseindeutig (Alle Werte der linken Menge m\u00fcssen klar einem Rechten Wert zu gewissen werden k\u00f6nnen). Injektiv und Surjektiv Eine Funktion ist Injektiv (links eindeutig ), wenn zu jedem y es h\u00f6chstens einmal x mit \\(xRy\\) zutrifft Eine Funktion ist surjektiv (rechtstotal), wenn es zu jedem y mindestens ein x gibt mit \\(xRy\\) Wenn eine Funktion injektiv und surjektiv ist, dann nennt man diese auch Bijektiv . Eine Funktion kann linkstotal, rechtseindeutig, rechtstotal und linkseindeutig sein. Dies kann man auch eine bijektive Funktion nennen. Da bei einer bijektiven Funktion in beiden Mengen alle Elemente \"besetzt\" sein m\u00fcssen, m\u00fcssen sie dieselbe M\u00e4chtigkeit haben ( \\(|A|=|B|\\) ) Homogene und heterogene Relation Eine Relation ist homogen, wenn beide Mengen gleich sind. Mathematischer ausgedr\u00fcckt: \\(A=B, R \\subseteq A \\times A\\) Reflexiit\u00e4t Es gilt \\(\\forall x \\in X (xRx)\\) . In Deutsch heisst dies, dass jedes Element auf sich selbst zeigt. Es darf auch Verbindungen gehen, welche nicht auf sich selbst zeigen, aber jedes Element brauch sicher eine Verbindung mit sich selbst. Symmetrisch \\(\\forall x,y \\in X (xRy \\Rightarrow yRx)\\) oder in Deutsch, wenn x zu y zeigt, muss auch y zu x zeigen. Antisymmetrisch \\(\\forall x,y \\in X (xRy \\wedge yRx \\Rightarrow x=y)\\) oder in Deutsch, es darf nur Pfeile geben, welche nur in eine Richtung oder auf sich selbst zeigen. Transitiv \\(\\forall x,y,z \\in X (xRy \\wedge yRz \\Rightarrow xRz)\\) oder in Deutsch, wenn wenn x zu y und y zu z in Verbindung steht, dann muss auch x zu z in Verbindung stehen. Transitiv ist eine Relation auch, wenn es nur ein Element gibt, oder auch in speziellen F\u00e4lle bei zwei Elemente. Folgende Relation w\u00e4re transitiv. Heterogene Relation Heterogen ist eine Relation hingegen, wenn die Mengen ungleich sind: \\(A \\neq B, R \\subseteq A \\times B\\) Unendliche Mengen Begriffe der Unendlichkeit Eine Menge ist endlich, wenn es eine Darstellung f\u00fcr alle Elemente in der Form \\(M=\\{x_1, x_2, x_3, ..., x_n\\}\\) gibt. Wenn dies nicht der Fall ist, dann nennt man eine Menge unendlich. Eine Menge ist abz\u00e4hlbar , wenn eine surjektive Funktion \\(F: \\mathbb N \\rightarrow X\\) existiert. Dass heisst, jedes Element von X muss mindestens ein Element von \\(\\mathbb N\\) haben. Wenn dies nicht m\u00f6glich ist, nennt man eine Menge \u00fcberabz\u00e4hlbar . Abz\u00e4hlbar und unendliche Mengen sind abz\u00e4hlbar und unendlich. Erste Diagonal Argument Das erste diagonale Argument besagt, dass die Menge \\(\\mathbb N \\times \\mathbb N\\) abz\u00e4hlbar ist. Man kann also eine Funktion bilden, welche wie folgt aussieht: \\(F: \\mathbb N \\rightarrow (\\mathbb N, \\mathbb N)\\) Dies kann erreicht wrden, in dem man die Tupels als 2D-Array darstellt und diagonal z\u00e4hlt Aus dem kann man auch schliessen, dass Vereinigungen von abz\u00e4hlbaren Mengen, abz\u00e4hlbar sind. \\[ \\bigcup _{i\\in \\mathbb N}A_i = \\{F_i(j) | i, j \\in \\mathbb N\\} = \\{F_i(j) | (i, j) \\in \\mathbb N \\times \\mathbb N\\}\\\\ \\text{Daraus kann man die folgende Funktion bilden: }\\\\ H(i, j)=F_i(j) \\] Da \\(\\mathbb N \\times \\mathbb N\\) abz\u00e4hlbar ist, muss auch \\(\\bigcup_{i \\in \\mathbb N}A_i\\) abz\u00e4hlbar sein Zweite Diagonal Argument Die Menge aller unendlichen Bin\u00e4rsequenzen ist \u00fcberabz\u00e4hlbar Die Begr\u00fcndung daf\u00fcr ist: Die Menge soll als folgende Tabelle dargestelt werden: Index Sequenz 1 011001000... 2 100100100... 3 110100100... n ... Damit man die Menge \u00fcberabz\u00e4hlbar nennen kann Ordnungsrelationen Ordnungsrelationen sind Relationen, mit welchen man Objekte in einer gewissen Reihenfolgen ordnen kann. Begriffe Es gibt mehrere Begriffe, welche man typsicherweisse mit den Ordnungsrelationen verwendet. Das R in den folgenden Begriffen ist der Name der Relation. Folgende Begriffe beziehen sich auf einzelne Elemente R-unvergleichbar nennt man zwei Elemente, wenn weder xRy, noch yRx gilt oder in anderen Worten, wenn die Elemente nicht miteinander verbunden sind. R-minimal nennt man ein Elemente, wenn kein anderes Element darauf zeigt. R-maximal nennt man ein Element, wenn es auf kein weiteres Element zeigt. Nun gibt es noch Begriffe, um Ordnungsrelationen zu benennen: Begriff Erkl\u00e4rung Pr\u00e4ordnung Relation, welche reflexiv und transitiv ist Halbordnung Relation, welche reflexiv, transitiv und antisymmetrisch ist totale-/ lineare Ordnung Relation, welche eine Halbordnung ist und keine R-unvergleichbaren Elemente besitzt (jedes Element muss mit Jedem indirekt verbunden sein) Wohlordnung Relation von M, welche eine totale Ordnung ist, bei welcher alle Teilmengen (ausser \\(\\empty\\) ), mindestens ein R-minimal Element enthalten Es gibt noch mehr Begriffe!!! \\(R^+\\) ist ein \"transitiver Abschluss\" und beinhaltet zus\u00e4tzlich zu R auch noch alle indirekten Verbindungen. Beispiel: Die Menge \\(M={(a, b), (b, c)}\\) ist gegeben, f\u00fcr \\(R^+\\) w\u00fcrde zus\u00e4tzlich noch \\((a, c)\\) hinzu kommen. \\(R^*\\) ist eine \"reflexiver transitiver Abschluss\" und beinhaltet zus\u00e4tzlich zu \\(R^+\\) auch noch die reflexive Werte Beispiel: Zus\u00e4tzlich zu \\(M^+\\) k\u00e4men noch folgende Paare hinzu: \\((a, a), (b, b), (c, c)\\) Hasse Diagram Ein Hasse Diagram kann nur f\u00fcr Halbordnungen verwendet werden. Graph Einen Graph wird formal durch eine Menge von Punkten und Kanten zwischen den Punkten beschrieben. Matematisch schreibt man dies folgendermassen: \\(G=(V, E)\\) , dabei ist V die Menge aller Punkte und E eine homogene Relation zwischen den Punkten, welche die Kanten beschreiben. DAG Ein DAG Graph ist ein gerichteter zyklenfreier Graph. Diese kann man z.B. in einem Hasse Diagram darstellen. \\(G(V, E \\setminus \\Delta_V)\\) Dabei steht \\(\\Delta_V\\) f\u00fcr alle zyklischen Verbindungen. Im unteren Beispiel sieht man einen Graph. Mit den roten Pfeilen w\u00e4re es keinen DAG, da diese zyklisch sind. topologische Sortierung","title":"Mengen"},{"location":"21HS/DM/03_Mengen.html#mengen","text":"Menge: Zusammenfassung wohlunterscheidbarer unsortierten Objekte (keine Duplikate sind erlaubt) Mengen Darstellung (Echte) Teilmengen Operationen Gleichheit Potenzmengen Partitionen Kardinalit\u00e4t Schnittmenge Vereinigung Komplement Kartesisches Produkt Disjunkte Mengen Faktormengen \u00c4quivalenzklasse Komplement (ohne) Rechneregeln Relationen Komposition Inverse Relationen Gerichtete Graphen Relationen und Funktionen Injektiv und Surjektiv Homogene und heterogene Relation Reflexiit\u00e4t Symmetrisch Antisymmetrisch Transitiv Heterogene Relation Unendliche Mengen Begriffe der Unendlichkeit Erste Diagonal Argument Zweite Diagonal Argument Ordnungsrelationen Begriffe Hasse Diagram Graph DAG topologische Sortierung","title":"Mengen"},{"location":"21HS/DM/03_Mengen.html#darstellung","text":"Explizite Darstellung (Aufz\u00e4hlung) Beispiel: {2, 3, 4} Leere Menge Beispiel: {} Beispiel: \\(\\emptyset\\) Spezielle Zahlenmenge: nat\u00fcrliche Zahlen \\(\\mathbb N_0 =\\mathbb N = [0; \\infty[\\) ganze Zahlen: \\(\\mathbb Z = ]\\infty: \\infty[\\) rationale Zahlen: \\(\\mathbb Q\\) (Alle Zahlen, welche durch einen Bruch darstellbar sind (1/3 ja, \\(\\pi\\) nein)) reelle zahlen: \\(\\mathbb R\\) (Alle Zahlen mit einem Komma \\(\\sqrt 2, \\pi, e\\) ) komplexe Zahlen Intervallchreibweisse \\([a,b] := \\{x \\in \\mathbb R | a \\leq x \\leq b \\}\\) \\(]a,b] := \\{x \\in \\mathbb R | a < x \\leq b \\}\\) Pr\u00e4dikatschreibweisse \\(\\{z | z < 10\\}\\) \\(\\{n \\in \\mathbb N | \\text{n ist gerade}\\} = \\{n \\in \\mathbb N | \\exist z \\in \\mathbb N (n = 2\\cdot z)\\}\\) Ersetzungsschreibweisse \\(\\{F(x) | x \\in X\\} = \\{y | \\exists x \\in X (y = F(x))\\}\\) Grafische Darstellung","title":"Darstellung"},{"location":"21HS/DM/03_Mengen.html#echte-teilmengen","text":"\\(X \\subseteq Y \\Leftrightarrow \\forall x(x \\in X \\Rightarrow x \\in Y)\\) X ist eine Teilmenge von Y. X kann auch Y sein \\(X \\subsetneq Y \\Leftrightarrow X \\subseteq Y \\wedge X \\neq Y\\) Dies ist die echte Teilmenge , was nichts anderst heisst, dass X eine Teilmenge von Y ist, aber X nicht Y ist.","title":"(Echte) Teilmengen"},{"location":"21HS/DM/03_Mengen.html#operationen","text":"","title":"Operationen"},{"location":"21HS/DM/03_Mengen.html#gleichheit","text":"Mengen sind gleich, wenn alle Elemente gleich sind: \\(X = Y \\Leftrightarrow \\forall z(z \\in X \\Leftrightarrow z \\in Y)\\) F\u00fcr das Mengen aber gleich sind, muss die Reihenfolge nicht \u00fcbereinstimmen, da Mengen nicht sortiert sind.","title":"Gleichheit"},{"location":"21HS/DM/03_Mengen.html#potenzmengen","text":"Menge aller Teilmengen Beispiele: \\(\\mathcal P(\\emptyset)=\\{\\emptyset\\}\\) \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) \\(\\mathcal P(\\{a, \\{c\\}\\}=\\{\\emptyset, \\{a\\}, \\{\\{c\\}\\}, \\{a, \\{c\\}\\}\\})\\) Die M\u00e4chtigkeit einer Potenzmenge ist zwei hoch die M\u00e4chtigkeit der urspr\u00fcnglichen Menge \\(|P(A)|=2^{|A|}\\)","title":"Potenzmengen"},{"location":"21HS/DM/03_Mengen.html#partitionen","text":"Eine Partition von A ist eine Menge von Teilmengen von A, welche nicht leer sind und welche zusammen wieder A ergeben ( \\(\\bigcup_{i \\in I}P_i = A\\) ) Beispiel: \\(A=\\{1, 2, 3\\}\\) \\(P=\\{\\{1\\}, \\{2\\}, \\{3\\}\\}\\) \\(P=\\{\\{1\\}, \\{2, 3\\}\\}\\)","title":"Partitionen"},{"location":"21HS/DM/03_Mengen.html#kardinalitat","text":"\\[ X=\\{1, 2, 3\\}\\\\ |X|=3 \\] Der Betrag von Mengen ist die Anzahl Elemente der Menge. \\(|A \\cup B| = |A| + |B| - |A\\cap B|\\) F\u00fcr disjunkte mengen gillt: \\(|A \\cup B | = |A| + |B|\\) F\u00fcr drei Mengen: \\(|A \\cup B \\cup C| = |A| + |B| + |C| - |A\\cap B| - |B \\cap C| - |A \\cap C| + |A \\cap B \\cap C|\\)","title":"Kardinalit\u00e4t"},{"location":"21HS/DM/03_Mengen.html#schnittmenge","text":"\\(X \\cap Y\\) In der Schnittmenge von zwei Meingen sind alle Elemente, welche in beiden Mengen enthalten sind. ![](/res/2021-11-06-14-05-00-image.png","title":"Schnittmenge"},{"location":"21HS/DM/03_Mengen.html#vereinigung","text":"\\(X \\cup Y\\) Die vereinigte Menge zweier Menge sind die Elemente von beiden Mengen in einer, nat\u00fcrlich ohne Duplikate.","title":"Vereinigung"},{"location":"21HS/DM/03_Mengen.html#komplement","text":"\\(X \\setminus Y = X \\cap \\bar Y\\)","title":"Komplement"},{"location":"21HS/DM/03_Mengen.html#kartesisches-produkt","text":"\\(A \\times B=\\{a, b\\} \\times \\{1, 2, 3\\} = \\{(a, 1), (a, 2), (a, 3), (b, 1), (b, 2), (b, 3), (c, 1), (c, 2), (c, 3)\\}\\) \\(A\\times B=\\{(a, b) | a \\in A \\wedge b \\in B\\}\\) M\u00e4chtigkeit: \\(|A \\times B| = |A| \\cdot |B|\\) \\(A\\times B \\neq B \\times A\\) Dies liegt daran, dass das Kartesisches Produkt Tupels ergibt und diese sortiert sind. Somit gillt \\((x, 1) \\neq (1, x)\\) Wenn man mehr als zwei Mengen hat, kann man es auch folgendermassen schreiben: \\(\\prod ^n_{A_i}=A\\times A_2\\times A_n\\)","title":"Kartesisches Produkt"},{"location":"21HS/DM/03_Mengen.html#disjunkte-mengen","text":"X und Y heissen diskunkt, falls sie keine Elemente teilen \\(X \\cap Y\\cap Z=\\emptyset\\) Paarweise Disjunkte Menge ist eine Menge, wenn sie untereinander keine Elemente Teilen.","title":"Disjunkte Mengen"},{"location":"21HS/DM/03_Mengen.html#faktormengen","text":"\\(^X/_R=\\{[x]_R | x \\in X\\}\\) Die Faktormenge besteht aus allen \u00c4quivalenzkalssen. Der Sytanx, wie er oben steht, bedeutet, dass alle \u00c4quivalenzklassen von der Relation R, welche von der Menge X gebildet wurde, in der Faktormenge sind. Beispiel: \\[ xRy \\Leftrightarrow (x - y) \\text{ durch 5 Teilbar ist} = x\\equiv_5 y \\\\ \\text{}^{\\mathbb Z}/_{R_{\\equiv_5}} = \\{[0]_{\\equiv_5},[1]_{\\equiv_5}, [2]_{\\equiv_5}, [3]_{\\equiv_5}, [4]_{\\equiv_5}\\} \\]","title":"Faktormengen"},{"location":"21HS/DM/03_Mengen.html#aquivalenzklasse","text":"Eine \u00c4quivalenzklasse eines Element beschreibt, welche Elemente damit in verbindng stehen in einer Relation. \\([x]_R={y \\in R | xRy}\\) graph LR 3((3)) 4((4)) 11((11)) 12((12)) 3 --> 3 4 --> 4 3 --> 4 --> 3 11 --> 11 --> 12 --> 12 --> 11","title":"\u00c4quivalenzklasse"},{"location":"21HS/DM/03_Mengen.html#_1","text":"In der oberen Relation g\u00e4be es zwei Relationsklassen: \\([3]_R = [4]_R\\) und \\([11]_R = [12]_R\\) Die Relationsklasse \\([11]_R\\) ist dieselbe, wie \\([12]_R\\) , da in den Klammern ein Vertreter der Relationsklasse steht.","title":""},{"location":"21HS/DM/03_Mengen.html#komplement-ohne","text":"\\(\\bar X=\\{x | x \\in G \\wedge x \\not \\in X\\}\\)","title":"Komplement (ohne)"},{"location":"21HS/DM/03_Mengen.html#rechneregeln","text":"De Morgan: \\(\\overline{A\\cup B} = \\bar A \\cap \\bar B\\) Komplementgesetzt","title":"Rechneregeln"},{"location":"21HS/DM/03_Mengen.html#relationen","text":"Relationen sind das Kartesischeprodukt zweier Mengen: \\(R \\subseteq X \\times Y\\) Dies ergibt eine Liste von Tupels. Daher kann folgenedes ausgesagt werden: \\((x, y) \\in R\\) was auch als \\(xRy\\) geschrieben werden kann. Man kann sie folgendermassen Darstellen: TODO Beschreibend: \\(xRy\\Leftrightarrow \\text{\"y ist doppelt so gross wie x\"}\\) Wahrheitstabelle Graph im Koordinatensystem Bipartifer Graph Gerichter Graphen Dieser funktioniert nur mit heterogenen Relationen. Hier ist ein Beispiel:","title":"Relationen"},{"location":"21HS/DM/03_Mengen.html#komposition","text":"Mit \\(S\\circ R\\) wird R mit S gejoint ( Achtung mit der Reihenfolge!! ) \\(S\\circ R = {(x, z) \\in A \\times C | \\exists y \\in B (xRy \\wedge y \\in Z)}\\)","title":"Komposition"},{"location":"21HS/DM/03_Mengen.html#inverse-relationen","text":"Ist das Pandon von Umkehrfunktionen. Achtung: \\((S\\circ R)^{-1}=R^{-1} \\circ S^{-1}\\)","title":"Inverse Relationen"},{"location":"21HS/DM/03_Mengen.html#gerichtete-graphen","text":"Der folgende gerichtete Graph zeigt die Teilbarkeit von Zahlen in der Menge \\(\\{1, 2, 3, 4\\}\\) . Ein gerichteten Graph kann man nur mit homogenen Relationen erstellen k\u00f6nnen. Die Relation w\u00e4re folgendes: {(1, 1), (1, 2), (1, 3), (1,4), (2, 2), (2, 3), (2,4), (3, 3), (3, 4), (4, 4)}","title":"Gerichtete Graphen"},{"location":"21HS/DM/03_Mengen.html#relationen-und-funktionen","text":"Eine bin\u00e4re Relation ist eine Funktion, falls f\u00fcr jedes \\(x \\in A\\) genau ein \\(y \\in B\\) mit \\(xRy\\) existiert. In diesem Fall kann man schreiben: \\(f: A\\rightarrow B \\text{ mit } f(x)=y\\) Mathematischer ausgedr\u00fcckt: Eine Relation \\(f\\subseteq A \\times B\\) ist eine Funktion von A nach B, falls: \\(\\forall x \\in A\\exists!y \\in B((x, y) \\in f)\\) In anderen Worte muss die Funktion muss linkseindeutig (alle Elemente der linken Menge m\u00fcssen einen Pfeil haben) und Rechtseindeutig (Alle Werte der linken Menge m\u00fcssen klar einem Rechten Wert zu gewissen werden k\u00f6nnen).","title":"Relationen und Funktionen"},{"location":"21HS/DM/03_Mengen.html#injektiv-und-surjektiv","text":"Eine Funktion ist Injektiv (links eindeutig ), wenn zu jedem y es h\u00f6chstens einmal x mit \\(xRy\\) zutrifft Eine Funktion ist surjektiv (rechtstotal), wenn es zu jedem y mindestens ein x gibt mit \\(xRy\\) Wenn eine Funktion injektiv und surjektiv ist, dann nennt man diese auch Bijektiv . Eine Funktion kann linkstotal, rechtseindeutig, rechtstotal und linkseindeutig sein. Dies kann man auch eine bijektive Funktion nennen. Da bei einer bijektiven Funktion in beiden Mengen alle Elemente \"besetzt\" sein m\u00fcssen, m\u00fcssen sie dieselbe M\u00e4chtigkeit haben ( \\(|A|=|B|\\) )","title":"Injektiv und Surjektiv"},{"location":"21HS/DM/03_Mengen.html#homogene-und-heterogene-relation","text":"Eine Relation ist homogen, wenn beide Mengen gleich sind. Mathematischer ausgedr\u00fcckt: \\(A=B, R \\subseteq A \\times A\\)","title":"Homogene und heterogene Relation"},{"location":"21HS/DM/03_Mengen.html#reflexiitat","text":"Es gilt \\(\\forall x \\in X (xRx)\\) . In Deutsch heisst dies, dass jedes Element auf sich selbst zeigt. Es darf auch Verbindungen gehen, welche nicht auf sich selbst zeigen, aber jedes Element brauch sicher eine Verbindung mit sich selbst.","title":"Reflexiit\u00e4t"},{"location":"21HS/DM/03_Mengen.html#symmetrisch","text":"\\(\\forall x,y \\in X (xRy \\Rightarrow yRx)\\) oder in Deutsch, wenn x zu y zeigt, muss auch y zu x zeigen.","title":"Symmetrisch"},{"location":"21HS/DM/03_Mengen.html#antisymmetrisch","text":"\\(\\forall x,y \\in X (xRy \\wedge yRx \\Rightarrow x=y)\\) oder in Deutsch, es darf nur Pfeile geben, welche nur in eine Richtung oder auf sich selbst zeigen.","title":"Antisymmetrisch"},{"location":"21HS/DM/03_Mengen.html#transitiv","text":"\\(\\forall x,y,z \\in X (xRy \\wedge yRz \\Rightarrow xRz)\\) oder in Deutsch, wenn wenn x zu y und y zu z in Verbindung steht, dann muss auch x zu z in Verbindung stehen. Transitiv ist eine Relation auch, wenn es nur ein Element gibt, oder auch in speziellen F\u00e4lle bei zwei Elemente. Folgende Relation w\u00e4re transitiv.","title":"Transitiv"},{"location":"21HS/DM/03_Mengen.html#heterogene-relation","text":"Heterogen ist eine Relation hingegen, wenn die Mengen ungleich sind: \\(A \\neq B, R \\subseteq A \\times B\\)","title":"Heterogene Relation"},{"location":"21HS/DM/03_Mengen.html#unendliche-mengen","text":"","title":"Unendliche Mengen"},{"location":"21HS/DM/03_Mengen.html#begriffe-der-unendlichkeit","text":"Eine Menge ist endlich, wenn es eine Darstellung f\u00fcr alle Elemente in der Form \\(M=\\{x_1, x_2, x_3, ..., x_n\\}\\) gibt. Wenn dies nicht der Fall ist, dann nennt man eine Menge unendlich. Eine Menge ist abz\u00e4hlbar , wenn eine surjektive Funktion \\(F: \\mathbb N \\rightarrow X\\) existiert. Dass heisst, jedes Element von X muss mindestens ein Element von \\(\\mathbb N\\) haben. Wenn dies nicht m\u00f6glich ist, nennt man eine Menge \u00fcberabz\u00e4hlbar . Abz\u00e4hlbar und unendliche Mengen sind abz\u00e4hlbar und unendlich.","title":"Begriffe der Unendlichkeit"},{"location":"21HS/DM/03_Mengen.html#erste-diagonal-argument","text":"Das erste diagonale Argument besagt, dass die Menge \\(\\mathbb N \\times \\mathbb N\\) abz\u00e4hlbar ist. Man kann also eine Funktion bilden, welche wie folgt aussieht: \\(F: \\mathbb N \\rightarrow (\\mathbb N, \\mathbb N)\\) Dies kann erreicht wrden, in dem man die Tupels als 2D-Array darstellt und diagonal z\u00e4hlt Aus dem kann man auch schliessen, dass Vereinigungen von abz\u00e4hlbaren Mengen, abz\u00e4hlbar sind. \\[ \\bigcup _{i\\in \\mathbb N}A_i = \\{F_i(j) | i, j \\in \\mathbb N\\} = \\{F_i(j) | (i, j) \\in \\mathbb N \\times \\mathbb N\\}\\\\ \\text{Daraus kann man die folgende Funktion bilden: }\\\\ H(i, j)=F_i(j) \\] Da \\(\\mathbb N \\times \\mathbb N\\) abz\u00e4hlbar ist, muss auch \\(\\bigcup_{i \\in \\mathbb N}A_i\\) abz\u00e4hlbar sein","title":"Erste Diagonal Argument"},{"location":"21HS/DM/03_Mengen.html#zweite-diagonal-argument","text":"Die Menge aller unendlichen Bin\u00e4rsequenzen ist \u00fcberabz\u00e4hlbar Die Begr\u00fcndung daf\u00fcr ist: Die Menge soll als folgende Tabelle dargestelt werden: Index Sequenz 1 011001000... 2 100100100... 3 110100100... n ... Damit man die Menge \u00fcberabz\u00e4hlbar nennen kann","title":"Zweite Diagonal Argument"},{"location":"21HS/DM/03_Mengen.html#ordnungsrelationen","text":"Ordnungsrelationen sind Relationen, mit welchen man Objekte in einer gewissen Reihenfolgen ordnen kann.","title":"Ordnungsrelationen"},{"location":"21HS/DM/03_Mengen.html#begriffe","text":"Es gibt mehrere Begriffe, welche man typsicherweisse mit den Ordnungsrelationen verwendet. Das R in den folgenden Begriffen ist der Name der Relation. Folgende Begriffe beziehen sich auf einzelne Elemente R-unvergleichbar nennt man zwei Elemente, wenn weder xRy, noch yRx gilt oder in anderen Worten, wenn die Elemente nicht miteinander verbunden sind. R-minimal nennt man ein Elemente, wenn kein anderes Element darauf zeigt. R-maximal nennt man ein Element, wenn es auf kein weiteres Element zeigt. Nun gibt es noch Begriffe, um Ordnungsrelationen zu benennen: Begriff Erkl\u00e4rung Pr\u00e4ordnung Relation, welche reflexiv und transitiv ist Halbordnung Relation, welche reflexiv, transitiv und antisymmetrisch ist totale-/ lineare Ordnung Relation, welche eine Halbordnung ist und keine R-unvergleichbaren Elemente besitzt (jedes Element muss mit Jedem indirekt verbunden sein) Wohlordnung Relation von M, welche eine totale Ordnung ist, bei welcher alle Teilmengen (ausser \\(\\empty\\) ), mindestens ein R-minimal Element enthalten Es gibt noch mehr Begriffe!!! \\(R^+\\) ist ein \"transitiver Abschluss\" und beinhaltet zus\u00e4tzlich zu R auch noch alle indirekten Verbindungen. Beispiel: Die Menge \\(M={(a, b), (b, c)}\\) ist gegeben, f\u00fcr \\(R^+\\) w\u00fcrde zus\u00e4tzlich noch \\((a, c)\\) hinzu kommen. \\(R^*\\) ist eine \"reflexiver transitiver Abschluss\" und beinhaltet zus\u00e4tzlich zu \\(R^+\\) auch noch die reflexive Werte Beispiel: Zus\u00e4tzlich zu \\(M^+\\) k\u00e4men noch folgende Paare hinzu: \\((a, a), (b, b), (c, c)\\)","title":"Begriffe"},{"location":"21HS/DM/03_Mengen.html#hasse-diagram","text":"Ein Hasse Diagram kann nur f\u00fcr Halbordnungen verwendet werden.","title":"Hasse Diagram"},{"location":"21HS/DM/03_Mengen.html#graph","text":"Einen Graph wird formal durch eine Menge von Punkten und Kanten zwischen den Punkten beschrieben. Matematisch schreibt man dies folgendermassen: \\(G=(V, E)\\) , dabei ist V die Menge aller Punkte und E eine homogene Relation zwischen den Punkten, welche die Kanten beschreiben.","title":"Graph"},{"location":"21HS/DM/03_Mengen.html#dag","text":"Ein DAG Graph ist ein gerichteter zyklenfreier Graph. Diese kann man z.B. in einem Hasse Diagram darstellen. \\(G(V, E \\setminus \\Delta_V)\\) Dabei steht \\(\\Delta_V\\) f\u00fcr alle zyklischen Verbindungen. Im unteren Beispiel sieht man einen Graph. Mit den roten Pfeilen w\u00e4re es keinen DAG, da diese zyklisch sind.","title":"DAG"},{"location":"21HS/DM/03_Mengen.html#topologische-sortierung","text":"","title":"topologische Sortierung"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html","text":"Nat\u00fcrliche Zahlen Nat\u00fcrliche Zahlen Volst\u00e4ndige Induktion Methode des kleinsten Verbrechers Rekursion Darstellungsm\u00f6glichkeiten Jede nat\u00fcrliche Zahl plus 1 ergibt die n\u00e4chste nat\u00fcrliche Zahl Die Zahl 0 hat als einzige nat\u00fcrliche Zahl keinen Vorg\u00e4nger Jede nat\u00fcrliche Zahl ist Nachfolger von h\u00f6chstens einer nat\u00fcrlichen Zahl Volst\u00e4ndige Induktion Idee: Beweissen, dass ein Vorgang f\u00fcr das 1. Element und f\u00fcr das n-te Element gillt. Wenn dies gegeben ist, dann wird es auch f\u00fcr das n+1-te Element gellten Um dies zu tun, werden folgende Schritte getan Induktionsverankerung (IV) E(0): wahr Induktionsschritt (IS) Wenn E(n) wahr, dann gillt auch E(n+1) oder \\(E(n) \\Rightarrow E(n+1)\\) Dies kann man normalerweissen in folgende Schritte weiter unterteilen: Induktionsverankerung (IV) Man beweist, dass E(0) wahr ist. Hier kann man einfach einsetzen Induktionsanhame (IA) Man schreibt auf, was man f\u00fcr E(n) erwartet. Dies ist eine Annahme und muss nicht in diesem Schritt bewiesen werden Induktionsbehauptung (IB) Man behauptet, wie sich E() f\u00fcr E(n+1) verhaltet Induktionschluss (IS) Man beweisst, dass wenn es f\u00fcr E(n) gilt, dann gilt es auch f\u00fcr E(n+1) Methode des kleinsten Verbrechers Rekursion F\u00fcr eine Rekursion wird das erste Glied angegeben, und wie man von diesem zum n\u00e4chsten kommt Also: F(0) = ... F(n+1)=...(n+1)... Darstellungsm\u00f6glichkeiten Es gibt drei m\u00f6glichkeiten solche Reihen darzustellen: Aufz\u00e4hlend - die Werte der Reihe aufgez\u00e4hlt ( Beispiel: 2, 4, 8, ... Rekursiv Als Rekusirve Funktion Beispiel: \\(F(0)=2; F(n+1)=2\\cdot F(n)\\) Explitzit Als Funktion, welche nicht sich selbst bent\u00fctzt Beispiel: \\(F(n)=2^n+1\\) Mit Hilfe einer vollst\u00e4ndigen Indukation kann man beweissen, dass die rekursive und explizite Form dasselbe darstellt.","title":"Nat\u00fcrliche Zahlen"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html#naturliche-zahlen","text":"Nat\u00fcrliche Zahlen Volst\u00e4ndige Induktion Methode des kleinsten Verbrechers Rekursion Darstellungsm\u00f6glichkeiten Jede nat\u00fcrliche Zahl plus 1 ergibt die n\u00e4chste nat\u00fcrliche Zahl Die Zahl 0 hat als einzige nat\u00fcrliche Zahl keinen Vorg\u00e4nger Jede nat\u00fcrliche Zahl ist Nachfolger von h\u00f6chstens einer nat\u00fcrlichen Zahl","title":"Nat\u00fcrliche Zahlen"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html#volstandige-induktion","text":"Idee: Beweissen, dass ein Vorgang f\u00fcr das 1. Element und f\u00fcr das n-te Element gillt. Wenn dies gegeben ist, dann wird es auch f\u00fcr das n+1-te Element gellten Um dies zu tun, werden folgende Schritte getan Induktionsverankerung (IV) E(0): wahr Induktionsschritt (IS) Wenn E(n) wahr, dann gillt auch E(n+1) oder \\(E(n) \\Rightarrow E(n+1)\\) Dies kann man normalerweissen in folgende Schritte weiter unterteilen: Induktionsverankerung (IV) Man beweist, dass E(0) wahr ist. Hier kann man einfach einsetzen Induktionsanhame (IA) Man schreibt auf, was man f\u00fcr E(n) erwartet. Dies ist eine Annahme und muss nicht in diesem Schritt bewiesen werden Induktionsbehauptung (IB) Man behauptet, wie sich E() f\u00fcr E(n+1) verhaltet Induktionschluss (IS) Man beweisst, dass wenn es f\u00fcr E(n) gilt, dann gilt es auch f\u00fcr E(n+1)","title":"Volst\u00e4ndige Induktion"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html#methode-des-kleinsten-verbrechers","text":"","title":"Methode des kleinsten Verbrechers"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html#rekursion","text":"F\u00fcr eine Rekursion wird das erste Glied angegeben, und wie man von diesem zum n\u00e4chsten kommt Also: F(0) = ... F(n+1)=...(n+1)...","title":"Rekursion"},{"location":"21HS/DM/04_Nat%C3%BCrliche%20Zahlen.html#darstellungsmoglichkeiten","text":"Es gibt drei m\u00f6glichkeiten solche Reihen darzustellen: Aufz\u00e4hlend - die Werte der Reihe aufgez\u00e4hlt ( Beispiel: 2, 4, 8, ... Rekursiv Als Rekusirve Funktion Beispiel: \\(F(0)=2; F(n+1)=2\\cdot F(n)\\) Explitzit Als Funktion, welche nicht sich selbst bent\u00fctzt Beispiel: \\(F(n)=2^n+1\\) Mit Hilfe einer vollst\u00e4ndigen Indukation kann man beweissen, dass die rekursive und explizite Form dasselbe darstellt.","title":"Darstellungsm\u00f6glichkeiten"},{"location":"21HS/DM/05_Ganz%20Zahlen.html","text":"Ganz Zahlen Ganz Zahlen Begriffe Teilbarkeit Teilermenge Teilen mit Rest GGT & KGV Rechenregeln GGT Euklischer Algorithmus Beispiel 1 Beispiel 2 Teilerfremd Lemma von B\u00e9zout Erweiterter euklidischen Algorithmus Primzahlen Eigenschaften Primzahlen finden (Sieb des Eratosthenes) \\(\\pi\\) Funktion Modulare Arithmetik Der mod Operator Kongruenz Notation f\u00fcr Restklassen Restklassen-Rechnen Addition Multiplikation Beispiel f\u00fcr Modulare Arithmetik Prime Restklassen Eulersche \\(\\varphi\\)-Funktion Chinesischer Restsatz Satz von Euler Kleiner Satz von Fermat Begriffe Begriff Erkl\u00e4rung Neutrales Element Das neutrale Element einer Operation, gibt wieder das eigentliche Element zur\u00fcck Absorbtion Das Element, welches bei jedem anderen Element 0 zur\u00fcck gibt. Teilbarkeit Um zu schreiben, dass die Zahl x teilt die Zahl y, wird dies auch in der Form x|y geschrieben. \\(x|y \\Leftrightarrow(y=k\\cdot x)\\) Beispiel: \\(5|10=\\text{wahr}\\) Folgende Gesetzte gellten: \\(z|z=\\text{wahr}\\) (reflexiv) \\(x|y \\Rightarrow x|k\\cdot y \\wedge k \\in \\Z\\) \\(x|y \\wedge x|(y+z)=x|z\\) \\(x|y \\wedge y|z=x|z\\) (transitive) \\(x|y \\wedge x|z \\Rightarrow x|(y-z)\\) (Wenn y und z durch x teilbar ist, ist auch (y-z) durch x teilbar) Teilermenge Die Menge aller nat\u00fcrlichen Teiler der Zahl. Man schreibt nur die positiven Zahl auf. Als Beispiel: \\(T(15)=\\{1, 3, 5, 15\\}\\) \\(T(-15)=\\{1, 3, 5, 15\\}\\) Teilen mit Rest Das Teilen durch Rest kann auch als \\(m=kn+r\\) dargestellt werden. Beispiel: \\[ 28:5=4\\text{ Rest } 3 = 5\\cdot 5 + 3\\\\ 7:3=2 \\text{ Rest } 1 = 2\\cdot 3 + 1\\\\ -7:3=-3 \\text{ Rest } 2 = -3 \\cdot 3 + 2 \\\\ 7:-3=-3 \\text{ Rest } -2 = -3 \\cdot -3 - 2 \\\\ -7:-3=2 \\text { Rest } -1 = -3 \\cdot 2 - 1 \\] GGT & KGV Der gr\u00f6sste gemeinsame Teiler kann als \\(ggT(n, m)=max\\{k \\in \\N \\mid k|n \\wedge k|m\\}\\) (max holt das gr\u00f6sste Elemente der Liste) Das kleinste gemeinsame Vielfache kann als \\(kgV(n, m)=min \\{k \\in \\N \\mid n | k \\wedge m|k\\}\\) \\(n\\cdot m = kgV(n, m)\\cdot ggT(n, m) \\Rightarrow kgV(n, m)=\\frac{n\\cdot m}{ggT(n, m)}\\) Rechenregeln GGT \\(ggT(n, n) = n\\) \\(ggT(n, 1)=1\\) \\(ggT(n, 0)=n\\) \\(ggT(n, m)=ggT(m, n)\\) \\(ggT(n, m)=ggT(n, m-n)\\) \\(ggT(n, m)=ggT(n, m-k\\cdot n) \\text{ wenn } k\\cdot n \\le m\\) Euklischer Algorithmus Mit diesem Algorithmus kann der ggT(n, m) bestummen weden. Allgeimein F\u00fcr \\(n, m \\in \\Z \\setminus \\{0\\}\\) : Berechne \\(k, r \\in \\N\\) mit \\(n=k\\cdot m + r\\) mit \\(0 \\le |r| \\lt m\\) Falls $r \\ne 0 $ setze \\(n=m\\) und \\(m = r\\) Wiederhole Schritt 1 Falls \\(r=0\\) ist \\(m\\) der ggT Beispiel 1 \\(ggT(693, 286)=ggT(286, 693-2\\cdot 286)=ggT(286, 121)\\) \\(ggT(286, 121)=ggT(121, 286-2\\cdot 121)=ggT(121, 44)\\) \\(ggT(121, 44)=ggT(44, 121 - 2\\cdot 44) = ggT(44, 33)\\) \\(ggT(44, 33)=ggT(33, 44 - 1\\cdot 33)=ggT(33, 11)\\) \\(ggT(33, 11)=ggT(11, 33 - 3\\cdot 11)=ggT(11, 0)=11\\) oder Verk\u00fcrzt geschrieben: \\(693=2\\cdot 286+121\\) \\(286=2\\cdot 121 + 44\\) \\(121=2\\cdot 44 + 33\\) \\(44=1\\cdot 33 + 11\\) \\(33=3\\cdot 11 + 0\\) Beispiel 2 Teilerfremd Zwei Zahlen \\(x, y \\in \\Z\\) heissen teilerfremd, falls \\(ggT(x, y)=1\\) ist. In Deutsch, zwei Zahlen haben keinen gemeinsammen Teiler (ausser 1 nat\u00fcrlich). Lemma von B\u00e9zout \\(ggT(x, y)=ax+by\\) , wenn \\(x, y \\neq 0\\) Erweiterter euklidischen Algorithmus Diesen Algorithmus kann dazu verwendet werden eine L\u00f6sung f\u00fcr \\(x\\) und \\(y\\) zur Gleichung \\(ggT(a, b)=xb+yc\\) zu finden (wenn \\(x > y\\) ist). Solche Gleichungen nennt man lineare diophalische Gleichungen. Dieser Algorithmus erweitert den euklidischen Algorithmus. Zuerst wird dieser durchgef\u00fchrt f\u00fcr den \\(ggT(a, b)\\) . Danach folgen die unteren Schritte. \\(q_k\\) ist dabei der Quotient in der Reihe \\(k\\) vom euklidischen Algorithmus. $$ x_0=1\\ x_1=0\\ x_k=x_{k-2}-q_k\\cdot x_{k-1}\\ \\space \\ y_0=0\\ y_1=1\\ y_k=y_{k-2}-q_k\\cdot y_{k-1} $$ {title: \"test\"} Beispiel: Primzahlen Definition: Primzahlen sind nat\u00fcrliche Zahlen, die nur durch 1 und durch sich selbst teilbar sind (1 selbst ist keine Primzahl) \\(|T(p)|=2\\) Eigenschaften Jede ganze Zahl \\(z\\) mit \\(z \\notin \\{-1, 1\\}\\) besitzt ein Primfaktor (ein Faktor, welcher eine Primzahl ist) Jede nat\u00fcrliche Zahl kann als Primfaktoren dargestellt werden Mersenne-Primzahl hat die Form \\(2^n-1\\) Es gibt unendlich viele Primzahlen Primzahlen finden (Sieb des Eratosthenes) Man geht jede (noch nicht gestrichene) Zahl und streicht die Vielfachen der Zahl. Dies wiederholt man so lange, bis die Quadradtzahl der aktuellen Zahl ist ausserhalb dem Suchbereich. \\(\\pi\\) Funktion Die Funktion \\(\\pi(n)\\) gibt zur\u00fcck, wie viele Primzahlen es gibt, welche kleiner als n sind. Modulare Arithmetik Der mod Operator Der mod Operator gibt zur\u00fcck, wie viel Rest bei einer Division ergibt. Das Vorzeichen des Resultates hat meistens dasselbe Vorzeichen, wie der Divident (die zweite Zahl). Kongruenz Zwei Zahlen sind konkruent, wenn sie denselben Resten ergeben, wenn man sie durch die selbe Zahl teilt. \\(r\\equiv_n s \\Leftrightarrow n|(r-s)\\) (n teilbar durch r-s) Als Beispiel: \\(26\\equiv_8 18\\equiv_8 10 \\equiv_8 2 \\equiv_8 -6 \\equiv_8 -14\\) Dieses Denken, kann helfen das Resultat von Minuszahlen sich vorzustellen. Dieser Operator kann auch als \u00c4quivalenrelation beschrieben werden, da die Eigenschaft reflexiv, symmetrisch und transitiv ist. In einer \u00c4quivalenzklasse dieser Relation sind alle Zahlen, welche den selben Rest haben. Diese nennet man auch Restklassen Beispiel: \\([10]_8=\\{..., -22, -14, -6, 2, 10, 18, 26, ...\\}\\) n\u00fctzlich sein kann: \\([38]_9+[22]_9=[2]_9+[4]_9=[6]_9\\) Notation f\u00fcr Restklassen Formel Erkl\u00e4rung \\(\\Z/n=\\{[z]_n\\|z\\in \\Z\\}\\) Die Menge aller Restklasse \\(\\Z^*_{/n}\\) Das Primes Restklassenssytem, welches nur die Restklassen enth\u00e4lt, welche zu n teilerfremd sind. Alle Restklassen in diesem System k\u00f6nnen multipliziert werden (Siehe Prime Restklassen ) \\([z]_n=\\overline{z}\\) Die Restklasse, bzw. \u00c4quivalenzklasse mit dem Teiler n und dem Vertreter \\(z\\) Restklassen-Rechnen Das Berechnen der Restklassen kann man auch vereinfachen. \\[ [a]_n+[b]_n=[a+b]_n\\\\ [a]_n\\cdot[b]_n=[a\\cdot b]_n \\] Addition Das neutrale Element dabei ist: \\([0]_n\\) Das inverse Element von \\([a]_n=[-a]_n=[n-a]_n\\) In der folgenden Tabelle sieht man, alle Additionen von \\([n]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([0]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([1]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([2]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([3]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([4]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([5]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) Multiplikation In der folgenden Tabelle sieht man, alle Multiplikationen von \\([n]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([1]_6\\) \\([0]_6\\) \\(\\mathbf{[1]_6}\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([2]_6\\) \\([0]_6\\) \\([2]_6\\) \\([4]_6\\) \\([0]_6\\) \\([2]_6\\) \\([4]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([4]_6\\) \\([0]_6\\) \\([4]_6\\) \\([2]_6\\) \\([0]_6\\) \\([4]_6\\) \\([2]_6\\) \\([5]_6\\) \\([0]_6\\) \\([5]_6\\) \\([4]_6\\) \\([3]_6\\) \\([2]_6\\) \\([1]_6\\) Neutrales Element: \\([1]_6\\) Inverse Element: Nur Zahlen, welche teilerfremd sind (ggT(Zahl, N)=1) Eine Zahl multipliziert mit ihrem inveren Element muss 1 geben Beispiel: \\([5]_6\\cdot[5]_6=[1]_6\\) Beispiel 2: \\([7^{49}]_{10}=(7^2)^{24}\\cdot 7 \\equiv_{10} 49^{24}\\cdot7\\equiv_{10}(-1)^{24}\\cdot 7 \\equiv_{10}\\cdot 7=[7]_{10}\\) Beispiel f\u00fcr Modulare Arithmetik \\[ 3\\cdot x \\equiv_7 4 \\\\ [3]\\cdot[3^{-1}]\\cdot x \\equiv_7 4\\\\ -2\\cdot 3 \\cdot x \\equiv_7 (-2)\\cdot 4\\\\ x \\equiv_7 -8\\equiv_7 6 \\] Prime Restklassen Prime Restklassen sind die Restklassen, welche ein Inverseselement f\u00fcr die Multiplikation besitzen. Dies wird mit einem Stern geschrieben, wie hier zu sehen: \\(\\Z_{/7}^{*}\\) . Beispiel: \\(\\Z^*_{/7}=\\{[1], [2], [3], [4], [5], [6]\\}\\) \\(\\Z^*_{/6}=\\{[1], [5]\\}\\) Eulersche \\(\\varphi\\) -Funktion Um die M\u00e4chtigkeit einer Prime Restklasse zu bestimmen kann folgenden getan werden: \\(\\varphi(n\\cdot m)=\\varphi(n)\\cdot \\varphi(m)\\) , wobei gillt \\(ggT(n, m)=1\\) \\(\\varphi(p)=p-1\\) , wobei gillt \\(p\\in \\mathbb P\\) \\(\\varphi(p^k)=p^k-p^{k-1}\\) , wobei gillt \\(k\\in \\N_{\\gt0}\\) Beispiel: \\[ |\\Z_{/8}^*|=\\varphi(8)=\\varphi(2^3)=2^3-2^{3-1} = 8 -4 =4\\\\ |\\Z_{/15}^*|=\\varphi(15)=\\varphi(3\\cdot5)=\\varphi(3)\\cdot \\varphi(5)\\\\ |\\Z_{/240}^*|=\\varphi(240)=\\varphi(2^4\\cdot3\\cdot5)=.. \\] Chinesischer Restsatz Der chinesischer Restsatz hilft ein Gleichungssystem mit mehreren Kongruenzen ( \\(\\equiv_n\\) ) . Es gibt garantiert eine L\u00f6sung, wenn alle Modulos paarweise teilerfremd sind (alle mit allen den ggT von 1 haben). Falls dies nicht der Fall ist, kann es trotzdem noch eine L\u00f6sung geben, dies ist aber nicht garantiert. Hier sind die Schritte f\u00fcr den Algorithmus: \\(M_k\\) berechnen Mit \\(M_k=\\frac{\\sum_k m_k}{m_k}\\) kann \\(M\\) f\u00fcr jede Gleichung berechnet werden. Dabei werden alle Modulos ( \\(\\sum_k m_k\\) ) durch das Module der aktuellen Zeile ( \\(m_k\\) ) gerechnet Das multiplikative Inverse \\(N_k\\) f\u00fcr jedes \\(M_k\\) berechnen. Bei kleinen Zahlen kann hier f\u00fcr gepr\u00f6pelt werden Nun folgt die Formel: \\(x=\\sum^n_{k=1}a_kM_kN_k=a_1M_1N_1+...+a_nM_nN_n\\) Beispiel: Folgendes ist die Gleichung und die daraus resultierende \\(a_k\\) und \\(m_k\\) Werte: $$ x\\equiv_3 2 &\\rightarrow &a_1=2&m_1=3\\ x\\equiv_5 7 &\\rightarrow &a_2=3 &m_2=5\\ x\\equiv_7 2 &\\rightarrow&a_3=2 &m_3=7\\ $$ Nun werden die \\(M_k\\) berechnet $$ M_1=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_1}=m_2\\cdot m_3 = 5\\cdot 7 = 35\\ M_2=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_2}=m_1\\cdot m_3 = 3\\cdot 7 = 21\\ M_3=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_3}=m_1\\cdot m_2 = 3\\cdot 5 = 15\\ $$ Als n\u00e4chstes werden die multiplikative Inverse \\(N_k\\) berechnet Beispiel: $$ x &\\equiv 2 \\mod3\\ x &\\equiv 5 \\mod 7\\ $$ Inverse der Modulen gegenseitig: Dies kann man mit dem erweiterten Euklidischen Algorithmus ausrechnen oder mit ausprobieren finden $$ M_1=7: 7\\cdot N_1\\equiv_3 1 \\rightarrow [N_1]_3=[1]_3\\ M_2=3: 3\\cdot N_2 \\equiv_7 1 \\rightarrow [N_2]_7=[5]_7\\ $$ Kongurenz Zusammenfassen $$ x & \\equiv 2 \\cdot 7 \\cdot 1 + 5 \\cdot 3 \\cdot 5 \\mod (3\\cdot 7)\\ & \\equiv (14 + 75)\\equiv 89 \\equiv 5 \\mod 21 $$ \\[ x\\equiv2 \\mod3 & a_1=2 &m_1=3\\\\ x\\equiv3 \\mod 5 & a_2=3 &m_2=5\\\\ x\\equiv2 \\mod 7& a_3=2 &m_3=7\\\\ \\] \\(M_n\\) bestimmen: $$ M_1=\\frac m {m_1} $$ \\(N_k\\) bestimmen Multiplikative Inverse von \\([N_k]_{mk}=[M_k^{-1}]_{mk}\\) $$ N_1: [N_1]_3=[35^{-1}]_3=[2^{-1}]_3=[2]_3 &N_1=2\\ N_2: [N_2]_5=[21^{-1}]_5=[1^{-1}]_5=[1]_5 &N_2=1\\ N_3: [N_3]_7=[15^{-1}]_7=[1^{-1}]_7=[1]_7 &N_3=1\\ $$ Kongruenz $$ x\\equiv 2\\cdot35\\cdot2+ 3\\cdot 21 \\cdot1 + 2\\cdot 15 \\cdot 1 \\mod 105\\ \\equiv 233 \\mod105 \\equiv 23 \\mod 105\\ \\mathbb L=[23]_105 $$ Satz von Euler \\[ a^e ... \\mod n\\\\ 3^{160}\\equiv_{10}(3^2)^{80}\\equiv_{10}9^{80}\\equiv{10}(-1)^{80}\\equiv_{10}1 \\] Der Satz von Euler besagt: \\(ggT(a, m)=1\\Rightarrow a^{\\varphi(m)}\\equiv1 \\mod m\\) Kleiner Satz von Fermat F\u00fcr \\((p \\in \\R \\wedge a \\in \\Z)\\wedge p \\not{|} a\\) gillt \\(a^{p-1}\\equiv 1 \\mod p\\) Beispiel: \\[ 26^{123}\\mod 7 & ggT(26, 7)=1\\\\ 26^{7-1}\\equiv_7 26^6\\equiv_7 1\\\\ 26^{123}\\equiv_7 (26^6)^{20}\\cdot 26^3\\equiv_7 1^20\\cdot 26^3\\equiv_7 5^3\\equiv_7(-2^3) \\equiv_7 -8 \\equiv_76 \\]","title":"Ganz Zahlen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#ganz-zahlen","text":"Ganz Zahlen Begriffe Teilbarkeit Teilermenge Teilen mit Rest GGT & KGV Rechenregeln GGT Euklischer Algorithmus Beispiel 1 Beispiel 2 Teilerfremd Lemma von B\u00e9zout Erweiterter euklidischen Algorithmus Primzahlen Eigenschaften Primzahlen finden (Sieb des Eratosthenes) \\(\\pi\\) Funktion Modulare Arithmetik Der mod Operator Kongruenz Notation f\u00fcr Restklassen Restklassen-Rechnen Addition Multiplikation Beispiel f\u00fcr Modulare Arithmetik Prime Restklassen Eulersche \\(\\varphi\\)-Funktion Chinesischer Restsatz Satz von Euler Kleiner Satz von Fermat","title":"Ganz Zahlen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#begriffe","text":"Begriff Erkl\u00e4rung Neutrales Element Das neutrale Element einer Operation, gibt wieder das eigentliche Element zur\u00fcck Absorbtion Das Element, welches bei jedem anderen Element 0 zur\u00fcck gibt.","title":"Begriffe"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#teilbarkeit","text":"Um zu schreiben, dass die Zahl x teilt die Zahl y, wird dies auch in der Form x|y geschrieben. \\(x|y \\Leftrightarrow(y=k\\cdot x)\\) Beispiel: \\(5|10=\\text{wahr}\\) Folgende Gesetzte gellten: \\(z|z=\\text{wahr}\\) (reflexiv) \\(x|y \\Rightarrow x|k\\cdot y \\wedge k \\in \\Z\\) \\(x|y \\wedge x|(y+z)=x|z\\) \\(x|y \\wedge y|z=x|z\\) (transitive) \\(x|y \\wedge x|z \\Rightarrow x|(y-z)\\) (Wenn y und z durch x teilbar ist, ist auch (y-z) durch x teilbar)","title":"Teilbarkeit"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#teilermenge","text":"Die Menge aller nat\u00fcrlichen Teiler der Zahl. Man schreibt nur die positiven Zahl auf. Als Beispiel: \\(T(15)=\\{1, 3, 5, 15\\}\\) \\(T(-15)=\\{1, 3, 5, 15\\}\\)","title":"Teilermenge"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#teilen-mit-rest","text":"Das Teilen durch Rest kann auch als \\(m=kn+r\\) dargestellt werden. Beispiel: \\[ 28:5=4\\text{ Rest } 3 = 5\\cdot 5 + 3\\\\ 7:3=2 \\text{ Rest } 1 = 2\\cdot 3 + 1\\\\ -7:3=-3 \\text{ Rest } 2 = -3 \\cdot 3 + 2 \\\\ 7:-3=-3 \\text{ Rest } -2 = -3 \\cdot -3 - 2 \\\\ -7:-3=2 \\text { Rest } -1 = -3 \\cdot 2 - 1 \\]","title":"Teilen mit Rest"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#ggt-kgv","text":"Der gr\u00f6sste gemeinsame Teiler kann als \\(ggT(n, m)=max\\{k \\in \\N \\mid k|n \\wedge k|m\\}\\) (max holt das gr\u00f6sste Elemente der Liste) Das kleinste gemeinsame Vielfache kann als \\(kgV(n, m)=min \\{k \\in \\N \\mid n | k \\wedge m|k\\}\\) \\(n\\cdot m = kgV(n, m)\\cdot ggT(n, m) \\Rightarrow kgV(n, m)=\\frac{n\\cdot m}{ggT(n, m)}\\)","title":"GGT &amp; KGV"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#rechenregeln-ggt","text":"\\(ggT(n, n) = n\\) \\(ggT(n, 1)=1\\) \\(ggT(n, 0)=n\\) \\(ggT(n, m)=ggT(m, n)\\) \\(ggT(n, m)=ggT(n, m-n)\\) \\(ggT(n, m)=ggT(n, m-k\\cdot n) \\text{ wenn } k\\cdot n \\le m\\)","title":"Rechenregeln GGT"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#euklischer-algorithmus","text":"Mit diesem Algorithmus kann der ggT(n, m) bestummen weden. Allgeimein F\u00fcr \\(n, m \\in \\Z \\setminus \\{0\\}\\) : Berechne \\(k, r \\in \\N\\) mit \\(n=k\\cdot m + r\\) mit \\(0 \\le |r| \\lt m\\) Falls $r \\ne 0 $ setze \\(n=m\\) und \\(m = r\\) Wiederhole Schritt 1 Falls \\(r=0\\) ist \\(m\\) der ggT","title":"Euklischer Algorithmus"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#beispiel-1","text":"\\(ggT(693, 286)=ggT(286, 693-2\\cdot 286)=ggT(286, 121)\\) \\(ggT(286, 121)=ggT(121, 286-2\\cdot 121)=ggT(121, 44)\\) \\(ggT(121, 44)=ggT(44, 121 - 2\\cdot 44) = ggT(44, 33)\\) \\(ggT(44, 33)=ggT(33, 44 - 1\\cdot 33)=ggT(33, 11)\\) \\(ggT(33, 11)=ggT(11, 33 - 3\\cdot 11)=ggT(11, 0)=11\\) oder Verk\u00fcrzt geschrieben: \\(693=2\\cdot 286+121\\) \\(286=2\\cdot 121 + 44\\) \\(121=2\\cdot 44 + 33\\) \\(44=1\\cdot 33 + 11\\) \\(33=3\\cdot 11 + 0\\)","title":"Beispiel 1"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#beispiel-2","text":"","title":"Beispiel 2"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#teilerfremd","text":"Zwei Zahlen \\(x, y \\in \\Z\\) heissen teilerfremd, falls \\(ggT(x, y)=1\\) ist. In Deutsch, zwei Zahlen haben keinen gemeinsammen Teiler (ausser 1 nat\u00fcrlich).","title":"Teilerfremd"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#lemma-von-bezout","text":"\\(ggT(x, y)=ax+by\\) , wenn \\(x, y \\neq 0\\)","title":"Lemma von B\u00e9zout"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#erweiterter-euklidischen-algorithmus","text":"Diesen Algorithmus kann dazu verwendet werden eine L\u00f6sung f\u00fcr \\(x\\) und \\(y\\) zur Gleichung \\(ggT(a, b)=xb+yc\\) zu finden (wenn \\(x > y\\) ist). Solche Gleichungen nennt man lineare diophalische Gleichungen. Dieser Algorithmus erweitert den euklidischen Algorithmus. Zuerst wird dieser durchgef\u00fchrt f\u00fcr den \\(ggT(a, b)\\) . Danach folgen die unteren Schritte. \\(q_k\\) ist dabei der Quotient in der Reihe \\(k\\) vom euklidischen Algorithmus. $$ x_0=1\\ x_1=0\\ x_k=x_{k-2}-q_k\\cdot x_{k-1}\\ \\space \\ y_0=0\\ y_1=1\\ y_k=y_{k-2}-q_k\\cdot y_{k-1} $$ {title: \"test\"} Beispiel:","title":"Erweiterter euklidischen Algorithmus"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#primzahlen","text":"Definition: Primzahlen sind nat\u00fcrliche Zahlen, die nur durch 1 und durch sich selbst teilbar sind (1 selbst ist keine Primzahl) \\(|T(p)|=2\\)","title":"Primzahlen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#eigenschaften","text":"Jede ganze Zahl \\(z\\) mit \\(z \\notin \\{-1, 1\\}\\) besitzt ein Primfaktor (ein Faktor, welcher eine Primzahl ist) Jede nat\u00fcrliche Zahl kann als Primfaktoren dargestellt werden Mersenne-Primzahl hat die Form \\(2^n-1\\) Es gibt unendlich viele Primzahlen","title":"Eigenschaften"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#primzahlen-finden-sieb-des-eratosthenes","text":"Man geht jede (noch nicht gestrichene) Zahl und streicht die Vielfachen der Zahl. Dies wiederholt man so lange, bis die Quadradtzahl der aktuellen Zahl ist ausserhalb dem Suchbereich.","title":"Primzahlen finden (Sieb des Eratosthenes)"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#pi-funktion","text":"Die Funktion \\(\\pi(n)\\) gibt zur\u00fcck, wie viele Primzahlen es gibt, welche kleiner als n sind.","title":"\\(\\pi\\) Funktion"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#modulare-arithmetik","text":"","title":"Modulare Arithmetik"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#der-mod-operator","text":"Der mod Operator gibt zur\u00fcck, wie viel Rest bei einer Division ergibt. Das Vorzeichen des Resultates hat meistens dasselbe Vorzeichen, wie der Divident (die zweite Zahl).","title":"Der mod Operator"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#kongruenz","text":"Zwei Zahlen sind konkruent, wenn sie denselben Resten ergeben, wenn man sie durch die selbe Zahl teilt. \\(r\\equiv_n s \\Leftrightarrow n|(r-s)\\) (n teilbar durch r-s) Als Beispiel: \\(26\\equiv_8 18\\equiv_8 10 \\equiv_8 2 \\equiv_8 -6 \\equiv_8 -14\\) Dieses Denken, kann helfen das Resultat von Minuszahlen sich vorzustellen. Dieser Operator kann auch als \u00c4quivalenrelation beschrieben werden, da die Eigenschaft reflexiv, symmetrisch und transitiv ist. In einer \u00c4quivalenzklasse dieser Relation sind alle Zahlen, welche den selben Rest haben. Diese nennet man auch Restklassen Beispiel: \\([10]_8=\\{..., -22, -14, -6, 2, 10, 18, 26, ...\\}\\) n\u00fctzlich sein kann: \\([38]_9+[22]_9=[2]_9+[4]_9=[6]_9\\)","title":"Kongruenz"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#notation-fur-restklassen","text":"Formel Erkl\u00e4rung \\(\\Z/n=\\{[z]_n\\|z\\in \\Z\\}\\) Die Menge aller Restklasse \\(\\Z^*_{/n}\\) Das Primes Restklassenssytem, welches nur die Restklassen enth\u00e4lt, welche zu n teilerfremd sind. Alle Restklassen in diesem System k\u00f6nnen multipliziert werden (Siehe Prime Restklassen ) \\([z]_n=\\overline{z}\\) Die Restklasse, bzw. \u00c4quivalenzklasse mit dem Teiler n und dem Vertreter \\(z\\)","title":"Notation f\u00fcr Restklassen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#restklassen-rechnen","text":"Das Berechnen der Restklassen kann man auch vereinfachen. \\[ [a]_n+[b]_n=[a+b]_n\\\\ [a]_n\\cdot[b]_n=[a\\cdot b]_n \\]","title":"Restklassen-Rechnen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#addition","text":"Das neutrale Element dabei ist: \\([0]_n\\) Das inverse Element von \\([a]_n=[-a]_n=[n-a]_n\\) In der folgenden Tabelle sieht man, alle Additionen von \\([n]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([0]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([1]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([2]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([3]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([4]_6\\) \\([4]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([5]_6\\) \\([5]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\)","title":"Addition"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#multiplikation","text":"In der folgenden Tabelle sieht man, alle Multiplikationen von \\([n]_6\\) \\([0]_6\\) \\([1]_6\\) \\([2]_6\\) \\([3]_6\\) \\([4]_4\\) \\([5]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([0]_6\\) \\([1]_6\\) \\([0]_6\\) \\(\\mathbf{[1]_6}\\) \\([2]_6\\) \\([3]_6\\) \\([4]_6\\) \\([5]_6\\) \\([2]_6\\) \\([0]_6\\) \\([2]_6\\) \\([4]_6\\) \\([0]_6\\) \\([2]_6\\) \\([4]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([0]_6\\) \\([3]_6\\) \\([4]_6\\) \\([0]_6\\) \\([4]_6\\) \\([2]_6\\) \\([0]_6\\) \\([4]_6\\) \\([2]_6\\) \\([5]_6\\) \\([0]_6\\) \\([5]_6\\) \\([4]_6\\) \\([3]_6\\) \\([2]_6\\) \\([1]_6\\) Neutrales Element: \\([1]_6\\) Inverse Element: Nur Zahlen, welche teilerfremd sind (ggT(Zahl, N)=1) Eine Zahl multipliziert mit ihrem inveren Element muss 1 geben Beispiel: \\([5]_6\\cdot[5]_6=[1]_6\\) Beispiel 2: \\([7^{49}]_{10}=(7^2)^{24}\\cdot 7 \\equiv_{10} 49^{24}\\cdot7\\equiv_{10}(-1)^{24}\\cdot 7 \\equiv_{10}\\cdot 7=[7]_{10}\\)","title":"Multiplikation"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#beispiel-fur-modulare-arithmetik","text":"\\[ 3\\cdot x \\equiv_7 4 \\\\ [3]\\cdot[3^{-1}]\\cdot x \\equiv_7 4\\\\ -2\\cdot 3 \\cdot x \\equiv_7 (-2)\\cdot 4\\\\ x \\equiv_7 -8\\equiv_7 6 \\]","title":"Beispiel f\u00fcr Modulare Arithmetik"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#prime-restklassen","text":"Prime Restklassen sind die Restklassen, welche ein Inverseselement f\u00fcr die Multiplikation besitzen. Dies wird mit einem Stern geschrieben, wie hier zu sehen: \\(\\Z_{/7}^{*}\\) . Beispiel: \\(\\Z^*_{/7}=\\{[1], [2], [3], [4], [5], [6]\\}\\) \\(\\Z^*_{/6}=\\{[1], [5]\\}\\)","title":"Prime Restklassen"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#eulersche-varphi-funktion","text":"Um die M\u00e4chtigkeit einer Prime Restklasse zu bestimmen kann folgenden getan werden: \\(\\varphi(n\\cdot m)=\\varphi(n)\\cdot \\varphi(m)\\) , wobei gillt \\(ggT(n, m)=1\\) \\(\\varphi(p)=p-1\\) , wobei gillt \\(p\\in \\mathbb P\\) \\(\\varphi(p^k)=p^k-p^{k-1}\\) , wobei gillt \\(k\\in \\N_{\\gt0}\\) Beispiel: \\[ |\\Z_{/8}^*|=\\varphi(8)=\\varphi(2^3)=2^3-2^{3-1} = 8 -4 =4\\\\ |\\Z_{/15}^*|=\\varphi(15)=\\varphi(3\\cdot5)=\\varphi(3)\\cdot \\varphi(5)\\\\ |\\Z_{/240}^*|=\\varphi(240)=\\varphi(2^4\\cdot3\\cdot5)=.. \\]","title":"Eulersche \\(\\varphi\\)-Funktion"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#chinesischer-restsatz","text":"Der chinesischer Restsatz hilft ein Gleichungssystem mit mehreren Kongruenzen ( \\(\\equiv_n\\) ) . Es gibt garantiert eine L\u00f6sung, wenn alle Modulos paarweise teilerfremd sind (alle mit allen den ggT von 1 haben). Falls dies nicht der Fall ist, kann es trotzdem noch eine L\u00f6sung geben, dies ist aber nicht garantiert. Hier sind die Schritte f\u00fcr den Algorithmus: \\(M_k\\) berechnen Mit \\(M_k=\\frac{\\sum_k m_k}{m_k}\\) kann \\(M\\) f\u00fcr jede Gleichung berechnet werden. Dabei werden alle Modulos ( \\(\\sum_k m_k\\) ) durch das Module der aktuellen Zeile ( \\(m_k\\) ) gerechnet Das multiplikative Inverse \\(N_k\\) f\u00fcr jedes \\(M_k\\) berechnen. Bei kleinen Zahlen kann hier f\u00fcr gepr\u00f6pelt werden Nun folgt die Formel: \\(x=\\sum^n_{k=1}a_kM_kN_k=a_1M_1N_1+...+a_nM_nN_n\\) Beispiel: Folgendes ist die Gleichung und die daraus resultierende \\(a_k\\) und \\(m_k\\) Werte: $$ x\\equiv_3 2 &\\rightarrow &a_1=2&m_1=3\\ x\\equiv_5 7 &\\rightarrow &a_2=3 &m_2=5\\ x\\equiv_7 2 &\\rightarrow&a_3=2 &m_3=7\\ $$ Nun werden die \\(M_k\\) berechnet $$ M_1=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_1}=m_2\\cdot m_3 = 5\\cdot 7 = 35\\ M_2=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_2}=m_1\\cdot m_3 = 3\\cdot 7 = 21\\ M_3=\\frac{m_1\\cdot m_2 \\cdot m_3}{m_3}=m_1\\cdot m_2 = 3\\cdot 5 = 15\\ $$ Als n\u00e4chstes werden die multiplikative Inverse \\(N_k\\) berechnet Beispiel: $$ x &\\equiv 2 \\mod3\\ x &\\equiv 5 \\mod 7\\ $$ Inverse der Modulen gegenseitig: Dies kann man mit dem erweiterten Euklidischen Algorithmus ausrechnen oder mit ausprobieren finden $$ M_1=7: 7\\cdot N_1\\equiv_3 1 \\rightarrow [N_1]_3=[1]_3\\ M_2=3: 3\\cdot N_2 \\equiv_7 1 \\rightarrow [N_2]_7=[5]_7\\ $$ Kongurenz Zusammenfassen $$ x & \\equiv 2 \\cdot 7 \\cdot 1 + 5 \\cdot 3 \\cdot 5 \\mod (3\\cdot 7)\\ & \\equiv (14 + 75)\\equiv 89 \\equiv 5 \\mod 21 $$ \\[ x\\equiv2 \\mod3 & a_1=2 &m_1=3\\\\ x\\equiv3 \\mod 5 & a_2=3 &m_2=5\\\\ x\\equiv2 \\mod 7& a_3=2 &m_3=7\\\\ \\] \\(M_n\\) bestimmen: $$ M_1=\\frac m {m_1} $$ \\(N_k\\) bestimmen Multiplikative Inverse von \\([N_k]_{mk}=[M_k^{-1}]_{mk}\\) $$ N_1: [N_1]_3=[35^{-1}]_3=[2^{-1}]_3=[2]_3 &N_1=2\\ N_2: [N_2]_5=[21^{-1}]_5=[1^{-1}]_5=[1]_5 &N_2=1\\ N_3: [N_3]_7=[15^{-1}]_7=[1^{-1}]_7=[1]_7 &N_3=1\\ $$ Kongruenz $$ x\\equiv 2\\cdot35\\cdot2+ 3\\cdot 21 \\cdot1 + 2\\cdot 15 \\cdot 1 \\mod 105\\ \\equiv 233 \\mod105 \\equiv 23 \\mod 105\\ \\mathbb L=[23]_105 $$","title":"Chinesischer Restsatz"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#satz-von-euler","text":"\\[ a^e ... \\mod n\\\\ 3^{160}\\equiv_{10}(3^2)^{80}\\equiv_{10}9^{80}\\equiv{10}(-1)^{80}\\equiv_{10}1 \\] Der Satz von Euler besagt: \\(ggT(a, m)=1\\Rightarrow a^{\\varphi(m)}\\equiv1 \\mod m\\)","title":"Satz von Euler"},{"location":"21HS/DM/05_Ganz%20Zahlen.html#kleiner-satz-von-fermat","text":"F\u00fcr \\((p \\in \\R \\wedge a \\in \\Z)\\wedge p \\not{|} a\\) gillt \\(a^{p-1}\\equiv 1 \\mod p\\) Beispiel: \\[ 26^{123}\\mod 7 & ggT(26, 7)=1\\\\ 26^{7-1}\\equiv_7 26^6\\equiv_7 1\\\\ 26^{123}\\equiv_7 (26^6)^{20}\\cdot 26^3\\equiv_7 1^20\\cdot 26^3\\equiv_7 5^3\\equiv_7(-2^3) \\equiv_7 -8 \\equiv_76 \\]","title":"Kleiner Satz von Fermat"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html","text":"Summary - 2021-11-23 Summary - 2021-11-23 Aussagenlogik Gesetze Beweistechniken Semantik Mengen Relationen Aussagenlogik Begriff Erkl\u00e4rung \\(\\top\\) (Tautologie) immer wahr \\(\\bot\\) (Wiederspruch) immer falsch \\(\\vee\\) oder \\(\\wedge\\) und Bindung: \\(\\neg, \\wedge, \\vee, \\Rightarrow, \\Leftrightarrow\\) Gesetze Distributivgesetzt: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) Der Morgen: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition: \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\) Beweistechniken Direkten Beweis So veralgemeinern, dass der einte der Term gleich dem anderen Term ist Beweis durch Widerspruch Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. Beweis durch (Gegen-) Beispiel Wenn beweissen werden soll, dass etwas immer korrekt oder immer falsch ist, kann mit ein korrekten, bzw. falschem Beispiel gezeigt werden, dass die Aussage falsch ist Beweis durch Kontraposition Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz Da eine \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B \\wedge B \\Rightarrow A)\\) ist, kann einfach das zweitere bewiessen werden. Semantik Begriff Erkl\u00e4rung G\u00fclltig oder Wahr Bei einer spezifischen Belegung wahr Allgemeing\u00fclltig Bei allen Belegungen wahr Erf\u00fcllbar mind. eine Belegung ist erf\u00fcllbar Unerf\u00fcllbar immer falsch Wiederlegbar mind. einmal falsch; nicht umbedingt immer falsch Literale \\(\\neg a \\text{ oder } a\\) Negotions Normalform (NNF) Keine Implikationen und alle \\(\\neg\\) in Literale Disjunktive Normalform (DNF) Form: \\((L_1 \\wedge L_2 \\wedge ...)\\vee (L_3 \\wedge L_4) \\vee ...\\) Konjuktive Normalform (KNF) Form: \\(L_1 \\vee L_2 \\vee ...) \\wedge (L_3 \\vee L_4)\\wedge ...\\) Funktional Vollst\u00e4ndig Menge von Logischen Verkn\u00fcpfungen, welche die Funktionen \\(\\vee, \\wedge, \\neg, \\rightarrow\\) darstellen k\u00f6nnen Mengen Begriff Erkl\u00e4rung Nat\u00fcrliche Zahlen ( \\(\\N\\) ) \\([0; \\infty]\\) Ganze Zahlen ( \\(\\Z\\) ) \\([-\\infty;\\infty]\\) Rationale Zahlen ( \\(\\mathbb Q\\) ) Alle Zahlen, darstellbar durch einen Bruch Reele Zahlen ( \\(\\R\\) ) Alle Zahlen mit einem Komma ( \\(\\pi\\) , \\(e\\) , 2.32, 2, ...) Intervallschreibweisse Ist immer im Zahlenbereich \\(\\R\\) Teilmenge ( \\(X \\subseteq Y\\) ) \\(\\forall x (x \\in X \\Rightarrow x \\in Y)\\) / X ist eine Teilmenge von Y, X=Y kann auch sein Echte Teilmenge ( \\(X \\subsetneq Y\\) ) \\(X \\subseteq Y \\wedge X \\neq Y\\) / X ist eine Teilmenge von Y, X kann nicht Y sein Potenzmenge ( \\(\\mathcal P(X)\\) ) Menge aller Teilmenge ( \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\} \\}\\) . Die M\u00e4chtigkeit ist $\\mathcal P(A)=2^{ \\vert A \\vert} $ Partition Eine Menge von Teilmengen von A, welche nicht leer sind ( \\(\\bigcup_{i\\in I}P_i=A\\) ) Kardinalit\u00e4t/M\u00e4chtigkeit Anzahl Elemente in Menge Schnittmenge ( \\(X \\cap Y\\) ) Alle Elemente, welch ein beiden enthalten sind Vereinigung ( \\(X \\cup Y\\) ) Alle Elemente von beiden Mengen Komplement ( \\(X\\setminus Y)\\) Alle Elemente aus X, welche nicht in Y vorkommen ( \\(X \\cap \\bar Y\\) ) (nicht paarweise) Disjunkte Mengen Zwei Mengen teilen keine Elemente paarwweise Disjunkte Mengen Alle Mengen teilen keine Elemente Abz\u00e4hlbare Menge Wenn eine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert \u00dcberabz\u00e4hlbare Menge Wenn es keine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert Relationen Begriff Erkl\u00e4rung Injektiv (linkseindeutig) Wenn zu jedem y h\u00f6chsten ein x gibt Surjektiv (rechtstotal) Wenn es zu jedem y mindestens ein x gibt Bijektive Funktion Eine Funktion, welche injektiv und surjktiv ist ( Homogene Relation \\(A=B, R\\subseteq A\\times A\\) \u00c4quivalenzrelationen Eine reflexive, symmetrische und transitive Relation, in welcher alle Elemente zu einander eine Beziehung haben $x\\equiv_5y $ \\((x - y) \\text{ ist ein vielfaches von 5}\\)","title":"Summary - 2021-11-23"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#summary-2021-11-23","text":"Summary - 2021-11-23 Aussagenlogik Gesetze Beweistechniken Semantik Mengen Relationen","title":"Summary - 2021-11-23"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#aussagenlogik","text":"Begriff Erkl\u00e4rung \\(\\top\\) (Tautologie) immer wahr \\(\\bot\\) (Wiederspruch) immer falsch \\(\\vee\\) oder \\(\\wedge\\) und Bindung: \\(\\neg, \\wedge, \\vee, \\Rightarrow, \\Leftrightarrow\\)","title":"Aussagenlogik"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#gesetze","text":"Distributivgesetzt: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) Der Morgen: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition: \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\)","title":"Gesetze"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#beweistechniken","text":"Direkten Beweis So veralgemeinern, dass der einte der Term gleich dem anderen Term ist Beweis durch Widerspruch Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. Beweis durch (Gegen-) Beispiel Wenn beweissen werden soll, dass etwas immer korrekt oder immer falsch ist, kann mit ein korrekten, bzw. falschem Beispiel gezeigt werden, dass die Aussage falsch ist Beweis durch Kontraposition Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz Da eine \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B \\wedge B \\Rightarrow A)\\) ist, kann einfach das zweitere bewiessen werden.","title":"Beweistechniken"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#semantik","text":"Begriff Erkl\u00e4rung G\u00fclltig oder Wahr Bei einer spezifischen Belegung wahr Allgemeing\u00fclltig Bei allen Belegungen wahr Erf\u00fcllbar mind. eine Belegung ist erf\u00fcllbar Unerf\u00fcllbar immer falsch Wiederlegbar mind. einmal falsch; nicht umbedingt immer falsch Literale \\(\\neg a \\text{ oder } a\\) Negotions Normalform (NNF) Keine Implikationen und alle \\(\\neg\\) in Literale Disjunktive Normalform (DNF) Form: \\((L_1 \\wedge L_2 \\wedge ...)\\vee (L_3 \\wedge L_4) \\vee ...\\) Konjuktive Normalform (KNF) Form: \\(L_1 \\vee L_2 \\vee ...) \\wedge (L_3 \\vee L_4)\\wedge ...\\) Funktional Vollst\u00e4ndig Menge von Logischen Verkn\u00fcpfungen, welche die Funktionen \\(\\vee, \\wedge, \\neg, \\rightarrow\\) darstellen k\u00f6nnen","title":"Semantik"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#mengen","text":"Begriff Erkl\u00e4rung Nat\u00fcrliche Zahlen ( \\(\\N\\) ) \\([0; \\infty]\\) Ganze Zahlen ( \\(\\Z\\) ) \\([-\\infty;\\infty]\\) Rationale Zahlen ( \\(\\mathbb Q\\) ) Alle Zahlen, darstellbar durch einen Bruch Reele Zahlen ( \\(\\R\\) ) Alle Zahlen mit einem Komma ( \\(\\pi\\) , \\(e\\) , 2.32, 2, ...) Intervallschreibweisse Ist immer im Zahlenbereich \\(\\R\\) Teilmenge ( \\(X \\subseteq Y\\) ) \\(\\forall x (x \\in X \\Rightarrow x \\in Y)\\) / X ist eine Teilmenge von Y, X=Y kann auch sein Echte Teilmenge ( \\(X \\subsetneq Y\\) ) \\(X \\subseteq Y \\wedge X \\neq Y\\) / X ist eine Teilmenge von Y, X kann nicht Y sein Potenzmenge ( \\(\\mathcal P(X)\\) ) Menge aller Teilmenge ( \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\} \\}\\) . Die M\u00e4chtigkeit ist $\\mathcal P(A)=2^{ \\vert A \\vert} $ Partition Eine Menge von Teilmengen von A, welche nicht leer sind ( \\(\\bigcup_{i\\in I}P_i=A\\) ) Kardinalit\u00e4t/M\u00e4chtigkeit Anzahl Elemente in Menge Schnittmenge ( \\(X \\cap Y\\) ) Alle Elemente, welch ein beiden enthalten sind Vereinigung ( \\(X \\cup Y\\) ) Alle Elemente von beiden Mengen Komplement ( \\(X\\setminus Y)\\) Alle Elemente aus X, welche nicht in Y vorkommen ( \\(X \\cap \\bar Y\\) ) (nicht paarweise) Disjunkte Mengen Zwei Mengen teilen keine Elemente paarwweise Disjunkte Mengen Alle Mengen teilen keine Elemente Abz\u00e4hlbare Menge Wenn eine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert \u00dcberabz\u00e4hlbare Menge Wenn es keine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert","title":"Mengen"},{"location":"21HS/DM/Summaries/01_summary_2021-11-23.html#relationen","text":"Begriff Erkl\u00e4rung Injektiv (linkseindeutig) Wenn zu jedem y h\u00f6chsten ein x gibt Surjektiv (rechtstotal) Wenn es zu jedem y mindestens ein x gibt Bijektive Funktion Eine Funktion, welche injektiv und surjktiv ist ( Homogene Relation \\(A=B, R\\subseteq A\\times A\\) \u00c4quivalenzrelationen Eine reflexive, symmetrische und transitive Relation, in welcher alle Elemente zu einander eine Beziehung haben $x\\equiv_5y $ \\((x - y) \\text{ ist ein vielfaches von 5}\\)","title":"Relationen"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html","text":"tags: - summary - DM title: DM Summary Summary - 2022-01-17 Summary - 2022-01-17 Aussagenlogik Gesetze Beweistechniken Semantik Mengen Relationen Hase Diagram Volst\u00e4ndige Induktion Kleinster Verbrecher Teilbarkeit Rechnenregeln ggT (Erweiterten) Euklischer Algorithmus Modulare Arithmethik Eulerische \\(\\varphi\\)-Funktion Chinesischer Restsatz Kleiner Satz von Fermat Aussagenlogik Begriff Erkl\u00e4rung \\(\\top\\) (Tautologie) immer wahr \\(\\bot\\) (Wiederspruch) immer falsch \\(\\vee\\) oder \\(\\wedge\\) und Bindung: \\(\\neg, \\wedge, \\vee, \\Rightarrow, \\Leftrightarrow\\) Gesetze Distributivgesetzt: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) Der Morgen: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition: \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\) Formel Erkl\u00e4rung \\(A(x):=\\text{\"x ist einfach\"}\\) Aussage \\(\\neg\\exists x\\in P A(x)\\) oder \\(\\forall x \\in P(\\neg A(x))\\) Keine Pr\u00fcfung ist einfach \\(\\exists x \\in P A(x) \\wedge (\\forall y,z\\in P(A(x)\\wedge A(y)\\Rightarrow x=y))\\) Genau eine Pr\u00fcfung ist einfach \\(\\exists x \\in P A(x) \\wedge (\\forall a, b, c \\in P (a\\neq b \\neq c \\Rightarrow \\neg(A(a) \\wedge A(b) \\wedge A(c)))\\) Genau zwei Pr\u00fcfungen sind einfach \\(\\exists a,b \\in P(a\\neq b \\wedge A(a) )\\) Beweistechniken Direkten Beweis So veralgemeinern, dass der einte der Term gleich dem anderen Term ist Beweis durch Widerspruch Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. Also Anstatt \\(\\forall n (A(n) \\Rightarrow B(n)): true\\) soll man beweissen \\(\\neg (\\forall n(A(n)\\Rightarrow B(n))):false\\) ist Beweis durch (Gegen-) Beispiel Wenn beweissen werden soll, dass etwas immer korrekt oder immer falsch ist, kann mit ein korrekten, bzw. falschem Beispiel gezeigt werden, dass die Aussage falsch ist Beweis durch Kontraposition Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz Da eine \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B \\wedge B \\Rightarrow A)\\) ist, kann einfach das zweitere bewiessen werden. Semantik Begriff Erkl\u00e4rung G\u00fclltig oder Wahr Bei einer spezifischen Belegung wahr Allgemeing\u00fclltig Bei allen Belegungen wahr Erf\u00fcllbar mind. eine Belegung ist erf\u00fcllbar Unerf\u00fcllbar immer falsch Wiederlegbar mind. einmal falsch; nicht umbedingt immer falsch Literale \\(\\neg a \\text{ oder } a\\) Negotions Normalform (NNF) Keine Implikationen und alle \\(\\neg\\) in Literale Disjunktive Normalform (DNF) Form: \\((L_1 \\wedge L_2 \\wedge ...)\\vee (L_3 \\wedge L_4) \\vee ...\\) Konjuktive Normalform (KNF) Form: \\(L_1 \\vee L_2 \\vee ...) \\wedge (L_3 \\vee L_4)\\wedge ...\\) Funktional Vollst\u00e4ndig Menge von Logischen Verkn\u00fcpfungen, welche die Funktionen \\(\\vee, \\wedge, \\neg, \\rightarrow\\) darstellen k\u00f6nnen Mengen Begriff Erkl\u00e4rung Nat\u00fcrliche Zahlen ( \\(\\N\\) ) \\([0; \\infty]\\) Ganze Zahlen ( \\(\\Z\\) ) \\([-\\infty;\\infty]\\) Rationale Zahlen ( \\(\\mathbb Q\\) ) Alle Zahlen, darstellbar durch einen Bruch Reele Zahlen ( \\(\\R\\) ) Alle Zahlen mit einem Komma ( \\(\\pi\\) , \\(e\\) , 2.32, 2, ...) Intervallschreibweisse Ist immer im Zahlenbereich \\(\\R\\) Teilmenge ( \\(X \\subseteq Y\\) ) \\(\\forall x (x \\in X \\Rightarrow x \\in Y)\\) / X ist eine Teilmenge von Y, X=Y kann auch sein Echte Teilmenge ( \\(X \\subsetneq Y\\) ) \\(X \\subseteq Y \\wedge X \\neq Y\\) / X ist eine Teilmenge von Y, X kann nicht Y sein Potenzmenge ( \\(\\mathcal P(X)\\) ) Menge aller Teilmenge ( \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\} \\}\\) . Die M\u00e4chtigkeit ist \\(\\mathcal \\vert P(A)\\vert=2^{ \\vert A \\vert}\\) ; \\(\\mathcal P(A)=\\{x\\mid x \\subseteq A\\}\\) Partition Eine Menge von Teilmengen von A, welche nicht leer sind ( \\(\\bigcup_{i\\in I}P_i=A\\) ) (nicht leer, paarweise disjunkt, Vereinigung gibt Ursprungsmenge) Kardinalit\u00e4t/M\u00e4chtigkeit Anzahl Elemente in Menge Schnittmenge ( \\(X \\cap Y\\) ) Alle Elemente, welche in beiden enthalten sind ( \\(X\\cup U=\\{x\\mid x \\in X \\wedge x \\in Y\\}\\) ) Distributivgesetz: \\(A\\cap(B\\cup C)=(A\\cap B)\\cup (A\\cap C)\\) DeMorgan: \\((C\\setminus A)\\cap(C\\setminus B)=C\\setminus(A\\cup B)\\) Vereinigung ( \\(X \\cup Y\\) ) Alle Elemente von beiden Mengen ( \\(X\\cup U=\\{x\\mid x \\in X \\vee x \\in Y\\}\\) ) Komplement ( \\(X\\setminus Y)\\) Alle Elemente aus X, welche nicht in Y vorkommen ( \\(X \\cap \\bar Y\\) ) (nicht paarweise) Disjunkte Mengen Zwei Mengen teilen keine Elemente paarwweise Disjunkte Mengen Alle Mengen teilen keine Elemente Abz\u00e4hlbare Menge Wenn eine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert: Abz\u00e4hlbar: \\(\\N\\times\\N\\) , \\(\\Z\\times\\Z\\) , \u00dcberabz\u00e4hlbare Menge Wenn es keine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert \u00dcberabz\u00e4hlbar: \\(\\mathcal P(\\N)\\) , \\([0;1]\\) ; Die Menge aller unendlichen Bin\u00e4rsequenzen (2. Diagonalargument) Relationen Begriff Erkl\u00e4rung Injektiv (linkseindeutig) Wenn zu jedem y h\u00f6chsten ein x gibt Surjektiv (rechtstotal) Wenn es zu jedem y mindestens ein x gibt Funktion (Relation) Eine Relation, bei welchem ein x Element nicht zwei y Werte gibt. Von einem Element d\u00fcrfen also nur maximal ein Pfeil wegzeigen. Bijektive Funktion Eine Funktion, welche injektiv und surjktiv ist Homogene Relation \\(A=B, R\\subseteq A\\times A\\) Wohldefiniertheit Eine Funktion, welche eine \u00c4quivalenzrelation als Argument nimmt, ist wohldefiniert, wenn \\(xRy \\Rightarrow F(x)=F(y)\\) bedeutet. \u00c4quivalenzrelationen Eine reflexive, symmetrische und transitive Relation, in welcher alle Elemente zu einander eine Beziehung haben Restklasse Eine Menge von Elementen in einer \u00c4quivalenzrelation, welche miteinander verbunden \\(x\\equiv_5y\\) \\((x - y) \\text{ ist ein vielfaches von 5}\\) transitiver Abschluss ( \\(R^+\\) ) Eine Relation \\(R^+\\) , enh\u00e4lt zus\u00e4tzlich zu R, alle Relation, damit R transitiv wird reflexiv-transitiven Abschluss ( \\(R^*\\) ) Eine Relation \\(R^*\\) , enh\u00e4lt zus\u00e4tzlich zu \\(R^+\\) , alle Relationen, damit \\(R^+\\) reflexiv wird. DAG Ein gerichteten zyklenfreien Graphen ist ein Graph, welcher keine zyklen enh\u00e4lt Dipartir Graph Ein Graph, welcher nicht auf einer Homogenen Relation funktioniert Ordnungsrelation Ordnung, welche sicherlich reflexiv, transitiv R-unvergleichbar Zwei elemente, wenn weder \\(xRy\\) und \\(yRx\\) gillt R-minimal Ein Element, wenn kein Pfeil auf das Element zeigen R-maximal Ein Element, wenn es keine Pfeile weg vom Element zeigen Pr\u00e4ordnung reflexiv und transitiv Halbordnung Eine Pr\u00e4ordnung (reflexiv und transitiv), welche auch noch antisymmetrisch ist (zyklenfrei) totale/lineare Ordnung Eine Halbordnung (reflexiv, transitiv und antisymmetrisch) ohne R-unvergleichbaren Elemente (zyklenfrei) Wohlordnung Eine totale Ordnung, bei welcher alle nicht leeren Teilmenge mindestens ein R-minimales Element (Element, auf welches keine Pfeile zeigen) enhalte (zyklenfrei) topologische Sortierung Einen Pfad von Elemente, welche alle miteinander verbunden sind. Matematisch ist dies eine Ordnung: \\((\\preceq) \\subseteq (M\\times M\\) ). \\(a\\preceq b\\) sagt aus, dass a der Vorg\u00e4nger von b ist Hase Diagram Funktioniert nur auf Halbordnungen, welche DAGs sind (also zyklen frei). F\u00fcr gr\u00f6ssere Diagramme kann man alle Elemente mit ihren Nachfolgern aufschreiben und danach alle Nachfolger streichen, welche ein Nachfolger eines Nachfolgers sind. Es lohnt sich zudemmit dem R-maximalen Element zu starten. Volst\u00e4ndige Induktion IV - Induktions Verankerung: \\(A(0)\\) , \\(A(1)\\) , oder anderen Startwert IA - Induktions Annahme: \\(A(n)\\) IB - Induktions Behauptung: \\(A(n+1)\\) IS - Induktions Schluss: \\(A(n)\\Rightarrow A(n+1)\\) Kleinster Verbrecher Es gibt eine Aussage \\(A(n), n\\in \\N\\) , welche wahr sein soll. Behauptung: Es gibt ein \"kleinsten Verbrecher\" aka. die kleinste Zahl, welche die eigentlich Behaupt verletzt. ( \\(A(n_0):f\\) ) Man versucht nun mit der kleinsten Zahl aus \\(\\N\\) , \\(0\\) : \\(A(0): t\\) \\(\\Rightarrow\\) Daher muss gelten \\(n>0 \\Rightarrow k+1=n\\) (wobei \\(k\\in \\N\\) ) Nun kann \\(k+1\\) als \\(n\\) in \\(A(n)\\) eingesetzt werden ( \\(A(k+1)\\) ). Falls dies ein Wiederspruch ergibt, ist die Aussage \\(A(n)\\) wahr, da es keinen kleinsten Verbrecher gibt Teilbarkeit Begriff Erkl\u00e4rung \\(x\\mid y\\) X teilt y (achtung Reihenfolge) \\(T(x)\\) Menge aller Teile von \\(x\\) ( \\(T(15)=\\{1, 3, 5, 15\\}\\) ) \\(\\pi(n)\\) Wie viel Primzahlen kleiner als n sind Prime Restklassen ( \\(\\Z^*_{/7}\\) ) Eine Menge von Elementen mit einem multiplikativen inversem Element Faktormenge ( \\(X_{/R}\\) ) Die Menge aller \u00c4quivalenzklassen von \\(X\\) modulo \\(R\\) \\(X_{/R}=\\{[x]_R\\mid x \\in X\\}\\) Peano-Axiomen Die Zahl 0 ist eine nat\u00fcrliche Zahl. Jede nat\u00fcrliche Zahl \\(k\\) hat gtenau einen Nachfolger \\(k+1\\) , welcher auch eine nat\u00fcrliche Zahl ist. Die Zahl \\(0\\) ist die einzige Zahl, welc Rechnenregeln ggT \\(n\\cdot m=kgv(n, m)\\cdot ggT(n, m) \\Rightarrow kgV(n, m)=\\frac{n \\cdot m}{ggT(n, m)}\\) \\(ggT(n, n)=n\\) \\(ggT(n, 1)=1\\) \\(ggT(n, 0)=n\\) \\(ggT(n, m)=ggT(n, m-n)\\) \\(ggT(n, m)=ggT(n, m-k\\cdot n)\\) , wenn \\(k\\cdot n \\le m\\) \\(ggT(n, m)=a\\cdot n + b \\cdot m\\) , wenn \\(x\\neq y\\) und \\(a,b \\in \\N\\) Um das \\(kgV(x, y)\\) zu bestimmen, wird eine Primfaktorzerlegung von \\(x\\) und \\(y\\) durchgef\u00fchrt. Danach werden die h\u00f6chsten Potenzen zusammen gerechnet. F\u00fcr den \\(ggT\\) werden die tiefsten Potenzen verwendet. (Erweiterten) Euklischer Algorithmus \\[ x_0=1\\\\ x_1=0\\\\ x_k=x_{k-2}-q_k\\cdot x_{k-1}\\\\ \\space \\\\ y_0=0\\\\ y_1=1\\\\ y_k=y_{k-2}-q_k\\cdot y_{k-1} \\] Modulare Arithmethik f\u00fcr Multiplikation: neutrales Element: \\([1]_n\\) inverses Element: Nur Zahlen, welche teilefrmed sind ( \\(ggT(Zahl, N)=1\\) ) Eine Zahl multipliziert mt ihrem inversen Element gibt \\(1\\) Kann mit dem Erweiterten Euklidischen Algorithmus berechnet werden: \\(Zahlenbereich \\cdot x + Zahl \\cdot y=1\\) \\(\\Rightarrow y\\) ist das multiplikative Inverse. (Zahl muss kleiner sein als Zahlenbereich, sonst muss gewechselt werden) Eulerische \\(\\varphi\\) -Funktion Findet die M\u00f6chtigkeit einer Prime Restklassen heraus: \\(\\varphi(n\\cdot m)=\\varphi(n)\\cdot \\varphi(m)\\) , wobei gillt \\(ggT(n, m)=1\\) \\(\\varphi(p)=p-1\\) , wobei gillt \\(p\\in \\mathbb P\\) \\(\\varphi(p^k)=p^k-p^{k-1}\\) , wobei gillt \\(k\\in \\N_{\\gt0}\\) Beispiel: \\[ |\\Z_{/8}^*|=\\varphi(8)=\\varphi(2^3)=2^3-2^{3-1} = 8 -4 =4\\\\ |\\Z_{/15}^*|=\\varphi(15)=\\varphi(3\\cdot5)=\\varphi(3)\\cdot \\varphi(5)\\\\ |\\Z_{/240}^*|=\\varphi(240)=\\varphi(2^4\\cdot3\\cdot5)=.. \\] Chinesischer Restsatz Es gibt garantiert eine L\u00f6sung, wenn alle Modulos paarweise teilerfremd sind (alle mit allen den \\(ggT\\) von \\(1\\) haben) Beispiel, um zu sehen, wie \\(a_1\\) und \\(m_1\\) zustande kommen: \\( \\(\\begin{aligned} x\\equiv_3 2 & \\rightarrow &a_1=2 &m_1=3\\\\ x\\equiv_5 7 & \\rightarrow &a_2=3 &m_2=5\\\\ x\\equiv_7 2 & \\rightarrow &a_3=2 &m_3=7 \\end{aligned}\\) \\) \\(M_k\\) berechnen: \\(M_k=\\frac{\\prod m_i}{m_k}\\) Das multiplaktive Inverse \\(N_k\\) f\u00fcr jedes \\(M_k\\) berechnen mit dem Module der Linie k Das Ergebnis mit \\(x=\\sum^n_{k=1}a_kM_kN_k\\) berechnen \\(x\\) ist im Modulo \\(\\prod_{i=1}m_i\\) (das Produkt von allen Modulos) Kleiner Satz von Fermat F\u00fcr \\((p \\in \\R \\wedge a \\in \\Z)\\wedge p \\not{|} a\\) gillt \\(a^{p-1}\\equiv 1 \\mod p\\) Beispiel: \\[ \\begin{aligned} \\begin{gathered} 26^{123}\\mod 7 & ggT(26, 7)=1\\\\ 26^{7-1}\\equiv_7 26^6\\equiv_7 1\\\\ 26^{123}\\equiv_7 (26^6)^{20}\\cdot 26^3\\equiv_7 1^20\\cdot 26^3\\equiv_7 5^3\\equiv_7(-2^3) \\equiv_7 -8 \\equiv_76 \\end{gathered} \\end{aligned} \\]","title":"01 summary 2022 01 17"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#summary-2022-01-17","text":"Summary - 2022-01-17 Aussagenlogik Gesetze Beweistechniken Semantik Mengen Relationen Hase Diagram Volst\u00e4ndige Induktion Kleinster Verbrecher Teilbarkeit Rechnenregeln ggT (Erweiterten) Euklischer Algorithmus Modulare Arithmethik Eulerische \\(\\varphi\\)-Funktion Chinesischer Restsatz Kleiner Satz von Fermat","title":"Summary - 2022-01-17"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#aussagenlogik","text":"Begriff Erkl\u00e4rung \\(\\top\\) (Tautologie) immer wahr \\(\\bot\\) (Wiederspruch) immer falsch \\(\\vee\\) oder \\(\\wedge\\) und Bindung: \\(\\neg, \\wedge, \\vee, \\Rightarrow, \\Leftrightarrow\\)","title":"Aussagenlogik"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#gesetze","text":"Distributivgesetzt: \\(A \\wedge (B \\vee C) \\Leftrightarrow (A \\wedge B) \\vee (A \\wedge C)\\) Der Morgen: \\(\\neg(A\\vee B) \\Leftrightarrow \\neg A \\wedge \\neg B\\) Implikation: \\(A \\Rightarrow B \\Leftrightarrow \\neg A \\vee B\\) Kontraposition: \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B) \\wedge (B \\Rightarrow A) \\Leftrightarrow (\\neg A \\vee B) \\wedge (\\neg B \\vee A)\\) Formel Erkl\u00e4rung \\(A(x):=\\text{\"x ist einfach\"}\\) Aussage \\(\\neg\\exists x\\in P A(x)\\) oder \\(\\forall x \\in P(\\neg A(x))\\) Keine Pr\u00fcfung ist einfach \\(\\exists x \\in P A(x) \\wedge (\\forall y,z\\in P(A(x)\\wedge A(y)\\Rightarrow x=y))\\) Genau eine Pr\u00fcfung ist einfach \\(\\exists x \\in P A(x) \\wedge (\\forall a, b, c \\in P (a\\neq b \\neq c \\Rightarrow \\neg(A(a) \\wedge A(b) \\wedge A(c)))\\) Genau zwei Pr\u00fcfungen sind einfach \\(\\exists a,b \\in P(a\\neq b \\wedge A(a) )\\)","title":"Gesetze"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#beweistechniken","text":"Direkten Beweis So veralgemeinern, dass der einte der Term gleich dem anderen Term ist Beweis durch Widerspruch Anstatt zu zeigen, dass die Aussage A immer wahr ist, wird bewiessen, dass A niemals falsch ist. Also Anstatt \\(\\forall n (A(n) \\Rightarrow B(n)): true\\) soll man beweissen \\(\\neg (\\forall n(A(n)\\Rightarrow B(n))):false\\) ist Beweis durch (Gegen-) Beispiel Wenn beweissen werden soll, dass etwas immer korrekt oder immer falsch ist, kann mit ein korrekten, bzw. falschem Beispiel gezeigt werden, dass die Aussage falsch ist Beweis durch Kontraposition Es gillt die Aussage von der Form \\(A \\Rightarrow B \\Leftrightarrow \\neg B \\Rightarrow \\neg A\\) \u00c4quivalenz Da eine \u00c4quivalenz \\((A \\Leftrightarrow B) \\Leftrightarrow (A \\Rightarrow B \\wedge B \\Rightarrow A)\\) ist, kann einfach das zweitere bewiessen werden.","title":"Beweistechniken"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#semantik","text":"Begriff Erkl\u00e4rung G\u00fclltig oder Wahr Bei einer spezifischen Belegung wahr Allgemeing\u00fclltig Bei allen Belegungen wahr Erf\u00fcllbar mind. eine Belegung ist erf\u00fcllbar Unerf\u00fcllbar immer falsch Wiederlegbar mind. einmal falsch; nicht umbedingt immer falsch Literale \\(\\neg a \\text{ oder } a\\) Negotions Normalform (NNF) Keine Implikationen und alle \\(\\neg\\) in Literale Disjunktive Normalform (DNF) Form: \\((L_1 \\wedge L_2 \\wedge ...)\\vee (L_3 \\wedge L_4) \\vee ...\\) Konjuktive Normalform (KNF) Form: \\(L_1 \\vee L_2 \\vee ...) \\wedge (L_3 \\vee L_4)\\wedge ...\\) Funktional Vollst\u00e4ndig Menge von Logischen Verkn\u00fcpfungen, welche die Funktionen \\(\\vee, \\wedge, \\neg, \\rightarrow\\) darstellen k\u00f6nnen","title":"Semantik"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#mengen","text":"Begriff Erkl\u00e4rung Nat\u00fcrliche Zahlen ( \\(\\N\\) ) \\([0; \\infty]\\) Ganze Zahlen ( \\(\\Z\\) ) \\([-\\infty;\\infty]\\) Rationale Zahlen ( \\(\\mathbb Q\\) ) Alle Zahlen, darstellbar durch einen Bruch Reele Zahlen ( \\(\\R\\) ) Alle Zahlen mit einem Komma ( \\(\\pi\\) , \\(e\\) , 2.32, 2, ...) Intervallschreibweisse Ist immer im Zahlenbereich \\(\\R\\) Teilmenge ( \\(X \\subseteq Y\\) ) \\(\\forall x (x \\in X \\Rightarrow x \\in Y)\\) / X ist eine Teilmenge von Y, X=Y kann auch sein Echte Teilmenge ( \\(X \\subsetneq Y\\) ) \\(X \\subseteq Y \\wedge X \\neq Y\\) / X ist eine Teilmenge von Y, X kann nicht Y sein Potenzmenge ( \\(\\mathcal P(X)\\) ) Menge aller Teilmenge ( \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\} \\}\\) . Die M\u00e4chtigkeit ist \\(\\mathcal \\vert P(A)\\vert=2^{ \\vert A \\vert}\\) ; \\(\\mathcal P(A)=\\{x\\mid x \\subseteq A\\}\\) Partition Eine Menge von Teilmengen von A, welche nicht leer sind ( \\(\\bigcup_{i\\in I}P_i=A\\) ) (nicht leer, paarweise disjunkt, Vereinigung gibt Ursprungsmenge) Kardinalit\u00e4t/M\u00e4chtigkeit Anzahl Elemente in Menge Schnittmenge ( \\(X \\cap Y\\) ) Alle Elemente, welche in beiden enthalten sind ( \\(X\\cup U=\\{x\\mid x \\in X \\wedge x \\in Y\\}\\) ) Distributivgesetz: \\(A\\cap(B\\cup C)=(A\\cap B)\\cup (A\\cap C)\\) DeMorgan: \\((C\\setminus A)\\cap(C\\setminus B)=C\\setminus(A\\cup B)\\) Vereinigung ( \\(X \\cup Y\\) ) Alle Elemente von beiden Mengen ( \\(X\\cup U=\\{x\\mid x \\in X \\vee x \\in Y\\}\\) ) Komplement ( \\(X\\setminus Y)\\) Alle Elemente aus X, welche nicht in Y vorkommen ( \\(X \\cap \\bar Y\\) ) (nicht paarweise) Disjunkte Mengen Zwei Mengen teilen keine Elemente paarwweise Disjunkte Mengen Alle Mengen teilen keine Elemente Abz\u00e4hlbare Menge Wenn eine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert: Abz\u00e4hlbar: \\(\\N\\times\\N\\) , \\(\\Z\\times\\Z\\) , \u00dcberabz\u00e4hlbare Menge Wenn es keine surjektive Funktion \\(F: \\N \\rightarrow X\\) existiert \u00dcberabz\u00e4hlbar: \\(\\mathcal P(\\N)\\) , \\([0;1]\\) ; Die Menge aller unendlichen Bin\u00e4rsequenzen (2. Diagonalargument)","title":"Mengen"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#relationen","text":"Begriff Erkl\u00e4rung Injektiv (linkseindeutig) Wenn zu jedem y h\u00f6chsten ein x gibt Surjektiv (rechtstotal) Wenn es zu jedem y mindestens ein x gibt Funktion (Relation) Eine Relation, bei welchem ein x Element nicht zwei y Werte gibt. Von einem Element d\u00fcrfen also nur maximal ein Pfeil wegzeigen. Bijektive Funktion Eine Funktion, welche injektiv und surjktiv ist Homogene Relation \\(A=B, R\\subseteq A\\times A\\) Wohldefiniertheit Eine Funktion, welche eine \u00c4quivalenzrelation als Argument nimmt, ist wohldefiniert, wenn \\(xRy \\Rightarrow F(x)=F(y)\\) bedeutet. \u00c4quivalenzrelationen Eine reflexive, symmetrische und transitive Relation, in welcher alle Elemente zu einander eine Beziehung haben Restklasse Eine Menge von Elementen in einer \u00c4quivalenzrelation, welche miteinander verbunden \\(x\\equiv_5y\\) \\((x - y) \\text{ ist ein vielfaches von 5}\\) transitiver Abschluss ( \\(R^+\\) ) Eine Relation \\(R^+\\) , enh\u00e4lt zus\u00e4tzlich zu R, alle Relation, damit R transitiv wird reflexiv-transitiven Abschluss ( \\(R^*\\) ) Eine Relation \\(R^*\\) , enh\u00e4lt zus\u00e4tzlich zu \\(R^+\\) , alle Relationen, damit \\(R^+\\) reflexiv wird. DAG Ein gerichteten zyklenfreien Graphen ist ein Graph, welcher keine zyklen enh\u00e4lt Dipartir Graph Ein Graph, welcher nicht auf einer Homogenen Relation funktioniert Ordnungsrelation Ordnung, welche sicherlich reflexiv, transitiv R-unvergleichbar Zwei elemente, wenn weder \\(xRy\\) und \\(yRx\\) gillt R-minimal Ein Element, wenn kein Pfeil auf das Element zeigen R-maximal Ein Element, wenn es keine Pfeile weg vom Element zeigen Pr\u00e4ordnung reflexiv und transitiv Halbordnung Eine Pr\u00e4ordnung (reflexiv und transitiv), welche auch noch antisymmetrisch ist (zyklenfrei) totale/lineare Ordnung Eine Halbordnung (reflexiv, transitiv und antisymmetrisch) ohne R-unvergleichbaren Elemente (zyklenfrei) Wohlordnung Eine totale Ordnung, bei welcher alle nicht leeren Teilmenge mindestens ein R-minimales Element (Element, auf welches keine Pfeile zeigen) enhalte (zyklenfrei) topologische Sortierung Einen Pfad von Elemente, welche alle miteinander verbunden sind. Matematisch ist dies eine Ordnung: \\((\\preceq) \\subseteq (M\\times M\\) ). \\(a\\preceq b\\) sagt aus, dass a der Vorg\u00e4nger von b ist","title":"Relationen"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#hase-diagram","text":"Funktioniert nur auf Halbordnungen, welche DAGs sind (also zyklen frei). F\u00fcr gr\u00f6ssere Diagramme kann man alle Elemente mit ihren Nachfolgern aufschreiben und danach alle Nachfolger streichen, welche ein Nachfolger eines Nachfolgers sind. Es lohnt sich zudemmit dem R-maximalen Element zu starten.","title":"Hase Diagram"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#volstandige-induktion","text":"IV - Induktions Verankerung: \\(A(0)\\) , \\(A(1)\\) , oder anderen Startwert IA - Induktions Annahme: \\(A(n)\\) IB - Induktions Behauptung: \\(A(n+1)\\) IS - Induktions Schluss: \\(A(n)\\Rightarrow A(n+1)\\)","title":"Volst\u00e4ndige Induktion"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#kleinster-verbrecher","text":"Es gibt eine Aussage \\(A(n), n\\in \\N\\) , welche wahr sein soll. Behauptung: Es gibt ein \"kleinsten Verbrecher\" aka. die kleinste Zahl, welche die eigentlich Behaupt verletzt. ( \\(A(n_0):f\\) ) Man versucht nun mit der kleinsten Zahl aus \\(\\N\\) , \\(0\\) : \\(A(0): t\\) \\(\\Rightarrow\\) Daher muss gelten \\(n>0 \\Rightarrow k+1=n\\) (wobei \\(k\\in \\N\\) ) Nun kann \\(k+1\\) als \\(n\\) in \\(A(n)\\) eingesetzt werden ( \\(A(k+1)\\) ). Falls dies ein Wiederspruch ergibt, ist die Aussage \\(A(n)\\) wahr, da es keinen kleinsten Verbrecher gibt","title":"Kleinster Verbrecher"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#teilbarkeit","text":"Begriff Erkl\u00e4rung \\(x\\mid y\\) X teilt y (achtung Reihenfolge) \\(T(x)\\) Menge aller Teile von \\(x\\) ( \\(T(15)=\\{1, 3, 5, 15\\}\\) ) \\(\\pi(n)\\) Wie viel Primzahlen kleiner als n sind Prime Restklassen ( \\(\\Z^*_{/7}\\) ) Eine Menge von Elementen mit einem multiplikativen inversem Element Faktormenge ( \\(X_{/R}\\) ) Die Menge aller \u00c4quivalenzklassen von \\(X\\) modulo \\(R\\) \\(X_{/R}=\\{[x]_R\\mid x \\in X\\}\\) Peano-Axiomen Die Zahl 0 ist eine nat\u00fcrliche Zahl. Jede nat\u00fcrliche Zahl \\(k\\) hat gtenau einen Nachfolger \\(k+1\\) , welcher auch eine nat\u00fcrliche Zahl ist. Die Zahl \\(0\\) ist die einzige Zahl, welc","title":"Teilbarkeit"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#rechnenregeln-ggt","text":"\\(n\\cdot m=kgv(n, m)\\cdot ggT(n, m) \\Rightarrow kgV(n, m)=\\frac{n \\cdot m}{ggT(n, m)}\\) \\(ggT(n, n)=n\\) \\(ggT(n, 1)=1\\) \\(ggT(n, 0)=n\\) \\(ggT(n, m)=ggT(n, m-n)\\) \\(ggT(n, m)=ggT(n, m-k\\cdot n)\\) , wenn \\(k\\cdot n \\le m\\) \\(ggT(n, m)=a\\cdot n + b \\cdot m\\) , wenn \\(x\\neq y\\) und \\(a,b \\in \\N\\) Um das \\(kgV(x, y)\\) zu bestimmen, wird eine Primfaktorzerlegung von \\(x\\) und \\(y\\) durchgef\u00fchrt. Danach werden die h\u00f6chsten Potenzen zusammen gerechnet. F\u00fcr den \\(ggT\\) werden die tiefsten Potenzen verwendet.","title":"Rechnenregeln ggT"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#erweiterten-euklischer-algorithmus","text":"\\[ x_0=1\\\\ x_1=0\\\\ x_k=x_{k-2}-q_k\\cdot x_{k-1}\\\\ \\space \\\\ y_0=0\\\\ y_1=1\\\\ y_k=y_{k-2}-q_k\\cdot y_{k-1} \\]","title":"(Erweiterten) Euklischer Algorithmus"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#modulare-arithmethik","text":"f\u00fcr Multiplikation: neutrales Element: \\([1]_n\\) inverses Element: Nur Zahlen, welche teilefrmed sind ( \\(ggT(Zahl, N)=1\\) ) Eine Zahl multipliziert mt ihrem inversen Element gibt \\(1\\) Kann mit dem Erweiterten Euklidischen Algorithmus berechnet werden: \\(Zahlenbereich \\cdot x + Zahl \\cdot y=1\\) \\(\\Rightarrow y\\) ist das multiplikative Inverse. (Zahl muss kleiner sein als Zahlenbereich, sonst muss gewechselt werden)","title":"Modulare Arithmethik"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#eulerische-varphi-funktion","text":"Findet die M\u00f6chtigkeit einer Prime Restklassen heraus: \\(\\varphi(n\\cdot m)=\\varphi(n)\\cdot \\varphi(m)\\) , wobei gillt \\(ggT(n, m)=1\\) \\(\\varphi(p)=p-1\\) , wobei gillt \\(p\\in \\mathbb P\\) \\(\\varphi(p^k)=p^k-p^{k-1}\\) , wobei gillt \\(k\\in \\N_{\\gt0}\\) Beispiel: \\[ |\\Z_{/8}^*|=\\varphi(8)=\\varphi(2^3)=2^3-2^{3-1} = 8 -4 =4\\\\ |\\Z_{/15}^*|=\\varphi(15)=\\varphi(3\\cdot5)=\\varphi(3)\\cdot \\varphi(5)\\\\ |\\Z_{/240}^*|=\\varphi(240)=\\varphi(2^4\\cdot3\\cdot5)=.. \\]","title":"Eulerische \\(\\varphi\\)-Funktion"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#chinesischer-restsatz","text":"Es gibt garantiert eine L\u00f6sung, wenn alle Modulos paarweise teilerfremd sind (alle mit allen den \\(ggT\\) von \\(1\\) haben) Beispiel, um zu sehen, wie \\(a_1\\) und \\(m_1\\) zustande kommen: \\( \\(\\begin{aligned} x\\equiv_3 2 & \\rightarrow &a_1=2 &m_1=3\\\\ x\\equiv_5 7 & \\rightarrow &a_2=3 &m_2=5\\\\ x\\equiv_7 2 & \\rightarrow &a_3=2 &m_3=7 \\end{aligned}\\) \\) \\(M_k\\) berechnen: \\(M_k=\\frac{\\prod m_i}{m_k}\\) Das multiplaktive Inverse \\(N_k\\) f\u00fcr jedes \\(M_k\\) berechnen mit dem Module der Linie k Das Ergebnis mit \\(x=\\sum^n_{k=1}a_kM_kN_k\\) berechnen \\(x\\) ist im Modulo \\(\\prod_{i=1}m_i\\) (das Produkt von allen Modulos)","title":"Chinesischer Restsatz"},{"location":"21HS/DM/Summaries/01_summary_2022_01_17.html#kleiner-satz-von-fermat","text":"F\u00fcr \\((p \\in \\R \\wedge a \\in \\Z)\\wedge p \\not{|} a\\) gillt \\(a^{p-1}\\equiv 1 \\mod p\\) Beispiel: \\[ \\begin{aligned} \\begin{gathered} 26^{123}\\mod 7 & ggT(26, 7)=1\\\\ 26^{7-1}\\equiv_7 26^6\\equiv_7 1\\\\ 26^{123}\\equiv_7 (26^6)^{20}\\cdot 26^3\\equiv_7 1^20\\cdot 26^3\\equiv_7 5^3\\equiv_7(-2^3) \\equiv_7 -8 \\equiv_76 \\end{gathered} \\end{aligned} \\]","title":"Kleiner Satz von Fermat"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html","text":"Knotenregel Was in ein Kabel an Ladung(I) hinein geht, muss auch wieder raus. Mit der Knotenregel kann man erkl\u00e4ren, wieso in einer Parallelschaltung die Ladung sich aufteilt. Denn was in einen Knoten hinein geht, muss sich aufteilen. Maschensatz Eine Masche ist ein \"Loop\" im Stromkreis. Alle Str\u00f6me (V) zusammen m\u00fcssen 0 ergeben. Mit dem kann man erkl\u00e4ren, wieso in Parallelschaltungen auf beiden Leitungen der Strom gleich bleibt. Bei einer Serienschaltung gibt es nur eine Masche, daher bleibt der Strom nicht gleich bei einer Serienschaltung. Elektronischebauteile Ohm'scher Leiter hat eine Lineare Spannungs-Strom-Charakteristik. Nicht-Ohm'scher Leiter hingegen nicht (z.B. LED's). Wiederst\u00e4nden Das Ohm'sche Gesetzt gillt: \\(U=R \\cdot I\\) Die Leistung : \\(P=U\\cdot I=\\frac {U^2} R = I^2R\\) Kondensatoren Ein Kondensator ist eine Art Feder, durch welche kein Strom fliessen kann. Beim Aufladen werden immer mehr Elektronen hinein gepumpt. Daher wird es immer schwieriger noch mehr Elektronen hinein zu pressen, je voller der Kondensator wird. Ladung kann mit \\(CU_c = Q\\) berechnen. C stellt dabei die Kapazit\u00e4t in Farad [F] and (nicht die Ladung) Ein Kondensator ist kein Ohm'sches Bauteil und folgt demnach nicht dem Ohm'schen gesetzt. Anstatt kann folgende Exponentialfunktion f\u00fcr Q benutzt werden. \\(U_0\\) ist dabei die Spannungsquelle, C die Kapazit\u00e4t in Fahrad und R der Wiederstand, durch welcher der Strom fliessen muss: f\u00fcr zum Laden: \\(Q(t) = U_0\\cdot C (1 - e^{\\frac{-t}{R\\cdot C}})\\) f\u00fcr zum Entladen: \\(Q(t) = U_0\\cdot C (e^{\\frac{-t}{R\\cdot C}})\\) Um U (Strom) des Kondensators zu berechnen, einfach das \\(\\cdot C\\) aus der Gleichung entfernen, da \\(C\\cdot U_c=Q \\rightarrow U_c=\\frac Q C\\) bedeutet Schwinungen //TODO Spule Wenn durch eine Spule Strom (V) fliesst, dann erzeugt dies ein Magnetfeld. Beim Hochfahren des Stromes (V) wird Energie ben\u00f6tig, um das Magnetfeld zu erzeugen. Wenn der Strom (V) zur\u00fcckgefahren wird, wird die Energie wieder freigegeben. Es gilt: \\(U=L\\frac {dI}{dt}\\) L ist die Induktivit\u00e4t in Henry [H] I Formel Lange Kabel/Dr\u00e4hte Der Wiederstand eines Drahtes kann mit der Formel \\(R=\\rho \\frac L A\\) . Grunds\u00e4tzlich gillt je L\u00e4nger und je d\u00fcnner ein Draht ist, desto h\u00f6her ist der Wiederstand. Nat\u00fcrlich h\u00e4ngt es auch noch von \\(\\rho\\) ( \\(mm^2m^{-1}...\\) ), dem Spezifischer Wierstand, ab. Spannungsb\u00e4nder Da man im Computer nicht genau 0V oder 5V, definiert man Spannungsb\u00e4nder, in welcher eine Schaltung einen Input oder Output als 1 oder 0 erkennt. ![](/res/2021-10-27-08-57-35-image.png","title":"Knotenregel"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#knotenregel","text":"Was in ein Kabel an Ladung(I) hinein geht, muss auch wieder raus. Mit der Knotenregel kann man erkl\u00e4ren, wieso in einer Parallelschaltung die Ladung sich aufteilt. Denn was in einen Knoten hinein geht, muss sich aufteilen.","title":"Knotenregel"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#maschensatz","text":"Eine Masche ist ein \"Loop\" im Stromkreis. Alle Str\u00f6me (V) zusammen m\u00fcssen 0 ergeben. Mit dem kann man erkl\u00e4ren, wieso in Parallelschaltungen auf beiden Leitungen der Strom gleich bleibt. Bei einer Serienschaltung gibt es nur eine Masche, daher bleibt der Strom nicht gleich bei einer Serienschaltung.","title":"Maschensatz"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#elektronischebauteile","text":"Ohm'scher Leiter hat eine Lineare Spannungs-Strom-Charakteristik. Nicht-Ohm'scher Leiter hingegen nicht (z.B. LED's).","title":"Elektronischebauteile"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#wiederstanden","text":"Das Ohm'sche Gesetzt gillt: \\(U=R \\cdot I\\) Die Leistung : \\(P=U\\cdot I=\\frac {U^2} R = I^2R\\)","title":"Wiederst\u00e4nden"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#kondensatoren","text":"Ein Kondensator ist eine Art Feder, durch welche kein Strom fliessen kann. Beim Aufladen werden immer mehr Elektronen hinein gepumpt. Daher wird es immer schwieriger noch mehr Elektronen hinein zu pressen, je voller der Kondensator wird. Ladung kann mit \\(CU_c = Q\\) berechnen. C stellt dabei die Kapazit\u00e4t in Farad [F] and (nicht die Ladung) Ein Kondensator ist kein Ohm'sches Bauteil und folgt demnach nicht dem Ohm'schen gesetzt. Anstatt kann folgende Exponentialfunktion f\u00fcr Q benutzt werden. \\(U_0\\) ist dabei die Spannungsquelle, C die Kapazit\u00e4t in Fahrad und R der Wiederstand, durch welcher der Strom fliessen muss: f\u00fcr zum Laden: \\(Q(t) = U_0\\cdot C (1 - e^{\\frac{-t}{R\\cdot C}})\\) f\u00fcr zum Entladen: \\(Q(t) = U_0\\cdot C (e^{\\frac{-t}{R\\cdot C}})\\) Um U (Strom) des Kondensators zu berechnen, einfach das \\(\\cdot C\\) aus der Gleichung entfernen, da \\(C\\cdot U_c=Q \\rightarrow U_c=\\frac Q C\\) bedeutet","title":"Kondensatoren"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#schwinungen","text":"//TODO","title":"Schwinungen"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#spule","text":"Wenn durch eine Spule Strom (V) fliesst, dann erzeugt dies ein Magnetfeld. Beim Hochfahren des Stromes (V) wird Energie ben\u00f6tig, um das Magnetfeld zu erzeugen. Wenn der Strom (V) zur\u00fcckgefahren wird, wird die Energie wieder freigegeben. Es gilt: \\(U=L\\frac {dI}{dt}\\) L ist die Induktivit\u00e4t in Henry [H] I Formel","title":"Spule"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#lange-kabeldrahte","text":"Der Wiederstand eines Drahtes kann mit der Formel \\(R=\\rho \\frac L A\\) . Grunds\u00e4tzlich gillt je L\u00e4nger und je d\u00fcnner ein Draht ist, desto h\u00f6her ist der Wiederstand. Nat\u00fcrlich h\u00e4ngt es auch noch von \\(\\rho\\) ( \\(mm^2m^{-1}...\\) ), dem Spezifischer Wierstand, ab.","title":"Lange Kabel/Dr\u00e4hte"},{"location":"21HS/GED/Elektronik/Maschen%20und%20Knotensatz.html#spannungsbander","text":"Da man im Computer nicht genau 0V oder 5V, definiert man Spannungsb\u00e4nder, in welcher eine Schaltung einen Input oder Output als 1 oder 0 erkennt. ![](/res/2021-10-27-08-57-35-image.png","title":"Spannungsb\u00e4nder"},{"location":"21HS/GED/Physik/00_Formeln.html","text":"Formeln In dieser Datei werden alle Formeln und Konstanten zusammen gefasst. Prefix Exponent peta \\(10^{15}\\) tera \\(10^{12}\\) giga \\(10^9\\) mega \\(10^6\\) kilo \\(10^3\\) hecto \\(10^2\\) deca \\(10^1\\) - \\(10^0\\) dezi \\(10^{-1}\\) cento \\(10^{-2}\\) milli \\(10^{-3}\\) micro \\(10^{-6}\\) nano \\(10^{-9}\\) pico \\(10^{-12}\\) femto \\(10^{-15}\\) Elektronik Thema Formeln Erkl\u00e4rung \\(I [A]\\) Strom \\(U [V]\\) Spannung Wiederst\u00e4nde \\(U=R\\cdot I\\) Formel f\u00fcr Ohmnische Wiederst\u00e4nde Wiederst\u00e4nde \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Formel zum zwei parallele Wiederst\u00e4nde zusammen zu fassen Kondensator \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U\\) und der Ladung \\(Q\\) Kondensator \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden Kondensator \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet Kondensator \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet Kondensator \\(\\tau=R\\cdot C\\) Der Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\) auf/ab in der Zeit \\(\\tau\\) Themische Strahlungen Konstante Erkl\u00e4rung \\(c=3\\cdot 10^8m/s\\) Lichtgeschwindigkeit im Vakum \\(h=6.626\\cdot10^{-34} Js\\) Planck'sche Konstante Formel Erkl\u00e4rung \\(c=\\lambda \\cdot\\nu\\) Dies ist der Zusammenhang zwischen der Wellenl\u00e4nge \\(\\lambda\\) und der Frequenz \\(\\nu\\) . \\(c\\) ist die Lichtgeschwindigkeit \\(E=h\\nu\\) Die Energie einer Strahlung mit der Frequenz \\(\\nu\\) . \\(h\\) ist die Plank'sche Konstante \\(\\rho(\\nu)=1-\\alpha(\\nu)\\) Umrechnungs Formel zwischen Reflektionskoeffizenten ( \\(\\rho\\) ) und Absorptionskoeffizenten ( \\(\\alpha\\) ) Noch zu lernen B-Felder induziert E-Felder In welche Richtung positive E-Felder anziehen oder abstossen","title":"Formeln"},{"location":"21HS/GED/Physik/00_Formeln.html#formeln","text":"In dieser Datei werden alle Formeln und Konstanten zusammen gefasst. Prefix Exponent peta \\(10^{15}\\) tera \\(10^{12}\\) giga \\(10^9\\) mega \\(10^6\\) kilo \\(10^3\\) hecto \\(10^2\\) deca \\(10^1\\) - \\(10^0\\) dezi \\(10^{-1}\\) cento \\(10^{-2}\\) milli \\(10^{-3}\\) micro \\(10^{-6}\\) nano \\(10^{-9}\\) pico \\(10^{-12}\\) femto \\(10^{-15}\\)","title":"Formeln"},{"location":"21HS/GED/Physik/00_Formeln.html#elektronik","text":"Thema Formeln Erkl\u00e4rung \\(I [A]\\) Strom \\(U [V]\\) Spannung Wiederst\u00e4nde \\(U=R\\cdot I\\) Formel f\u00fcr Ohmnische Wiederst\u00e4nde Wiederst\u00e4nde \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Formel zum zwei parallele Wiederst\u00e4nde zusammen zu fassen Kondensator \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U\\) und der Ladung \\(Q\\) Kondensator \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden Kondensator \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet Kondensator \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet Kondensator \\(\\tau=R\\cdot C\\) Der Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\) auf/ab in der Zeit \\(\\tau\\)","title":"Elektronik"},{"location":"21HS/GED/Physik/00_Formeln.html#themische-strahlungen","text":"Konstante Erkl\u00e4rung \\(c=3\\cdot 10^8m/s\\) Lichtgeschwindigkeit im Vakum \\(h=6.626\\cdot10^{-34} Js\\) Planck'sche Konstante Formel Erkl\u00e4rung \\(c=\\lambda \\cdot\\nu\\) Dies ist der Zusammenhang zwischen der Wellenl\u00e4nge \\(\\lambda\\) und der Frequenz \\(\\nu\\) . \\(c\\) ist die Lichtgeschwindigkeit \\(E=h\\nu\\) Die Energie einer Strahlung mit der Frequenz \\(\\nu\\) . \\(h\\) ist die Plank'sche Konstante \\(\\rho(\\nu)=1-\\alpha(\\nu)\\) Umrechnungs Formel zwischen Reflektionskoeffizenten ( \\(\\rho\\) ) und Absorptionskoeffizenten ( \\(\\alpha\\) )","title":"Themische Strahlungen"},{"location":"21HS/GED/Physik/00_Formeln.html#noch-zu-lernen","text":"B-Felder induziert E-Felder In welche Richtung positive E-Felder anziehen oder abstossen","title":"Noch zu lernen"},{"location":"21HS/GED/Physik/01_ch%C3%BCgelif%C3%BCsik.html","text":"Ch\u00fcgeli F\u00fcsik Kraft \\(\\vec F = m \\cdot \\vec a\\) Diese Formel nimmt einiges an: Bewegung in einer Dimension (keine Vektoren) Konstante Beschleunigung (a = const.) Start bei \\(s(0)=0\\) Anfangsgeschwindigkeit bei Beschleunigung und co. Hier sind einige g\u00e4ngige Formeln aufgelistet, welche hilfreich bei Beschleunigung sind. In der obersten Reihe steht, was die Formel ergeben soll. In der ersten Spalte, was sich nicht \u00e4ndert und somit nicht in der Formel erw\u00e4hnt wird. t s v a t - \\(s=\\frac{v^2}{2a}\\) \\(v=\\sqrt{2as}\\) \\(a=\\frac{v^2}{2s}\\) s \\(t=\\frac{v}{a}\\) - \\(v=at\\) \\(a=\\frac{v}{t}\\) v \\(t=\\sqrt{\\frac{2s}{a}}\\) \\(s=\\frac{at^2}{2}\\) - \\(a=\\frac{2s}{t^2}\\) a \\(t=\\frac{2s}{v}\\) \\(s=\\frac{vt}{2}\\) \\(v=\\frac{2s}{t}\\) - Energie Energie ist \\(Kraft \\cdot Strecke\\) . Es gilt also die Formel \\(E=F\\cdot s [J]\\) . Die Masseinheit \\(J\\) kann auch als \\(\\frac{kgm^2}{s^2}\\)","title":"Ch\u00fcgeli F\u00fcsik"},{"location":"21HS/GED/Physik/01_ch%C3%BCgelif%C3%BCsik.html#chugeli-fusik","text":"","title":"Ch\u00fcgeli F\u00fcsik"},{"location":"21HS/GED/Physik/01_ch%C3%BCgelif%C3%BCsik.html#kraft","text":"\\(\\vec F = m \\cdot \\vec a\\) Diese Formel nimmt einiges an: Bewegung in einer Dimension (keine Vektoren) Konstante Beschleunigung (a = const.) Start bei \\(s(0)=0\\) Anfangsgeschwindigkeit bei","title":"Kraft"},{"location":"21HS/GED/Physik/01_ch%C3%BCgelif%C3%BCsik.html#beschleunigung-und-co","text":"Hier sind einige g\u00e4ngige Formeln aufgelistet, welche hilfreich bei Beschleunigung sind. In der obersten Reihe steht, was die Formel ergeben soll. In der ersten Spalte, was sich nicht \u00e4ndert und somit nicht in der Formel erw\u00e4hnt wird. t s v a t - \\(s=\\frac{v^2}{2a}\\) \\(v=\\sqrt{2as}\\) \\(a=\\frac{v^2}{2s}\\) s \\(t=\\frac{v}{a}\\) - \\(v=at\\) \\(a=\\frac{v}{t}\\) v \\(t=\\sqrt{\\frac{2s}{a}}\\) \\(s=\\frac{at^2}{2}\\) - \\(a=\\frac{2s}{t^2}\\) a \\(t=\\frac{2s}{v}\\) \\(s=\\frac{vt}{2}\\) \\(v=\\frac{2s}{t}\\) -","title":"Beschleunigung und co."},{"location":"21HS/GED/Physik/01_ch%C3%BCgelif%C3%BCsik.html#energie","text":"Energie ist \\(Kraft \\cdot Strecke\\) . Es gilt also die Formel \\(E=F\\cdot s [J]\\) . Die Masseinheit \\(J\\) kann auch als \\(\\frac{kgm^2}{s^2}\\)","title":"Energie"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html","text":"Elektrotechnik Strom, Spannung und Leistung Ampere ist die Einheit des Stromes \\(I\\) und ist Coulomb pro Sekunde \\([Cs^{-1}]\\) . Die H\u00f6he zwischen zwei Energiepotentialen nennt sich die Spannung \\(U\\) ( \\(U(\\vec r_A,\\vec r_B)=\\varphi(\\vec r_A)-\\varphi(\\vec r_B)\\) ). Spannung kann aber auch \u00fcber Arbeit definiert werden. Die Spannung zwischen zwei Punkten \\(A\\) und \\(B\\) ist die Energie pro Ladung, welche frei wird, wxenn die Ladung von \\(A\\) nach \\(B\\) bewegt wird: \\(U=\\int^{\\vec r_B}_{\\vec r_A}\\vec E d\\vec r\\) . Die kinetische Energie, welche eine Ladung \\(q\\) gewinnt, wenn sie eine Spannung \\(U\\) \"herunterf\u00e4llt\" betr\u00e4gt: \\(\\Delta E_{kin}=\\int^{\\vec r_B}_{\\vec r_A}\\vec q\\cdot E d\\vec r=q\\cdot U\\) Schaltung Knotenregel Die Knotenregel besagt, dass was in einen Knoten hinein geht, muss auch wieder aus dem Knoten hinaus. Oder \\(I_1=I_2+I_3\\) bzw. \\(I_6=i_5+I_4\\) Maschenregel Die Maschenregel besagt, dass alle Spannungen in einer Masche zusammen \\(0\\) ergeben m\u00fcssen. Man rechnet plus wenn es in die Referenzrichtung eines Bauteils geht und minus , wenn es gegen die Referenzrichtung geht. Ebenfalls wichtig zu erw\u00e4hnt ist, dass eine Batterie in die andere Richtung zeigt, als die anderen Bauteile (Dies ist einwenig komisch im Beispiel oben). In der gr\u00fcnen Maschen sieht man, wie dies aussehen kann, f\u00fcr eine Masche, welche nicht \u00fcber die Baterie geht: \\(U_4-U_5=0\\) Batterien Reale Batterien haben einen Innenwiederstand, welcher in Serie mit der Batterie geschalten ist. Dass heisst, dass die realte Spanung einer Batterie kleiner als \\(U_0\\) ist, da \\(U_{in}\\) abgezogen werden muss. Wiederstand Ein Wiederstand folgt dem Ohm'sche Gesetzt. Dass heisst, ein Wiederstand kann mit \\(U=R\\cdot I\\) berechnet werden. Da f\u00fcr die Leistung gillt \\(P=U\\cdot I\\) , kann in diese Formel das Ohm'sche Gesetzt eingesetzt werden, um die Formel \\(P=\\frac {U^2} R=I^2R\\) zu bekommen. Wegen der Knoten und Maschenregeln verhalten sich Wiederst\u00e4nde (wie auch andere Bauteile) anderst, jenach dem, ob sie Parallel oder Serial angeschlossen sind. Name Erkl\u00e4rung Bild Parallel geschaltet In einer Parallelschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusammen gefasst werden: \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Seriel geschaltet In einer Serielschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusamengefasst werden: \\(R_{12}=R_1+R_2\\) Kondensator Ein Kondensator (oder Capacitor) kann man sich als Feder vorstellen, welche aus zwei Metallplatten nahe bei einander bestehen. Es wird Strom hinein \"gepumpt\". Dies wird immer schwerer, je voller der Kondensator wird, bis am Ende der Kondensator voll ist. Das zweite wichtige an einem Kondensator ist, dass keine Elektronen durch ihn durch fliessen k\u00f6nnen. Anstelle dessen sammeln sich auf der einen Seite mehr Elektronen an, auf der anderen Seite werden die bereits vorhanden Elektronen abgesaugt. formel Erkl\u00e4rung \\(\\frac {dQ}{dt}=I\\) Die Ver\u00e4nderungsrate der Ladung, ist der Strom \\(I\\) \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U [V]\\) und der Ladung \\(Q\\) abh\u00e4ngig von der Kapazit\u00e4t \\(C [F]\\) in Farad \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet \\(U_C(t)=U_0\\cdot e^{-\\frac t {RC}}\\) Wie sich die Spannung \\(U\\) beim Entladen verhaltet \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet \\(\\tau=R\\cdot C\\) Die Zeitkonstante \\(\\tau\\) . Der Strom des Kondensator f\u00e4llt auf ca \\(\\frac 1 e\\approx0.37\\) ab in der Zeit \\(\\tau\\) oder steigt auf \\(1-\\frac 1 e\\approx0.63\\) in \\(\\tau\\) an, wenn der Kondensator geladen wird Spulen Wenn durch ein Draht Strom fliesst, entsteht ein Magnetfeld. Dies ist ebenfalls der Fall bei einer Spule. Wenn der Strom hochgefahren wird, dann wird ein Magnetfeld aufgebaut. Dies ben\u00f6tigt aber Energie, was wiederum einen Wiederstand erzeugt. Wenn der Strom abgebaut wird, wir die Energie des Magnetfeldes wieder zur\u00fcck in die Spannung gespiessen und \u00fcber der Spule entsteht eine Spannung, welche den Strom antreibt. Die Richtung des Magnetfeldes findet man heraus, in dem man die Rechte hand nimmt und mit dem Daumen in die Ricthung des - zeigt, bzw. die Stromrichtung auf dem Schaltungsplan (nicht die physikalische Stromrichtung, die ist in die andere Richtung). Formel Erkl\u00e4rung \\(U_L=L\\frac{dI}{dt}\\) Die Ver\u00e4nderungsrate von dem Strom \\(I\\) mit der Konstante \\(L [Henry]\\) multipliziert, ergibt die Spannung Unged\u00e4mpfte Schwingkreise In einem Schwingungskreis, schwingen die Elektronen zwischen den zwei Platten des Kondensators hin und her. Dies kann man in die folgende Schritte unterteilen: Der Kondensator ist geladen und es herrscht eine Spanung \\(U_0\\) \u00fcber dem Kondensator. Der Schalter ist aber noch offen. Der Schalter \\(s_1\\) wurde geschlossen und der Strom fliesst. Wegen dem Maschensatz muss \\(U_C=U_L\\) sein. Da die Spannung \\(U_C\\) w\u00e4chst, muss auch der Strom \\(I\\) wachsen und somit ein Magnetfeld \u00fcber L entstehen. Der Strom \\(I\\) und somit auch das Magnetfeld \\(B\\) sind maximal. Irgendwann wird der Kondensator leer sein (Auf beiden Seiten der Platte sind gleich viele Elektronen) und \\(U_L\\) und \\(UC\\) sind 0. Somit gilt auch \\(I=0\\) . Da nun der Strom in der Spule freigesetzt wird, l\u00e4dt sich der Kondensator wieder auf (allerdings mit einem anderen Vorzeichen) und so entsteht wieder eine Spannung \\(U_C\\) \u00fcber dem Kondensator. So bald die Spule \"leer\" ist, wechselt die Stromrichtung wieder Der Zyklus wiederholt sich nun wiede Formel Erkl\u00e4rung \\(Q(t)=CU_0\\cdot \\cos(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Die Ladung \\(Q\\) eines Schwinungskreises \\(I(t)=-\\sqrt {\\frac C L}\\cdot U_0\\cdot \\sin(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Der Strom \\(I\\) eines Schwinungskreises \\(U_L(t)=-\\frac 1 {\\sqrt{LC}}\\cdot U_0\\cdot \\cos(\\frac 1 {\\sqrt{LC}} \\cdot t)\\) Die Spannun \\(U_L\\) eines Schwinungskreises \\(f=\\frac 1 {2\\pi\\sqrt{LC}}\\) Die Frequenz \\(f\\) , mit welcher der Schwingunskreis schwingt \\(T=2\\pi\\sqrt{LC}\\) Die Periodendauer \\(T\\) , welche eine Schwinung des Schwingungskreis ben\u00f6tigt Ged\u00e4mpfte Schwingungskreise Der Strom im Schwinungskreis wird schw\u00e4cher, wenn \\(R < 2\\sqrt {\\frac L C}\\) (oder wenn \\(\\frac{R^2}{4L^2}>\\frac 1 {LC}\\) ist) Wenn dies gegeben ist, dann ist es ein ged\u00e4mpfter Schwingungskreis. Formel Erkl\u00e4rung \\(Q(t)=Q_0e^{-\\frac t \\tau}\\cos(\\omega_dt-\\phi_0)\\) Die Ladung des Schwinungskreis1 \\(f=\\frac 1 {2\\pi}\\sqrt{\\frac 1 {LC} -\\frac{R^2}{4L^2}}\\) , \\(T=\\frac 1 f\\) Die (Kreis-)frequenz \\(\\omega_d\\) \\(\\tau=\\frac{2L} R\\) Die Zeitkonstante \\(\\tau\\) der D\u00e4mpfung. Der Strom des Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\%\\) auf/ab in der Zeit \\(\\tau\\) Low-Pass und High-Pass-Filter Bei einem Low-Pass-Filter werden die tiefen Frequenzen durchgelassen und die Hochen weggefiltert. Bei einem High-Pass-Filter ist es umgekehrt und die hochen Frequenzen werden duch gelassen und die tiefen weggefiltert. \u00dcber dem Wiederstand misst man ein Signal, bei welchem die tiefen Frequenzen ged\u00e4mpft wurden und die hochen Frequenzen fast unver\u00e4ndert. Dies w\u00e4re ein High-Pass-Filter. Hingegen \u00fcber dem Kondensator misst werden die hochen Frequenzen ged\u00e4mpft und die tiefen durchgelassen, was ein Low-Pass-Filter ist. Draht Der Wiederstand in einem Kabel ist ungef\u00e4hr: \\(R=\\rho\\frac L A\\) , wobei \\(\\rho\\) den spezifischen Wiederstand mit der Einheit \\([mm^2m^{-1}\\Omega]\\) . \\(L\\) ist die L\u00e4nge in \\([m]\\) und \\(A\\) ist die Querschnittsfl\u00e4che in \\([mm^2]\\) . Karnaugh-Veitsch Diagramme Ein KV-Diagram kann praktisch sein, um eine Wahrheitstabelle mit vier Inputs in eine Schaltung zu verwandeln. Daf\u00fcr wird zuerst die Wahrheitstabelle in das folgende Raster einf\u00fchrt. Dabei ist oben, bzw. auf der linken Seite das erste Bit und auf der unteren/rechten Seite das linke Bit. Das Feld oben rechts stellt also f\u00fcr den Wert aus der Wahrheitstabelle A=1, B=0, C=0, D=0. Wenn dies getan ist, versucht man Bl\u00f6cke mit Einsen zu finden. Die Bl\u00f6cke k\u00f6nnen 1, 2, 4, 8 oder 16 lang und/oder breit sein. Falls es egal ist, ob ein Input 0 oder 1 ist, kann er so betrachtet werden, dass es sch\u00f6nere Bl\u00f6cke gibt. Ebenfalls wichtig, ein Block darf \u00fcber die Kante hinausgehen. Im letzten Schritt wird nun aus den Bl\u00f6cken Und-Schaltungen gebaut. Dabei m\u00fcssen zwei Dinge beachtet werden: Wenn ein Block \u00fcber den not und \"normalen\" Block geht (z.B. A und not-A), dann muss das And-Gate keine Verbindung zu diesem Input haben, da es in beiden F\u00e4llen true ist. Wenn ein Block nur \u00fcbr ein Block geht (z.B. nur \u00fcber den A oder nur den not-A Block), dann muss das And-Gate mit diesem Input verbunden sein. Hier sieht man noch das Beispiel f\u00fcr die oberigen Bl\u00f6cke. Transformer Stromnetz In unserem Stromnetzt werden mehrere Spannungen gen\u00fctzt. Zum einten m\u00f6chte man hohe Spannungen f\u00fcrs Transportieren von Strom ben\u00fctzten, da dies um einiges effizienter ist. Allerdings ist es zu gef\u00e4hrlich Hochspannung direkt im Haus zu gebrauchen. Daher hat man vier Netzebenen, welche mit Transformern gekoppelt sind. 1 Ebene - H\u00f6chstspannungsebene : 380kV, bzw. 220 kV aus dem Kraftwerk oder vom Ausland 3 Ebene - Hochspannungsebene : 36kV - 150kV: \u00dcberregionale Verteilungsnetzte 5 Ebene - Mittelspannungsebene : 1kV - 36kV: Regionale Verteilungsnetzte 7 Ebene - Niederspannungsebene : < 1kV: Lokale Verteilungsnetzte Die Ebenen 2, 4 und 6 sind die Transformatorenebenen. Auf diesen Ebenen wird der Strom auf die n\u00e4chst tiefere oder h\u00f6here Ebene transformiert. Wechsel- vs. Gleichstrom Man hat sich in der Vergangenheit auf Wechselstrom geeinigt, weil es relativ einfach ist, Wechselstrom zu transformieren. Heute ist dies aber auch mit Gleichstrom m\u00f6glich. Gleichstrom erzeugt weniger Verl\u00fcste, wenn transportiert auf lange Streckenen, als Wechselstrom, da Wechselstrom nah an der Kabeloberfl\u00e4chse fliest und daher ein st\u00e4rkeres Magnetfeld erzeugt. Der \\(U_{Eff}\\) kann mit der folgender Formel berechnet werden: \\(U_{Eff}=\\frac{U_S}{\\sqrt 2}\\) . Dies berechnet den quadratischen Mittelwert einer Wechselspannung. Der Sinus kann mit der folgenden Formel angegebene werden: \\(f(t)=U_{Eff}\\cos(\\omega\\cdot t)=U_{Eff}\\cos(f\\cdot 2\\pi\\cdot t)\\) Drehstrom (Siehe Script_GED_Lect_3_4.pdf) Drehstrom ist praktisch f\u00fcr Motoren, da es keine \"Totenp\u00fcnkte\" gibt, an dem ein Magnet stoppen k\u00f6nnte. Zudem sind alle H\u00e4user in der Schweiz an einem Drehstrom angeschlossen. Auf den Aussenleiter wird der Strom \"transportiert\" und stehen gegen\u00fcber der Erde unter einer Spannung von 230V. Der Neutralleiter ist der \"Ausgang\" f\u00fcr die Elektronen, welche \u00fcber die Aussenleiter hinein gepumpt werden. Gefahr durch Strom Wie gef\u00e4hrlich Strom ist h\u00e4ngt von der Stromst\u00e4rke und der Dauer ab. Gefahrebereiche: Wird nicht wahrgenommen, da der Strom zu klein ist Kribbeln, Kr\u00e4mpfte, aber keine bleibenden Sch\u00e4den Stromquelle kann wegen Museklverkrampfung nicht mehr losgelassen werden (bei Gleichstrom) T\u00f6dlich, wegen z.B. Herzkammerflimmern","title":"Elektrotechnik"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#elektrotechnik","text":"","title":"Elektrotechnik"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#strom-spannung-und-leistung","text":"Ampere ist die Einheit des Stromes \\(I\\) und ist Coulomb pro Sekunde \\([Cs^{-1}]\\) . Die H\u00f6he zwischen zwei Energiepotentialen nennt sich die Spannung \\(U\\) ( \\(U(\\vec r_A,\\vec r_B)=\\varphi(\\vec r_A)-\\varphi(\\vec r_B)\\) ). Spannung kann aber auch \u00fcber Arbeit definiert werden. Die Spannung zwischen zwei Punkten \\(A\\) und \\(B\\) ist die Energie pro Ladung, welche frei wird, wxenn die Ladung von \\(A\\) nach \\(B\\) bewegt wird: \\(U=\\int^{\\vec r_B}_{\\vec r_A}\\vec E d\\vec r\\) . Die kinetische Energie, welche eine Ladung \\(q\\) gewinnt, wenn sie eine Spannung \\(U\\) \"herunterf\u00e4llt\" betr\u00e4gt: \\(\\Delta E_{kin}=\\int^{\\vec r_B}_{\\vec r_A}\\vec q\\cdot E d\\vec r=q\\cdot U\\)","title":"Strom, Spannung und Leistung"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#schaltung","text":"","title":"Schaltung"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#knotenregel","text":"Die Knotenregel besagt, dass was in einen Knoten hinein geht, muss auch wieder aus dem Knoten hinaus. Oder \\(I_1=I_2+I_3\\) bzw. \\(I_6=i_5+I_4\\)","title":"Knotenregel"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#maschenregel","text":"Die Maschenregel besagt, dass alle Spannungen in einer Masche zusammen \\(0\\) ergeben m\u00fcssen. Man rechnet plus wenn es in die Referenzrichtung eines Bauteils geht und minus , wenn es gegen die Referenzrichtung geht. Ebenfalls wichtig zu erw\u00e4hnt ist, dass eine Batterie in die andere Richtung zeigt, als die anderen Bauteile (Dies ist einwenig komisch im Beispiel oben). In der gr\u00fcnen Maschen sieht man, wie dies aussehen kann, f\u00fcr eine Masche, welche nicht \u00fcber die Baterie geht: \\(U_4-U_5=0\\)","title":"Maschenregel"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#batterien","text":"Reale Batterien haben einen Innenwiederstand, welcher in Serie mit der Batterie geschalten ist. Dass heisst, dass die realte Spanung einer Batterie kleiner als \\(U_0\\) ist, da \\(U_{in}\\) abgezogen werden muss.","title":"Batterien"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#wiederstand","text":"Ein Wiederstand folgt dem Ohm'sche Gesetzt. Dass heisst, ein Wiederstand kann mit \\(U=R\\cdot I\\) berechnet werden. Da f\u00fcr die Leistung gillt \\(P=U\\cdot I\\) , kann in diese Formel das Ohm'sche Gesetzt eingesetzt werden, um die Formel \\(P=\\frac {U^2} R=I^2R\\) zu bekommen. Wegen der Knoten und Maschenregeln verhalten sich Wiederst\u00e4nde (wie auch andere Bauteile) anderst, jenach dem, ob sie Parallel oder Serial angeschlossen sind. Name Erkl\u00e4rung Bild Parallel geschaltet In einer Parallelschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusammen gefasst werden: \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Seriel geschaltet In einer Serielschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusamengefasst werden: \\(R_{12}=R_1+R_2\\)","title":"Wiederstand"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#kondensator","text":"Ein Kondensator (oder Capacitor) kann man sich als Feder vorstellen, welche aus zwei Metallplatten nahe bei einander bestehen. Es wird Strom hinein \"gepumpt\". Dies wird immer schwerer, je voller der Kondensator wird, bis am Ende der Kondensator voll ist. Das zweite wichtige an einem Kondensator ist, dass keine Elektronen durch ihn durch fliessen k\u00f6nnen. Anstelle dessen sammeln sich auf der einen Seite mehr Elektronen an, auf der anderen Seite werden die bereits vorhanden Elektronen abgesaugt. formel Erkl\u00e4rung \\(\\frac {dQ}{dt}=I\\) Die Ver\u00e4nderungsrate der Ladung, ist der Strom \\(I\\) \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U [V]\\) und der Ladung \\(Q\\) abh\u00e4ngig von der Kapazit\u00e4t \\(C [F]\\) in Farad \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet \\(U_C(t)=U_0\\cdot e^{-\\frac t {RC}}\\) Wie sich die Spannung \\(U\\) beim Entladen verhaltet \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet \\(\\tau=R\\cdot C\\) Die Zeitkonstante \\(\\tau\\) . Der Strom des Kondensator f\u00e4llt auf ca \\(\\frac 1 e\\approx0.37\\) ab in der Zeit \\(\\tau\\) oder steigt auf \\(1-\\frac 1 e\\approx0.63\\) in \\(\\tau\\) an, wenn der Kondensator geladen wird","title":"Kondensator"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#spulen","text":"Wenn durch ein Draht Strom fliesst, entsteht ein Magnetfeld. Dies ist ebenfalls der Fall bei einer Spule. Wenn der Strom hochgefahren wird, dann wird ein Magnetfeld aufgebaut. Dies ben\u00f6tigt aber Energie, was wiederum einen Wiederstand erzeugt. Wenn der Strom abgebaut wird, wir die Energie des Magnetfeldes wieder zur\u00fcck in die Spannung gespiessen und \u00fcber der Spule entsteht eine Spannung, welche den Strom antreibt. Die Richtung des Magnetfeldes findet man heraus, in dem man die Rechte hand nimmt und mit dem Daumen in die Ricthung des - zeigt, bzw. die Stromrichtung auf dem Schaltungsplan (nicht die physikalische Stromrichtung, die ist in die andere Richtung). Formel Erkl\u00e4rung \\(U_L=L\\frac{dI}{dt}\\) Die Ver\u00e4nderungsrate von dem Strom \\(I\\) mit der Konstante \\(L [Henry]\\) multipliziert, ergibt die Spannung","title":"Spulen"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#ungedampfte-schwingkreise","text":"In einem Schwingungskreis, schwingen die Elektronen zwischen den zwei Platten des Kondensators hin und her. Dies kann man in die folgende Schritte unterteilen: Der Kondensator ist geladen und es herrscht eine Spanung \\(U_0\\) \u00fcber dem Kondensator. Der Schalter ist aber noch offen. Der Schalter \\(s_1\\) wurde geschlossen und der Strom fliesst. Wegen dem Maschensatz muss \\(U_C=U_L\\) sein. Da die Spannung \\(U_C\\) w\u00e4chst, muss auch der Strom \\(I\\) wachsen und somit ein Magnetfeld \u00fcber L entstehen. Der Strom \\(I\\) und somit auch das Magnetfeld \\(B\\) sind maximal. Irgendwann wird der Kondensator leer sein (Auf beiden Seiten der Platte sind gleich viele Elektronen) und \\(U_L\\) und \\(UC\\) sind 0. Somit gilt auch \\(I=0\\) . Da nun der Strom in der Spule freigesetzt wird, l\u00e4dt sich der Kondensator wieder auf (allerdings mit einem anderen Vorzeichen) und so entsteht wieder eine Spannung \\(U_C\\) \u00fcber dem Kondensator. So bald die Spule \"leer\" ist, wechselt die Stromrichtung wieder Der Zyklus wiederholt sich nun wiede Formel Erkl\u00e4rung \\(Q(t)=CU_0\\cdot \\cos(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Die Ladung \\(Q\\) eines Schwinungskreises \\(I(t)=-\\sqrt {\\frac C L}\\cdot U_0\\cdot \\sin(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Der Strom \\(I\\) eines Schwinungskreises \\(U_L(t)=-\\frac 1 {\\sqrt{LC}}\\cdot U_0\\cdot \\cos(\\frac 1 {\\sqrt{LC}} \\cdot t)\\) Die Spannun \\(U_L\\) eines Schwinungskreises \\(f=\\frac 1 {2\\pi\\sqrt{LC}}\\) Die Frequenz \\(f\\) , mit welcher der Schwingunskreis schwingt \\(T=2\\pi\\sqrt{LC}\\) Die Periodendauer \\(T\\) , welche eine Schwinung des Schwingungskreis ben\u00f6tigt","title":"Unged\u00e4mpfte Schwingkreise"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#gedampfte-schwingungskreise","text":"Der Strom im Schwinungskreis wird schw\u00e4cher, wenn \\(R < 2\\sqrt {\\frac L C}\\) (oder wenn \\(\\frac{R^2}{4L^2}>\\frac 1 {LC}\\) ist) Wenn dies gegeben ist, dann ist es ein ged\u00e4mpfter Schwingungskreis. Formel Erkl\u00e4rung \\(Q(t)=Q_0e^{-\\frac t \\tau}\\cos(\\omega_dt-\\phi_0)\\) Die Ladung des Schwinungskreis1 \\(f=\\frac 1 {2\\pi}\\sqrt{\\frac 1 {LC} -\\frac{R^2}{4L^2}}\\) , \\(T=\\frac 1 f\\) Die (Kreis-)frequenz \\(\\omega_d\\) \\(\\tau=\\frac{2L} R\\) Die Zeitkonstante \\(\\tau\\) der D\u00e4mpfung. Der Strom des Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\%\\) auf/ab in der Zeit \\(\\tau\\)","title":"Ged\u00e4mpfte Schwingungskreise"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#low-pass-und-high-pass-filter","text":"Bei einem Low-Pass-Filter werden die tiefen Frequenzen durchgelassen und die Hochen weggefiltert. Bei einem High-Pass-Filter ist es umgekehrt und die hochen Frequenzen werden duch gelassen und die tiefen weggefiltert. \u00dcber dem Wiederstand misst man ein Signal, bei welchem die tiefen Frequenzen ged\u00e4mpft wurden und die hochen Frequenzen fast unver\u00e4ndert. Dies w\u00e4re ein High-Pass-Filter. Hingegen \u00fcber dem Kondensator misst werden die hochen Frequenzen ged\u00e4mpft und die tiefen durchgelassen, was ein Low-Pass-Filter ist.","title":"Low-Pass und High-Pass-Filter"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#draht","text":"Der Wiederstand in einem Kabel ist ungef\u00e4hr: \\(R=\\rho\\frac L A\\) , wobei \\(\\rho\\) den spezifischen Wiederstand mit der Einheit \\([mm^2m^{-1}\\Omega]\\) . \\(L\\) ist die L\u00e4nge in \\([m]\\) und \\(A\\) ist die Querschnittsfl\u00e4che in \\([mm^2]\\) .","title":"Draht"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#karnaugh-veitsch-diagramme","text":"Ein KV-Diagram kann praktisch sein, um eine Wahrheitstabelle mit vier Inputs in eine Schaltung zu verwandeln. Daf\u00fcr wird zuerst die Wahrheitstabelle in das folgende Raster einf\u00fchrt. Dabei ist oben, bzw. auf der linken Seite das erste Bit und auf der unteren/rechten Seite das linke Bit. Das Feld oben rechts stellt also f\u00fcr den Wert aus der Wahrheitstabelle A=1, B=0, C=0, D=0. Wenn dies getan ist, versucht man Bl\u00f6cke mit Einsen zu finden. Die Bl\u00f6cke k\u00f6nnen 1, 2, 4, 8 oder 16 lang und/oder breit sein. Falls es egal ist, ob ein Input 0 oder 1 ist, kann er so betrachtet werden, dass es sch\u00f6nere Bl\u00f6cke gibt. Ebenfalls wichtig, ein Block darf \u00fcber die Kante hinausgehen. Im letzten Schritt wird nun aus den Bl\u00f6cken Und-Schaltungen gebaut. Dabei m\u00fcssen zwei Dinge beachtet werden: Wenn ein Block \u00fcber den not und \"normalen\" Block geht (z.B. A und not-A), dann muss das And-Gate keine Verbindung zu diesem Input haben, da es in beiden F\u00e4llen true ist. Wenn ein Block nur \u00fcbr ein Block geht (z.B. nur \u00fcber den A oder nur den not-A Block), dann muss das And-Gate mit diesem Input verbunden sein. Hier sieht man noch das Beispiel f\u00fcr die oberigen Bl\u00f6cke.","title":"Karnaugh-Veitsch Diagramme"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#transformer","text":"","title":"Transformer"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#stromnetz","text":"In unserem Stromnetzt werden mehrere Spannungen gen\u00fctzt. Zum einten m\u00f6chte man hohe Spannungen f\u00fcrs Transportieren von Strom ben\u00fctzten, da dies um einiges effizienter ist. Allerdings ist es zu gef\u00e4hrlich Hochspannung direkt im Haus zu gebrauchen. Daher hat man vier Netzebenen, welche mit Transformern gekoppelt sind. 1 Ebene - H\u00f6chstspannungsebene : 380kV, bzw. 220 kV aus dem Kraftwerk oder vom Ausland 3 Ebene - Hochspannungsebene : 36kV - 150kV: \u00dcberregionale Verteilungsnetzte 5 Ebene - Mittelspannungsebene : 1kV - 36kV: Regionale Verteilungsnetzte 7 Ebene - Niederspannungsebene : < 1kV: Lokale Verteilungsnetzte Die Ebenen 2, 4 und 6 sind die Transformatorenebenen. Auf diesen Ebenen wird der Strom auf die n\u00e4chst tiefere oder h\u00f6here Ebene transformiert.","title":"Stromnetz"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#wechsel-vs-gleichstrom","text":"Man hat sich in der Vergangenheit auf Wechselstrom geeinigt, weil es relativ einfach ist, Wechselstrom zu transformieren. Heute ist dies aber auch mit Gleichstrom m\u00f6glich. Gleichstrom erzeugt weniger Verl\u00fcste, wenn transportiert auf lange Streckenen, als Wechselstrom, da Wechselstrom nah an der Kabeloberfl\u00e4chse fliest und daher ein st\u00e4rkeres Magnetfeld erzeugt. Der \\(U_{Eff}\\) kann mit der folgender Formel berechnet werden: \\(U_{Eff}=\\frac{U_S}{\\sqrt 2}\\) . Dies berechnet den quadratischen Mittelwert einer Wechselspannung. Der Sinus kann mit der folgenden Formel angegebene werden: \\(f(t)=U_{Eff}\\cos(\\omega\\cdot t)=U_{Eff}\\cos(f\\cdot 2\\pi\\cdot t)\\)","title":"Wechsel- vs. Gleichstrom"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#drehstrom","text":"(Siehe Script_GED_Lect_3_4.pdf) Drehstrom ist praktisch f\u00fcr Motoren, da es keine \"Totenp\u00fcnkte\" gibt, an dem ein Magnet stoppen k\u00f6nnte. Zudem sind alle H\u00e4user in der Schweiz an einem Drehstrom angeschlossen. Auf den Aussenleiter wird der Strom \"transportiert\" und stehen gegen\u00fcber der Erde unter einer Spannung von 230V. Der Neutralleiter ist der \"Ausgang\" f\u00fcr die Elektronen, welche \u00fcber die Aussenleiter hinein gepumpt werden.","title":"Drehstrom"},{"location":"21HS/GED/Physik/02_Elektrotechnik.html#gefahr-durch-strom","text":"Wie gef\u00e4hrlich Strom ist h\u00e4ngt von der Stromst\u00e4rke und der Dauer ab. Gefahrebereiche: Wird nicht wahrgenommen, da der Strom zu klein ist Kribbeln, Kr\u00e4mpfte, aber keine bleibenden Sch\u00e4den Stromquelle kann wegen Museklverkrampfung nicht mehr losgelassen werden (bei Gleichstrom) T\u00f6dlich, wegen z.B. Herzkammerflimmern","title":"Gefahr durch Strom"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html","text":"Elektromagnetismus Formeln Formel Erkl\u00e4rung $\\vec F_{12}=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac {Q_1Q_2}{ \\vec r_{12} $\\vec E(\\vec r)=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac Q { \\vec r - \\vec r_Q \\(\\vec F =q\\vec E(\\vec r, t)\\) Die Kraft \\(\\vec F\\) , mit welcher das Feld \\(\\vec E\\) die Probeladung \\(q\\) beschleunigt \\(\\vec F_L=q\\cdot(\\vec v\\times\\vec B)\\) Die Kraft, eines Magnetfeldes auf eine Ladung \\(q\\) , welche sich mit \\(\\vec v\\) bewegt. $m=\\frac{rq \\vec B Auf dem TI-nspire cx gibt es den Befehl \\(crossP(x, y)\\) , um mit den Vektoren \\(\\vec x\\) und \\(\\vec y\\) ein Kreuzprodukt zu rechnen. Das Skalarprodukt ist folgendermassen definiert: \\(\\vec a \\cdot \\vec b=|\\vec a| \\cdot |\\vec b|\\cdot \\cos(\\alpha)\\) Aus dem kann geschlossen werden, dass wenn \\(\\alpha=90\u00b0\\) , bzw. die Vektoren \\(\\vec a\\) und \\(\\vec b\\) senkrecht aufeinander stehen, dass das Skalarprodukt 0 is Linienintegrale \\(W=\\int_\\gamma\\vec F\\cdot d\\vec \\gamma\\) Arbeit wurde in der BMS als \\(W=F\\cdot s\\) definiert. Nun kann aber \\(F\\) und \\(s\\) auch Vektoren sein. Hier kommt das Linienintegral ins Spiel, denn mit diesem kann man die Arbeit mit Vektoren ausrechnen. Der Vektor \\(\\vec F\\) und \\(\\vec \\gamma\\) m\u00fcssen nicht umbedingt in dieselbe Richtung zeigen. Wenn man z.B. einen Schlitten zieht, hat die Kraft \\(\\vec F\\) ca. eine 45\u00b0 gegen oben, w\u00e4hrend \\(\\vec \\gamma\\) die Strecke des Schlittens darstellt. Spannung kann auch als Linienintegral angesehen werden: \\(U(\\gamma)=\\int_\\gamma\\vec E \\cdot d\\vec \\gamma\\) Spezialf\u00e4lle Name Formel Bild Kreis Das Vektorfeld liegt \u00fcberall tangential an der Kurve und alle Vektoren haben dieselbe L\u00e4nge. \\(\\int_\\gamma\\vec U\\cdot d\\vec\\gamma =2\\pi r\\vert\\vec U\\vert\\) Rechteck Das Vektorfeld ist parallel zu zwei Seiten (A, C) des Rechteck. Entlang einer Seite haben die Vektoren eine konstante Gr\u00f6sse \\(\\int_\\gamma\\vec U \\cdot d\\vec \\gamma=aU_1-aU_5\\) Flussintegrale Beim Flussintegral wie viel Volumen \\(vdt\\) fliesst durch \\(A\\) , wenn es die Geschwindigkeit \\(\\vec U\\) hat. Dies kann als Integral geschrieben werden, in GED wird allerdings nur folgende Spezialf\u00e4lle behandelt. \\(U\\) sind in diesen Formel die L\u00e4nge der Pfeile. Maxwellgleichungen Geschlossene und nicht-geschlossene Fl\u00e4chen Eine geschlossene Fl\u00e4che hat keinen Rand (wie zB. eine Kugel) und es gibt ein klares Innen und Aussen. Eine nicht geschlossene Fl\u00e4che hat einen Rand. Gauss'sche Gesetzt Metalle Rechte-Hand Regel Rechte-Hand Regel 2 Wenn der Daumen in die technische Stromrichtung zeigt, dann zeigen die Finger den Umlaufsinn des \\(\\vec B\\) -Feldes an. Vektorfelder \\[ \\vec E (x, y, z, t)=\\begin{bmatrix} E_x(x, y, z, t) \\\\ E_y(x, y, z, t) \\\\ E_z(x, y, z, t) \\\\ \\end{bmatrix} \\] Ein Vektor kann ein 2D oder 3D Koordinatensystem sein, in welchem Vektoren in eine Richtung zeigen. Diese Richtung kann zus\u00e4tzlich auch noch von der Zeit abh\u00e4ngig sein. Magnetfeld \\([\\vec B(\\vec r, t)]=\\frac {Ns}{Cm}=\\frac{\\text{Newton Sekunden}}{\\text{Coulomb Meter}}=\\frac{kg}{s C} = \\text{Tesla}\\) Ein Magnetfeld wird in Teslas angegeben. Dabei ist ein Tesla kg pro Coulomb Sekunde oder Newton Sekunden pro Coulomb Meter. Um zu berechnen, mit vieviel Kraft ein Objekt mit einer Ladung beeinflusst wird, gibt es folgende Formel: \\(\\vec F = q(\\vec v \\times \\vec B)\\) Elektrofeld \\([\\vec E (\\vec r, t)]=\\frac N C = \\frac V M = \\frac{kg}{ms^3A}\\) Ein Elektrofeld wird Newton pro Coulomb, Volt pro Meter oder Kilogram pro Meter Sekunden\u00b3 Amper angegeben. Die Einheiten bedeuten dasselbe (Coulomb = Amper Sekunde) Wenn ein Leiter positiv geladen ist, wirkt er abstossend zu Elektronen, wenn ein Leiter negative geladen ist, dann wirkt er anziehend. Zu dem sind die Pfeile im senkrecht auf dem Leiter. Um das Elektrofeld einer einzuelne Ladung zu berechnen, kann die folgende Formel verwendet werden Elektrofelder und Magnetfelder zusammen Zeitlich ver\u00e4nderliche B-Felder erzeugen zeitlich ver\u00e4nderliche E-Felder, welche wiederum zeitlich ver\u00e4nderliche B-Felder erzeugen. Diesen Effekt f\u00fchrt zu einer Welle, welche sich ausbreitet. Initialisiert kann es z.B. von einer Antenne werden, welche nichts anderses als Str\u00f6me zeitlich ver\u00e4ndert durch einen Draht schickt. Magnete Magnete haben immer einen Nord- und S\u00fcdpol. Wenn man ein Magnet trennt, entstehen zwei neue Magnete, mit jeweils einem Nord- und S\u00fcdpol. Wie auch bei elektrischen Feldern kann man auch bei magnetischen Feldern Linien zeichnen. Magnete wirken eine Kraft auf bewegte Ladung aus. Auf ruhende Ladung hat es keinen Effekt. Diese Kraft nennt sich Lorentz-Kraft und kann mit folgender Formel berechnet werden: \\(\\vec F_L=q\\cdot(\\vec v \\times \\vec B)\\) Wenn \\(\\vec v\\) senkrecht auf \\(\\vec B\\) steht,und \\(\\vec B\\) konstant ist, kann mit folgender Formel den Zusammenhang von der Geschwindigkeit der Ladung \\(\\vec v\\) mit dem Magnetfeld \\(\\vec B\\) und dem Radius \\(r\\) beschrieben werden: \\(m=\\frac{rq|\\vec B|}{v}\\) Bei Elementarteilchen ist die Ladung entweder \\(0\\) , \\(e\\) oder \\(-e\\) . Intensit\u00e4t Die Intensit\u00e4t einer ebenen Welle kann mit der folgenden Formeln berechnet werden: $$ I_{em}=\\frac{E_0B_0}{2 \\mu _0}=\\frac{E^2_0}{2c\\mu_0}=\\frac{cB^2_0}{2\\mu_0}\\ $$ Dabei ist \\(\\mu_0\\) die magnetische Feldkonstante \\(1.257\\cdot10^{-6}=4\\pi\\cdot 10^{-7}\\) Strahlendruck $$ p_s=\\frac{I_{em}}c=\\frac{E_0B_0}{2c\\mu_0}=\\frac{E^2}{2c^2\\mu_0}=\\frac{B^2_0}{2\\mu_0} $$","title":"Elektromagnetismus"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#elektromagnetismus","text":"","title":"Elektromagnetismus"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#formeln","text":"Formel Erkl\u00e4rung $\\vec F_{12}=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac {Q_1Q_2}{ \\vec r_{12} $\\vec E(\\vec r)=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac Q { \\vec r - \\vec r_Q \\(\\vec F =q\\vec E(\\vec r, t)\\) Die Kraft \\(\\vec F\\) , mit welcher das Feld \\(\\vec E\\) die Probeladung \\(q\\) beschleunigt \\(\\vec F_L=q\\cdot(\\vec v\\times\\vec B)\\) Die Kraft, eines Magnetfeldes auf eine Ladung \\(q\\) , welche sich mit \\(\\vec v\\) bewegt. $m=\\frac{rq \\vec B Auf dem TI-nspire cx gibt es den Befehl \\(crossP(x, y)\\) , um mit den Vektoren \\(\\vec x\\) und \\(\\vec y\\) ein Kreuzprodukt zu rechnen. Das Skalarprodukt ist folgendermassen definiert: \\(\\vec a \\cdot \\vec b=|\\vec a| \\cdot |\\vec b|\\cdot \\cos(\\alpha)\\) Aus dem kann geschlossen werden, dass wenn \\(\\alpha=90\u00b0\\) , bzw. die Vektoren \\(\\vec a\\) und \\(\\vec b\\) senkrecht aufeinander stehen, dass das Skalarprodukt 0 is","title":"Formeln"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#linienintegrale","text":"\\(W=\\int_\\gamma\\vec F\\cdot d\\vec \\gamma\\) Arbeit wurde in der BMS als \\(W=F\\cdot s\\) definiert. Nun kann aber \\(F\\) und \\(s\\) auch Vektoren sein. Hier kommt das Linienintegral ins Spiel, denn mit diesem kann man die Arbeit mit Vektoren ausrechnen. Der Vektor \\(\\vec F\\) und \\(\\vec \\gamma\\) m\u00fcssen nicht umbedingt in dieselbe Richtung zeigen. Wenn man z.B. einen Schlitten zieht, hat die Kraft \\(\\vec F\\) ca. eine 45\u00b0 gegen oben, w\u00e4hrend \\(\\vec \\gamma\\) die Strecke des Schlittens darstellt. Spannung kann auch als Linienintegral angesehen werden: \\(U(\\gamma)=\\int_\\gamma\\vec E \\cdot d\\vec \\gamma\\)","title":"Linienintegrale"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#spezialfalle","text":"Name Formel Bild Kreis Das Vektorfeld liegt \u00fcberall tangential an der Kurve und alle Vektoren haben dieselbe L\u00e4nge. \\(\\int_\\gamma\\vec U\\cdot d\\vec\\gamma =2\\pi r\\vert\\vec U\\vert\\) Rechteck Das Vektorfeld ist parallel zu zwei Seiten (A, C) des Rechteck. Entlang einer Seite haben die Vektoren eine konstante Gr\u00f6sse \\(\\int_\\gamma\\vec U \\cdot d\\vec \\gamma=aU_1-aU_5\\)","title":"Spezialf\u00e4lle"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#flussintegrale","text":"Beim Flussintegral wie viel Volumen \\(vdt\\) fliesst durch \\(A\\) , wenn es die Geschwindigkeit \\(\\vec U\\) hat. Dies kann als Integral geschrieben werden, in GED wird allerdings nur folgende Spezialf\u00e4lle behandelt. \\(U\\) sind in diesen Formel die L\u00e4nge der Pfeile.","title":"Flussintegrale"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#maxwellgleichungen","text":"","title":"Maxwellgleichungen"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#geschlossene-und-nicht-geschlossene-flachen","text":"Eine geschlossene Fl\u00e4che hat keinen Rand (wie zB. eine Kugel) und es gibt ein klares Innen und Aussen. Eine nicht geschlossene Fl\u00e4che hat einen Rand.","title":"Geschlossene und nicht-geschlossene Fl\u00e4chen"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#gausssche-gesetzt","text":"","title":"Gauss'sche Gesetzt"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#metalle","text":"","title":"Metalle"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#rechte-hand-regel","text":"","title":"Rechte-Hand Regel"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#rechte-hand-regel-2","text":"Wenn der Daumen in die technische Stromrichtung zeigt, dann zeigen die Finger den Umlaufsinn des \\(\\vec B\\) -Feldes an.","title":"Rechte-Hand Regel 2"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#vektorfelder","text":"\\[ \\vec E (x, y, z, t)=\\begin{bmatrix} E_x(x, y, z, t) \\\\ E_y(x, y, z, t) \\\\ E_z(x, y, z, t) \\\\ \\end{bmatrix} \\] Ein Vektor kann ein 2D oder 3D Koordinatensystem sein, in welchem Vektoren in eine Richtung zeigen. Diese Richtung kann zus\u00e4tzlich auch noch von der Zeit abh\u00e4ngig sein.","title":"Vektorfelder"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#magnetfeld","text":"\\([\\vec B(\\vec r, t)]=\\frac {Ns}{Cm}=\\frac{\\text{Newton Sekunden}}{\\text{Coulomb Meter}}=\\frac{kg}{s C} = \\text{Tesla}\\) Ein Magnetfeld wird in Teslas angegeben. Dabei ist ein Tesla kg pro Coulomb Sekunde oder Newton Sekunden pro Coulomb Meter. Um zu berechnen, mit vieviel Kraft ein Objekt mit einer Ladung beeinflusst wird, gibt es folgende Formel: \\(\\vec F = q(\\vec v \\times \\vec B)\\)","title":"Magnetfeld"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#elektrofeld","text":"\\([\\vec E (\\vec r, t)]=\\frac N C = \\frac V M = \\frac{kg}{ms^3A}\\) Ein Elektrofeld wird Newton pro Coulomb, Volt pro Meter oder Kilogram pro Meter Sekunden\u00b3 Amper angegeben. Die Einheiten bedeuten dasselbe (Coulomb = Amper Sekunde) Wenn ein Leiter positiv geladen ist, wirkt er abstossend zu Elektronen, wenn ein Leiter negative geladen ist, dann wirkt er anziehend. Zu dem sind die Pfeile im senkrecht auf dem Leiter. Um das Elektrofeld einer einzuelne Ladung zu berechnen, kann die folgende Formel verwendet werden","title":"Elektrofeld"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#elektrofelder-und-magnetfelder-zusammen","text":"Zeitlich ver\u00e4nderliche B-Felder erzeugen zeitlich ver\u00e4nderliche E-Felder, welche wiederum zeitlich ver\u00e4nderliche B-Felder erzeugen. Diesen Effekt f\u00fchrt zu einer Welle, welche sich ausbreitet. Initialisiert kann es z.B. von einer Antenne werden, welche nichts anderses als Str\u00f6me zeitlich ver\u00e4ndert durch einen Draht schickt.","title":"Elektrofelder und Magnetfelder zusammen"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#magnete","text":"Magnete haben immer einen Nord- und S\u00fcdpol. Wenn man ein Magnet trennt, entstehen zwei neue Magnete, mit jeweils einem Nord- und S\u00fcdpol. Wie auch bei elektrischen Feldern kann man auch bei magnetischen Feldern Linien zeichnen. Magnete wirken eine Kraft auf bewegte Ladung aus. Auf ruhende Ladung hat es keinen Effekt. Diese Kraft nennt sich Lorentz-Kraft und kann mit folgender Formel berechnet werden: \\(\\vec F_L=q\\cdot(\\vec v \\times \\vec B)\\) Wenn \\(\\vec v\\) senkrecht auf \\(\\vec B\\) steht,und \\(\\vec B\\) konstant ist, kann mit folgender Formel den Zusammenhang von der Geschwindigkeit der Ladung \\(\\vec v\\) mit dem Magnetfeld \\(\\vec B\\) und dem Radius \\(r\\) beschrieben werden: \\(m=\\frac{rq|\\vec B|}{v}\\) Bei Elementarteilchen ist die Ladung entweder \\(0\\) , \\(e\\) oder \\(-e\\) .","title":"Magnete"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#intensitat","text":"Die Intensit\u00e4t einer ebenen Welle kann mit der folgenden Formeln berechnet werden: $$ I_{em}=\\frac{E_0B_0}{2 \\mu _0}=\\frac{E^2_0}{2c\\mu_0}=\\frac{cB^2_0}{2\\mu_0}\\ $$ Dabei ist \\(\\mu_0\\) die magnetische Feldkonstante \\(1.257\\cdot10^{-6}=4\\pi\\cdot 10^{-7}\\)","title":"Intensit\u00e4t"},{"location":"21HS/GED/Physik/03_Elektromagnetismus.html#strahlendruck","text":"$$ p_s=\\frac{I_{em}}c=\\frac{E_0B_0}{2c\\mu_0}=\\frac{E^2}{2c^2\\mu_0}=\\frac{B^2_0}{2\\mu_0} $$","title":"Strahlendruck"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html","text":"Termische Strahlung Wichtig: Alle Temperaturen sind in Kelvin. Um von Celsius zu Kelvin zu konvertieren: \\(T_{kelvin}=T_{celsius}+273.15\\) Formeln Formel Erkl\u00e4rung \\(E\\) Sichtbares Licht Sichtbares Licht: Lichtbrechung $$ \\frac{\\sin(\\alpha)}{\\sin(\\beta)}=\\frac {c_1} {c_2}=\\frac{n_2}{n_1} $$ Dabei stellt \\(c\\) die Lichtgeschwindigkeit im jeweiligen Material dar und \\(n\\) der Brechungsindex. Totalreflexion Wenn ein Lichtstrahl genug Flach auf die \"Bruchkanta\" (z.B. die Wasseroberfl\u00e4che). In diesemfall wird alles zur\u00fcck reflektiert. F\u00fcr die Formel heisst das, dass \\(\\alpha\\ge 90\u00b0\\) oder \\(\\beta \\ge 90\u00b0\\) Photonen Jedem Photon wird eine Wellenl\u00e4nge, bzw eine Frequenz zu geordnet: \\(E=h\\nu\\) , dabei ist die Planck'sche Konstante \\(h=6.626\\cdot 10^{-34} [Js]\\) und \\(E\\) die Energie des Photons. Elektromagnitische Strahlung Eine Elektromagnetische Strahlung besteht aus einer Welle mit einer Wellenl\u00e4nge \\(\\lambda\\) und einer Frequenz \\(\\nu\\) . Die Formel \\(c=\\lambda\\cdot \\nu\\) zeigt den Zusammenhang zwischen \\(\\lambda\\) und \\(\\nu\\) . \\(c\\) ist dabei die Lichtgeschwindigkeit ( \\(c=3\\cdot10^8 m/s\\) ) Die Energie einer Strahlung kann mit \\(E=h\\nu\\) errechnet werden. \\(h\\) ist dabei die Planck'sche Konstante ( \\(h=6.626\\cdot10^b{-34}\\) ) Der Absorptionskoeffizent beschreibt, wie viel der Frequenzen ein K\u00f6rper absorbiert. 1 heisst, dass alles absorbiert wird, 0 , dass nichts absorbiert wird. Der Gegenpol, der Reflexionskoeffizent, beschreibt, wie viel der Frequenzen reflektiert werden und kann mit der folgenden Formel umgerechnet werden: \\(\\rho=1-\\alpha\\) Oft sind diese Koeffizenten abh\u00e4hngig von der Frequenz (also \\(\\alpha(\\nu)\\) und \\(\\rho(\\nu)\\) ). Ein blaues T-Shirt w\u00fcrde die \"blauen Frequenzen\" reflektieren und die anderen absorbieren. Bei einem schwarzen Strahler kann bewiessen werden, dass es keinen Unterschied gibt, ob die Strahlung vom Material 1 ins Material 2 oder umgekehrt geht. \\[ \\alpha_{1\\rightarrow 2}=\\alpha_{2\\rightarrow 1}\\\\ \\sigma_{1\\rightarrow 2}=\\sigma_{2\\rightarrow 1} \\] Emission Wenn eine Strahle von einem \"d\u00fcnnem\" Material, wie Luft, aufgenommen wird, wird von Emission von Strahlung gesprochen und anstatt dem Absorptionskoeffizent, wird der Emissionskoeffizenten \\(\\varepsilon\\) verwendet (es gilt also: \\(\\alpha_{2\\rightarrow1}=\\varepsilon_{2\\rightarrow 1}\\) ) Schwarzer Strahler Ein K\u00f6rper mit dem Reflexionskoeffizent \\(\\rho=0\\) und Absorptionskoeffizenten von \\(\\alpha=1\\) wird schwarzer Strahler genannt. Ein schwarzer Block kann als Schwarzerstrahler angen\u00e4hert werden (er reflektiert trotzdem noch ein wenig Licht), aber auch die Sonne , da diese keine Frequenzen und somit auch Licht reflektiert . Grauer Strahler Ein grauer Strahler ist ein K\u00f6rper, welcher in gewissen Wellenbereichen nicht so stark strahlen, wie ein schwarzer Strahler. Dass heisst, dass der Emmisionskoeffizent \\(\\varepsilon\\) nicht umbedingt 1 muss sein. Wien'sches Verschiebungsgesetzt Mit \\(\\lambda_{max}=\\frac b T\\) kann man die Temperatur in Kelvin zu der maximalen Wellenl\u00e4nge umrechnen. Mit dieser Formel kann man auch die Lichtfarbe, welche in Kelvin angegeben wird, erkl\u00e4ren. Stefan-Boltzmann Gesetzt (Gesammtleistung) Um die Gesamtleistung eines Strahlendenk\u00f6rpers zu berechnen kann man die folgende Formel ben\u00fctzten: \\(P_{rad}=\\sigma AT^4\\) Dabei ist \\(\\sigma=5.67\\cdot10^{-8} [Wm^{-2}K^{-4}]\\) , \\(A\\) die Oberfl\u00e4che des K\u00f6rpers und \\(T\\) die Temperatur des K\u00f6rpers. Energetische Bilanz eines Strahlers Die Energiebilanz sagt aus, ob Energie vom K\u00f6rper aufgenommen wird und er daher w\u00e4rmer wird oder ob mehr Energie abgegeben wird und er daher k\u00e4lter wird. Dies kann mit der folgenden Formel berechnet werden: $$ I=-\\frac{dE}{dt}=\\sigma\\varepsilon A(T^4-T_{env}^4) $$ Dabei ist \\(\\sigma=5.67\\cdot10^{-8}\\) , \\(\\varepsilon\\) den Emmisionskoeffizenten, \\(A\\) die Oberfl\u00e4che des K\u00f6rpers, \\(T\\) die Temperator des K\u00f6rpers und \\(T_{env}\\) die Umgebungstemperatur. Bei einem grauen Strahler kann \\(\\varepsilon \\neq1\\) sein. Wie man an der Formeln mit den Temperaturen erkennen kann, wird die Temperatur hoch 4 gerechnet. Dies f\u00fchrt bei einer 16-facher vergr\u00f6sserung, wenn die Temperatur verdoppelt wird. Ein \u00e4hliches Ph\u00e4nomen gibt es, wenn die L\u00e4nge eines K\u00f6rpers veroppelt werden, wird die Fl\u00e4che vervierfacht und das Volumen verachtfacht. Sonneneinstrahlung Um zu berechnen, wie viel Energie die Sonne auf die Erde strahlt, kann folgende Formel gebraucht werden: $$ I=\\sin(\\beta)Aj $$ Dabei ist \\(\\beta\\) den Einstrahls-Winkel der Sonne, \\(A\\) die Fl\u00e4che, wo f\u00fcr man die Energie \\(I\\) berechnen m\u00f6chte und \\(j\\) der Faktor der Sonneneinstrahlung. W\u00e4rmeleitung \\[ I=-Ah_{X,Y}(T_X-T_Y) \\] Mit dieser Formel kann der W\u00e4rmestrom (Energie pro Zeit) berechnet werden, welcher von einem Objekt \\(X\\) mit der Temperatur \\(T_X\\) zu einem Objekt \\(Y\\) mit der Temperatur \\(T_Y\\) fliesst. \\(A\\) ist dabei die Ber\u00fchrungsfl\u00e4che der zwei Objekte und \\(h_{X,Y}\\) ist der W\u00e4rme\u00fcbertragunskoeffizent.","title":"Termische Strahlung"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#termische-strahlung","text":"Wichtig: Alle Temperaturen sind in Kelvin. Um von Celsius zu Kelvin zu konvertieren: \\(T_{kelvin}=T_{celsius}+273.15\\)","title":"Termische Strahlung"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#formeln","text":"Formel Erkl\u00e4rung \\(E\\)","title":"Formeln"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#sichtbares-licht","text":"Sichtbares Licht:","title":"Sichtbares Licht"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#lichtbrechung","text":"$$ \\frac{\\sin(\\alpha)}{\\sin(\\beta)}=\\frac {c_1} {c_2}=\\frac{n_2}{n_1} $$ Dabei stellt \\(c\\) die Lichtgeschwindigkeit im jeweiligen Material dar und \\(n\\) der Brechungsindex.","title":"Lichtbrechung"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#totalreflexion","text":"Wenn ein Lichtstrahl genug Flach auf die \"Bruchkanta\" (z.B. die Wasseroberfl\u00e4che). In diesemfall wird alles zur\u00fcck reflektiert. F\u00fcr die Formel heisst das, dass \\(\\alpha\\ge 90\u00b0\\) oder \\(\\beta \\ge 90\u00b0\\)","title":"Totalreflexion"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#photonen","text":"Jedem Photon wird eine Wellenl\u00e4nge, bzw eine Frequenz zu geordnet: \\(E=h\\nu\\) , dabei ist die Planck'sche Konstante \\(h=6.626\\cdot 10^{-34} [Js]\\) und \\(E\\) die Energie des Photons.","title":"Photonen"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#elektromagnitische-strahlung","text":"Eine Elektromagnetische Strahlung besteht aus einer Welle mit einer Wellenl\u00e4nge \\(\\lambda\\) und einer Frequenz \\(\\nu\\) . Die Formel \\(c=\\lambda\\cdot \\nu\\) zeigt den Zusammenhang zwischen \\(\\lambda\\) und \\(\\nu\\) . \\(c\\) ist dabei die Lichtgeschwindigkeit ( \\(c=3\\cdot10^8 m/s\\) ) Die Energie einer Strahlung kann mit \\(E=h\\nu\\) errechnet werden. \\(h\\) ist dabei die Planck'sche Konstante ( \\(h=6.626\\cdot10^b{-34}\\) ) Der Absorptionskoeffizent beschreibt, wie viel der Frequenzen ein K\u00f6rper absorbiert. 1 heisst, dass alles absorbiert wird, 0 , dass nichts absorbiert wird. Der Gegenpol, der Reflexionskoeffizent, beschreibt, wie viel der Frequenzen reflektiert werden und kann mit der folgenden Formel umgerechnet werden: \\(\\rho=1-\\alpha\\) Oft sind diese Koeffizenten abh\u00e4hngig von der Frequenz (also \\(\\alpha(\\nu)\\) und \\(\\rho(\\nu)\\) ). Ein blaues T-Shirt w\u00fcrde die \"blauen Frequenzen\" reflektieren und die anderen absorbieren. Bei einem schwarzen Strahler kann bewiessen werden, dass es keinen Unterschied gibt, ob die Strahlung vom Material 1 ins Material 2 oder umgekehrt geht. \\[ \\alpha_{1\\rightarrow 2}=\\alpha_{2\\rightarrow 1}\\\\ \\sigma_{1\\rightarrow 2}=\\sigma_{2\\rightarrow 1} \\]","title":"Elektromagnitische Strahlung"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#emission","text":"Wenn eine Strahle von einem \"d\u00fcnnem\" Material, wie Luft, aufgenommen wird, wird von Emission von Strahlung gesprochen und anstatt dem Absorptionskoeffizent, wird der Emissionskoeffizenten \\(\\varepsilon\\) verwendet (es gilt also: \\(\\alpha_{2\\rightarrow1}=\\varepsilon_{2\\rightarrow 1}\\) )","title":"Emission"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#schwarzer-strahler","text":"Ein K\u00f6rper mit dem Reflexionskoeffizent \\(\\rho=0\\) und Absorptionskoeffizenten von \\(\\alpha=1\\) wird schwarzer Strahler genannt. Ein schwarzer Block kann als Schwarzerstrahler angen\u00e4hert werden (er reflektiert trotzdem noch ein wenig Licht), aber auch die Sonne , da diese keine Frequenzen und somit auch Licht reflektiert .","title":"Schwarzer Strahler"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#grauer-strahler","text":"Ein grauer Strahler ist ein K\u00f6rper, welcher in gewissen Wellenbereichen nicht so stark strahlen, wie ein schwarzer Strahler. Dass heisst, dass der Emmisionskoeffizent \\(\\varepsilon\\) nicht umbedingt 1 muss sein.","title":"Grauer Strahler"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#wiensches-verschiebungsgesetzt","text":"Mit \\(\\lambda_{max}=\\frac b T\\) kann man die Temperatur in Kelvin zu der maximalen Wellenl\u00e4nge umrechnen. Mit dieser Formel kann man auch die Lichtfarbe, welche in Kelvin angegeben wird, erkl\u00e4ren.","title":"Wien'sches Verschiebungsgesetzt"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#stefan-boltzmann-gesetzt-gesammtleistung","text":"Um die Gesamtleistung eines Strahlendenk\u00f6rpers zu berechnen kann man die folgende Formel ben\u00fctzten: \\(P_{rad}=\\sigma AT^4\\) Dabei ist \\(\\sigma=5.67\\cdot10^{-8} [Wm^{-2}K^{-4}]\\) , \\(A\\) die Oberfl\u00e4che des K\u00f6rpers und \\(T\\) die Temperatur des K\u00f6rpers.","title":"Stefan-Boltzmann Gesetzt (Gesammtleistung)"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#energetische-bilanz-eines-strahlers","text":"Die Energiebilanz sagt aus, ob Energie vom K\u00f6rper aufgenommen wird und er daher w\u00e4rmer wird oder ob mehr Energie abgegeben wird und er daher k\u00e4lter wird. Dies kann mit der folgenden Formel berechnet werden: $$ I=-\\frac{dE}{dt}=\\sigma\\varepsilon A(T^4-T_{env}^4) $$ Dabei ist \\(\\sigma=5.67\\cdot10^{-8}\\) , \\(\\varepsilon\\) den Emmisionskoeffizenten, \\(A\\) die Oberfl\u00e4che des K\u00f6rpers, \\(T\\) die Temperator des K\u00f6rpers und \\(T_{env}\\) die Umgebungstemperatur. Bei einem grauen Strahler kann \\(\\varepsilon \\neq1\\) sein. Wie man an der Formeln mit den Temperaturen erkennen kann, wird die Temperatur hoch 4 gerechnet. Dies f\u00fchrt bei einer 16-facher vergr\u00f6sserung, wenn die Temperatur verdoppelt wird. Ein \u00e4hliches Ph\u00e4nomen gibt es, wenn die L\u00e4nge eines K\u00f6rpers veroppelt werden, wird die Fl\u00e4che vervierfacht und das Volumen verachtfacht.","title":"Energetische Bilanz eines Strahlers"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#sonneneinstrahlung","text":"Um zu berechnen, wie viel Energie die Sonne auf die Erde strahlt, kann folgende Formel gebraucht werden: $$ I=\\sin(\\beta)Aj $$ Dabei ist \\(\\beta\\) den Einstrahls-Winkel der Sonne, \\(A\\) die Fl\u00e4che, wo f\u00fcr man die Energie \\(I\\) berechnen m\u00f6chte und \\(j\\) der Faktor der Sonneneinstrahlung.","title":"Sonneneinstrahlung"},{"location":"21HS/GED/Physik/04_Thermische_Strahlung.html#warmeleitung","text":"\\[ I=-Ah_{X,Y}(T_X-T_Y) \\] Mit dieser Formel kann der W\u00e4rmestrom (Energie pro Zeit) berechnet werden, welcher von einem Objekt \\(X\\) mit der Temperatur \\(T_X\\) zu einem Objekt \\(Y\\) mit der Temperatur \\(T_Y\\) fliesst. \\(A\\) ist dabei die Ber\u00fchrungsfl\u00e4che der zwei Objekte und \\(h_{X,Y}\\) ist der W\u00e4rme\u00fcbertragunskoeffizent.","title":"W\u00e4rmeleitung"},{"location":"21HS/GED/Physik/05_Signale.html","text":"Signale Signalarten Name Bild Sinussignal Rechtecksignal S\u00e4gezahnsignal Dreieckssignal Eine Welle wird haupts\u00e4chlich durch ihre Amplitude \\(A\\) , Periode \\(T\\) , Frequenz \\(\\nu\\) und Phasenverschiebung \\(\\varphi\\) definiert. Mit \\(T=\\frac 1 \\nu\\) kann man von der Frequenz \\(\\nu\\) zur Periode \\(T\\) umwandeln. Ein Sinussignal kann in ein Cosinussignal und umgekehrt folgendermassen umgewandelt werden: $$ sin(a-\\frac \\pi 2)=cos(a)\\ cos(a+\\frac \\pi 2)=sin(a) $$ Fourierzerlegung Man kann jede Funktion in eine Summe von Cosinusen oder Sinusen zerlegen T\u00f6ne und Klangfarbe Neben eines Grundtones produziert ein Instrument auch noch Obert\u00f6ne. Als Daumenregeln: Je mehr Obert\u00f6ne, desto sch\u00e4rfer t\u00f6nt ein Instrument. Nyquist - Shannon Theorem Es m\u00fcssen doppelt so viele Messpunkte existieren, wie die maximale Frequenz: \\(f_{measure}>2\\cdot f_{max}\\) . Wenn dies nicht gegeben ist, tritt Aliasing auf und es werden falsche Frequenzen gespeichert. F\u00fcr die tiefste Frequenz gilt, dass das Intervall \\(T\\) zwischen den Messpunkten : \\(T > \\frac 1 {f_{min}}\\) Blip Ein Blip ist ein kurzes Signal. Dabei gilt, je k\u00fcrzer der Blip, desto mehr Frequenzen gibt es um die Hauptfrequenz \\(\\nu_0\\) Ein zweites Prinzip, das \u00e4hlich funktioniert: Je steiler eine Flanke eines Signales, desto mehr Frequenzen werden ben\u00f6tigt, um die Flanke darzustellen. Schnelle Orgeln Damit ein Ton als harmonisch empfunden wird, muss eine Frequenz domonieren. Bei einem Blip ist dies allerdings nicht umbedingt gegeben. Ebenfalls gilt, je h\u00f6her ein Ton, desto k\u00fcrzer kann er sein, dass trotzdem noch eine Frequenz dominiert und der Ton harmonisch klingt. Aus diesem Grund kann eine Picolo schnell spielen und eine tiefe Orgel nicht. Mathematisch kann diese Relation folgendermassen ausgedr\u00fcckt werden: $$ \\frac{\\Delta f\\cdot \\Delta t}{2}\\sim 1 $$ Signal-to-Noise Ratio \\(A_{noise}=\\text{Die durchschnittliche Noise Amplitude}\\) $$ SNR=\\frac{P_{signal}} {P_{noise}}=\\frac{I_{signal}} {I_{noise}}=\\frac{A^2_{signal}}{A^2_{noise}} $$ Dabei bezeichnet \\(P\\) die Leistung, \\(I\\) die Intensit\u00e4t und \\(A\\) die Amplitude.","title":"Signale"},{"location":"21HS/GED/Physik/05_Signale.html#signale","text":"","title":"Signale"},{"location":"21HS/GED/Physik/05_Signale.html#signalarten","text":"Name Bild Sinussignal Rechtecksignal S\u00e4gezahnsignal Dreieckssignal Eine Welle wird haupts\u00e4chlich durch ihre Amplitude \\(A\\) , Periode \\(T\\) , Frequenz \\(\\nu\\) und Phasenverschiebung \\(\\varphi\\) definiert. Mit \\(T=\\frac 1 \\nu\\) kann man von der Frequenz \\(\\nu\\) zur Periode \\(T\\) umwandeln. Ein Sinussignal kann in ein Cosinussignal und umgekehrt folgendermassen umgewandelt werden: $$ sin(a-\\frac \\pi 2)=cos(a)\\ cos(a+\\frac \\pi 2)=sin(a) $$","title":"Signalarten"},{"location":"21HS/GED/Physik/05_Signale.html#fourierzerlegung","text":"Man kann jede Funktion in eine Summe von Cosinusen oder Sinusen zerlegen","title":"Fourierzerlegung"},{"location":"21HS/GED/Physik/05_Signale.html#tone-und-klangfarbe","text":"Neben eines Grundtones produziert ein Instrument auch noch Obert\u00f6ne. Als Daumenregeln: Je mehr Obert\u00f6ne, desto sch\u00e4rfer t\u00f6nt ein Instrument.","title":"T\u00f6ne und Klangfarbe"},{"location":"21HS/GED/Physik/05_Signale.html#nyquist-shannon-theorem","text":"Es m\u00fcssen doppelt so viele Messpunkte existieren, wie die maximale Frequenz: \\(f_{measure}>2\\cdot f_{max}\\) . Wenn dies nicht gegeben ist, tritt Aliasing auf und es werden falsche Frequenzen gespeichert. F\u00fcr die tiefste Frequenz gilt, dass das Intervall \\(T\\) zwischen den Messpunkten : \\(T > \\frac 1 {f_{min}}\\)","title":"Nyquist - Shannon Theorem"},{"location":"21HS/GED/Physik/05_Signale.html#blip","text":"Ein Blip ist ein kurzes Signal. Dabei gilt, je k\u00fcrzer der Blip, desto mehr Frequenzen gibt es um die Hauptfrequenz \\(\\nu_0\\) Ein zweites Prinzip, das \u00e4hlich funktioniert: Je steiler eine Flanke eines Signales, desto mehr Frequenzen werden ben\u00f6tigt, um die Flanke darzustellen.","title":"Blip"},{"location":"21HS/GED/Physik/05_Signale.html#schnelle-orgeln","text":"Damit ein Ton als harmonisch empfunden wird, muss eine Frequenz domonieren. Bei einem Blip ist dies allerdings nicht umbedingt gegeben. Ebenfalls gilt, je h\u00f6her ein Ton, desto k\u00fcrzer kann er sein, dass trotzdem noch eine Frequenz dominiert und der Ton harmonisch klingt. Aus diesem Grund kann eine Picolo schnell spielen und eine tiefe Orgel nicht. Mathematisch kann diese Relation folgendermassen ausgedr\u00fcckt werden: $$ \\frac{\\Delta f\\cdot \\Delta t}{2}\\sim 1 $$","title":"Schnelle Orgeln"},{"location":"21HS/GED/Physik/05_Signale.html#signal-to-noise-ratio","text":"\\(A_{noise}=\\text{Die durchschnittliche Noise Amplitude}\\) $$ SNR=\\frac{P_{signal}} {P_{noise}}=\\frac{I_{signal}} {I_{noise}}=\\frac{A^2_{signal}}{A^2_{noise}} $$ Dabei bezeichnet \\(P\\) die Leistung, \\(I\\) die Intensit\u00e4t und \\(A\\) die Amplitude.","title":"Signal-to-Noise Ratio"},{"location":"21HS/GED/Physik/all-ged-summaries.html","text":"Formeln Elektronik Themische Strahlungen Noch zu lernen Ch\u00fcgeli F\u00fcsik Kraft Beschleunigung und co. Energie Elektrotechnik Strom, Spannung und Leistung Schaltung Knotenregel Maschenregel Batterien Wiederstand Kondensator Spulen Unged\u00e4mpfte Schwingkreise Ged\u00e4mpfte Schwingungskreise Low-Pass und High-Pass-Filter Draht Karnaugh-Veitsch Diagramme Transformer Stromnetz Wechsel- vs. Gleichstrom Drehstrom Gefahr durch Strom Elektromagnetismus Formeln Linienintegrale Spezialf\u00e4lle Flussintegrale Maxwellgleichungen Geschlossene und nicht-geschlossene Fl\u00e4chen Gauss'sche Gesetzt Metalle Rechte-Hand Regel Rechte-Hand Regel 2 Vektorfelder Magnetfeld Elektrofeld Elektrofelder und Magnetfelder zusammen Magnete Intensit\u00e4t Strahlendruck Termische Strahlung Formeln Sichtbares Licht Lichtbrechung Totalreflexion Photonen Elektromagnitische Strahlung Emission Schwarzer Strahler Grauer Strahler Wien'sches Verschiebungsgesetzt Stefan-Boltzmann Gesetzt (Gesammtleistung) Energetische Bilanz eines Strahlers Sonneneinstrahlung W\u00e4rmeleitung Signale Signalarten Fourierzerlegung T\u00f6ne und Klangfarbe Nyquist - Shannon Theorem Blip Schnelle Orgeln Signal-to-Noise Ratio Formeln In dieser Datei werden alle Formeln und Konstanten zusammen gefasst. Prefix Exponent peta \\(10^{15}\\) tera \\(10^{12}\\) giga \\(10^9\\) mega \\(10^6\\) kilo \\(10^3\\) hecto \\(10^2\\) deca \\(10^1\\) - \\(10^0\\) dezi \\(10^{-1}\\) cento \\(10^{-2}\\) milli \\(10^{-3}\\) micro \\(10^{-6}\\) nano \\(10^{-9}\\) pico \\(10^{-12}\\) femto \\(10^{-15}\\) Elektronik Thema Formeln Erkl\u00e4rung \\(I [A]\\) Strom \\(U [V]\\) Spannung Wiederst\u00e4nde \\(U=R\\cdot I\\) Formel f\u00fcr Ohmnische Wiederst\u00e4nde Wiederst\u00e4nde \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Formel zum zwei parallele Wiederst\u00e4nde zusammen zu fassen Kondensator \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U\\) und der Ladung \\(Q\\) Kondensator \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden Kondensator \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet Kondensator \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet Kondensator \\(\\tau=R\\cdot C\\) Der Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\) auf/ab in der Zeit \\(\\tau\\) Themische Strahlungen Konstante Erkl\u00e4rung \\(c=3\\cdot 10^8m/s\\) Lichtgeschwindigkeit im Vakum \\(h=6.626\\cdot10^{-34} Js\\) Planck'sche Konstante Formel Erkl\u00e4rung \\(c=\\lambda \\cdot\\nu\\) Dies ist der Zusammenhang zwischen der Wellenl\u00e4nge \\(\\lambda\\) und der Frequenz \\(\\nu\\) . \\(c\\) ist die Lichtgeschwindigkeit \\(E=h\\nu\\) Die Energie einer Strahlung mit der Frequenz \\(\\nu\\) . \\(h\\) ist die Plank'sche Konstante \\(\\rho(\\nu)=1-\\alpha(\\nu)\\) Umrechnungs Formel zwischen Reflektionskoeffizenten ( \\(\\rho\\) ) und Absorptionskoeffizenten ( \\(\\alpha\\) ) Noch zu lernen B-Felder induziert E-Felder In welche Richtung positive E-Felder anziehen oder abstossen Ch\u00fcgeli F\u00fcsik Kraft \\(\\vec F = m \\cdot \\vec a\\) Diese Formel nimmt einiges an: Bewegung in einer Dimension (keine Vektoren) Konstante Beschleunigung (a = const.) Start bei \\(s(0)=0\\) Anfangsgeschwindigkeit bei Beschleunigung und co. Hier sind einige g\u00e4ngige Formeln aufgelistet, welche hilfreich bei Beschleunigung sind. In der obersten Reihe steht, was die Formel ergeben soll. In der ersten Spalte, was sich nicht \u00e4ndert und somit nicht in der Formel erw\u00e4hnt wird. t s v a t - \\(s=\\frac{v^2}{2a}\\) \\(v=\\sqrt{2as}\\) \\(a=\\frac{v^2}{2s}\\) s \\(t=\\frac{v}{a}\\) - \\(v=at\\) \\(a=\\frac{v}{t}\\) v \\(t=\\sqrt{\\frac{2s}{a}}\\) \\(s=\\frac{at^2}{2}\\) - \\(a=\\frac{2s}{t^2}\\) a \\(t=\\frac{2s}{v}\\) \\(s=\\frac{vt}{2}\\) \\(v=\\frac{2s}{t}\\) - Energie Energie ist \\(Kraft \\cdot Strecke\\) . Es gilt also die Formel \\(E=F\\cdot s [J]\\) . Die Masseinheit \\(J\\) kann auch als \\(\\frac{kgm^2}{s^2}\\) Elektrotechnik Strom, Spannung und Leistung Ampere ist die Einheit des Stromes \\(I\\) und ist Coulomb pro Sekunde \\([Cs^{-1}]\\) . Die H\u00f6he zwischen zwei Energiepotentialen nennt sich die Spannung \\(U\\) ( \\(U(\\vec r_A,\\vec r_B)=\\varphi(\\vec r_A)-\\varphi(\\vec r_B)\\) ). Spannung kann aber auch \u00fcber Arbeit definiert werden. Die Spannung zwischen zwei Punkten \\(A\\) und \\(B\\) ist die Energie pro Ladung, welche frei wird, wenn die Ladung von \\(A\\) nach \\(B\\) bewegt wird: \\(U=\\int^{\\vec r_B}_{\\vec r_A}\\vec E d\\vec r\\) . Die kinetische Energie, welche eine Ladung \\(q\\) gewinnt, wenn sie eine Spannung \\(U\\) \"herunterf\u00e4llt\" betr\u00e4gt: \\(\\Delta E_{kin}=\\int^{\\vec r_B}_{\\vec r_A}\\vec q\\cdot E d\\vec r=q\\cdot U\\) Schaltung Knotenregel Die Knotenregel besagt, dass was in einen Knoten hinein geht, muss auch wieder aus dem Knoten hinaus. Oder \\(I_1=I_2+I_3\\) bzw. \\(I_6=i_5+I_4\\) Maschenregel Die Maschenregel besagt, dass alle Spannungen in einer Masche zusammen \\(0\\) ergeben m\u00fcssen. Man rechnet plus wenn es in die Referenzrichtung eines Bauteils geht und minus , wenn es gegen die Referenzrichtung geht. Ebenfalls wichtig zu erw\u00e4hnt ist, dass eine Batterie in die andere Richtung zeigt, als die anderen Bauteile (Dies ist einwenig komisch im Beispiel oben). In der gr\u00fcnen Maschen sieht man, wie dies aussehen kann, f\u00fcr eine Masche, welche nicht \u00fcber die Baterie geht: \\(U_4-U_5=0\\) Batterien Reale Batterien haben einen Innenwiederstand, welcher in Serie mit der Batterie geschalten ist. Dass heisst, dass die realte Spanung einer Batterie kleiner als \\(U_0\\) ist, da \\(U_{in}\\) abgezogen werden muss. Wiederstand Ein Wiederstand folgt dem Ohm'sche Gesetzt. Dass heisst, ein Wiederstand kann mit \\(U=R\\cdot I\\) berechnet werden. Da f\u00fcr die Leistung gillt \\(P=U\\cdot I\\) , kann in diese Formel das Ohm'sche Gesetzt eingesetzt werden, um die Formel \\(P=\\frac {U^2} R=I^2R\\) zu bekommen. Wegen der Knoten und Maschenregeln verhalten sich Wiederst\u00e4nde (wie auch andere Bauteile) anderst, jenach dem, ob sie Parallel oder Serial angeschlossen sind. Name Erkl\u00e4rung Bild Parallel geschaltet In einer Parallelschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusammen gefasst werden: \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Seriel geschaltet In einer Serielschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusamengefasst werden: \\(R_{12}=R_1+R_2\\) Kondensator Ein Kondensator (oder Capacitor) kann man sich als Feder vorstellen, welche aus zwei Metallplatten nahe bei einander bestehen. Es wird Strom hinein \"gepumpt\". Dies wird immer schwerer, je voller der Kondensator wird, bis am Ende der Kondensator voll ist. Das zweite wichtige an einem Kondensator ist, dass keine Elektronen durch ihn durch fliessen k\u00f6nnen. Anstelle dessen sammeln sich auf der einen Seite mehr Elektronen an, auf der anderen Seite werden die bereits vorhanden Elektronen abgesaugt. formel Erkl\u00e4rung \\(\\frac {dQ}{dt}=I\\) Die Ver\u00e4nderungsrate der Ladung, ist der Strom \\(I\\) \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U [V]\\) und der Ladung \\(Q\\) abh\u00e4ngig von der Kapazit\u00e4t \\(C [F]\\) in Farad \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet \\(U_C(t)=U_0\\cdot e^{-\\frac t {RC}}\\) Wie sich die Spannung \\(U\\) beim Entladen verhaltet \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet \\(\\tau=R\\cdot C\\) Die Zeitkonstante \\(\\tau\\) . Der Strom des Kondensator f\u00e4llt auf ca \\(\\frac 1 e\\approx0.37\\) ab in der Zeit \\(\\tau\\) oder steigt auf \\(1-\\frac 1 e\\approx0.63\\) in \\(\\tau\\) an, wenn der Kondensator geladen wird Spulen Wenn durch ein Draht Strom fliesst, entsteht ein Magnetfeld. Dies ist ebenfalls der Fall bei einer Spule. Wenn der Strom hochgefahren wird, dann wird ein Magnetfeld aufgebaut. Dies ben\u00f6tigt aber Energie, was wiederum einen Wiederstand erzeugt. Wenn der Strom abgebaut wird, wir die Energie des Magnetfeldes wieder zur\u00fcck in die Spannung gespiessen und \u00fcber der Spule entsteht eine Spannung, welche den Strom antreibt. Die Richtung des Magnetfeldes findet man heraus, in dem man die Rechte hand nimmt und mit dem Daumen in die Ricthung des - zeigt, bzw. die Stromrichtung auf dem Schaltungsplan (nicht die physikalische Stromrichtung, die ist in die andere Richtung). Formel Erkl\u00e4rung \\(U_L=L\\frac{dI}{dt}\\) Die Ver\u00e4nderungsrate von dem Strom \\(I\\) mit der Konstante \\(L [Henry]\\) multipliziert, ergibt die Spannung Unged\u00e4mpfte Schwingkreise In einem Schwingungskreis, schwingen die Elektronen zwischen den zwei Platten des Kondensators hin und her. Dies kann man in die folgende Schritte unterteilen: Der Kondensator ist geladen und es herrscht eine Spanung \\(U_0\\) \u00fcber dem Kondensator. Der Schalter ist aber noch offen. Der Schalter \\(s_1\\) wurde geschlossen und der Strom fliesst. Wegen dem Maschensatz muss \\(U_C=U_L\\) sein. Da die Spannung \\(U_C\\) w\u00e4chst, muss auch der Strom \\(I\\) wachsen und somit ein Magnetfeld \u00fcber L entstehen. Der Strom \\(I\\) und somit auch das Magnetfeld \\(B\\) sind maximal. Irgendwann wird der Kondensator leer sein (Auf beiden Seiten der Platte sind gleich viele Elektronen) und \\(U_L\\) und \\(UC\\) sind 0. Somit gilt auch \\(I=0\\) . Da nun der Strom in der Spule freigesetzt wird, l\u00e4dt sich der Kondensator wieder auf (allerdings mit einem anderen Vorzeichen) und so entsteht wieder eine Spannung \\(U_C\\) \u00fcber dem Kondensator. So bald die Spule \"leer\" ist, wechselt die Stromrichtung wieder Der Zyklus wiederholt sich nun wiede Formel Erkl\u00e4rung \\(Q(t)=CU_0\\cdot \\cos(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Die Ladung \\(Q\\) eines Schwinungskreises \\(I(t)=-\\sqrt {\\frac C L}\\cdot U_0\\cdot \\sin(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Der Strom \\(I\\) eines Schwinungskreises \\(U_L(t)=-\\frac 1 {\\sqrt{LC}}\\cdot U_0\\cdot \\cos(\\frac 1 {\\sqrt{LC}} \\cdot t)\\) Die Spannun \\(U_L\\) eines Schwinungskreises \\(f=\\frac 1 {2\\pi\\sqrt{LC}}\\) Die Frequenz \\(f\\) , mit welcher der Schwingunskreis schwingt \\(T=2\\pi\\sqrt{LC}\\) Die Periodendauer \\(T\\) , welche eine Schwinung des Schwingungskreis ben\u00f6tigt Ged\u00e4mpfte Schwingungskreise Der Strom im Schwinungskreis wird schw\u00e4cher, wenn \\(R < 2\\sqrt {\\frac L C}\\) (oder wenn \\(\\frac{R^2}{4L^2}>\\frac 1 {LC}\\) ist) Wenn dies gegeben ist, dann ist es ein ged\u00e4mpfter Schwingungskreis. Formel Erkl\u00e4rung \\(Q(t)=Q_0e^{-\\frac t \\tau}\\cos(\\omega_dt-\\phi_0)\\) Die Ladung des Schwinungskreis1 \\(f=\\frac 1 {2\\pi}\\sqrt{\\frac 1 {LC} -\\frac{R^2}{4L^2}}\\) , \\(T=\\frac 1 f\\) Die (Kreis-)frequenz \\(\\omega_d\\) \\(\\tau=\\frac{2L} R\\) Die Zeitkonstante \\(\\tau\\) der D\u00e4mpfung. Der Strom des Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\%\\) auf/ab in der Zeit \\(\\tau\\) Low-Pass und High-Pass-Filter Bei einem Low-Pass-Filter werden die tiefen Frequenzen durchgelassen und die Hochen weggefiltert. Bei einem High-Pass-Filter ist es umgekehrt und die hochen Frequenzen werden duch gelassen und die tiefen weggefiltert. \u00dcber dem Wiederstand misst man ein Signal, bei welchem die tiefen Frequenzen ged\u00e4mpft wurden und die hochen Frequenzen fast unver\u00e4ndert. Dies w\u00e4re ein High-Pass-Filter. Hingegen \u00fcber dem Kondensator misst werden die hochen Frequenzen ged\u00e4mpft und die tiefen durchgelassen, was ein Low-Pass-Filter ist. Draht Der Wiederstand in einem Kabel ist ungef\u00e4hr: \\(R=\\rho\\frac L A\\) , wobei \\(\\rho\\) den spezifischen Wiederstand mit der Einheit \\([mm^2m^{-1}\\Omega]\\) . \\(L\\) ist die L\u00e4nge in \\([m]\\) und \\(A\\) ist die Querschnittsfl\u00e4che in \\([mm^2]\\) . Karnaugh-Veitsch Diagramme Ein KV-Diagram kann praktisch sein, um eine Wahrheitstabelle mit vier Inputs in eine Schaltung zu verwandeln. Daf\u00fcr wird zuerst die Wahrheitstabelle in das folgende Raster einf\u00fchrt. Dabei ist oben, bzw. auf der linken Seite das erste Bit und auf der unteren/rechten Seite das linke Bit. Das Feld oben rechts stellt also f\u00fcr den Wert aus der Wahrheitstabelle A=1, B=0, C=0, D=0. Wenn dies getan ist, versucht man Bl\u00f6cke mit Einsen zu finden. Die Bl\u00f6cke k\u00f6nnen 1, 2, 4, 8 oder 16 lang und/oder breit sein. Falls es egal ist, ob ein Input 0 oder 1 ist, kann er so betrachtet werden, dass es sch\u00f6nere Bl\u00f6cke gibt. Ebenfalls wichtig, ein Block darf \u00fcber die Kante hinausgehen. Im letzten Schritt wird nun aus den Bl\u00f6cken Und-Schaltungen gebaut. Dabei m\u00fcssen zwei Dinge beachtet werden: Wenn ein Block \u00fcber den not und \"normalen\" Block geht (z.B. A und not-A), dann muss das And-Gate keine Verbindung zu diesem Input haben, da es in beiden F\u00e4llen true ist. Wenn ein Block nur \u00fcbr ein Block geht (z.B. nur \u00fcber den A oder nur den not-A Block), dann muss das And-Gate mit diesem Input verbunden sein. Hier sieht man noch das Beispiel f\u00fcr die oberigen Bl\u00f6cke. Transformer Stromnetz In unserem Stromnetzt werden mehrere Spannungen gen\u00fctzt. Zum einten m\u00f6chte man hohe Spannungen f\u00fcrs Transportieren von Strom ben\u00fctzten, da dies um einiges effizienter ist. Allerdings ist es zu gef\u00e4hrlich Hochspannung direkt im Haus zu gebrauchen. Daher hat man vier Netzebenen, welche mit Transformern gekoppelt sind. 1 Ebene - H\u00f6chstspannungsebene : 380kV, bzw. 220 kV aus dem Kraftwerk oder vom Ausland 3 Ebene - Hochspannungsebene : 36kV - 150kV: \u00dcberregionale Verteilungsnetzte 5 Ebene - Mittelspannungsebene : 1kV - 36kV: Regionale Verteilungsnetzte 7 Ebene - Niederspannungsebene : < 1kV: Lokale Verteilungsnetzte Die Ebenen 2, 4 und 6 sind die Transformatorenebenen. Auf diesen Ebenen wird der Strom auf die n\u00e4chst tiefere oder h\u00f6here Ebene transformiert. Wechsel- vs. Gleichstrom Man hat sich in der Vergangenheit auf Wechselstrom geeinigt, weil es relativ einfach ist, Wechselstrom zu transformieren. Heute ist dies aber auch mit Gleichstrom m\u00f6glich. Gleichstrom erzeugt weniger Verl\u00fcste, wenn transportiert auf lange Streckenen, als Wechselstrom, da Wechselstrom nah an der Kabeloberfl\u00e4chse fliest und daher ein st\u00e4rkeres Magnetfeld erzeugt. Der \\(U_{Eff}\\) kann mit der folgender Formel berechnet werden: \\(U_{Eff}=\\frac{U_S}{\\sqrt 2}\\) . Dies berechnet den quadratischen Mittelwert einer Wechselspannung. Der Sinus kann mit der folgenden Formel angegebene werden: \\(f(t)=U_{Eff}\\cos(\\omega\\cdot t)=U_{Eff}\\cos(f\\cdot 2\\pi\\cdot t)\\) Drehstrom (Siehe Script_GED_Lect_3_4.pdf) Drehstrom ist praktisch f\u00fcr Motoren, da es keine \"Totenp\u00fcnkte\" gibt, an dem ein Magnet stoppen k\u00f6nnte. Zudem sind alle H\u00e4user in der Schweiz an einem Drehstrom angeschlossen. Auf den Aussenleiter wird der Strom \"transportiert\" und stehen gegen\u00fcber der Erde unter einer Spannung von 230V. Der Neutralleiter ist der \"Ausgang\" f\u00fcr die Elektronen, welche \u00fcber die Aussenleiter hinein gepumpt werden. Gefahr durch Strom Wie gef\u00e4hrlich Strom ist h\u00e4ngt von der Stromst\u00e4rke und der Dauer ab. Gefahrebereiche: Wird nicht wahrgenommen, da der Strom zu klein ist Kribbeln, Kr\u00e4mpfte, aber keine bleibenden Sch\u00e4den Stromquelle kann wegen Museklverkrampfung nicht mehr losgelassen werden (bei Gleichstrom) T\u00f6dlich, wegen z.B. Herzkammerflimmern Elektromagnetismus Formeln Formel Erkl\u00e4rung $\\vec F_{12}=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac {Q_1Q_2}{ \\vec r_{12} $\\vec E(\\vec r)=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac Q { \\vec r - \\vec r_Q \\(\\vec F =q\\vec E(\\vec r, t)\\) Die Kraft \\(\\vec F\\) , mit welcher das Feld \\(\\vec E\\) die Probeladung \\(q\\) beschleunigt \\(\\vec F_L=q\\cdot(\\vec v\\times\\vec B)\\) Die Kraft, eines Magnetfeldes auf eine Ladung \\(q\\) , welche sich mit \\(\\vec v\\) bewegt. $m=\\frac{rq \\vec B Auf dem TI-nspire cx gibt es den Befehl \\(crossP(x, y)\\) , um mit den Vektoren \\(\\vec x\\) und \\(\\vec y\\) ein Kreuzprodukt zu rechnen. Das Skalarprodukt ist folgendermassen definiert: \\(\\vec a \\cdot \\vec b=|\\vec a| \\cdot |\\vec b|\\cdot \\cos(\\alpha)\\) Aus dem kann geschlossen werden, dass wenn \\(\\alpha=90\u00b0\\) , bzw. die Vektoren \\(\\vec a\\) und \\(\\vec b\\) senkrecht aufeinander stehen, dass das Skalarprodukt 0 is Linienintegrale \\(W=\\int_\\gamma\\vec F\\cdot d\\vec \\gamma\\) Arbeit wurde in der BMS als \\(W=F\\cdot s\\) definiert. Nun kann aber \\(F\\) und \\(s\\) auch Vektoren sein. Hier kommt das Linienintegral ins Spiel, denn mit diesem kann man die Arbeit mit Vektoren ausrechnen. Der Vektor \\(\\vec F\\) und \\(\\vec \\gamma\\) m\u00fcssen nicht umbedingt in dieselbe Richtung zeigen. Wenn man z.B. einen Schlitten zieht, hat die Kraft \\(\\vec F\\) ca. eine 45\u00b0 gegen oben, w\u00e4hrend \\(\\vec \\gamma\\) die Strecke des Schlittens darstellt. Spannung kann auch als Linienintegral angesehen werden: \\(U(\\gamma)=\\int_\\gamma\\vec E \\cdot d\\vec \\gamma\\) Spezialf\u00e4lle Name Formel Bild Kreis Das Vektorfeld liegt \u00fcberall tangential an der Kurve und alle Vektoren haben dieselbe L\u00e4nge. \\(\\int_\\gamma\\vec U\\cdot d\\vec\\gamma =2\\pi r\\vert\\vec U\\vert\\) Rechteck Das Vektorfeld ist parallel zu zwei Seiten (A, C) des Rechteck. Entlang einer Seite haben die Vektoren eine konstante Gr\u00f6sse \\(\\int_\\gamma\\vec U \\cdot d\\vec \\gamma=aU_1-aU_5\\) Flussintegrale Beim Flussintegral wie viel Volumen \\(vdt\\) fliesst durch \\(A\\) , wenn es die Geschwindigkeit \\(\\vec U\\) hat. Dies kann als Integral geschrieben werden, in GED wird allerdings nur folgende Spezialf\u00e4lle behandelt. \\(U\\) sind in diesen Formel die L\u00e4nge der Pfeile. Maxwellgleichungen Geschlossene und nicht-geschlossene Fl\u00e4chen Eine geschlossene Fl\u00e4che hat keinen Rand (wie zB. eine Kugel) und es gibt ein klares Innen und Aussen. Eine nicht geschlossene Fl\u00e4che hat einen Rand. Gauss'sche Gesetzt Metalle Rechte-Hand Regel Rechte-Hand Regel 2 Wenn der Daumen in die technische Stromrichtung zeigt, dann zeigen die Finger den Umlaufsinn des \\(\\vec B\\) -Feldes an. Vektorfelder \\[ \\vec E (x, y, z, t)=\\begin{bmatrix} E_x(x, y, z, t) \\\\ E_y(x, y, z, t) \\\\ E_z(x, y, z, t) \\\\ \\end{bmatrix} \\] Ein Vektor kann ein 2D oder 3D Koordinatensystem sein, in welchem Vektoren in eine Richtung zeigen. Diese Richtung kann zus\u00e4tzlich auch noch von der Zeit abh\u00e4ngig sein. Magnetfeld \\([\\vec B(\\vec r, t)]=\\frac {Ns}{Cm}=\\frac{\\text{Newton Sekunden}}{\\text{Coulomb Meter}}=\\frac{kg}{s C} = \\text{Tesla}\\) Ein Magnetfeld wird in Teslas angegeben. Dabei ist ein Tesla kg pro Coulomb Sekunde oder Newton Sekunden pro Coulomb Meter. Um zu berechnen, mit vieviel Kraft ein Objekt mit einer Ladung beeinflusst wird, gibt es folgende Formel: \\(\\vec F = q(\\vec v \\times \\vec B)\\) Elektrofeld \\([\\vec E (\\vec r, t)]=\\frac N C = \\frac V M = \\frac{kg}{ms^3A}\\) Ein Elektrofeld wird Newton pro Coulomb, Volt pro Meter oder Kilogram pro Meter Sekunden\u00b3 Amper angegeben. Die Einheiten bedeuten dasselbe (Coulomb = Amper Sekunde) Wenn ein Leiter positiv geladen ist, wirkt er abstossend zu Elektronen, wenn ein Leiter negative geladen ist, dann wirkt er anziehend. Zu dem sind die Pfeile im senkrecht auf dem Leiter. Um das Elektrofeld einer einzuelne Ladung zu berechnen, kann die folgende Formel verwendet werden Elektrofelder und Magnetfelder zusammen Zeitlich ver\u00e4nderliche B-Felder erzeugen zeitlich ver\u00e4nderliche E-Felder, welche wiederum zeitlich ver\u00e4nderliche B-Felder erzeugen. Diesen Effekt f\u00fchrt zu einer Welle, welche sich ausbreitet. Initialisiert kann es z.B. von einer Antenne werden, welche nichts anderses als Str\u00f6me zeitlich ver\u00e4ndert durch einen Draht schickt. Magnete Magnete haben immer einen Nord- und S\u00fcdpol. Wenn man ein Magnet trennt, entstehen zwei neue Magnete, mit jeweils einem Nord- und S\u00fcdpol. Wie auch bei elektrischen Feldern kann man auch bei magnetischen Feldern Linien zeichnen. Magnete wirken eine Kraft auf bewegte Ladung aus. Auf ruhende Ladung hat es keinen Effekt. Diese Kraft nennt sich Lorentz-Kraft und kann mit folgender Formel berechnet werden: \\(\\vec F_L=q\\cdot(\\vec v \\times \\vec B)\\) Wenn \\(\\vec v\\) senkrecht auf \\(\\vec B\\) steht,und \\(\\vec B\\) konstant ist, kann mit folgender Formel den Zusammenhang von der Geschwindigkeit der Ladung \\(\\vec v\\) mit dem Magnetfeld \\(\\vec B\\) und dem Radius \\(r\\) beschrieben werden: \\(m=\\frac{rq|\\vec B|}{v}\\) Bei Elementarteilchen ist die Ladung entweder \\(0\\) , \\(e\\) oder \\(-e\\) . Intensit\u00e4t Die Intensit\u00e4t einer ebenen Welle kann mit der folgenden Formeln berechnet werden: $$ I_{em}=\\frac{E_0B_0}{2 \\mu _0}=\\frac{E^2_0}{2c\\mu_0}=\\frac{cB^2_0}{2\\mu_0}\\ $$ Dabei ist \\(\\mu_0\\) die magnetische Feldkonstante \\(1.257\\cdot10^{-6}=4\\pi\\cdot 10^{-7}\\) Strahlendruck $$ p_s=\\frac{I_{em}}c=\\frac{E_0B_0}{2c\\mu_0}=\\frac{E^2}{2c^2\\mu_0}=\\frac{B^2_0}{2\\mu_0} $$ Termische Strahlung Wichtig: Alle Temperaturen sind in Kelvin. Um von Celsius zu Kelvin zu konvertieren: \\(T_{kelvin}=T_{celsius}+273.15\\) Formeln Formel Erkl\u00e4rung \\(E\\) Sichtbares Licht Sichtbares Licht: Lichtbrechung $$ \\frac{\\sin(\\alpha)}{\\sin(\\beta)}=\\frac {c_1} {c_2}=\\frac{n_2}{n_1} $$ Dabei stellt \\(c\\) die Lichtgeschwindigkeit im jeweiligen Material dar und \\(n\\) der Brechungsindex. Totalreflexion Wenn ein Lichtstrahl genug Flach auf die \"Bruchkanta\" (z.B. die Wasseroberfl\u00e4che). In diesemfall wird alles zur\u00fcck reflektiert. F\u00fcr die Formel heisst das, dass \\(\\alpha\\ge 90\u00b0\\) oder \\(\\beta \\ge 90\u00b0\\) Photonen Jedem Photon wird eine Wellenl\u00e4nge, bzw eine Frequenz zu geordnet: \\(E=h\\nu\\) , dabei ist die Planck'sche Konstante \\(h=6.626\\cdot 10^{-34} [Js]\\) und \\(E\\) die Energie des Photons. Elektromagnitische Strahlung Eine Elektromagnetische Strahlung besteht aus einer Welle mit einer Wellenl\u00e4nge \\(\\lambda\\) und einer Frequenz \\(\\nu\\) . Die Formel \\(c=\\lambda\\cdot \\nu\\) zeigt den Zusammenhang zwischen \\(\\lambda\\) und \\(\\nu\\) . \\(c\\) ist dabei die Lichtgeschwindigkeit ( \\(c=3\\cdot10^8 m/s\\) ) Die Energie einer Strahlung kann mit \\(E=h\\nu\\) errechnet werden. \\(h\\) ist dabei die Planck'sche Konstante ( \\(h=6.626\\cdot10^b{-34}\\) ) Der Absorptionskoeffizent beschreibt, wie viel der Frequenzen ein K\u00f6rper absorbiert. 1 heisst, dass alles absorbiert wird, 0 , dass nichts absorbiert wird. Der Gegenpol, der Reflexionskoeffizent, beschreibt, wie viel der Frequenzen reflektiert werden und kann mit der folgenden Formel umgerechnet werden: \\(\\rho=1-\\alpha\\) Oft sind diese Koeffizenten abh\u00e4hngig von der Frequenz (also \\(\\alpha(\\nu)\\) und \\(\\rho(\\nu)\\) ). Ein blaues T-Shirt w\u00fcrde die \"blauen Frequenzen\" reflektieren und die anderen absorbieren. Bei einem schwarzen Strahler kann bewiessen werden, dass es keinen Unterschied gibt, ob die Strahlung vom Material 1 ins Material 2 oder umgekehrt geht. \\[ \\alpha_{1\\rightarrow 2}=\\alpha_{2\\rightarrow 1}\\\\ \\sigma_{1\\rightarrow 2}=\\sigma_{2\\rightarrow 1} \\] Emission Wenn eine Strahle von einem \"d\u00fcnnem\" Material, wie Luft, aufgenommen wird, wird von Emission von Strahlung gesprochen und anstatt dem Absorptionskoeffizent, wird der Emissionskoeffizenten \\(\\varepsilon\\) verwendet (es gilt also: \\(\\alpha_{2\\rightarrow1}=\\varepsilon_{2\\rightarrow 1}\\) ) Schwarzer Strahler Ein K\u00f6rper mit dem Reflexionskoeffizent \\(\\rho=0\\) und Absorptionskoeffizenten von \\(\\alpha=1\\) wird schwarzer Strahler genannt. Ein schwarzer Block kann als Schwarzerstrahler angen\u00e4hert werden (er reflektiert trotzdem noch ein wenig Licht), aber auch die Sonne , da diese keine Frequenzen und somit auch Licht reflektiert . Grauer Strahler Ein grauer Strahler ist ein K\u00f6rper, welcher in gewissen Wellenbereichen nicht so stark strahlen, wie ein schwarzer Strahler. Dass heisst, dass der Emmisionskoeffizent \\(\\varepsilon\\) nicht umbedingt 1 muss sein. Wien'sches Verschiebungsgesetzt Mit \\(\\lambda_{max}=\\frac b T\\) kann man die Temperatur in Kelvin zu der maximalen Wellenl\u00e4nge umrechnen. Mit dieser Formel kann man auch die Lichtfarbe, welche in Kelvin angegeben wird, erkl\u00e4ren. Stefan-Boltzmann Gesetzt (Gesammtleistung) Um die Gesamtleistung eines Strahlendenk\u00f6rpers zu berechnen kann man die folgende Formel ben\u00fctzten: \\(P_{rad}=\\sigma AT^4\\) Dabei ist \\(\\sigma=5.67\\cdot10^{-8} [Wm^{-2}K^{-4}]\\) , \\(A\\) die Oberfl\u00e4che des K\u00f6rpers und \\(T\\) die Temperatur des K\u00f6rpers. Energetische Bilanz eines Strahlers Die Energiebilanz sagt aus, ob Energie vom K\u00f6rper aufgenommen wird und er daher w\u00e4rmer wird oder ob mehr Energie abgegeben wird und er daher k\u00e4lter wird. Dies kann mit der folgenden Formel berechnet werden: $$ I=-\\frac{dE}{dt}=\\sigma\\varepsilon A(T^4-T_{env}^4) $$ Dabei ist \\(\\sigma=5.67\\cdot10^{-8}\\) , \\(\\varepsilon\\) den Emmisionskoeffizenten, \\(A\\) die Oberfl\u00e4che des K\u00f6rpers, \\(T\\) die Temperator des K\u00f6rpers und \\(T_{env}\\) die Umgebungstemperatur. Bei einem grauen Strahler kann \\(\\varepsilon \\neq1\\) sein. Wie man an der Formeln mit den Temperaturen erkennen kann, wird die Temperatur hoch 4 gerechnet. Dies f\u00fchrt bei einer 16-facher vergr\u00f6sserung, wenn die Temperatur verdoppelt wird. Ein \u00e4hliches Ph\u00e4nomen gibt es, wenn die L\u00e4nge eines K\u00f6rpers veroppelt werden, wird die Fl\u00e4che vervierfacht und das Volumen verachtfacht. Sonneneinstrahlung Um zu berechnen, wie viel Energie die Sonne auf die Erde strahlt, kann folgende Formel gebraucht werden: $$ I=\\sin(\\beta)Aj $$ Dabei ist \\(\\beta\\) den Einstrahls-Winkel der Sonne, \\(A\\) die Fl\u00e4che, wo f\u00fcr man die Energie \\(I\\) berechnen m\u00f6chte und \\(j\\) der Faktor der Sonneneinstrahlung. W\u00e4rmeleitung \\[ I=-Ah_{X,Y}(T_X-T_Y) \\] Mit dieser Formel kann der W\u00e4rmestrom (Energie pro Zeit) berechnet werden, welcher von einem Objekt \\(X\\) mit der Temperatur \\(T_X\\) zu einem Objekt \\(Y\\) mit der Temperatur \\(T_Y\\) fliesst. \\(A\\) ist dabei die Ber\u00fchrungsfl\u00e4che der zwei Objekte und \\(h_{X,Y}\\) ist der W\u00e4rme\u00fcbertragunskoeffizent. Signale Signalarten Name Bild Sinussignal Rechtecksignal S\u00e4gezahnsignal Dreieckssignal Eine Welle wird haupts\u00e4chlich durch ihre Amplitude \\(A\\) , Periode \\(T\\) , Frequenz \\(\\nu\\) und Phasenverschiebung \\(\\varphi\\) definiert. Mit \\(T=\\frac 1 \\nu\\) kann man von der Frequenz \\(\\nu\\) zur Periode \\(T\\) umwandeln. Ein Sinussignal kann in ein Cosinussignal und umgekehrt folgendermassen umgewandelt werden: $$ sin(a-\\frac \\pi 2)=cos(a)\\ cos(a+\\frac \\pi 2)=sin(a) $$ Fourierzerlegung Man kann jede Funktion in eine Summe von Cosinusen oder Sinusen zerlegen T\u00f6ne und Klangfarbe Neben eines Grundtones produziert ein Instrument auch noch Obert\u00f6ne. Als Daumenregeln: Je mehr Obert\u00f6ne, desto sch\u00e4rfer t\u00f6nt ein Instrument. Nyquist - Shannon Theorem Es m\u00fcssen doppelt so viele Messpunkte existieren, wie die maximale Frequenz: \\(f_{measure}>2\\cdot f_{max}\\) . Wenn dies nicht gegeben ist, tritt Aliasing auf und es werden falsche Frequenzen gespeichert. F\u00fcr die tiefste Frequenz gilt, dass das Intervall \\(T\\) zwischen den Messpunkten : \\(T > \\frac 1 {f_{min}}\\) Blip Ein Blip ist ein kurzes Signal. Dabei gilt, je k\u00fcrzer der Blip, desto mehr Frequenzen gibt es um die Hauptfrequenz \\(\\nu_0\\) Ein zweites Prinzip, das \u00e4hlich funktioniert: Je steiler eine Flanke eines Signales, desto mehr Frequenzen werden ben\u00f6tigt, um die Flanke darzustellen. Schnelle Orgeln Damit ein Ton als harmonisch empfunden wird, muss eine Frequenz domonieren. Bei einem Blip ist dies allerdings nicht umbedingt gegeben. Ebenfalls gilt, je h\u00f6her ein Ton, desto k\u00fcrzer kann er sein, dass trotzdem noch eine Frequenz dominiert und der Ton harmonisch klingt. Aus diesem Grund kann eine Picolo schnell spielen und eine tiefe Orgel nicht. Mathematisch kann diese Relation folgendermassen ausgedr\u00fcckt werden: $$ \\frac{\\Delta f\\cdot \\Delta t}{2}\\sim 1 $$ Signal-to-Noise Ratio \\(A_{noise}=\\text{Die durchschnittliche Noise Amplitude}\\) $$ SNR=\\frac{P_{signal}} {P_{noise}}=\\frac{I_{signal}} {I_{noise}}=\\frac{A^2_{signal}}{A^2_{noise}} $$ Dabei bezeichnet \\(P\\) die Leistung, \\(I\\) die Intensit\u00e4t und \\(A\\) die Amplitude.","title":"All ged summaries"},{"location":"21HS/GED/Physik/all-ged-summaries.html#formeln","text":"In dieser Datei werden alle Formeln und Konstanten zusammen gefasst. Prefix Exponent peta \\(10^{15}\\) tera \\(10^{12}\\) giga \\(10^9\\) mega \\(10^6\\) kilo \\(10^3\\) hecto \\(10^2\\) deca \\(10^1\\) - \\(10^0\\) dezi \\(10^{-1}\\) cento \\(10^{-2}\\) milli \\(10^{-3}\\) micro \\(10^{-6}\\) nano \\(10^{-9}\\) pico \\(10^{-12}\\) femto \\(10^{-15}\\)","title":"Formeln"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektronik","text":"Thema Formeln Erkl\u00e4rung \\(I [A]\\) Strom \\(U [V]\\) Spannung Wiederst\u00e4nde \\(U=R\\cdot I\\) Formel f\u00fcr Ohmnische Wiederst\u00e4nde Wiederst\u00e4nde \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Formel zum zwei parallele Wiederst\u00e4nde zusammen zu fassen Kondensator \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U\\) und der Ladung \\(Q\\) Kondensator \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden Kondensator \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet Kondensator \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet Kondensator \\(\\tau=R\\cdot C\\) Der Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\) auf/ab in der Zeit \\(\\tau\\)","title":"Elektronik"},{"location":"21HS/GED/Physik/all-ged-summaries.html#themische-strahlungen","text":"Konstante Erkl\u00e4rung \\(c=3\\cdot 10^8m/s\\) Lichtgeschwindigkeit im Vakum \\(h=6.626\\cdot10^{-34} Js\\) Planck'sche Konstante Formel Erkl\u00e4rung \\(c=\\lambda \\cdot\\nu\\) Dies ist der Zusammenhang zwischen der Wellenl\u00e4nge \\(\\lambda\\) und der Frequenz \\(\\nu\\) . \\(c\\) ist die Lichtgeschwindigkeit \\(E=h\\nu\\) Die Energie einer Strahlung mit der Frequenz \\(\\nu\\) . \\(h\\) ist die Plank'sche Konstante \\(\\rho(\\nu)=1-\\alpha(\\nu)\\) Umrechnungs Formel zwischen Reflektionskoeffizenten ( \\(\\rho\\) ) und Absorptionskoeffizenten ( \\(\\alpha\\) )","title":"Themische Strahlungen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#noch-zu-lernen","text":"B-Felder induziert E-Felder In welche Richtung positive E-Felder anziehen oder abstossen","title":"Noch zu lernen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#chugeli-fusik","text":"","title":"Ch\u00fcgeli F\u00fcsik"},{"location":"21HS/GED/Physik/all-ged-summaries.html#kraft","text":"\\(\\vec F = m \\cdot \\vec a\\) Diese Formel nimmt einiges an: Bewegung in einer Dimension (keine Vektoren) Konstante Beschleunigung (a = const.) Start bei \\(s(0)=0\\) Anfangsgeschwindigkeit bei","title":"Kraft"},{"location":"21HS/GED/Physik/all-ged-summaries.html#beschleunigung-und-co","text":"Hier sind einige g\u00e4ngige Formeln aufgelistet, welche hilfreich bei Beschleunigung sind. In der obersten Reihe steht, was die Formel ergeben soll. In der ersten Spalte, was sich nicht \u00e4ndert und somit nicht in der Formel erw\u00e4hnt wird. t s v a t - \\(s=\\frac{v^2}{2a}\\) \\(v=\\sqrt{2as}\\) \\(a=\\frac{v^2}{2s}\\) s \\(t=\\frac{v}{a}\\) - \\(v=at\\) \\(a=\\frac{v}{t}\\) v \\(t=\\sqrt{\\frac{2s}{a}}\\) \\(s=\\frac{at^2}{2}\\) - \\(a=\\frac{2s}{t^2}\\) a \\(t=\\frac{2s}{v}\\) \\(s=\\frac{vt}{2}\\) \\(v=\\frac{2s}{t}\\) -","title":"Beschleunigung und co."},{"location":"21HS/GED/Physik/all-ged-summaries.html#energie","text":"Energie ist \\(Kraft \\cdot Strecke\\) . Es gilt also die Formel \\(E=F\\cdot s [J]\\) . Die Masseinheit \\(J\\) kann auch als \\(\\frac{kgm^2}{s^2}\\)","title":"Energie"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektrotechnik","text":"","title":"Elektrotechnik"},{"location":"21HS/GED/Physik/all-ged-summaries.html#strom-spannung-und-leistung","text":"Ampere ist die Einheit des Stromes \\(I\\) und ist Coulomb pro Sekunde \\([Cs^{-1}]\\) . Die H\u00f6he zwischen zwei Energiepotentialen nennt sich die Spannung \\(U\\) ( \\(U(\\vec r_A,\\vec r_B)=\\varphi(\\vec r_A)-\\varphi(\\vec r_B)\\) ). Spannung kann aber auch \u00fcber Arbeit definiert werden. Die Spannung zwischen zwei Punkten \\(A\\) und \\(B\\) ist die Energie pro Ladung, welche frei wird, wenn die Ladung von \\(A\\) nach \\(B\\) bewegt wird: \\(U=\\int^{\\vec r_B}_{\\vec r_A}\\vec E d\\vec r\\) . Die kinetische Energie, welche eine Ladung \\(q\\) gewinnt, wenn sie eine Spannung \\(U\\) \"herunterf\u00e4llt\" betr\u00e4gt: \\(\\Delta E_{kin}=\\int^{\\vec r_B}_{\\vec r_A}\\vec q\\cdot E d\\vec r=q\\cdot U\\)","title":"Strom, Spannung und Leistung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#schaltung","text":"","title":"Schaltung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#knotenregel","text":"Die Knotenregel besagt, dass was in einen Knoten hinein geht, muss auch wieder aus dem Knoten hinaus. Oder \\(I_1=I_2+I_3\\) bzw. \\(I_6=i_5+I_4\\)","title":"Knotenregel"},{"location":"21HS/GED/Physik/all-ged-summaries.html#maschenregel","text":"Die Maschenregel besagt, dass alle Spannungen in einer Masche zusammen \\(0\\) ergeben m\u00fcssen. Man rechnet plus wenn es in die Referenzrichtung eines Bauteils geht und minus , wenn es gegen die Referenzrichtung geht. Ebenfalls wichtig zu erw\u00e4hnt ist, dass eine Batterie in die andere Richtung zeigt, als die anderen Bauteile (Dies ist einwenig komisch im Beispiel oben). In der gr\u00fcnen Maschen sieht man, wie dies aussehen kann, f\u00fcr eine Masche, welche nicht \u00fcber die Baterie geht: \\(U_4-U_5=0\\)","title":"Maschenregel"},{"location":"21HS/GED/Physik/all-ged-summaries.html#batterien","text":"Reale Batterien haben einen Innenwiederstand, welcher in Serie mit der Batterie geschalten ist. Dass heisst, dass die realte Spanung einer Batterie kleiner als \\(U_0\\) ist, da \\(U_{in}\\) abgezogen werden muss.","title":"Batterien"},{"location":"21HS/GED/Physik/all-ged-summaries.html#wiederstand","text":"Ein Wiederstand folgt dem Ohm'sche Gesetzt. Dass heisst, ein Wiederstand kann mit \\(U=R\\cdot I\\) berechnet werden. Da f\u00fcr die Leistung gillt \\(P=U\\cdot I\\) , kann in diese Formel das Ohm'sche Gesetzt eingesetzt werden, um die Formel \\(P=\\frac {U^2} R=I^2R\\) zu bekommen. Wegen der Knoten und Maschenregeln verhalten sich Wiederst\u00e4nde (wie auch andere Bauteile) anderst, jenach dem, ob sie Parallel oder Serial angeschlossen sind. Name Erkl\u00e4rung Bild Parallel geschaltet In einer Parallelschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusammen gefasst werden: \\(R_{12}=\\frac 1 {\\frac 1 {R_1} + \\frac 1 {R_2}}\\) Seriel geschaltet In einer Serielschaltung m\u00fcssen Wiederst\u00e4nde folgendermassen zusamengefasst werden: \\(R_{12}=R_1+R_2\\)","title":"Wiederstand"},{"location":"21HS/GED/Physik/all-ged-summaries.html#kondensator","text":"Ein Kondensator (oder Capacitor) kann man sich als Feder vorstellen, welche aus zwei Metallplatten nahe bei einander bestehen. Es wird Strom hinein \"gepumpt\". Dies wird immer schwerer, je voller der Kondensator wird, bis am Ende der Kondensator voll ist. Das zweite wichtige an einem Kondensator ist, dass keine Elektronen durch ihn durch fliessen k\u00f6nnen. Anstelle dessen sammeln sich auf der einen Seite mehr Elektronen an, auf der anderen Seite werden die bereits vorhanden Elektronen abgesaugt. formel Erkl\u00e4rung \\(\\frac {dQ}{dt}=I\\) Die Ver\u00e4nderungsrate der Ladung, ist der Strom \\(I\\) \\(CU_c=Q\\) Der Zusammenhang zwischen der Spannung \\(U [V]\\) und der Ladung \\(Q\\) abh\u00e4ngig von der Kapazit\u00e4t \\(C [F]\\) in Farad \\(Q(t)=CU_0(1-e^{-\\frac t{RC}})\\) Wie sich die Ladung \\(Q\\) beim Laden \\(U_C(t)=\\frac{Q(t)}{C}=U_0(1-e^{-\\frac t{RC}})\\) Wie sich die Spannung \\(U\\) beim Laden verhaltet \\(U_C(t)=U_0\\cdot e^{-\\frac t {RC}}\\) Wie sich die Spannung \\(U\\) beim Entladen verhaltet \\(I(t)=\\frac{U_0}{R}e^{-\\frac t {RC}}\\) Wie sich der Strom \\(I\\) beim Laden verhaltet \\(\\tau=R\\cdot C\\) Die Zeitkonstante \\(\\tau\\) . Der Strom des Kondensator f\u00e4llt auf ca \\(\\frac 1 e\\approx0.37\\) ab in der Zeit \\(\\tau\\) oder steigt auf \\(1-\\frac 1 e\\approx0.63\\) in \\(\\tau\\) an, wenn der Kondensator geladen wird","title":"Kondensator"},{"location":"21HS/GED/Physik/all-ged-summaries.html#spulen","text":"Wenn durch ein Draht Strom fliesst, entsteht ein Magnetfeld. Dies ist ebenfalls der Fall bei einer Spule. Wenn der Strom hochgefahren wird, dann wird ein Magnetfeld aufgebaut. Dies ben\u00f6tigt aber Energie, was wiederum einen Wiederstand erzeugt. Wenn der Strom abgebaut wird, wir die Energie des Magnetfeldes wieder zur\u00fcck in die Spannung gespiessen und \u00fcber der Spule entsteht eine Spannung, welche den Strom antreibt. Die Richtung des Magnetfeldes findet man heraus, in dem man die Rechte hand nimmt und mit dem Daumen in die Ricthung des - zeigt, bzw. die Stromrichtung auf dem Schaltungsplan (nicht die physikalische Stromrichtung, die ist in die andere Richtung). Formel Erkl\u00e4rung \\(U_L=L\\frac{dI}{dt}\\) Die Ver\u00e4nderungsrate von dem Strom \\(I\\) mit der Konstante \\(L [Henry]\\) multipliziert, ergibt die Spannung","title":"Spulen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#ungedampfte-schwingkreise","text":"In einem Schwingungskreis, schwingen die Elektronen zwischen den zwei Platten des Kondensators hin und her. Dies kann man in die folgende Schritte unterteilen: Der Kondensator ist geladen und es herrscht eine Spanung \\(U_0\\) \u00fcber dem Kondensator. Der Schalter ist aber noch offen. Der Schalter \\(s_1\\) wurde geschlossen und der Strom fliesst. Wegen dem Maschensatz muss \\(U_C=U_L\\) sein. Da die Spannung \\(U_C\\) w\u00e4chst, muss auch der Strom \\(I\\) wachsen und somit ein Magnetfeld \u00fcber L entstehen. Der Strom \\(I\\) und somit auch das Magnetfeld \\(B\\) sind maximal. Irgendwann wird der Kondensator leer sein (Auf beiden Seiten der Platte sind gleich viele Elektronen) und \\(U_L\\) und \\(UC\\) sind 0. Somit gilt auch \\(I=0\\) . Da nun der Strom in der Spule freigesetzt wird, l\u00e4dt sich der Kondensator wieder auf (allerdings mit einem anderen Vorzeichen) und so entsteht wieder eine Spannung \\(U_C\\) \u00fcber dem Kondensator. So bald die Spule \"leer\" ist, wechselt die Stromrichtung wieder Der Zyklus wiederholt sich nun wiede Formel Erkl\u00e4rung \\(Q(t)=CU_0\\cdot \\cos(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Die Ladung \\(Q\\) eines Schwinungskreises \\(I(t)=-\\sqrt {\\frac C L}\\cdot U_0\\cdot \\sin(\\frac 1 {\\sqrt {LC}}\\cdot t)\\) Der Strom \\(I\\) eines Schwinungskreises \\(U_L(t)=-\\frac 1 {\\sqrt{LC}}\\cdot U_0\\cdot \\cos(\\frac 1 {\\sqrt{LC}} \\cdot t)\\) Die Spannun \\(U_L\\) eines Schwinungskreises \\(f=\\frac 1 {2\\pi\\sqrt{LC}}\\) Die Frequenz \\(f\\) , mit welcher der Schwingunskreis schwingt \\(T=2\\pi\\sqrt{LC}\\) Die Periodendauer \\(T\\) , welche eine Schwinung des Schwingungskreis ben\u00f6tigt","title":"Unged\u00e4mpfte Schwingkreise"},{"location":"21HS/GED/Physik/all-ged-summaries.html#gedampfte-schwingungskreise","text":"Der Strom im Schwinungskreis wird schw\u00e4cher, wenn \\(R < 2\\sqrt {\\frac L C}\\) (oder wenn \\(\\frac{R^2}{4L^2}>\\frac 1 {LC}\\) ist) Wenn dies gegeben ist, dann ist es ein ged\u00e4mpfter Schwingungskreis. Formel Erkl\u00e4rung \\(Q(t)=Q_0e^{-\\frac t \\tau}\\cos(\\omega_dt-\\phi_0)\\) Die Ladung des Schwinungskreis1 \\(f=\\frac 1 {2\\pi}\\sqrt{\\frac 1 {LC} -\\frac{R^2}{4L^2}}\\) , \\(T=\\frac 1 f\\) Die (Kreis-)frequenz \\(\\omega_d\\) \\(\\tau=\\frac{2L} R\\) Die Zeitkonstante \\(\\tau\\) der D\u00e4mpfung. Der Strom des Kondensator f\u00e4llt/steigt auf ca \\(\\frac 1 e\\approx0.37\\%\\) auf/ab in der Zeit \\(\\tau\\)","title":"Ged\u00e4mpfte Schwingungskreise"},{"location":"21HS/GED/Physik/all-ged-summaries.html#low-pass-und-high-pass-filter","text":"Bei einem Low-Pass-Filter werden die tiefen Frequenzen durchgelassen und die Hochen weggefiltert. Bei einem High-Pass-Filter ist es umgekehrt und die hochen Frequenzen werden duch gelassen und die tiefen weggefiltert. \u00dcber dem Wiederstand misst man ein Signal, bei welchem die tiefen Frequenzen ged\u00e4mpft wurden und die hochen Frequenzen fast unver\u00e4ndert. Dies w\u00e4re ein High-Pass-Filter. Hingegen \u00fcber dem Kondensator misst werden die hochen Frequenzen ged\u00e4mpft und die tiefen durchgelassen, was ein Low-Pass-Filter ist.","title":"Low-Pass und High-Pass-Filter"},{"location":"21HS/GED/Physik/all-ged-summaries.html#draht","text":"Der Wiederstand in einem Kabel ist ungef\u00e4hr: \\(R=\\rho\\frac L A\\) , wobei \\(\\rho\\) den spezifischen Wiederstand mit der Einheit \\([mm^2m^{-1}\\Omega]\\) . \\(L\\) ist die L\u00e4nge in \\([m]\\) und \\(A\\) ist die Querschnittsfl\u00e4che in \\([mm^2]\\) .","title":"Draht"},{"location":"21HS/GED/Physik/all-ged-summaries.html#karnaugh-veitsch-diagramme","text":"Ein KV-Diagram kann praktisch sein, um eine Wahrheitstabelle mit vier Inputs in eine Schaltung zu verwandeln. Daf\u00fcr wird zuerst die Wahrheitstabelle in das folgende Raster einf\u00fchrt. Dabei ist oben, bzw. auf der linken Seite das erste Bit und auf der unteren/rechten Seite das linke Bit. Das Feld oben rechts stellt also f\u00fcr den Wert aus der Wahrheitstabelle A=1, B=0, C=0, D=0. Wenn dies getan ist, versucht man Bl\u00f6cke mit Einsen zu finden. Die Bl\u00f6cke k\u00f6nnen 1, 2, 4, 8 oder 16 lang und/oder breit sein. Falls es egal ist, ob ein Input 0 oder 1 ist, kann er so betrachtet werden, dass es sch\u00f6nere Bl\u00f6cke gibt. Ebenfalls wichtig, ein Block darf \u00fcber die Kante hinausgehen. Im letzten Schritt wird nun aus den Bl\u00f6cken Und-Schaltungen gebaut. Dabei m\u00fcssen zwei Dinge beachtet werden: Wenn ein Block \u00fcber den not und \"normalen\" Block geht (z.B. A und not-A), dann muss das And-Gate keine Verbindung zu diesem Input haben, da es in beiden F\u00e4llen true ist. Wenn ein Block nur \u00fcbr ein Block geht (z.B. nur \u00fcber den A oder nur den not-A Block), dann muss das And-Gate mit diesem Input verbunden sein. Hier sieht man noch das Beispiel f\u00fcr die oberigen Bl\u00f6cke.","title":"Karnaugh-Veitsch Diagramme"},{"location":"21HS/GED/Physik/all-ged-summaries.html#transformer","text":"","title":"Transformer"},{"location":"21HS/GED/Physik/all-ged-summaries.html#stromnetz","text":"In unserem Stromnetzt werden mehrere Spannungen gen\u00fctzt. Zum einten m\u00f6chte man hohe Spannungen f\u00fcrs Transportieren von Strom ben\u00fctzten, da dies um einiges effizienter ist. Allerdings ist es zu gef\u00e4hrlich Hochspannung direkt im Haus zu gebrauchen. Daher hat man vier Netzebenen, welche mit Transformern gekoppelt sind. 1 Ebene - H\u00f6chstspannungsebene : 380kV, bzw. 220 kV aus dem Kraftwerk oder vom Ausland 3 Ebene - Hochspannungsebene : 36kV - 150kV: \u00dcberregionale Verteilungsnetzte 5 Ebene - Mittelspannungsebene : 1kV - 36kV: Regionale Verteilungsnetzte 7 Ebene - Niederspannungsebene : < 1kV: Lokale Verteilungsnetzte Die Ebenen 2, 4 und 6 sind die Transformatorenebenen. Auf diesen Ebenen wird der Strom auf die n\u00e4chst tiefere oder h\u00f6here Ebene transformiert.","title":"Stromnetz"},{"location":"21HS/GED/Physik/all-ged-summaries.html#wechsel-vs-gleichstrom","text":"Man hat sich in der Vergangenheit auf Wechselstrom geeinigt, weil es relativ einfach ist, Wechselstrom zu transformieren. Heute ist dies aber auch mit Gleichstrom m\u00f6glich. Gleichstrom erzeugt weniger Verl\u00fcste, wenn transportiert auf lange Streckenen, als Wechselstrom, da Wechselstrom nah an der Kabeloberfl\u00e4chse fliest und daher ein st\u00e4rkeres Magnetfeld erzeugt. Der \\(U_{Eff}\\) kann mit der folgender Formel berechnet werden: \\(U_{Eff}=\\frac{U_S}{\\sqrt 2}\\) . Dies berechnet den quadratischen Mittelwert einer Wechselspannung. Der Sinus kann mit der folgenden Formel angegebene werden: \\(f(t)=U_{Eff}\\cos(\\omega\\cdot t)=U_{Eff}\\cos(f\\cdot 2\\pi\\cdot t)\\)","title":"Wechsel- vs. Gleichstrom"},{"location":"21HS/GED/Physik/all-ged-summaries.html#drehstrom","text":"(Siehe Script_GED_Lect_3_4.pdf) Drehstrom ist praktisch f\u00fcr Motoren, da es keine \"Totenp\u00fcnkte\" gibt, an dem ein Magnet stoppen k\u00f6nnte. Zudem sind alle H\u00e4user in der Schweiz an einem Drehstrom angeschlossen. Auf den Aussenleiter wird der Strom \"transportiert\" und stehen gegen\u00fcber der Erde unter einer Spannung von 230V. Der Neutralleiter ist der \"Ausgang\" f\u00fcr die Elektronen, welche \u00fcber die Aussenleiter hinein gepumpt werden.","title":"Drehstrom"},{"location":"21HS/GED/Physik/all-ged-summaries.html#gefahr-durch-strom","text":"Wie gef\u00e4hrlich Strom ist h\u00e4ngt von der Stromst\u00e4rke und der Dauer ab. Gefahrebereiche: Wird nicht wahrgenommen, da der Strom zu klein ist Kribbeln, Kr\u00e4mpfte, aber keine bleibenden Sch\u00e4den Stromquelle kann wegen Museklverkrampfung nicht mehr losgelassen werden (bei Gleichstrom) T\u00f6dlich, wegen z.B. Herzkammerflimmern","title":"Gefahr durch Strom"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektromagnetismus","text":"","title":"Elektromagnetismus"},{"location":"21HS/GED/Physik/all-ged-summaries.html#formeln_1","text":"Formel Erkl\u00e4rung $\\vec F_{12}=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac {Q_1Q_2}{ \\vec r_{12} $\\vec E(\\vec r)=\\frac 1 {4\\pi\\varepsilon_0}\\cdot \\frac Q { \\vec r - \\vec r_Q \\(\\vec F =q\\vec E(\\vec r, t)\\) Die Kraft \\(\\vec F\\) , mit welcher das Feld \\(\\vec E\\) die Probeladung \\(q\\) beschleunigt \\(\\vec F_L=q\\cdot(\\vec v\\times\\vec B)\\) Die Kraft, eines Magnetfeldes auf eine Ladung \\(q\\) , welche sich mit \\(\\vec v\\) bewegt. $m=\\frac{rq \\vec B Auf dem TI-nspire cx gibt es den Befehl \\(crossP(x, y)\\) , um mit den Vektoren \\(\\vec x\\) und \\(\\vec y\\) ein Kreuzprodukt zu rechnen. Das Skalarprodukt ist folgendermassen definiert: \\(\\vec a \\cdot \\vec b=|\\vec a| \\cdot |\\vec b|\\cdot \\cos(\\alpha)\\) Aus dem kann geschlossen werden, dass wenn \\(\\alpha=90\u00b0\\) , bzw. die Vektoren \\(\\vec a\\) und \\(\\vec b\\) senkrecht aufeinander stehen, dass das Skalarprodukt 0 is","title":"Formeln"},{"location":"21HS/GED/Physik/all-ged-summaries.html#linienintegrale","text":"\\(W=\\int_\\gamma\\vec F\\cdot d\\vec \\gamma\\) Arbeit wurde in der BMS als \\(W=F\\cdot s\\) definiert. Nun kann aber \\(F\\) und \\(s\\) auch Vektoren sein. Hier kommt das Linienintegral ins Spiel, denn mit diesem kann man die Arbeit mit Vektoren ausrechnen. Der Vektor \\(\\vec F\\) und \\(\\vec \\gamma\\) m\u00fcssen nicht umbedingt in dieselbe Richtung zeigen. Wenn man z.B. einen Schlitten zieht, hat die Kraft \\(\\vec F\\) ca. eine 45\u00b0 gegen oben, w\u00e4hrend \\(\\vec \\gamma\\) die Strecke des Schlittens darstellt. Spannung kann auch als Linienintegral angesehen werden: \\(U(\\gamma)=\\int_\\gamma\\vec E \\cdot d\\vec \\gamma\\)","title":"Linienintegrale"},{"location":"21HS/GED/Physik/all-ged-summaries.html#spezialfalle","text":"Name Formel Bild Kreis Das Vektorfeld liegt \u00fcberall tangential an der Kurve und alle Vektoren haben dieselbe L\u00e4nge. \\(\\int_\\gamma\\vec U\\cdot d\\vec\\gamma =2\\pi r\\vert\\vec U\\vert\\) Rechteck Das Vektorfeld ist parallel zu zwei Seiten (A, C) des Rechteck. Entlang einer Seite haben die Vektoren eine konstante Gr\u00f6sse \\(\\int_\\gamma\\vec U \\cdot d\\vec \\gamma=aU_1-aU_5\\)","title":"Spezialf\u00e4lle"},{"location":"21HS/GED/Physik/all-ged-summaries.html#flussintegrale","text":"Beim Flussintegral wie viel Volumen \\(vdt\\) fliesst durch \\(A\\) , wenn es die Geschwindigkeit \\(\\vec U\\) hat. Dies kann als Integral geschrieben werden, in GED wird allerdings nur folgende Spezialf\u00e4lle behandelt. \\(U\\) sind in diesen Formel die L\u00e4nge der Pfeile.","title":"Flussintegrale"},{"location":"21HS/GED/Physik/all-ged-summaries.html#maxwellgleichungen","text":"","title":"Maxwellgleichungen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#geschlossene-und-nicht-geschlossene-flachen","text":"Eine geschlossene Fl\u00e4che hat keinen Rand (wie zB. eine Kugel) und es gibt ein klares Innen und Aussen. Eine nicht geschlossene Fl\u00e4che hat einen Rand.","title":"Geschlossene und nicht-geschlossene Fl\u00e4chen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#gausssche-gesetzt","text":"","title":"Gauss'sche Gesetzt"},{"location":"21HS/GED/Physik/all-ged-summaries.html#metalle","text":"","title":"Metalle"},{"location":"21HS/GED/Physik/all-ged-summaries.html#rechte-hand-regel","text":"","title":"Rechte-Hand Regel"},{"location":"21HS/GED/Physik/all-ged-summaries.html#rechte-hand-regel-2","text":"Wenn der Daumen in die technische Stromrichtung zeigt, dann zeigen die Finger den Umlaufsinn des \\(\\vec B\\) -Feldes an.","title":"Rechte-Hand Regel 2"},{"location":"21HS/GED/Physik/all-ged-summaries.html#vektorfelder","text":"\\[ \\vec E (x, y, z, t)=\\begin{bmatrix} E_x(x, y, z, t) \\\\ E_y(x, y, z, t) \\\\ E_z(x, y, z, t) \\\\ \\end{bmatrix} \\] Ein Vektor kann ein 2D oder 3D Koordinatensystem sein, in welchem Vektoren in eine Richtung zeigen. Diese Richtung kann zus\u00e4tzlich auch noch von der Zeit abh\u00e4ngig sein.","title":"Vektorfelder"},{"location":"21HS/GED/Physik/all-ged-summaries.html#magnetfeld","text":"\\([\\vec B(\\vec r, t)]=\\frac {Ns}{Cm}=\\frac{\\text{Newton Sekunden}}{\\text{Coulomb Meter}}=\\frac{kg}{s C} = \\text{Tesla}\\) Ein Magnetfeld wird in Teslas angegeben. Dabei ist ein Tesla kg pro Coulomb Sekunde oder Newton Sekunden pro Coulomb Meter. Um zu berechnen, mit vieviel Kraft ein Objekt mit einer Ladung beeinflusst wird, gibt es folgende Formel: \\(\\vec F = q(\\vec v \\times \\vec B)\\)","title":"Magnetfeld"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektrofeld","text":"\\([\\vec E (\\vec r, t)]=\\frac N C = \\frac V M = \\frac{kg}{ms^3A}\\) Ein Elektrofeld wird Newton pro Coulomb, Volt pro Meter oder Kilogram pro Meter Sekunden\u00b3 Amper angegeben. Die Einheiten bedeuten dasselbe (Coulomb = Amper Sekunde) Wenn ein Leiter positiv geladen ist, wirkt er abstossend zu Elektronen, wenn ein Leiter negative geladen ist, dann wirkt er anziehend. Zu dem sind die Pfeile im senkrecht auf dem Leiter. Um das Elektrofeld einer einzuelne Ladung zu berechnen, kann die folgende Formel verwendet werden","title":"Elektrofeld"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektrofelder-und-magnetfelder-zusammen","text":"Zeitlich ver\u00e4nderliche B-Felder erzeugen zeitlich ver\u00e4nderliche E-Felder, welche wiederum zeitlich ver\u00e4nderliche B-Felder erzeugen. Diesen Effekt f\u00fchrt zu einer Welle, welche sich ausbreitet. Initialisiert kann es z.B. von einer Antenne werden, welche nichts anderses als Str\u00f6me zeitlich ver\u00e4ndert durch einen Draht schickt.","title":"Elektrofelder und Magnetfelder zusammen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#magnete","text":"Magnete haben immer einen Nord- und S\u00fcdpol. Wenn man ein Magnet trennt, entstehen zwei neue Magnete, mit jeweils einem Nord- und S\u00fcdpol. Wie auch bei elektrischen Feldern kann man auch bei magnetischen Feldern Linien zeichnen. Magnete wirken eine Kraft auf bewegte Ladung aus. Auf ruhende Ladung hat es keinen Effekt. Diese Kraft nennt sich Lorentz-Kraft und kann mit folgender Formel berechnet werden: \\(\\vec F_L=q\\cdot(\\vec v \\times \\vec B)\\) Wenn \\(\\vec v\\) senkrecht auf \\(\\vec B\\) steht,und \\(\\vec B\\) konstant ist, kann mit folgender Formel den Zusammenhang von der Geschwindigkeit der Ladung \\(\\vec v\\) mit dem Magnetfeld \\(\\vec B\\) und dem Radius \\(r\\) beschrieben werden: \\(m=\\frac{rq|\\vec B|}{v}\\) Bei Elementarteilchen ist die Ladung entweder \\(0\\) , \\(e\\) oder \\(-e\\) .","title":"Magnete"},{"location":"21HS/GED/Physik/all-ged-summaries.html#intensitat","text":"Die Intensit\u00e4t einer ebenen Welle kann mit der folgenden Formeln berechnet werden: $$ I_{em}=\\frac{E_0B_0}{2 \\mu _0}=\\frac{E^2_0}{2c\\mu_0}=\\frac{cB^2_0}{2\\mu_0}\\ $$ Dabei ist \\(\\mu_0\\) die magnetische Feldkonstante \\(1.257\\cdot10^{-6}=4\\pi\\cdot 10^{-7}\\)","title":"Intensit\u00e4t"},{"location":"21HS/GED/Physik/all-ged-summaries.html#strahlendruck","text":"$$ p_s=\\frac{I_{em}}c=\\frac{E_0B_0}{2c\\mu_0}=\\frac{E^2}{2c^2\\mu_0}=\\frac{B^2_0}{2\\mu_0} $$","title":"Strahlendruck"},{"location":"21HS/GED/Physik/all-ged-summaries.html#termische-strahlung","text":"Wichtig: Alle Temperaturen sind in Kelvin. Um von Celsius zu Kelvin zu konvertieren: \\(T_{kelvin}=T_{celsius}+273.15\\)","title":"Termische Strahlung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#formeln_2","text":"Formel Erkl\u00e4rung \\(E\\)","title":"Formeln"},{"location":"21HS/GED/Physik/all-ged-summaries.html#sichtbares-licht","text":"Sichtbares Licht:","title":"Sichtbares Licht"},{"location":"21HS/GED/Physik/all-ged-summaries.html#lichtbrechung","text":"$$ \\frac{\\sin(\\alpha)}{\\sin(\\beta)}=\\frac {c_1} {c_2}=\\frac{n_2}{n_1} $$ Dabei stellt \\(c\\) die Lichtgeschwindigkeit im jeweiligen Material dar und \\(n\\) der Brechungsindex.","title":"Lichtbrechung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#totalreflexion","text":"Wenn ein Lichtstrahl genug Flach auf die \"Bruchkanta\" (z.B. die Wasseroberfl\u00e4che). In diesemfall wird alles zur\u00fcck reflektiert. F\u00fcr die Formel heisst das, dass \\(\\alpha\\ge 90\u00b0\\) oder \\(\\beta \\ge 90\u00b0\\)","title":"Totalreflexion"},{"location":"21HS/GED/Physik/all-ged-summaries.html#photonen","text":"Jedem Photon wird eine Wellenl\u00e4nge, bzw eine Frequenz zu geordnet: \\(E=h\\nu\\) , dabei ist die Planck'sche Konstante \\(h=6.626\\cdot 10^{-34} [Js]\\) und \\(E\\) die Energie des Photons.","title":"Photonen"},{"location":"21HS/GED/Physik/all-ged-summaries.html#elektromagnitische-strahlung","text":"Eine Elektromagnetische Strahlung besteht aus einer Welle mit einer Wellenl\u00e4nge \\(\\lambda\\) und einer Frequenz \\(\\nu\\) . Die Formel \\(c=\\lambda\\cdot \\nu\\) zeigt den Zusammenhang zwischen \\(\\lambda\\) und \\(\\nu\\) . \\(c\\) ist dabei die Lichtgeschwindigkeit ( \\(c=3\\cdot10^8 m/s\\) ) Die Energie einer Strahlung kann mit \\(E=h\\nu\\) errechnet werden. \\(h\\) ist dabei die Planck'sche Konstante ( \\(h=6.626\\cdot10^b{-34}\\) ) Der Absorptionskoeffizent beschreibt, wie viel der Frequenzen ein K\u00f6rper absorbiert. 1 heisst, dass alles absorbiert wird, 0 , dass nichts absorbiert wird. Der Gegenpol, der Reflexionskoeffizent, beschreibt, wie viel der Frequenzen reflektiert werden und kann mit der folgenden Formel umgerechnet werden: \\(\\rho=1-\\alpha\\) Oft sind diese Koeffizenten abh\u00e4hngig von der Frequenz (also \\(\\alpha(\\nu)\\) und \\(\\rho(\\nu)\\) ). Ein blaues T-Shirt w\u00fcrde die \"blauen Frequenzen\" reflektieren und die anderen absorbieren. Bei einem schwarzen Strahler kann bewiessen werden, dass es keinen Unterschied gibt, ob die Strahlung vom Material 1 ins Material 2 oder umgekehrt geht. \\[ \\alpha_{1\\rightarrow 2}=\\alpha_{2\\rightarrow 1}\\\\ \\sigma_{1\\rightarrow 2}=\\sigma_{2\\rightarrow 1} \\]","title":"Elektromagnitische Strahlung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#emission","text":"Wenn eine Strahle von einem \"d\u00fcnnem\" Material, wie Luft, aufgenommen wird, wird von Emission von Strahlung gesprochen und anstatt dem Absorptionskoeffizent, wird der Emissionskoeffizenten \\(\\varepsilon\\) verwendet (es gilt also: \\(\\alpha_{2\\rightarrow1}=\\varepsilon_{2\\rightarrow 1}\\) )","title":"Emission"},{"location":"21HS/GED/Physik/all-ged-summaries.html#schwarzer-strahler","text":"Ein K\u00f6rper mit dem Reflexionskoeffizent \\(\\rho=0\\) und Absorptionskoeffizenten von \\(\\alpha=1\\) wird schwarzer Strahler genannt. Ein schwarzer Block kann als Schwarzerstrahler angen\u00e4hert werden (er reflektiert trotzdem noch ein wenig Licht), aber auch die Sonne , da diese keine Frequenzen und somit auch Licht reflektiert .","title":"Schwarzer Strahler"},{"location":"21HS/GED/Physik/all-ged-summaries.html#grauer-strahler","text":"Ein grauer Strahler ist ein K\u00f6rper, welcher in gewissen Wellenbereichen nicht so stark strahlen, wie ein schwarzer Strahler. Dass heisst, dass der Emmisionskoeffizent \\(\\varepsilon\\) nicht umbedingt 1 muss sein.","title":"Grauer Strahler"},{"location":"21HS/GED/Physik/all-ged-summaries.html#wiensches-verschiebungsgesetzt","text":"Mit \\(\\lambda_{max}=\\frac b T\\) kann man die Temperatur in Kelvin zu der maximalen Wellenl\u00e4nge umrechnen. Mit dieser Formel kann man auch die Lichtfarbe, welche in Kelvin angegeben wird, erkl\u00e4ren.","title":"Wien'sches Verschiebungsgesetzt"},{"location":"21HS/GED/Physik/all-ged-summaries.html#stefan-boltzmann-gesetzt-gesammtleistung","text":"Um die Gesamtleistung eines Strahlendenk\u00f6rpers zu berechnen kann man die folgende Formel ben\u00fctzten: \\(P_{rad}=\\sigma AT^4\\) Dabei ist \\(\\sigma=5.67\\cdot10^{-8} [Wm^{-2}K^{-4}]\\) , \\(A\\) die Oberfl\u00e4che des K\u00f6rpers und \\(T\\) die Temperatur des K\u00f6rpers.","title":"Stefan-Boltzmann Gesetzt (Gesammtleistung)"},{"location":"21HS/GED/Physik/all-ged-summaries.html#energetische-bilanz-eines-strahlers","text":"Die Energiebilanz sagt aus, ob Energie vom K\u00f6rper aufgenommen wird und er daher w\u00e4rmer wird oder ob mehr Energie abgegeben wird und er daher k\u00e4lter wird. Dies kann mit der folgenden Formel berechnet werden: $$ I=-\\frac{dE}{dt}=\\sigma\\varepsilon A(T^4-T_{env}^4) $$ Dabei ist \\(\\sigma=5.67\\cdot10^{-8}\\) , \\(\\varepsilon\\) den Emmisionskoeffizenten, \\(A\\) die Oberfl\u00e4che des K\u00f6rpers, \\(T\\) die Temperator des K\u00f6rpers und \\(T_{env}\\) die Umgebungstemperatur. Bei einem grauen Strahler kann \\(\\varepsilon \\neq1\\) sein. Wie man an der Formeln mit den Temperaturen erkennen kann, wird die Temperatur hoch 4 gerechnet. Dies f\u00fchrt bei einer 16-facher vergr\u00f6sserung, wenn die Temperatur verdoppelt wird. Ein \u00e4hliches Ph\u00e4nomen gibt es, wenn die L\u00e4nge eines K\u00f6rpers veroppelt werden, wird die Fl\u00e4che vervierfacht und das Volumen verachtfacht.","title":"Energetische Bilanz eines Strahlers"},{"location":"21HS/GED/Physik/all-ged-summaries.html#sonneneinstrahlung","text":"Um zu berechnen, wie viel Energie die Sonne auf die Erde strahlt, kann folgende Formel gebraucht werden: $$ I=\\sin(\\beta)Aj $$ Dabei ist \\(\\beta\\) den Einstrahls-Winkel der Sonne, \\(A\\) die Fl\u00e4che, wo f\u00fcr man die Energie \\(I\\) berechnen m\u00f6chte und \\(j\\) der Faktor der Sonneneinstrahlung.","title":"Sonneneinstrahlung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#warmeleitung","text":"\\[ I=-Ah_{X,Y}(T_X-T_Y) \\] Mit dieser Formel kann der W\u00e4rmestrom (Energie pro Zeit) berechnet werden, welcher von einem Objekt \\(X\\) mit der Temperatur \\(T_X\\) zu einem Objekt \\(Y\\) mit der Temperatur \\(T_Y\\) fliesst. \\(A\\) ist dabei die Ber\u00fchrungsfl\u00e4che der zwei Objekte und \\(h_{X,Y}\\) ist der W\u00e4rme\u00fcbertragunskoeffizent.","title":"W\u00e4rmeleitung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#signale","text":"","title":"Signale"},{"location":"21HS/GED/Physik/all-ged-summaries.html#signalarten","text":"Name Bild Sinussignal Rechtecksignal S\u00e4gezahnsignal Dreieckssignal Eine Welle wird haupts\u00e4chlich durch ihre Amplitude \\(A\\) , Periode \\(T\\) , Frequenz \\(\\nu\\) und Phasenverschiebung \\(\\varphi\\) definiert. Mit \\(T=\\frac 1 \\nu\\) kann man von der Frequenz \\(\\nu\\) zur Periode \\(T\\) umwandeln. Ein Sinussignal kann in ein Cosinussignal und umgekehrt folgendermassen umgewandelt werden: $$ sin(a-\\frac \\pi 2)=cos(a)\\ cos(a+\\frac \\pi 2)=sin(a) $$","title":"Signalarten"},{"location":"21HS/GED/Physik/all-ged-summaries.html#fourierzerlegung","text":"Man kann jede Funktion in eine Summe von Cosinusen oder Sinusen zerlegen","title":"Fourierzerlegung"},{"location":"21HS/GED/Physik/all-ged-summaries.html#tone-und-klangfarbe","text":"Neben eines Grundtones produziert ein Instrument auch noch Obert\u00f6ne. Als Daumenregeln: Je mehr Obert\u00f6ne, desto sch\u00e4rfer t\u00f6nt ein Instrument.","title":"T\u00f6ne und Klangfarbe"},{"location":"21HS/GED/Physik/all-ged-summaries.html#nyquist-shannon-theorem","text":"Es m\u00fcssen doppelt so viele Messpunkte existieren, wie die maximale Frequenz: \\(f_{measure}>2\\cdot f_{max}\\) . Wenn dies nicht gegeben ist, tritt Aliasing auf und es werden falsche Frequenzen gespeichert. F\u00fcr die tiefste Frequenz gilt, dass das Intervall \\(T\\) zwischen den Messpunkten : \\(T > \\frac 1 {f_{min}}\\)","title":"Nyquist - Shannon Theorem"},{"location":"21HS/GED/Physik/all-ged-summaries.html#blip","text":"Ein Blip ist ein kurzes Signal. Dabei gilt, je k\u00fcrzer der Blip, desto mehr Frequenzen gibt es um die Hauptfrequenz \\(\\nu_0\\) Ein zweites Prinzip, das \u00e4hlich funktioniert: Je steiler eine Flanke eines Signales, desto mehr Frequenzen werden ben\u00f6tigt, um die Flanke darzustellen.","title":"Blip"},{"location":"21HS/GED/Physik/all-ged-summaries.html#schnelle-orgeln","text":"Damit ein Ton als harmonisch empfunden wird, muss eine Frequenz domonieren. Bei einem Blip ist dies allerdings nicht umbedingt gegeben. Ebenfalls gilt, je h\u00f6her ein Ton, desto k\u00fcrzer kann er sein, dass trotzdem noch eine Frequenz dominiert und der Ton harmonisch klingt. Aus diesem Grund kann eine Picolo schnell spielen und eine tiefe Orgel nicht. Mathematisch kann diese Relation folgendermassen ausgedr\u00fcckt werden: $$ \\frac{\\Delta f\\cdot \\Delta t}{2}\\sim 1 $$","title":"Schnelle Orgeln"},{"location":"21HS/GED/Physik/all-ged-summaries.html#signal-to-noise-ratio","text":"\\(A_{noise}=\\text{Die durchschnittliche Noise Amplitude}\\) $$ SNR=\\frac{P_{signal}} {P_{noise}}=\\frac{I_{signal}} {I_{noise}}=\\frac{A^2_{signal}}{A^2_{noise}} $$ Dabei bezeichnet \\(P\\) die Leistung, \\(I\\) die Intensit\u00e4t und \\(A\\) die Amplitude.","title":"Signal-to-Noise Ratio"},{"location":"21HS/GED/Physik/include.html","text":"[[TOC]] !!!include(./00_Formeln.md)!!! !!!include(./01_ch\u00fcgelif\u00fcsik.md)!!! !!!include(./02_Elektrotechnik.md)!!! !!!include(./04_Thermische_Strahlung.md)!!! !!!include(./05_Signale.md)!!!","title":"Include"},{"location":"21HS/INCO/00_Infos.html","text":"Infos Pr\u00fcfung Zusammenfassung (14 Seiten/7-A4 Seiten) CAS-Taschenrechner ist erlaubt Keine weiteren Hilfsmittel sind erlaubt Tipps vom Dozenten Dezibel weden oft schlecht verstanden Huffman kommt (fast) sicher Faltungscode","title":"Infos"},{"location":"21HS/INCO/00_Infos.html#infos","text":"","title":"Infos"},{"location":"21HS/INCO/00_Infos.html#prufung","text":"Zusammenfassung (14 Seiten/7-A4 Seiten) CAS-Taschenrechner ist erlaubt Keine weiteren Hilfsmittel sind erlaubt","title":"Pr\u00fcfung"},{"location":"21HS/INCO/00_Infos.html#tipps-vom-dozenten","text":"Dezibel weden oft schlecht verstanden Huffman kommt (fast) sicher Faltungscode","title":"Tipps vom Dozenten"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html","text":"Software zur Simulierng: https://kra.lc/projects/jdigitalsimulator/download.html D-Flip-Flop 1bit Speicher hat 3 Eing\u00e4ge Clock (C) Eingang (D) Ausgang (Q) Wenn C von niedrig zu hoch geht (steigende Flanke), wird D gelesen und gespeichert. Der gespeicherte Wert wird auf Q ausgegeben Beispiele: Wenn D hoch ist und C steigt, dann wird ein 1 gespeichert. Wenn D tief ist und C steigt , dann wird ein 0 gespeichert Wenn D hoch oder tief ist, aber C nicht steigt, dann passiert nichts Fakten: n Flip-Flop k\u00f6nnen \\(2^n\\) Zust\u00e4nde speichern Periode T = T0 + T1 [s] T0 = Periode, in welcher das Signal 0 ist T1 = Periode, in welcher das Signal 1 ist Frequenz f = 1/T [HZ] Duty Cycle = T1/T = Wie viel Prozent das Signal auf 1 ist Beispiel: Frequenzteiler Bilder einf\u00fcgen Generelle Form Bild von Folien einf\u00fcgen Typsiche Anwendungen Counter ... (von Folien) Finit State Machine Shift Register Paralleles Register Zustands-Automaten Zustands Tabelle einf\u00fcgen","title":"2 Sequenzelle Bauteile"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#d-flip-flop","text":"1bit Speicher hat 3 Eing\u00e4ge Clock (C) Eingang (D) Ausgang (Q) Wenn C von niedrig zu hoch geht (steigende Flanke), wird D gelesen und gespeichert. Der gespeicherte Wert wird auf Q ausgegeben Beispiele: Wenn D hoch ist und C steigt, dann wird ein 1 gespeichert. Wenn D tief ist und C steigt , dann wird ein 0 gespeichert Wenn D hoch oder tief ist, aber C nicht steigt, dann passiert nichts Fakten: n Flip-Flop k\u00f6nnen \\(2^n\\) Zust\u00e4nde speichern Periode T = T0 + T1 [s] T0 = Periode, in welcher das Signal 0 ist T1 = Periode, in welcher das Signal 1 ist Frequenz f = 1/T [HZ] Duty Cycle = T1/T = Wie viel Prozent das Signal auf 1 ist","title":"D-Flip-Flop"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#beispiel-frequenzteiler","text":"Bilder einf\u00fcgen","title":"Beispiel: Frequenzteiler"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#generelle-form","text":"Bild von Folien einf\u00fcgen Typsiche Anwendungen Counter ... (von Folien)","title":"Generelle Form"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#finit-state-machine","text":"","title":"Finit State Machine"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#shift-register","text":"","title":"Shift Register"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#paralleles-register","text":"","title":"Paralleles Register"},{"location":"21HS/INCO/2_Sequenzelle%20Bauteile.html#zustands-automaten","text":"Zustands Tabelle einf\u00fcgen","title":"Zustands-Automaten"},{"location":"21HS/INCO/3_Zahlensysteme.html","text":"Zahlensysteme Generel Das Zusammen-Rechnen kann auch als Summenzeichen: \\(\\sum^{n}_{i=0}(a_i\\cdot b^i)\\) Bin\u00e4r Abek\u00fcrzungen: 0b0010 0000 0B0010 0000 \\(0010'0000_b\\) Hexadezimal Abk\u00fcrzungen: \\(AF3C_h\\) AF3Ch (<- h am Ende anf\u00fcgen) 0xAF3C Umrechnen Achtung von welcher Richtung man den Rest liest TODO \\(\\frac{a_n\\cdot b^n + a_2\\cdot b^2+a_1\\cdot b^1+a_0}{b}\\) Beispiel: \\(1000_d:16_d = 62_d R8_d=8_h\\) \\(62_d : 16_d = 3_d R 14_d=E_h\\) \\(3_d : 16d = 0_d R 3_d=3_h\\) \\(\\text{Daraus gibt es von unten nach oben gelesen: } 3E8_h=1000_d\\) Beispiel #2: \\(26.6875_d = binar\\) Man beginnt nur mit der ganz Zahl, also 26 \\(26_d : 2_d = 13_d R0\\) \\(13_d : 2_d = 6_d R1\\) \\(6_d : 2_d = 3_d R0\\) \\(3_d : 2_d = 1_d R1\\) \\(1_d : 2_d = 0_d R1\\) Von unten nach oben gelesen gibt dies: \\(11010_b\\) Nun noch \\(0.6875_d\\) \\(0.6875_d \\cdot 2 = 0.375 + 1\\) \\(0.374 \\cdot 2 = 0.75 + 0\\) \\(0.75 * 2 = 0.5 + 1\\) \\(0.5 * 2 = 0 + 2\\) Nun von oben nach unten lesen: \\(1011_b\\) Zusammen: \\(11010.1011_b\\) Addition & Subtraktion Wie Schriftliches-Addieren Bei Hexadezimal darauf denken, dass der \u00dcbertrag im Hexadezimal-System ist. Heisst eine 1 beim \u00dcbertrag von der Einerstelle ist 16 Ziffern verschieben Wenn man eine 0 anh\u00e4nkt, rechnet man Mal die Basis. Als Beispiel: \\(12 \\cdot 10 = 120\\) oder \\(10b\\cdot2_d=100_b\\) Multiplikaton Beim Bin\u00e4r (oder auch andre Zahlensystem) multiplizeren, wird jede einzelne Stelle mit der ganzen anderen Zahlen multipliziert und die Ergebnisse addiert. Dies funktioniert im Zehnersystem, wie auch in Bin\u00e4r. Beispiel: 101 x 1110 1 x 1110 = 1110 0 x 1110 = 0000 1 x 1110 = 1110 1000110 Dividieren 6 : 5 = 1.2 110 : 101 = 1.0001 - (hat 1x platz -> 1.) 001 010 (ein 0 wird hinzugef\u00fcgt) 0100 (da 101 nicht in 100 hineinpasst, wird ein weiteres 0 hinzugef\u00fcgt -> 1.0) 01000 (ein weiteres 0 wird hinzugef\u00fcgt -> 1.00) -101 (jetzt kann 101 abgezogen werden -> 1.001) 011 Dieses Spiel k\u00f6nnte man nun wiederholen bis in alle Ewigkeit, da 1.2 sich nicht als bin\u00e4r oder hexadezimal Zahle l\u00e4sst. Minuszahlen Um Minuszahlen ohne ein Minuszeichen darzustellen wird in der Informatik einen Trick verwendet. 9er- & 10er-Komplement Wenn man von 0 Eins abzieht (-1 rechnet), dann bekommt man -1. Wenn man nun dasselbe durchf\u00fchrt, aber ohne Minuszeichen, dann wird aus 0000 \\(\\to\\) 9999, da es einen Underflow gibt. Man halbiert die Anzahl m\u00f6glichen Zahlen, da nun die H\u00e4lfte der Zahlen f\u00fcr positive Zahlen und die andere H\u00e4lfte f\u00fcr die negativen Zahlen steht. Dies nennt sich das Komplement . Wenn im 10-er System gedacht wird, ist das 9-er Komplement, wenn jede Ziffer von 9 abgez\u00e4hlt wird. Die negative Representation von 0001 (also -1), w\u00e4re 9998 . Dieses System hat aber den Nachteil, dass man zwei 0 hat: 9999 und 0000 . Da dies Platzverschwendung w\u00e4re, gibt es das 10er-Komplement, in dem noch +1 gerechnet wird. Aus 0001 wird zuerst 9998 und dann 9999 . 1er- & 2er-Komplement Dasselbe Konzept, wie beim 9er-, bzw. 10er-Komplement kann auch auf das 1er- und 2er-Komplement \u00fcbertragen werden. Beim 1er-Komplement wird jede Ziffer von 1 abegez\u00e4hlt. Die negative Representation von 0001 ist also 1110 . Auch hier hat man zwei Representation f\u00fcr die Zahl 0 , daher wird im 10er-Komplement noch +1 gerechnet. Aus 1110 wird also 1111 f\u00fcr -1 . Hier sieht man die verschiednenen Verfahren Bin\u00e4r unsigned 1er-Komplement 2er-Komplement 1111 15 -0 -1 1110 14 -1 -2 1101 13 -2 -3 1100 12 -3 -4 1011 11 -4 -5 1010 10 -5 -6 1001 9 -6 -7 1000 8 -7 -8 0111 7 7 7 0110 6 6 6 0101 5 5 5 0100 4 4 4 0011 3 3 3 0010 2 2 2 0001 1 1 1 0000 0 0 0 Dasselbe Verfahren funktioniert auch f\u00fcr Kommazahlen. In diesemfall wird die ganze Kommazahl als eine Zahl gedacht und nur einmal +1 beim 2er-Komplement gerechnet. Um eine Zahl in ihr Komplement um zuwandeln, muss der Umwandler wissen, wie viel Stellen die Zahl hat. Daher am besten 1, als 0001 schreiben. Over- & Underflows Ein Overflow, bzw. ein Underflow passieren, wenn eine Zahl gr\u00f6sser ist, als der Wertebereich, in denen man sie speichert. Je nachdem ob ein Komplement verwendet wird oder nicht, ist dieser Punkt an einem anderen Ort. Bei Zahlen ohne Vorzeichen ist der Overflow-Punkt zwischen 0 und 15: Bei Zahlen, welche mit dem 2er-Komplement formatiert sind, ist dieser Punkt zwischen 7 und -8: Verschiedene Codes BCD Code (Binary Code Decimal) Ein Code, welcher verwendet wird, wenn Dezimalzahlen auf einer Anzeige dargestellt werden. Die Bin\u00e4rzahlen 0000 bis 1001 gelten f\u00fcr 0 - 9, die anderen sind ung\u00fcltige Zeichen. Gray Code Gray Code ist ein Code, bei welchen maximal 1 Bit von einem Codewort zum einem benachbarten Codewort (z.B. 5 zu 6 oder 5 zu 4). Dieses System wird f\u00fcr Schleifkontakte genutzt, da es dort problematisch sein kann, wenn sich mehrere Bits gleichzeitig \u00e4ndern. Wenn sich zwei Bits \u00e4ndern, kann es sein, dass ein Bit sich ein wenig sp\u00e4ter \u00e4ndert und so der Computer eine Falsche Zahl liest. Dezimal GrayCode 0 000 1 001 2 011 3 010 4 110 5 111 6 101 7 100 Oft wird ein Graycode f\u00fcr Schleifkontakte auf einer Drehscheibe genutzt. ASCII Code Unicode Unicode ist ein Zeichensatz in dem alle Modernensprachen (und viele historische Sprachen) abgebildet werden k\u00f6nnen und hat das Ziel die inkompatibilit\u00e4t zwischen Encodings aufzuheben. Dabei hat Unicode Platz f\u00fcr rund 1 Milion Zeichen, wovon heute ca 10% genutzt sind. Dabei definiert der Standart 17 Ebenen. Die erste ist die Base Multilinugal Plane (BMP), in welcher die Zeichen der modernen Sprachen abgelegt sind. In der Supplementary Multilingual Plane (SMP) sind historische Zeichen, Symbole und auch Emoticons abgelegt. UTF-8, UTF-16 & UTF-32 UTF-8 ist ein Code mit variabler Breite und kann 1 bis 4 Bytes pro Zeichen gross sein. Unicode-Bereicht Utf-8 Codierung Anzahl Code-Bits 0000'0000 - 0000'007F 0xxxxxxx 7 0000'0080-0000'07FF 110xxxxx 10xxxxxx 11 (5 + 1*6) 0000'0800-0000'FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 (4 + 2*6) 0001'0000-0010'FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 (3 + 3*6) UTF-16 ist ein Encoding, welches entweder aus 2 oder 4 Bytes besteht. Die Code Points zwischen \\(0000_h\\) und \\(FFFF_h\\) k\u00f6nnen mit 2 Bytes dargestellt werden. F\u00fcr h\u00f6hrere Code Points werden 4 Bytes ben\u00f6tigt. Das ein 2 bytiges und 4 bytiges Code Wort nicht verwechselt werden, wird der Bereich \\(D800_h\\) bis \\(DFFF_h\\) freigehalten. Wenn ein Code Wort in diesem Bereich liegt, dann ist es klar, dass die n\u00e4chsten zwei Bytes auch noch dazu geh\u00f6ren. Endiannes Wenn mehrere Bytes als eine Zahl verschickt werden, stellt sich die Frage, welches Byte zuerst kommt. Hier gibt es zwei Varianten. Name Beschreibung Darstellung Little Endian Das niederstwertige Byte wird zuerst geschickt FEDCBA9 87654321 Big Endian Das h\u00f6chstwertige Byte wird zuerst geschickt 87654321 FEDCBA9","title":"Zahlensysteme"},{"location":"21HS/INCO/3_Zahlensysteme.html#zahlensysteme","text":"","title":"Zahlensysteme"},{"location":"21HS/INCO/3_Zahlensysteme.html#generel","text":"Das Zusammen-Rechnen kann auch als Summenzeichen: \\(\\sum^{n}_{i=0}(a_i\\cdot b^i)\\)","title":"Generel"},{"location":"21HS/INCO/3_Zahlensysteme.html#binar","text":"Abek\u00fcrzungen: 0b0010 0000 0B0010 0000 \\(0010'0000_b\\)","title":"Bin\u00e4r"},{"location":"21HS/INCO/3_Zahlensysteme.html#hexadezimal","text":"Abk\u00fcrzungen: \\(AF3C_h\\) AF3Ch (<- h am Ende anf\u00fcgen) 0xAF3C","title":"Hexadezimal"},{"location":"21HS/INCO/3_Zahlensysteme.html#umrechnen","text":"Achtung von welcher Richtung man den Rest liest TODO \\(\\frac{a_n\\cdot b^n + a_2\\cdot b^2+a_1\\cdot b^1+a_0}{b}\\) Beispiel: \\(1000_d:16_d = 62_d R8_d=8_h\\) \\(62_d : 16_d = 3_d R 14_d=E_h\\) \\(3_d : 16d = 0_d R 3_d=3_h\\) \\(\\text{Daraus gibt es von unten nach oben gelesen: } 3E8_h=1000_d\\) Beispiel #2: \\(26.6875_d = binar\\) Man beginnt nur mit der ganz Zahl, also 26 \\(26_d : 2_d = 13_d R0\\) \\(13_d : 2_d = 6_d R1\\) \\(6_d : 2_d = 3_d R0\\) \\(3_d : 2_d = 1_d R1\\) \\(1_d : 2_d = 0_d R1\\) Von unten nach oben gelesen gibt dies: \\(11010_b\\) Nun noch \\(0.6875_d\\) \\(0.6875_d \\cdot 2 = 0.375 + 1\\) \\(0.374 \\cdot 2 = 0.75 + 0\\) \\(0.75 * 2 = 0.5 + 1\\) \\(0.5 * 2 = 0 + 2\\) Nun von oben nach unten lesen: \\(1011_b\\) Zusammen: \\(11010.1011_b\\)","title":"Umrechnen"},{"location":"21HS/INCO/3_Zahlensysteme.html#addition-subtraktion","text":"Wie Schriftliches-Addieren Bei Hexadezimal darauf denken, dass der \u00dcbertrag im Hexadezimal-System ist. Heisst eine 1 beim \u00dcbertrag von der Einerstelle ist 16","title":"Addition &amp; Subtraktion"},{"location":"21HS/INCO/3_Zahlensysteme.html#ziffern-verschieben","text":"Wenn man eine 0 anh\u00e4nkt, rechnet man Mal die Basis. Als Beispiel: \\(12 \\cdot 10 = 120\\) oder \\(10b\\cdot2_d=100_b\\)","title":"Ziffern verschieben"},{"location":"21HS/INCO/3_Zahlensysteme.html#multiplikaton","text":"Beim Bin\u00e4r (oder auch andre Zahlensystem) multiplizeren, wird jede einzelne Stelle mit der ganzen anderen Zahlen multipliziert und die Ergebnisse addiert. Dies funktioniert im Zehnersystem, wie auch in Bin\u00e4r. Beispiel: 101 x 1110 1 x 1110 = 1110 0 x 1110 = 0000 1 x 1110 = 1110 1000110","title":"Multiplikaton"},{"location":"21HS/INCO/3_Zahlensysteme.html#dividieren","text":"6 : 5 = 1.2 110 : 101 = 1.0001 - (hat 1x platz -> 1.) 001 010 (ein 0 wird hinzugef\u00fcgt) 0100 (da 101 nicht in 100 hineinpasst, wird ein weiteres 0 hinzugef\u00fcgt -> 1.0) 01000 (ein weiteres 0 wird hinzugef\u00fcgt -> 1.00) -101 (jetzt kann 101 abgezogen werden -> 1.001) 011 Dieses Spiel k\u00f6nnte man nun wiederholen bis in alle Ewigkeit, da 1.2 sich nicht als bin\u00e4r oder hexadezimal Zahle l\u00e4sst.","title":"Dividieren"},{"location":"21HS/INCO/3_Zahlensysteme.html#minuszahlen","text":"Um Minuszahlen ohne ein Minuszeichen darzustellen wird in der Informatik einen Trick verwendet.","title":"Minuszahlen"},{"location":"21HS/INCO/3_Zahlensysteme.html#9er-10er-komplement","text":"Wenn man von 0 Eins abzieht (-1 rechnet), dann bekommt man -1. Wenn man nun dasselbe durchf\u00fchrt, aber ohne Minuszeichen, dann wird aus 0000 \\(\\to\\) 9999, da es einen Underflow gibt. Man halbiert die Anzahl m\u00f6glichen Zahlen, da nun die H\u00e4lfte der Zahlen f\u00fcr positive Zahlen und die andere H\u00e4lfte f\u00fcr die negativen Zahlen steht. Dies nennt sich das Komplement . Wenn im 10-er System gedacht wird, ist das 9-er Komplement, wenn jede Ziffer von 9 abgez\u00e4hlt wird. Die negative Representation von 0001 (also -1), w\u00e4re 9998 . Dieses System hat aber den Nachteil, dass man zwei 0 hat: 9999 und 0000 . Da dies Platzverschwendung w\u00e4re, gibt es das 10er-Komplement, in dem noch +1 gerechnet wird. Aus 0001 wird zuerst 9998 und dann 9999 .","title":"9er- &amp; 10er-Komplement"},{"location":"21HS/INCO/3_Zahlensysteme.html#1er-2er-komplement","text":"Dasselbe Konzept, wie beim 9er-, bzw. 10er-Komplement kann auch auf das 1er- und 2er-Komplement \u00fcbertragen werden. Beim 1er-Komplement wird jede Ziffer von 1 abegez\u00e4hlt. Die negative Representation von 0001 ist also 1110 . Auch hier hat man zwei Representation f\u00fcr die Zahl 0 , daher wird im 10er-Komplement noch +1 gerechnet. Aus 1110 wird also 1111 f\u00fcr -1 . Hier sieht man die verschiednenen Verfahren Bin\u00e4r unsigned 1er-Komplement 2er-Komplement 1111 15 -0 -1 1110 14 -1 -2 1101 13 -2 -3 1100 12 -3 -4 1011 11 -4 -5 1010 10 -5 -6 1001 9 -6 -7 1000 8 -7 -8 0111 7 7 7 0110 6 6 6 0101 5 5 5 0100 4 4 4 0011 3 3 3 0010 2 2 2 0001 1 1 1 0000 0 0 0 Dasselbe Verfahren funktioniert auch f\u00fcr Kommazahlen. In diesemfall wird die ganze Kommazahl als eine Zahl gedacht und nur einmal +1 beim 2er-Komplement gerechnet. Um eine Zahl in ihr Komplement um zuwandeln, muss der Umwandler wissen, wie viel Stellen die Zahl hat. Daher am besten 1, als 0001 schreiben.","title":"1er- &amp; 2er-Komplement"},{"location":"21HS/INCO/3_Zahlensysteme.html#over-underflows","text":"Ein Overflow, bzw. ein Underflow passieren, wenn eine Zahl gr\u00f6sser ist, als der Wertebereich, in denen man sie speichert. Je nachdem ob ein Komplement verwendet wird oder nicht, ist dieser Punkt an einem anderen Ort. Bei Zahlen ohne Vorzeichen ist der Overflow-Punkt zwischen 0 und 15: Bei Zahlen, welche mit dem 2er-Komplement formatiert sind, ist dieser Punkt zwischen 7 und -8:","title":"Over- &amp; Underflows"},{"location":"21HS/INCO/3_Zahlensysteme.html#verschiedene-codes","text":"","title":"Verschiedene Codes"},{"location":"21HS/INCO/3_Zahlensysteme.html#bcd-code-binary-code-decimal","text":"Ein Code, welcher verwendet wird, wenn Dezimalzahlen auf einer Anzeige dargestellt werden. Die Bin\u00e4rzahlen 0000 bis 1001 gelten f\u00fcr 0 - 9, die anderen sind ung\u00fcltige Zeichen.","title":"BCD Code (Binary Code Decimal)"},{"location":"21HS/INCO/3_Zahlensysteme.html#gray-code","text":"Gray Code ist ein Code, bei welchen maximal 1 Bit von einem Codewort zum einem benachbarten Codewort (z.B. 5 zu 6 oder 5 zu 4). Dieses System wird f\u00fcr Schleifkontakte genutzt, da es dort problematisch sein kann, wenn sich mehrere Bits gleichzeitig \u00e4ndern. Wenn sich zwei Bits \u00e4ndern, kann es sein, dass ein Bit sich ein wenig sp\u00e4ter \u00e4ndert und so der Computer eine Falsche Zahl liest. Dezimal GrayCode 0 000 1 001 2 011 3 010 4 110 5 111 6 101 7 100 Oft wird ein Graycode f\u00fcr Schleifkontakte auf einer Drehscheibe genutzt.","title":"Gray Code"},{"location":"21HS/INCO/3_Zahlensysteme.html#ascii-code","text":"","title":"ASCII Code"},{"location":"21HS/INCO/3_Zahlensysteme.html#unicode","text":"Unicode ist ein Zeichensatz in dem alle Modernensprachen (und viele historische Sprachen) abgebildet werden k\u00f6nnen und hat das Ziel die inkompatibilit\u00e4t zwischen Encodings aufzuheben. Dabei hat Unicode Platz f\u00fcr rund 1 Milion Zeichen, wovon heute ca 10% genutzt sind. Dabei definiert der Standart 17 Ebenen. Die erste ist die Base Multilinugal Plane (BMP), in welcher die Zeichen der modernen Sprachen abgelegt sind. In der Supplementary Multilingual Plane (SMP) sind historische Zeichen, Symbole und auch Emoticons abgelegt.","title":"Unicode"},{"location":"21HS/INCO/3_Zahlensysteme.html#utf-8-utf-16-utf-32","text":"UTF-8 ist ein Code mit variabler Breite und kann 1 bis 4 Bytes pro Zeichen gross sein. Unicode-Bereicht Utf-8 Codierung Anzahl Code-Bits 0000'0000 - 0000'007F 0xxxxxxx 7 0000'0080-0000'07FF 110xxxxx 10xxxxxx 11 (5 + 1*6) 0000'0800-0000'FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 (4 + 2*6) 0001'0000-0010'FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 (3 + 3*6) UTF-16 ist ein Encoding, welches entweder aus 2 oder 4 Bytes besteht. Die Code Points zwischen \\(0000_h\\) und \\(FFFF_h\\) k\u00f6nnen mit 2 Bytes dargestellt werden. F\u00fcr h\u00f6hrere Code Points werden 4 Bytes ben\u00f6tigt. Das ein 2 bytiges und 4 bytiges Code Wort nicht verwechselt werden, wird der Bereich \\(D800_h\\) bis \\(DFFF_h\\) freigehalten. Wenn ein Code Wort in diesem Bereich liegt, dann ist es klar, dass die n\u00e4chsten zwei Bytes auch noch dazu geh\u00f6ren.","title":"UTF-8, UTF-16 &amp; UTF-32"},{"location":"21HS/INCO/3_Zahlensysteme.html#endiannes","text":"Wenn mehrere Bytes als eine Zahl verschickt werden, stellt sich die Frage, welches Byte zuerst kommt. Hier gibt es zwei Varianten. Name Beschreibung Darstellung Little Endian Das niederstwertige Byte wird zuerst geschickt FEDCBA9 87654321 Big Endian Das h\u00f6chstwertige Byte wird zuerst geschickt 87654321 FEDCBA9","title":"Endiannes"},{"location":"21HS/INCO/4_Informationstheorie.html","text":"Was ist Information Etwas, was das eigene Wissen erweitert; etwas neues , was wir vorhin noch nicht wussten mit \\(F=ceiling(log(_2(N))\\) Daten Quellen Discrete Memoryless Source (DMS) Discrete = Einzelne Nachrichten Die einzelnen Nachrichten sind Unabh\u00e4ngig Beispiele: W\u00fcrfel (errinnert sich nicht an den letzten Wurf, getrennte Nachrichten) Liste von Nummerschild von Autos von einer Kamera auf der Autobahn Binary Memoryless Source (BMS) Wie eine DMS, aber nur 1 oder 0 (scheint ein wenig nutzlos zu sein\u2026) Irrelevanz Informationen ist irrelevant, wenn f\u00fcr den Empf\u00e4nger die Informationen nicht ben\u00f6tigt. Um dies festzustellen zu k\u00f6nnen, muss man wissen, f\u00fcr was der Empf\u00e4nger die Informationen verwendet. Mathe dahinter Information \\(I(x)=log_2(\\frac 1 {P(x)})\\) Diese Formel stellt dar, wie gross der \u00dcberraschungseffekt ist. Die Einheit ist \"Bits\". ( \\(P(x)\\) ist, wie wahrscheinlich es ist, dass x vorkommt) Entropie Die Entropie ist der gewichtete Durchschnitt der Informationen und wird mit folgender Formel berechnet: \\(H(X)=\\sum^{N-1}_{n=0} P(x_n)\\cdot I(x_n)=\\sum^{N-1}_{n=0}P(x_n)\\cdot log_2(\\frac 1 {P(x_n)})\\) Das folgende Bild zeigt die Entropie von einer BMS mit der Wahrscheinlichkeit von \\(p\\) f\u00fcr das eine Zeichen (und die Wahrscheinlichkeit \\(1-p\\) f\u00fcr das andere Zeichen). Wie man sieht, ist die Entropie am h\u00f6chsten, wenn alle Zeichen gleich oft Vorkommen. Zweier Logarithmus ohne zweier Logarithmus \\(2^x=K\\) \\(log(2^x)=log(K)\\) \\(x\\cdot log(2)=log(K)\\) \\(x=\\frac{log(K)}{log(2)}\\) Quellenkodierung Redundanz Daten, welche reversible entfernt werden k\u00f6nnen. Um dies zu berechnen, kann man von der Code-L\u00e4nge die Entropie abziehen. Jetzt kann es aber sein, dass es Codierungen gibt, bei welcher nicht alle Zeichen dieselbe L\u00e4nge haben. Daher braucht man die mittlere Codewortl\u00e4nge, welche wie folgt berechnet wird: \\(L(X)=\\sum^{N-1}_{n=0}P(x_n)\\cdot l(x_n)\\) (Also eigentlich einfach nur der gewichtete Durchschnitt von allen Codel\u00e4ngen) Die Redundanz ist nun folgendes: \\(R(X)=L(X)-H(X)\\) Wenn die Redundanz < 0 ist, dann komprimiert man mit Verl\u00fcste, da nicht alle Informationen hineinpassen und somit Informationen weggeworfen wird Huffman Codes Codes mit dem Huffmanverfahren sind: automatisch pr\u00e4fixfrei optimal (Das heisst, es gibt keine besseren pr\u00e4fixfreie Code) Vorgehen Ordne alle Symbole nach aufsteigenen Auftretenswahrscheinlichkeiten auf einer Zeile. Dies sind die Bl\u00e4tter Notiere unter jedes Blatt seine Wahrscheinlichkeit Schliesse die beiden Bl\u00e4tter mit der kleinsten Wahrscheinlichekit an einer gemeinsamen Astgabel an und ordne dem Ast die Summe der Wahrscheinlichkeiten zu Wiederhole Schritt 2 es nur noch ein Stamm gibt Jedem Ast wird nun ein eine 0, wenn man links geht und eine 1 wenn man rechts geht, zugewiessen Die Pfade zu allen Bl\u00e4tter aufschreiben. Das ist der Huffmancode Laufl\u00e4ngenkodierung Man speichert, wie oft ein Symbol vorkommt. Anstatt \"AAAAAABBC\" k\u00f6nnte man einfach \"6A2B1C\" Um auch Symbole, welche nur einmal vorkommen, effizent zu speichern, wird ein Token benutzt, welcher symbolisiert, dass nun eine Laufl\u00e4ngenkodierung kommt. Um das obere Beispiel nochmals aufzugreiffen: \"Z6AZ2BC\". Hier wurde Z als Marker (oder Token) gew\u00e4hlt, und nur wenn ein Z gelesen wird, wird das folgende als L\u00e4nge interpretiert. Wie viel Zeichen als Marker reserviert werden soll, ist abh\u00e4ngig von der Quelle in ihre statistischen Eigenschaften. LZ77 Ein Token ist definiert als (Offset, L\u00e4nge, Zeichen). Es hat eine fixe L\u00e4nge. Es gibt ebenfalls ein Such- und ein Vorschau-Buffer. Es werden im Such-Buffer nach denselben Muster gesucht. Falls ein Match gefunden wurde, wird ein Token geschrieben. In diesem ist der Offset des Such-Buffer, die L\u00e4nge ist die L\u00e4nge des Musters, und das Zeichen das n\u00e4chste Zeichen nach dem gemachten Muster. Falls kein Match gefunden wurde, wird folgender Token geschrieben (0, 0, Zeichen). Dies ist n\u00f6tig, da zu Beginn des Algorithmus noch nichts im Such-Buffer ist. Um dies zu dekodieren, wird dies R\u00fcckw\u00e4rts durch gearbeitet LZW LZW bassiert auf LZ77 mit einigen \u00c4nderungen. Anstatt eines \"Sliding Window\" ben\u00fctzt man ein W\u00f6rterbuch. Ein Token besteht nur aus einem Index, welchen auf das W\u00f6rterbuch referenziert. Der Dekoder baut gleichzeitig mit den empfangenen Tokens das W\u00f6rterbuch auf. Um ein Text zu enkodieren, werden folgende Schritte durchgef\u00fchrt Suche das aktuelle Zeichen im W\u00f6rterbuch So lange verl\u00e4ngern, wie m\u00f6glich und dieses als Token versenden Ein neuen Eintrag Token + der n\u00e4chste Zeichen ins W\u00f6rterbuch hinzuf\u00fcgen Um nun einen Tokenstream wieder zu dekodieren, muss man folgendes tun: Empfangener Token ausgeben Empfangener Token ins W\u00f6rterbuch als neuer Eintrag hinzuf\u00fcgen (mit einem Blank am Ende) N\u00e4chster empfangener Token ausgeben und die Blank vom letzten Schritt ausf\u00fcllen mit dem ersten ausgegeben Buchstaben des empfangen Tokens Gehe zu Schritt 2","title":"Was ist Information"},{"location":"21HS/INCO/4_Informationstheorie.html#was-ist-information","text":"Etwas, was das eigene Wissen erweitert; etwas neues , was wir vorhin noch nicht wussten mit \\(F=ceiling(log(_2(N))\\)","title":"Was ist Information"},{"location":"21HS/INCO/4_Informationstheorie.html#daten-quellen","text":"","title":"Daten Quellen"},{"location":"21HS/INCO/4_Informationstheorie.html#discrete-memoryless-source-dms","text":"Discrete = Einzelne Nachrichten Die einzelnen Nachrichten sind Unabh\u00e4ngig Beispiele: W\u00fcrfel (errinnert sich nicht an den letzten Wurf, getrennte Nachrichten) Liste von Nummerschild von Autos von einer Kamera auf der Autobahn","title":"Discrete Memoryless Source (DMS)"},{"location":"21HS/INCO/4_Informationstheorie.html#binary-memoryless-source-bms","text":"Wie eine DMS, aber nur 1 oder 0 (scheint ein wenig nutzlos zu sein\u2026)","title":"Binary Memoryless Source (BMS)"},{"location":"21HS/INCO/4_Informationstheorie.html#irrelevanz","text":"Informationen ist irrelevant, wenn f\u00fcr den Empf\u00e4nger die Informationen nicht ben\u00f6tigt. Um dies festzustellen zu k\u00f6nnen, muss man wissen, f\u00fcr was der Empf\u00e4nger die Informationen verwendet.","title":"Irrelevanz"},{"location":"21HS/INCO/4_Informationstheorie.html#mathe-dahinter","text":"","title":"Mathe dahinter"},{"location":"21HS/INCO/4_Informationstheorie.html#information","text":"\\(I(x)=log_2(\\frac 1 {P(x)})\\) Diese Formel stellt dar, wie gross der \u00dcberraschungseffekt ist. Die Einheit ist \"Bits\". ( \\(P(x)\\) ist, wie wahrscheinlich es ist, dass x vorkommt)","title":"Information"},{"location":"21HS/INCO/4_Informationstheorie.html#entropie","text":"Die Entropie ist der gewichtete Durchschnitt der Informationen und wird mit folgender Formel berechnet: \\(H(X)=\\sum^{N-1}_{n=0} P(x_n)\\cdot I(x_n)=\\sum^{N-1}_{n=0}P(x_n)\\cdot log_2(\\frac 1 {P(x_n)})\\) Das folgende Bild zeigt die Entropie von einer BMS mit der Wahrscheinlichkeit von \\(p\\) f\u00fcr das eine Zeichen (und die Wahrscheinlichkeit \\(1-p\\) f\u00fcr das andere Zeichen). Wie man sieht, ist die Entropie am h\u00f6chsten, wenn alle Zeichen gleich oft Vorkommen.","title":"Entropie"},{"location":"21HS/INCO/4_Informationstheorie.html#zweier-logarithmus-ohne-zweier-logarithmus","text":"\\(2^x=K\\) \\(log(2^x)=log(K)\\) \\(x\\cdot log(2)=log(K)\\) \\(x=\\frac{log(K)}{log(2)}\\)","title":"Zweier Logarithmus ohne zweier Logarithmus"},{"location":"21HS/INCO/4_Informationstheorie.html#quellenkodierung","text":"","title":"Quellenkodierung"},{"location":"21HS/INCO/4_Informationstheorie.html#redundanz","text":"Daten, welche reversible entfernt werden k\u00f6nnen. Um dies zu berechnen, kann man von der Code-L\u00e4nge die Entropie abziehen. Jetzt kann es aber sein, dass es Codierungen gibt, bei welcher nicht alle Zeichen dieselbe L\u00e4nge haben. Daher braucht man die mittlere Codewortl\u00e4nge, welche wie folgt berechnet wird: \\(L(X)=\\sum^{N-1}_{n=0}P(x_n)\\cdot l(x_n)\\) (Also eigentlich einfach nur der gewichtete Durchschnitt von allen Codel\u00e4ngen) Die Redundanz ist nun folgendes: \\(R(X)=L(X)-H(X)\\) Wenn die Redundanz < 0 ist, dann komprimiert man mit Verl\u00fcste, da nicht alle Informationen hineinpassen und somit Informationen weggeworfen wird","title":"Redundanz"},{"location":"21HS/INCO/4_Informationstheorie.html#huffman-codes","text":"Codes mit dem Huffmanverfahren sind: automatisch pr\u00e4fixfrei optimal (Das heisst, es gibt keine besseren pr\u00e4fixfreie Code)","title":"Huffman Codes"},{"location":"21HS/INCO/4_Informationstheorie.html#vorgehen","text":"Ordne alle Symbole nach aufsteigenen Auftretenswahrscheinlichkeiten auf einer Zeile. Dies sind die Bl\u00e4tter Notiere unter jedes Blatt seine Wahrscheinlichkeit Schliesse die beiden Bl\u00e4tter mit der kleinsten Wahrscheinlichekit an einer gemeinsamen Astgabel an und ordne dem Ast die Summe der Wahrscheinlichkeiten zu Wiederhole Schritt 2 es nur noch ein Stamm gibt Jedem Ast wird nun ein eine 0, wenn man links geht und eine 1 wenn man rechts geht, zugewiessen Die Pfade zu allen Bl\u00e4tter aufschreiben. Das ist der Huffmancode","title":"Vorgehen"},{"location":"21HS/INCO/4_Informationstheorie.html#lauflangenkodierung","text":"Man speichert, wie oft ein Symbol vorkommt. Anstatt \"AAAAAABBC\" k\u00f6nnte man einfach \"6A2B1C\" Um auch Symbole, welche nur einmal vorkommen, effizent zu speichern, wird ein Token benutzt, welcher symbolisiert, dass nun eine Laufl\u00e4ngenkodierung kommt. Um das obere Beispiel nochmals aufzugreiffen: \"Z6AZ2BC\". Hier wurde Z als Marker (oder Token) gew\u00e4hlt, und nur wenn ein Z gelesen wird, wird das folgende als L\u00e4nge interpretiert. Wie viel Zeichen als Marker reserviert werden soll, ist abh\u00e4ngig von der Quelle in ihre statistischen Eigenschaften.","title":"Laufl\u00e4ngenkodierung"},{"location":"21HS/INCO/4_Informationstheorie.html#lz77","text":"Ein Token ist definiert als (Offset, L\u00e4nge, Zeichen). Es hat eine fixe L\u00e4nge. Es gibt ebenfalls ein Such- und ein Vorschau-Buffer. Es werden im Such-Buffer nach denselben Muster gesucht. Falls ein Match gefunden wurde, wird ein Token geschrieben. In diesem ist der Offset des Such-Buffer, die L\u00e4nge ist die L\u00e4nge des Musters, und das Zeichen das n\u00e4chste Zeichen nach dem gemachten Muster. Falls kein Match gefunden wurde, wird folgender Token geschrieben (0, 0, Zeichen). Dies ist n\u00f6tig, da zu Beginn des Algorithmus noch nichts im Such-Buffer ist. Um dies zu dekodieren, wird dies R\u00fcckw\u00e4rts durch gearbeitet","title":"LZ77"},{"location":"21HS/INCO/4_Informationstheorie.html#lzw","text":"LZW bassiert auf LZ77 mit einigen \u00c4nderungen. Anstatt eines \"Sliding Window\" ben\u00fctzt man ein W\u00f6rterbuch. Ein Token besteht nur aus einem Index, welchen auf das W\u00f6rterbuch referenziert. Der Dekoder baut gleichzeitig mit den empfangenen Tokens das W\u00f6rterbuch auf. Um ein Text zu enkodieren, werden folgende Schritte durchgef\u00fchrt Suche das aktuelle Zeichen im W\u00f6rterbuch So lange verl\u00e4ngern, wie m\u00f6glich und dieses als Token versenden Ein neuen Eintrag Token + der n\u00e4chste Zeichen ins W\u00f6rterbuch hinzuf\u00fcgen Um nun einen Tokenstream wieder zu dekodieren, muss man folgendes tun: Empfangener Token ausgeben Empfangener Token ins W\u00f6rterbuch als neuer Eintrag hinzuf\u00fcgen (mit einem Blank am Ende) N\u00e4chster empfangener Token ausgeben und die Blank vom letzten Schritt ausf\u00fcllen mit dem ersten ausgegeben Buchstaben des empfangen Tokens Gehe zu Schritt 2","title":"LZW"},{"location":"21HS/INCO/5_JEPG.html","text":"Was ist ein digitales Bild? Ein Bild ist ein zweidimensionales Pixel-Array schwarzweiss Bild: 2-wertige Pixel Graustufenbild: Pixel mit Wertebereich \\([0..2^W-1]\\) , typisch W=8 bit nat\u00fcrliches Bild: (Farb-)Pixel mit 3 Komponenten (z.B. RGB). Benachbarte Pixelwerte sind oft fast gleich gross Grafik oder syntetisches Bild: haben oft scharfe Kanten JPEG Verfahren Das RGB Bild wird zu einem YCrCb Bild umgewandelt Das Bild in 8x8 Bl\u00f6cke aufteilen Eine Discrete Cosine Transform (DCT) wird auf das Bild angewendet Quanitzation - Es werden gewisse Bildinformationen mehr komprimiert als andere, da sie der Mensch besser wahrnehmen kann DC und AC Seperation Runlength Encoding & Huffman enkodierung In ein File verpacken Man benutzt bei JPG die Luminance, da das menschliche Auge auf Helligkeit empfindlicher ist Schritt 1 - RGB zu YCrCb Y - Helligkeitinformationen (eigentlich. ein Graustufenbild) Cb - Blau anteil Cr - Rotanteil Im Folgenden Bild sieht man die Beziehung von Cb und Cr: Um die Luminaz von einem Pixel zu berechnen, kann man eine gewichtetes Summe der RGB Pixel errechnen: \\(L=0.299\\cdot R + 0.587 \\cdot G + 0.115\\cdot B\\) . Die Faktoren kommen davon, dass das menschliche Auge die Farben Blau, Gelb und Rot verschieden wahrnehmen. \\(\\begin{bmatrix} Y \\\\ C_B \\\\ C_R \\end{bmatrix} = \\begin{bmatrix}0.299 & 0.587 & 0.114\\\\ -0.1687 & -0.3313 & 0.5\\\\ 0.5 & -0.4187 & -0.0813\\end{bmatrix} \\cdot \\begin{bmatrix} R\\\\G\\\\B \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 128 \\\\ 128 \\end{bmatrix}\\) Umgekehrt kann man folgende Formel benutzen: \\(\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix}1 & 0 & 1.402\\\\ 1 & -0.34414 & -0.71414\\\\ 1 & 1.772 & 0\\end{bmatrix} \\cdot \\begin{bmatrix} Y\\\\C_B - 128\\\\C_R - 128\\end{bmatrix}\\) Downsampling Man gibt mit dem folgenden Muster \"Blockbreite:Reduktion Breite:Redutktion H\u00f6he\" Diskrete Cosinus Transformation (DCT) Die Idee von einer DCT ist, dass anstatt in einem Pixel zu speichern, wie Schwarz dieser Pixel ist, speichert man, wie stark eine Frequenz in einem 8x8-Block vorkommt. Diese Operation ist komplet reversieble und es werden keine Informationen verloren. Im unteren Beispiel sieht man eine 1D-DCT. In diesem Fall ist der Pixel-Block 8x1 gross. Im ersten Pixel wird gespeichert, wie hell das Bild ist. Dieser Wert wird auch DC-Wert genannt von Direct Current, da die dargestelle \"Frequenz\" 0Hz hat, wie man im unteren Beispiel sieht. Der zweite Pixel stellt danach dar, wie stark die Frequenz mit 1Hz in diesem 8x1-Block verterten ist. Der dritte Pixel, wie stark 2Hz vertretten sind und so weiter. Dieses Prinzip, wie es in 1D funktioniert, kann auch f\u00fcr ein 2D Bild angewendet werden. Hierbei stellen die Pixel dar, wie stark eine horizontale und vertikale Frequenz vertreten sind. Im Beispiel unten ist der Pixel 1/1 (der erste Pixel) wieder der DC, mit den Frequenzen 0Hz/0Hz. Der Pixel 2/2 hat die Frequenz 1Hz/1Hz, der Pixel 4/3 hat die Frequenzen 3Hz/2Hz. Im unteren Bild sieht man die Muster, welche erkannt werden. F\u00fcr diese Konvertierung gilt die folgende Formel: $$ F_{vu}=\\frac 1 4 C_u C_v \\sum^7_{x=0}\\sum^7_{y=0}B_{yx} \\cos(\\frac {(2x+1)u\\pi} {16})\\cos(\\frac{(2y+1)v\\pi} {16}) $$ Dies gibt f\u00fcr jedes \\(B_{yx}\\) einen Wert \\(F_{vu}\\) . Diese Konvertierung kann mit einer Inversen DCT wieder r\u00fcckg\u00e4ngig gemacht werden: $$ B_{yx}=\\frac 1 4 \\sum^7_{u=0}\\sum^7_{v=0}C_uC_vF_{vu}\\cos(\\frac{(2x+1)u\\pi}{16})\\cos(\\frac{(2y+1)v\\pi}{16}) $$ Nach einer DCT ergibt dies ein Resultat, wie dies: In diesem Bild gibt es einige gr\u00f6ssere Werte im oberen linken Ecken. Die anderen Werte sind relative klein. Quantisierung Beim Quantisieren wird das Resultat der DCT gewichtet. Daf\u00fcr nimmt man eine weitere Tabelle mit Werte. Jeder Wert in der DCT Tabelle wird durch den Wert an derselben Position in der Gewichtungstabelle geteilt. Danach wird auf Ganzzahlen gerundet. Damit wirft man Daten weg, welche weniger relevant sind. Run-Lenght Encoding Es gibt folgende Tokens: (DC Wert) - Ein Token f\u00fcr den DC Wert. Dies ist der Wert oben links (Anzahl Nullen, n\u00e4chstes nicht Null-Zeichen) - Die Anzahl Nullen vor dem n\u00e4chsten Zeichen (EOB) - End Of Block -> der Rest ist Null Dies wird danach noch mit einem Huffmancode enkodiert. Daf\u00fcr kann eine fixen Code verwendet werden oder der Encoder kann einen selbst erstellen. Der DC Wert wird mit eine \"horizontale Pr\u00e4diktion\" verwendet. Dabei sieht ein Token (Anzahl Bits, \\(DC_n-DC_{n-1}\\) ). Es wird also die Differenz des DC-Wertes zwischen zwei Bl\u00f6cken gespeichert, da sich diese selten komplet \u00e4ndert. MPEG Ansatz: Man speichert nicht jedes Frame einzeln, sondern die Unterschiede Makrobl\u00f6cke Wenn man ein Video komprimiert, teilt man ein Frame in mehrere Makrobl\u00f6cke auf. Danach sucht man im letzten Bild nach demselben Block. Da man nicht das ganze Bild absuchen m\u00f6chte, sucht man nur in einem Suchfenster um den Block herum, da man an nimmt, dass sich das Bild nicht gross ver\u00e4ndert. Wenn kein Makroblock im letzten Frame im Suchfenster gefunden wurde, wird der Block als JPG komprimiert und gespeichert. Um Makrobl\u00f6cke zu finden, werden nicht die eigentlich Pixel verglichen, da kleine \u00c4nderungen, welche von z.B. von Sensorrauschen verursacht wurde, dazuf\u00fchren w\u00fcrde, dass man keine Bl\u00f6cke finden. MPEG schreibt nicht vor, wie man nach diesen Bl\u00f6cke sucht. Meistens schr\u00e4nkt man aber das Fenster zwischen 7-15 Pixel ein. Frames Intra Frame (I-Frame) - Ein koplettes Frame als JPG Predicated Frame (P-Frame) - ein vorheriges Frame wird als Referenz benutzt Bidirectional Frame (B-Frame) - ein vorheriges Frame, wie auch das n\u00e4chste Frame kann als Referenz benutzt werden Da man bei den B-Frames auch voraussehen kann, ist die Reihenfolge der Frames wie man es schaut, nicht dieselbe, wie man es sendet. Geschichte MPEG-1: Typisch f\u00fcr Fernseher 318 MBit/s -> 1.5 MBit/s MPEG-2: F\u00fcr HD-TV Resultierte in ca. 80 - 100 MBit/s","title":"5 JEPG"},{"location":"21HS/INCO/5_JEPG.html#was-ist-ein-digitales-bild","text":"Ein Bild ist ein zweidimensionales Pixel-Array schwarzweiss Bild: 2-wertige Pixel Graustufenbild: Pixel mit Wertebereich \\([0..2^W-1]\\) , typisch W=8 bit nat\u00fcrliches Bild: (Farb-)Pixel mit 3 Komponenten (z.B. RGB). Benachbarte Pixelwerte sind oft fast gleich gross Grafik oder syntetisches Bild: haben oft scharfe Kanten","title":"Was ist ein digitales Bild?"},{"location":"21HS/INCO/5_JEPG.html#jpeg-verfahren","text":"Das RGB Bild wird zu einem YCrCb Bild umgewandelt Das Bild in 8x8 Bl\u00f6cke aufteilen Eine Discrete Cosine Transform (DCT) wird auf das Bild angewendet Quanitzation - Es werden gewisse Bildinformationen mehr komprimiert als andere, da sie der Mensch besser wahrnehmen kann DC und AC Seperation Runlength Encoding & Huffman enkodierung In ein File verpacken Man benutzt bei JPG die Luminance, da das menschliche Auge auf Helligkeit empfindlicher ist","title":"JPEG Verfahren"},{"location":"21HS/INCO/5_JEPG.html#schritt-1-rgb-zu-ycrcb","text":"Y - Helligkeitinformationen (eigentlich. ein Graustufenbild) Cb - Blau anteil Cr - Rotanteil Im Folgenden Bild sieht man die Beziehung von Cb und Cr: Um die Luminaz von einem Pixel zu berechnen, kann man eine gewichtetes Summe der RGB Pixel errechnen: \\(L=0.299\\cdot R + 0.587 \\cdot G + 0.115\\cdot B\\) . Die Faktoren kommen davon, dass das menschliche Auge die Farben Blau, Gelb und Rot verschieden wahrnehmen. \\(\\begin{bmatrix} Y \\\\ C_B \\\\ C_R \\end{bmatrix} = \\begin{bmatrix}0.299 & 0.587 & 0.114\\\\ -0.1687 & -0.3313 & 0.5\\\\ 0.5 & -0.4187 & -0.0813\\end{bmatrix} \\cdot \\begin{bmatrix} R\\\\G\\\\B \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 128 \\\\ 128 \\end{bmatrix}\\) Umgekehrt kann man folgende Formel benutzen: \\(\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix}1 & 0 & 1.402\\\\ 1 & -0.34414 & -0.71414\\\\ 1 & 1.772 & 0\\end{bmatrix} \\cdot \\begin{bmatrix} Y\\\\C_B - 128\\\\C_R - 128\\end{bmatrix}\\)","title":"Schritt 1 - RGB zu YCrCb"},{"location":"21HS/INCO/5_JEPG.html#downsampling","text":"Man gibt mit dem folgenden Muster \"Blockbreite:Reduktion Breite:Redutktion H\u00f6he\"","title":"Downsampling"},{"location":"21HS/INCO/5_JEPG.html#diskrete-cosinus-transformation-dct","text":"Die Idee von einer DCT ist, dass anstatt in einem Pixel zu speichern, wie Schwarz dieser Pixel ist, speichert man, wie stark eine Frequenz in einem 8x8-Block vorkommt. Diese Operation ist komplet reversieble und es werden keine Informationen verloren. Im unteren Beispiel sieht man eine 1D-DCT. In diesem Fall ist der Pixel-Block 8x1 gross. Im ersten Pixel wird gespeichert, wie hell das Bild ist. Dieser Wert wird auch DC-Wert genannt von Direct Current, da die dargestelle \"Frequenz\" 0Hz hat, wie man im unteren Beispiel sieht. Der zweite Pixel stellt danach dar, wie stark die Frequenz mit 1Hz in diesem 8x1-Block verterten ist. Der dritte Pixel, wie stark 2Hz vertretten sind und so weiter. Dieses Prinzip, wie es in 1D funktioniert, kann auch f\u00fcr ein 2D Bild angewendet werden. Hierbei stellen die Pixel dar, wie stark eine horizontale und vertikale Frequenz vertreten sind. Im Beispiel unten ist der Pixel 1/1 (der erste Pixel) wieder der DC, mit den Frequenzen 0Hz/0Hz. Der Pixel 2/2 hat die Frequenz 1Hz/1Hz, der Pixel 4/3 hat die Frequenzen 3Hz/2Hz. Im unteren Bild sieht man die Muster, welche erkannt werden. F\u00fcr diese Konvertierung gilt die folgende Formel: $$ F_{vu}=\\frac 1 4 C_u C_v \\sum^7_{x=0}\\sum^7_{y=0}B_{yx} \\cos(\\frac {(2x+1)u\\pi} {16})\\cos(\\frac{(2y+1)v\\pi} {16}) $$ Dies gibt f\u00fcr jedes \\(B_{yx}\\) einen Wert \\(F_{vu}\\) . Diese Konvertierung kann mit einer Inversen DCT wieder r\u00fcckg\u00e4ngig gemacht werden: $$ B_{yx}=\\frac 1 4 \\sum^7_{u=0}\\sum^7_{v=0}C_uC_vF_{vu}\\cos(\\frac{(2x+1)u\\pi}{16})\\cos(\\frac{(2y+1)v\\pi}{16}) $$ Nach einer DCT ergibt dies ein Resultat, wie dies: In diesem Bild gibt es einige gr\u00f6ssere Werte im oberen linken Ecken. Die anderen Werte sind relative klein.","title":"Diskrete Cosinus Transformation (DCT)"},{"location":"21HS/INCO/5_JEPG.html#quantisierung","text":"Beim Quantisieren wird das Resultat der DCT gewichtet. Daf\u00fcr nimmt man eine weitere Tabelle mit Werte. Jeder Wert in der DCT Tabelle wird durch den Wert an derselben Position in der Gewichtungstabelle geteilt. Danach wird auf Ganzzahlen gerundet. Damit wirft man Daten weg, welche weniger relevant sind.","title":"Quantisierung"},{"location":"21HS/INCO/5_JEPG.html#run-lenght-encoding","text":"Es gibt folgende Tokens: (DC Wert) - Ein Token f\u00fcr den DC Wert. Dies ist der Wert oben links (Anzahl Nullen, n\u00e4chstes nicht Null-Zeichen) - Die Anzahl Nullen vor dem n\u00e4chsten Zeichen (EOB) - End Of Block -> der Rest ist Null Dies wird danach noch mit einem Huffmancode enkodiert. Daf\u00fcr kann eine fixen Code verwendet werden oder der Encoder kann einen selbst erstellen. Der DC Wert wird mit eine \"horizontale Pr\u00e4diktion\" verwendet. Dabei sieht ein Token (Anzahl Bits, \\(DC_n-DC_{n-1}\\) ). Es wird also die Differenz des DC-Wertes zwischen zwei Bl\u00f6cken gespeichert, da sich diese selten komplet \u00e4ndert.","title":"Run-Lenght Encoding"},{"location":"21HS/INCO/5_JEPG.html#mpeg","text":"Ansatz: Man speichert nicht jedes Frame einzeln, sondern die Unterschiede","title":"MPEG"},{"location":"21HS/INCO/5_JEPG.html#makroblocke","text":"Wenn man ein Video komprimiert, teilt man ein Frame in mehrere Makrobl\u00f6cke auf. Danach sucht man im letzten Bild nach demselben Block. Da man nicht das ganze Bild absuchen m\u00f6chte, sucht man nur in einem Suchfenster um den Block herum, da man an nimmt, dass sich das Bild nicht gross ver\u00e4ndert. Wenn kein Makroblock im letzten Frame im Suchfenster gefunden wurde, wird der Block als JPG komprimiert und gespeichert. Um Makrobl\u00f6cke zu finden, werden nicht die eigentlich Pixel verglichen, da kleine \u00c4nderungen, welche von z.B. von Sensorrauschen verursacht wurde, dazuf\u00fchren w\u00fcrde, dass man keine Bl\u00f6cke finden. MPEG schreibt nicht vor, wie man nach diesen Bl\u00f6cke sucht. Meistens schr\u00e4nkt man aber das Fenster zwischen 7-15 Pixel ein.","title":"Makrobl\u00f6cke"},{"location":"21HS/INCO/5_JEPG.html#frames","text":"Intra Frame (I-Frame) - Ein koplettes Frame als JPG Predicated Frame (P-Frame) - ein vorheriges Frame wird als Referenz benutzt Bidirectional Frame (B-Frame) - ein vorheriges Frame, wie auch das n\u00e4chste Frame kann als Referenz benutzt werden Da man bei den B-Frames auch voraussehen kann, ist die Reihenfolge der Frames wie man es schaut, nicht dieselbe, wie man es sendet.","title":"Frames"},{"location":"21HS/INCO/5_JEPG.html#geschichte","text":"MPEG-1: Typisch f\u00fcr Fernseher 318 MBit/s -> 1.5 MBit/s MPEG-2: F\u00fcr HD-TV Resultierte in ca. 80 - 100 MBit/s","title":"Geschichte"},{"location":"21HS/INCO/6_Audio.html","text":"Audio Abtastrate Um ein Audio-Signal digital zu verwenden, muss man es Abtasten. Laut dem Abtasttheorem von Shanon muss die Abtastrate doppelt so gross sein, wie die maximale Frequenz ( \\(f_{abtast} > 2\\cdot f_{max}\\) ). Wegen dem Abtasten wird das Signal quantisiert. Wenn man \\(2\\cdot f_{max}\\) \u00fcbersteigt, beginnt sich die Frequenz zu spiegeln. Die hat die Frequenz \\(f_{abtast}-f_{zu hohe Frequenz}\\) Quantisierungsrauschen Das Quantisierungsrauschen entsteht bei Rundungsfehler auf die n\u00e4chste Zahl, welche abgespeichert weren kann. Das Rauschen ist die Differenz zwischen dem Analogensignal und dem digitalen Signal. Das Rauschen wird durch die gr\u00fcne \"Kurve\" dargestellt. Um jede erh\u00f6hung um 1 Bit nimmt das Rauschen um 6dB ab Schalldruckpegel (dB) Der Schallpegel wird mit der folgenden Formel berechnet: \\(L=20\\cdot log_{10}(\\frac p {p_0})\\) \\(p\\) = Effiektiver Schaldruck [PA] \\(p_0\\) =Bezugsschalldruck Wie man in der Formel sieht, ist Decibel eine Logarithmischeschwelle Puls Code Modulation (PCM) ITU-T G.711 (A-law) Der Frequenzbereicht ist 300-3400Hz und wird mit 8000Hz abgetastet. Ein Abtastpunkt werden als 8 bit gespeichert, das ergibt eine Datenrate von \\(8000Hz \\cdot 8Bit = 64KBit/s\\) CD-Adio Eine CD ben\u00fctzt eine Abtastfrequenz von 44.1kHz und speichert dies als 16-bit Wert ab. Die Datenrate ist \\(44'100 Hz * 2Byte * 2 Kan\u00e4le = 176'400 Byte/s=1.411 MBit/s\\) Quantisiert wird Linear. Dies heisst dass die Y-Achse in einem solchen Diagram linear ist. Arten von PCM PCM kann auf mehrere Arten abgespeichert werden Absolut: Jeder Wert wird als absoluter Wert abgespeichert Diffrerential-PCM (DPCM): Es werden nur die Differenzen gespeichert Adaptive Differential-PCM (ADPCM): Es werden die Differenzen der Differenzen gespeichert. Der Sinn dahinter: Bei Audio-Files \u00e4ndert sich die Differenz nicht fest, also ist es effizenter nur die Differenzen der Differenzen zu speichern Linear Prediction Coder (LPC) Das \u00c4quivelent zu der DCT in der Audio Welt. Wird heutzutage nicht mehr verwendet. Wave File Format Hier ist das Header Format von einem Wave-Files, welches PCM Daten enth\u00e4lt. Werte im Wave-Format sind im Little-Endian Format abgespeichert (Tieferer Wert kommt zu erst) Offset Byte Name Erkl\u00e4rung 0 4 ChunkID Contains the letters \"RIFF\" in ASCII form 4 4 ChunkSize 36 + SubChunk2Size, or more precisely:4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)This is the size of the rest of the chunkfollowing this number. This is the size of theentire file in bytes minus 8 bytes for thetwo fields not included in this count: ChunkID and ChunkSize. 8 4 Format Contains the 4 letters \"WAVE\" 12 4 Subchunk1ID Contains the 4 letters \"fmt \" 16 4 Subchung1Size 16 for PCM. This is the size of the rest of the Subchunk which follows this number. 20 2 AudioFormat PCM = 1 (i.e. Linear quantization) Values other than 1 indicate some form of compression. 22 2 NumChannels Mono = 1, Stereo = 2, etc. 24 4 SampleRate 8000, 44100, etc. 28 4 ByteRate == SampleRate * NumChannels * BitsPerSample/8 32 2 BlockAlign == NumChannels * BitsPerSample/8 The number of bytes for one sample including all channels. 34 2 BitsPerSample 8 bits = 8, 16 bits = 16, etc. 36 4 Subchunk2Id Contains the 4 letters \"data\" 40 4 Cubchank2Size == NumSamples * NumChannels * BitsPerSample/8 This is the number of bytes in the data. You can also think of this as the size of the read of the subchunk following this number. 44 * Data The actual sound data. FLAC (Free Lossless Audio Codec) Kompressionsrate: 30-50% Ben\u00fctzt ein Verfahren \u00e4hlich auf die LZ-Codierung MPEG Es werden zwei Fakten des Menschlichen Geh\u00f6hres ausgenutzt: die menschliche H\u00f6hrschwelle Die H\u00f6hrschwelle ist bei jedem Mensch verschieden und \u00e4ndert isch auch \u00fcber das Leben einer Person. Spektrale Maskierung Wenn ein Lauterton abgespielt wird, werden leisere T\u00f6ne unh\u00f6hrbar. Kurz bevor einem Lautenton h\u00f6hrt man bereits leisse T\u00f6ne nicht mehr. Dasselbe gillt auch f\u00fcr danach. Diese zwei Fakten m\u00fcssen zusammen betrachtet werden. In der Unteren Graphik sieht man, wie die beiden Effekte kombiniert wurden. Man unterteilt das Audiosignal in mehrere Frequenzb\u00e4nder. Jedes Frequenband enkodiert man mit genau so viel Bits, so dass das Quantisierungsrauschen unter der H\u00f6hrschwelle bzw. Maskierungsschwelle bleibt. MP3 Frequenzb\u00e4nder in MP3: 512 (in ACC: 2048 Frequenb\u00e4nder) Frequenz-Transformation - Adiosignal in mehrere Frequenzb\u00e4nder aufteilen Psycho-Akustisches-Modell - Man entscheidet, wie viel bits man ben\u00f6tigt (siehe oben)","title":"Audio"},{"location":"21HS/INCO/6_Audio.html#audio","text":"","title":"Audio"},{"location":"21HS/INCO/6_Audio.html#abtastrate","text":"Um ein Audio-Signal digital zu verwenden, muss man es Abtasten. Laut dem Abtasttheorem von Shanon muss die Abtastrate doppelt so gross sein, wie die maximale Frequenz ( \\(f_{abtast} > 2\\cdot f_{max}\\) ). Wegen dem Abtasten wird das Signal quantisiert. Wenn man \\(2\\cdot f_{max}\\) \u00fcbersteigt, beginnt sich die Frequenz zu spiegeln. Die hat die Frequenz \\(f_{abtast}-f_{zu hohe Frequenz}\\)","title":"Abtastrate"},{"location":"21HS/INCO/6_Audio.html#quantisierungsrauschen","text":"Das Quantisierungsrauschen entsteht bei Rundungsfehler auf die n\u00e4chste Zahl, welche abgespeichert weren kann. Das Rauschen ist die Differenz zwischen dem Analogensignal und dem digitalen Signal. Das Rauschen wird durch die gr\u00fcne \"Kurve\" dargestellt. Um jede erh\u00f6hung um 1 Bit nimmt das Rauschen um 6dB ab","title":"Quantisierungsrauschen"},{"location":"21HS/INCO/6_Audio.html#schalldruckpegel-db","text":"Der Schallpegel wird mit der folgenden Formel berechnet: \\(L=20\\cdot log_{10}(\\frac p {p_0})\\) \\(p\\) = Effiektiver Schaldruck [PA] \\(p_0\\) =Bezugsschalldruck Wie man in der Formel sieht, ist Decibel eine Logarithmischeschwelle","title":"Schalldruckpegel (dB)"},{"location":"21HS/INCO/6_Audio.html#puls-code-modulation-pcm","text":"","title":"Puls Code Modulation (PCM)"},{"location":"21HS/INCO/6_Audio.html#itu-t-g711-a-law","text":"Der Frequenzbereicht ist 300-3400Hz und wird mit 8000Hz abgetastet. Ein Abtastpunkt werden als 8 bit gespeichert, das ergibt eine Datenrate von \\(8000Hz \\cdot 8Bit = 64KBit/s\\)","title":"ITU-T G.711 (A-law)"},{"location":"21HS/INCO/6_Audio.html#cd-adio","text":"Eine CD ben\u00fctzt eine Abtastfrequenz von 44.1kHz und speichert dies als 16-bit Wert ab. Die Datenrate ist \\(44'100 Hz * 2Byte * 2 Kan\u00e4le = 176'400 Byte/s=1.411 MBit/s\\) Quantisiert wird Linear. Dies heisst dass die Y-Achse in einem solchen Diagram linear ist.","title":"CD-Adio"},{"location":"21HS/INCO/6_Audio.html#arten-von-pcm","text":"PCM kann auf mehrere Arten abgespeichert werden Absolut: Jeder Wert wird als absoluter Wert abgespeichert Diffrerential-PCM (DPCM): Es werden nur die Differenzen gespeichert Adaptive Differential-PCM (ADPCM): Es werden die Differenzen der Differenzen gespeichert. Der Sinn dahinter: Bei Audio-Files \u00e4ndert sich die Differenz nicht fest, also ist es effizenter nur die Differenzen der Differenzen zu speichern","title":"Arten von PCM"},{"location":"21HS/INCO/6_Audio.html#linear-prediction-coder-lpc","text":"Das \u00c4quivelent zu der DCT in der Audio Welt. Wird heutzutage nicht mehr verwendet.","title":"Linear Prediction Coder (LPC)"},{"location":"21HS/INCO/6_Audio.html#wave-file-format","text":"Hier ist das Header Format von einem Wave-Files, welches PCM Daten enth\u00e4lt. Werte im Wave-Format sind im Little-Endian Format abgespeichert (Tieferer Wert kommt zu erst) Offset Byte Name Erkl\u00e4rung 0 4 ChunkID Contains the letters \"RIFF\" in ASCII form 4 4 ChunkSize 36 + SubChunk2Size, or more precisely:4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)This is the size of the rest of the chunkfollowing this number. This is the size of theentire file in bytes minus 8 bytes for thetwo fields not included in this count: ChunkID and ChunkSize. 8 4 Format Contains the 4 letters \"WAVE\" 12 4 Subchunk1ID Contains the 4 letters \"fmt \" 16 4 Subchung1Size 16 for PCM. This is the size of the rest of the Subchunk which follows this number. 20 2 AudioFormat PCM = 1 (i.e. Linear quantization) Values other than 1 indicate some form of compression. 22 2 NumChannels Mono = 1, Stereo = 2, etc. 24 4 SampleRate 8000, 44100, etc. 28 4 ByteRate == SampleRate * NumChannels * BitsPerSample/8 32 2 BlockAlign == NumChannels * BitsPerSample/8 The number of bytes for one sample including all channels. 34 2 BitsPerSample 8 bits = 8, 16 bits = 16, etc. 36 4 Subchunk2Id Contains the 4 letters \"data\" 40 4 Cubchank2Size == NumSamples * NumChannels * BitsPerSample/8 This is the number of bytes in the data. You can also think of this as the size of the read of the subchunk following this number. 44 * Data The actual sound data.","title":"Wave File Format"},{"location":"21HS/INCO/6_Audio.html#flac-free-lossless-audio-codec","text":"Kompressionsrate: 30-50% Ben\u00fctzt ein Verfahren \u00e4hlich auf die LZ-Codierung","title":"FLAC (Free Lossless Audio Codec)"},{"location":"21HS/INCO/6_Audio.html#mpeg","text":"Es werden zwei Fakten des Menschlichen Geh\u00f6hres ausgenutzt: die menschliche H\u00f6hrschwelle Die H\u00f6hrschwelle ist bei jedem Mensch verschieden und \u00e4ndert isch auch \u00fcber das Leben einer Person. Spektrale Maskierung Wenn ein Lauterton abgespielt wird, werden leisere T\u00f6ne unh\u00f6hrbar. Kurz bevor einem Lautenton h\u00f6hrt man bereits leisse T\u00f6ne nicht mehr. Dasselbe gillt auch f\u00fcr danach. Diese zwei Fakten m\u00fcssen zusammen betrachtet werden. In der Unteren Graphik sieht man, wie die beiden Effekte kombiniert wurden. Man unterteilt das Audiosignal in mehrere Frequenzb\u00e4nder. Jedes Frequenband enkodiert man mit genau so viel Bits, so dass das Quantisierungsrauschen unter der H\u00f6hrschwelle bzw. Maskierungsschwelle bleibt.","title":"MPEG"},{"location":"21HS/INCO/6_Audio.html#mp3","text":"Frequenzb\u00e4nder in MP3: 512 (in ACC: 2048 Frequenb\u00e4nder) Frequenz-Transformation - Adiosignal in mehrere Frequenzb\u00e4nder aufteilen Psycho-Akustisches-Modell - Man entscheidet, wie viel bits man ben\u00f6tigt (siehe oben)","title":"MP3"},{"location":"21HS/INCO/7_Kanalkodierung.html","text":"Kanalkodierung Man kann nicht garantieren , dass ein Kanal eine \u00dcbertragung fehlerlos \u00fcbertragen hat. Bin\u00e4ren Kanal \\(\\varepsilon\\) (Epsilon) ist die Wahrscheinlichkeit, wie oft ein Fehlerauftritt (Bit Error Ratio = BER) Symmetrische und asymmetrische Kan\u00e4le Ein symetrischen kanal hat die selben \\(\\varepsilon\\) f\u00fcr beide wege. Ein Asymetrischen Kanal hat hingegen eine andere warscheinlichkeit, dass eine 0 zu einem 1 wird als umgekehrt. In dem folgenden Bild sieht man ein symmetrischen Kanal \\(P(y_m|x_n)\\) steht f\u00fcr die Wahrscheinlichkeit, dass \\(x_n\\) zu \\(y_m\\) wird. Im obigen Bild sieht man nun, wie die Formeln f\u00fcr die Wahrscheinlichkeit f\u00fcr das \\(y_0\\) eintritt, bzw. dass \\(y_1\\) eintritt. Die Summe von \\(P(y_1)\\) und \\(P(y_0)\\) muss 1 ergeben. TODO: Entropie berechnen Kanalkapazit\u00e4t Die h\u00f6chste Kapazit\u00e4t eines Kanals ist 1bit Information pro versendetes 1 bit. Beides, die maximale Kanalkapazit\u00e4t, wie auch die St\u00f6rquelle, kann als Binary Memoryless Source (BMS) interpretiert werden und so die standard Entropie Formeln ben\u00fctzt werden. Daher kommt man auf die foglenden Formel: \\(C_{BSC}(\\varepsilon)=1-H(\\varepsilon)=1-(\\varepsilon \\cdot log_2 \\frac 1 \\varepsilon + (1-\\varepsilon )\\cdot log_2 \\frac 1 {1 - \\varepsilon})\\) \\(C_{BSC}\\) hat die Masseinheit bits/bits (bits pro bits). Mathe Um ein Frame zu brechnen gillt folgene Formel: \\(A_1 = A(1 - \\varepsilon)\\) , dabei ist A die l\u00e4nge in Bits des Frames. F\u00fcr mehrere Frames gillt: \\(A_N=A(1-\\varepsilon)^N\\) Wenn \\(\\varepsilon\\) nahe an 1 ist, kann die folgende N\u00e4herung genutzt wird: \\(1 - N\\cdot \\varepsilon\\) Mehr-Bit-Fehlerwahrscheinlichkeit Wenn berechnet werden soll, was die Wahrscheinlichkeit ist, dass eine N-lange Sequenz genau F Fehler auftreten, dann kann folgende Formel genutzt werden: \\(P_{F,N}=\\begin{pmatrix}N \\\\ F\\end{pmatrix} \\cdot \\varepsilon^F \\cdot (1-\\varepsilon)^{N-F}\\) Dabei stellt F die Anzahl Fehler dar, N die L\u00e4nge des Block-Codes und \\(\\varepsilon\\) die Bit Error Ratio des Kanales. Binominalkoeffizenten \\(\\begin{pmatrix}N \\\\ F\\end{pmatrix}\\) wird gesprochen als n choose r und kann folgender massen berechnet werden \\(\\begin{pmatrix}n \\\\ k \\end{pmatrix}=\\frac{n!}{k!\\cdot(n-k)!}\\) Einige Taschenrechner haben eine Taste nCr , welche dies ausrechnen kann (der Canon F-718SGA hat dies ebenfalls) Framegr\u00f6ssen Im obigen Bild sieht man die Wahrscheinlichkeit, dass ein Frame ankommt f\u00fcr eine gewisse Frame-Gr\u00f6sse. In dieser Abbildung sieht man, dass grosse Frames erst wirklich Sinn ergeben, wenn man Fehlerresistenten Kanal hat. Fehlerkorrekturverfahren Backward Error Correction Es wird eine gewisse Redundanz hinzugef\u00fcgt (z.B. CRC), welche es erlauben, einen Fehler zu erkennen und die Daten nochmals anzufordern. Der Empf\u00e4nger schickt eine Quittung zur\u00fcck. Wenn keine Quittung erhalten wurde, wird das Packet nochmals gesendet. Nachteile: Langsam, da immer gewartet werden muss (Dies kann etwas mitigert werden, in dem die n\u00e4chste Nachricht bereits versendet wird, bevor die Quittung ankommt) Ein R\u00fcckkanal ist erfoderlich Forward Error Correction Mehr Redundanz, so dass der Fehler sogar korrigiert werden kann Hamming-Distanz Die Hamming-Distanz beschreibt, wie viel Bits sich zwischen zwei Codew\u00f6rter \u00e4ndert. Die Codw\u00f6rter k\u00f6nnen auch auf einem W\u00fcrfel dargestellt werden in dem die Codew\u00f6rter in folgendes Koordinatensystem eingetragen werden: Wenn alle Codew\u00f6rter (im Beispiel unten ein 3-Zeichen langen Block-Code) in einem solchen Koordiantesystem eingetragen werden, kommt einen W\u00fcrfel oder \u00e4hliches heraus. Pro Zahl braucht man eine Dimension. Die minimale Hamming-Distanz ist die kleinste Distanz zwischen zwei korrekten Code-Words. Fehlerkorrektur mit Matrizen Block-Code Bei einem Blockcode werden die Informationen in Bl\u00f6cke verschickt. Dabei gibt es die N, die Anzahl Bits f\u00fcr Informationen und K, die Bits f\u00fcr den Fehlerschutz Systematische Blockcodes sind Blockcodes, bei welcher die Fehlerschutzbits zu Beginn oder am Ende steht. Systematischer Block-Code In einem Systematischer Block-Code sind die Informationsbits klar von den Fehlerschutz-Bits getrennt. Als entweder kommen zuerst die informations-Bits und dann die Fehlerschutz-Bits oder umgekehrt. Linearer Block-Code In einem linearen Block-Code, wenn man zwei beliebige Codes zusammen xored, dann ergibt dies einen weiteren g\u00fclltigen Code. Der Code C={000, 110, 001, 101} w\u00e4re zum Beispiel einer. Jeder Linearer Block-Code ben\u00f6tigt einen Code mit nur 0. Wenn Codew\u00f6rter aus einer Generatormatrix generiert wird, dann ist der Code linear. Zyklischer Block-Code Ein zyklischer Block-Code kann man um eins Rotieren und bekommt wieder ein valides Codewort. Als Beispiel. Aus \"110\" wird \"011\", dann \"101\" und dann wieder \"110\". Perfekter Block-Code Ein Perfekter Blockcode hat die selbe Hamming-Distanz zwischen allen Codw\u00f6rtern Fehlererkennung Parity F\u00fcr ein Datenblock gibt es ein Parity-Bit. Even Parity: Parity-Bit ist 1, wenn die Anzahl 1-er inkl. Parity-Bit is gerade, sonst 0 Odd Parity: Parity-Bit ist 1, wenn die Anzahl 1-Bit inklusiv Parity-Bit ungerade ist, sonst 0 Der Vorteil von Even-Parity ist, dass es linearen Block-Code ist. Mit dieser Methode kann 1-Bit Fehler erkennt wrden. Quer-Pariy Es wird ein Parity-Bit horizontal gebildet und ein Parity-Bit vertikal. F\u00fcr einen Block gibt es nun eine Linie f\u00fcr die horizontale gebildete Parity-Bits und eine Line f\u00fcr die vertikal gebildete Parity-Bits. Diese zwei Parity-Bit-Linien werden nun in ein Gesamt-Parity-Bit gerechnet. Die Coderate ( \\(\\frac K N\\) ) ist \\(\\frac{l\u00e4nge\\cdot breite}{l\u00e4nge \\cdot breite + l\u00e4nge + breite + 1}\\) Um dies zu optimieren, sollte probiert weden, den Bl\u00f6ck m\u00f6glich Quadratisch zu gestalten. L\u00e4nge und Breite sollte also m\u00f6glich gleich sein. Pr\u00fcfsumme Man summiert alle Reihen/Elemente zusammen ( \\(\\sum^{n-1}_{i=0}Element_i\\) ) Dabei hat man eine minimale Hamming-Distanz von 2. Die Hamming-Distanz in einigen F\u00e4llen kann auch h\u00f6her sein, da es ein \u00dcbertrag geben kann und somit ein Bit-Wechsel mehrere Bit-\u00c4nderungen in der Pr\u00fcfsumme zu folge haben. TCP & UDP Pr\u00fcfsumme Die Pr\u00fcfsumme wird \u00fcber ein Frame gebildet mit der Wortbreite von 16 Bis. //TODO 1-Bit Arithmetik Wichtig ist, dass es keine 2 geben kann (1+1=0). Der \u00dcbertrag wird vergessen. Man kann eine solche Zahl auch als Polynom darstellen. \\(1011=1\\cdot z^3+0\\cdot z^2+1\\cdot z^1+1\\cdot z^0\\) Auch mit diesem Polynomen kann man mit der 1-Bit Arithmetik rechnen. Beispiel: \\(\\begin{alignat} {1} (z^3+z^2+1)\\pm(z^2+z+1)=&z^3\\cdot(1\\pm0)+z^2\\cdot(1\\pm1)+z^1\\cdot(0\\pm1)+z^0\\cdot (1\\pm1)\\\\=&z^3+z\\end{alignat}\\) Dasselbe Spiel kann auch den anderen Rechnenoperationen durchgespielt werden. CRC Bei CRC teilt man den Datenblock als Polynom durch ein Generator-Polynom. Der dabei resultierender Rest ist die Pr\u00fcfsumme, welche mit verschickt wird. Es gibt verschiedene Generator-Polynome, jenach dem welchen Standard man folgt. Im Verfahren wird der Datenblock um die Anzahl Bits der Pr\u00fcfsumme verschoben (also aus 10, wird zB. 1000, wenn die Pr\u00fcfsumme 2-bit lang ist). Danach wird das Datenblock Polynom durch das Generator-Polynom geteilt. Der Rest, der dabei heraus kommt wird zum Datenblock addiert. Da man um die Anzahl Stellen der Pr\u00fcfsumme zu begin verschoben hat, hat man nun die Pr\u00fcfsumme vor der Zahl \"eingef\u00fcgt\". Nun haben wir ein Datenblock, welchen sicher durch den Generatorblock geteilt werden kann. Beispiel mit Dezimalzahlen: Datenblock: 123, Generatorbits: 12) 1230 : 12 = R6 -> 1236 ist teilbar Ebenfalls wichtig ist, dass wenn man durch eine Zahl teilt, ist der Rest h\u00f6chsten der Rest-1. In Bin\u00e4r heisst dass, eine Stelle weniger als durch was man geteilt hat. Fehlerkorrektur Forward Error Correction Wenn man eine Hammingdistanz von 3 hat, kann man ein Bit korigieren. Dabei wird angenommen, dass ein Bit falsch ist und korrigiert zum n\u00e4chsten validen Codewort. Dies kann aber auch falsch sein!! Wie man oben bereits gesehen hat, nimmt man das Codewort, welches am n\u00e4chsten ist. Dabei kann man \\(\\left \\lfloor{\\frac{d_{min}-1)} 2}\\right \\rfloor\\) Fehler korrigieren.","title":"Kanalkodierung"},{"location":"21HS/INCO/7_Kanalkodierung.html#kanalkodierung","text":"Man kann nicht garantieren , dass ein Kanal eine \u00dcbertragung fehlerlos \u00fcbertragen hat.","title":"Kanalkodierung"},{"location":"21HS/INCO/7_Kanalkodierung.html#binaren-kanal","text":"\\(\\varepsilon\\) (Epsilon) ist die Wahrscheinlichkeit, wie oft ein Fehlerauftritt (Bit Error Ratio = BER)","title":"Bin\u00e4ren Kanal"},{"location":"21HS/INCO/7_Kanalkodierung.html#symmetrische-und-asymmetrische-kanale","text":"Ein symetrischen kanal hat die selben \\(\\varepsilon\\) f\u00fcr beide wege. Ein Asymetrischen Kanal hat hingegen eine andere warscheinlichkeit, dass eine 0 zu einem 1 wird als umgekehrt. In dem folgenden Bild sieht man ein symmetrischen Kanal \\(P(y_m|x_n)\\) steht f\u00fcr die Wahrscheinlichkeit, dass \\(x_n\\) zu \\(y_m\\) wird. Im obigen Bild sieht man nun, wie die Formeln f\u00fcr die Wahrscheinlichkeit f\u00fcr das \\(y_0\\) eintritt, bzw. dass \\(y_1\\) eintritt. Die Summe von \\(P(y_1)\\) und \\(P(y_0)\\) muss 1 ergeben. TODO: Entropie berechnen","title":"Symmetrische und asymmetrische Kan\u00e4le"},{"location":"21HS/INCO/7_Kanalkodierung.html#kanalkapazitat","text":"Die h\u00f6chste Kapazit\u00e4t eines Kanals ist 1bit Information pro versendetes 1 bit. Beides, die maximale Kanalkapazit\u00e4t, wie auch die St\u00f6rquelle, kann als Binary Memoryless Source (BMS) interpretiert werden und so die standard Entropie Formeln ben\u00fctzt werden. Daher kommt man auf die foglenden Formel: \\(C_{BSC}(\\varepsilon)=1-H(\\varepsilon)=1-(\\varepsilon \\cdot log_2 \\frac 1 \\varepsilon + (1-\\varepsilon )\\cdot log_2 \\frac 1 {1 - \\varepsilon})\\) \\(C_{BSC}\\) hat die Masseinheit bits/bits (bits pro bits).","title":"Kanalkapazit\u00e4t"},{"location":"21HS/INCO/7_Kanalkodierung.html#mathe","text":"Um ein Frame zu brechnen gillt folgene Formel: \\(A_1 = A(1 - \\varepsilon)\\) , dabei ist A die l\u00e4nge in Bits des Frames. F\u00fcr mehrere Frames gillt: \\(A_N=A(1-\\varepsilon)^N\\) Wenn \\(\\varepsilon\\) nahe an 1 ist, kann die folgende N\u00e4herung genutzt wird: \\(1 - N\\cdot \\varepsilon\\)","title":"Mathe"},{"location":"21HS/INCO/7_Kanalkodierung.html#mehr-bit-fehlerwahrscheinlichkeit","text":"Wenn berechnet werden soll, was die Wahrscheinlichkeit ist, dass eine N-lange Sequenz genau F Fehler auftreten, dann kann folgende Formel genutzt werden: \\(P_{F,N}=\\begin{pmatrix}N \\\\ F\\end{pmatrix} \\cdot \\varepsilon^F \\cdot (1-\\varepsilon)^{N-F}\\) Dabei stellt F die Anzahl Fehler dar, N die L\u00e4nge des Block-Codes und \\(\\varepsilon\\) die Bit Error Ratio des Kanales.","title":"Mehr-Bit-Fehlerwahrscheinlichkeit"},{"location":"21HS/INCO/7_Kanalkodierung.html#binominalkoeffizenten","text":"\\(\\begin{pmatrix}N \\\\ F\\end{pmatrix}\\) wird gesprochen als n choose r und kann folgender massen berechnet werden \\(\\begin{pmatrix}n \\\\ k \\end{pmatrix}=\\frac{n!}{k!\\cdot(n-k)!}\\) Einige Taschenrechner haben eine Taste nCr , welche dies ausrechnen kann (der Canon F-718SGA hat dies ebenfalls)","title":"Binominalkoeffizenten"},{"location":"21HS/INCO/7_Kanalkodierung.html#framegrossen","text":"Im obigen Bild sieht man die Wahrscheinlichkeit, dass ein Frame ankommt f\u00fcr eine gewisse Frame-Gr\u00f6sse. In dieser Abbildung sieht man, dass grosse Frames erst wirklich Sinn ergeben, wenn man Fehlerresistenten Kanal hat.","title":"Framegr\u00f6ssen"},{"location":"21HS/INCO/7_Kanalkodierung.html#fehlerkorrekturverfahren","text":"","title":"Fehlerkorrekturverfahren"},{"location":"21HS/INCO/7_Kanalkodierung.html#backward-error-correction","text":"Es wird eine gewisse Redundanz hinzugef\u00fcgt (z.B. CRC), welche es erlauben, einen Fehler zu erkennen und die Daten nochmals anzufordern. Der Empf\u00e4nger schickt eine Quittung zur\u00fcck. Wenn keine Quittung erhalten wurde, wird das Packet nochmals gesendet. Nachteile: Langsam, da immer gewartet werden muss (Dies kann etwas mitigert werden, in dem die n\u00e4chste Nachricht bereits versendet wird, bevor die Quittung ankommt) Ein R\u00fcckkanal ist erfoderlich","title":"Backward Error Correction"},{"location":"21HS/INCO/7_Kanalkodierung.html#forward-error-correction","text":"Mehr Redundanz, so dass der Fehler sogar korrigiert werden kann","title":"Forward Error Correction"},{"location":"21HS/INCO/7_Kanalkodierung.html#hamming-distanz","text":"Die Hamming-Distanz beschreibt, wie viel Bits sich zwischen zwei Codew\u00f6rter \u00e4ndert. Die Codw\u00f6rter k\u00f6nnen auch auf einem W\u00fcrfel dargestellt werden in dem die Codew\u00f6rter in folgendes Koordinatensystem eingetragen werden: Wenn alle Codew\u00f6rter (im Beispiel unten ein 3-Zeichen langen Block-Code) in einem solchen Koordiantesystem eingetragen werden, kommt einen W\u00fcrfel oder \u00e4hliches heraus. Pro Zahl braucht man eine Dimension. Die minimale Hamming-Distanz ist die kleinste Distanz zwischen zwei korrekten Code-Words.","title":"Hamming-Distanz"},{"location":"21HS/INCO/7_Kanalkodierung.html#fehlerkorrektur-mit-matrizen","text":"","title":"Fehlerkorrektur mit Matrizen"},{"location":"21HS/INCO/7_Kanalkodierung.html#block-code","text":"Bei einem Blockcode werden die Informationen in Bl\u00f6cke verschickt. Dabei gibt es die N, die Anzahl Bits f\u00fcr Informationen und K, die Bits f\u00fcr den Fehlerschutz Systematische Blockcodes sind Blockcodes, bei welcher die Fehlerschutzbits zu Beginn oder am Ende steht.","title":"Block-Code"},{"location":"21HS/INCO/7_Kanalkodierung.html#systematischer-block-code","text":"In einem Systematischer Block-Code sind die Informationsbits klar von den Fehlerschutz-Bits getrennt. Als entweder kommen zuerst die informations-Bits und dann die Fehlerschutz-Bits oder umgekehrt.","title":"Systematischer Block-Code"},{"location":"21HS/INCO/7_Kanalkodierung.html#linearer-block-code","text":"In einem linearen Block-Code, wenn man zwei beliebige Codes zusammen xored, dann ergibt dies einen weiteren g\u00fclltigen Code. Der Code C={000, 110, 001, 101} w\u00e4re zum Beispiel einer. Jeder Linearer Block-Code ben\u00f6tigt einen Code mit nur 0. Wenn Codew\u00f6rter aus einer Generatormatrix generiert wird, dann ist der Code linear.","title":"Linearer Block-Code"},{"location":"21HS/INCO/7_Kanalkodierung.html#zyklischer-block-code","text":"Ein zyklischer Block-Code kann man um eins Rotieren und bekommt wieder ein valides Codewort. Als Beispiel. Aus \"110\" wird \"011\", dann \"101\" und dann wieder \"110\".","title":"Zyklischer Block-Code"},{"location":"21HS/INCO/7_Kanalkodierung.html#perfekter-block-code","text":"Ein Perfekter Blockcode hat die selbe Hamming-Distanz zwischen allen Codw\u00f6rtern","title":"Perfekter Block-Code"},{"location":"21HS/INCO/7_Kanalkodierung.html#fehlererkennung","text":"","title":"Fehlererkennung"},{"location":"21HS/INCO/7_Kanalkodierung.html#parity","text":"F\u00fcr ein Datenblock gibt es ein Parity-Bit. Even Parity: Parity-Bit ist 1, wenn die Anzahl 1-er inkl. Parity-Bit is gerade, sonst 0 Odd Parity: Parity-Bit ist 1, wenn die Anzahl 1-Bit inklusiv Parity-Bit ungerade ist, sonst 0 Der Vorteil von Even-Parity ist, dass es linearen Block-Code ist. Mit dieser Methode kann 1-Bit Fehler erkennt wrden.","title":"Parity"},{"location":"21HS/INCO/7_Kanalkodierung.html#quer-pariy","text":"Es wird ein Parity-Bit horizontal gebildet und ein Parity-Bit vertikal. F\u00fcr einen Block gibt es nun eine Linie f\u00fcr die horizontale gebildete Parity-Bits und eine Line f\u00fcr die vertikal gebildete Parity-Bits. Diese zwei Parity-Bit-Linien werden nun in ein Gesamt-Parity-Bit gerechnet. Die Coderate ( \\(\\frac K N\\) ) ist \\(\\frac{l\u00e4nge\\cdot breite}{l\u00e4nge \\cdot breite + l\u00e4nge + breite + 1}\\) Um dies zu optimieren, sollte probiert weden, den Bl\u00f6ck m\u00f6glich Quadratisch zu gestalten. L\u00e4nge und Breite sollte also m\u00f6glich gleich sein.","title":"Quer-Pariy"},{"location":"21HS/INCO/7_Kanalkodierung.html#prufsumme","text":"Man summiert alle Reihen/Elemente zusammen ( \\(\\sum^{n-1}_{i=0}Element_i\\) ) Dabei hat man eine minimale Hamming-Distanz von 2. Die Hamming-Distanz in einigen F\u00e4llen kann auch h\u00f6her sein, da es ein \u00dcbertrag geben kann und somit ein Bit-Wechsel mehrere Bit-\u00c4nderungen in der Pr\u00fcfsumme zu folge haben.","title":"Pr\u00fcfsumme"},{"location":"21HS/INCO/7_Kanalkodierung.html#tcp-udp-prufsumme","text":"Die Pr\u00fcfsumme wird \u00fcber ein Frame gebildet mit der Wortbreite von 16 Bis. //TODO","title":"TCP &amp; UDP Pr\u00fcfsumme"},{"location":"21HS/INCO/7_Kanalkodierung.html#1-bit-arithmetik","text":"Wichtig ist, dass es keine 2 geben kann (1+1=0). Der \u00dcbertrag wird vergessen. Man kann eine solche Zahl auch als Polynom darstellen. \\(1011=1\\cdot z^3+0\\cdot z^2+1\\cdot z^1+1\\cdot z^0\\) Auch mit diesem Polynomen kann man mit der 1-Bit Arithmetik rechnen. Beispiel: \\(\\begin{alignat} {1} (z^3+z^2+1)\\pm(z^2+z+1)=&z^3\\cdot(1\\pm0)+z^2\\cdot(1\\pm1)+z^1\\cdot(0\\pm1)+z^0\\cdot (1\\pm1)\\\\=&z^3+z\\end{alignat}\\) Dasselbe Spiel kann auch den anderen Rechnenoperationen durchgespielt werden.","title":"1-Bit Arithmetik"},{"location":"21HS/INCO/7_Kanalkodierung.html#crc","text":"Bei CRC teilt man den Datenblock als Polynom durch ein Generator-Polynom. Der dabei resultierender Rest ist die Pr\u00fcfsumme, welche mit verschickt wird. Es gibt verschiedene Generator-Polynome, jenach dem welchen Standard man folgt. Im Verfahren wird der Datenblock um die Anzahl Bits der Pr\u00fcfsumme verschoben (also aus 10, wird zB. 1000, wenn die Pr\u00fcfsumme 2-bit lang ist). Danach wird das Datenblock Polynom durch das Generator-Polynom geteilt. Der Rest, der dabei heraus kommt wird zum Datenblock addiert. Da man um die Anzahl Stellen der Pr\u00fcfsumme zu begin verschoben hat, hat man nun die Pr\u00fcfsumme vor der Zahl \"eingef\u00fcgt\". Nun haben wir ein Datenblock, welchen sicher durch den Generatorblock geteilt werden kann. Beispiel mit Dezimalzahlen: Datenblock: 123, Generatorbits: 12) 1230 : 12 = R6 -> 1236 ist teilbar Ebenfalls wichtig ist, dass wenn man durch eine Zahl teilt, ist der Rest h\u00f6chsten der Rest-1. In Bin\u00e4r heisst dass, eine Stelle weniger als durch was man geteilt hat.","title":"CRC"},{"location":"21HS/INCO/7_Kanalkodierung.html#fehlerkorrektur","text":"","title":"Fehlerkorrektur"},{"location":"21HS/INCO/7_Kanalkodierung.html#forward-error-correction_1","text":"Wenn man eine Hammingdistanz von 3 hat, kann man ein Bit korigieren. Dabei wird angenommen, dass ein Bit falsch ist und korrigiert zum n\u00e4chsten validen Codewort. Dies kann aber auch falsch sein!! Wie man oben bereits gesehen hat, nimmt man das Codewort, welches am n\u00e4chsten ist. Dabei kann man \\(\\left \\lfloor{\\frac{d_{min}-1)} 2}\\right \\rfloor\\) Fehler korrigieren.","title":"Forward Error Correction"},{"location":"21HS/INCO/8_Matrix.html","text":"Matrix Eine Matrix ist ein rechteckiges Zahlenfeld, wie z.B. diese 3x2 Matrix: \\(\\begin{bmatrix}7 & 6 & 2\\\\2 & 3 & 3\\end{bmatrix}\\) Addition und Subtraktion Matrizen addieren und subtrahieren ist denkbar einfach. Jede Zahl wird mir der Zahl an der gleichen Stelle in der anderen Matrix addiert, bzw. subtrahiert. $$ \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix} - \\begin{bmatrix}y_1 & y_2 & y_3 \\ y_4 & y_5 & y_6\\end{bmatrix} = \\begin{bmatrix}x_1-y_1 & x_2-y_2 & x_3-y_3 \\ x_4-y_4 & x_5-y_5 & x_6-y_6\\end{bmatrix} $$ Dasselbe gilt auch f\u00fcr die Addition. Skalar Multiplikation Wenn eine Matrix mit einem Wert, wie 3 multipliziert wird, entsteht eine neue Matrix, in welcher alle Werte mit diesem Wert multipliziert wurden: $$ c \\cdot \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix}= \\begin{bmatrix}c\\cdot x_1 & c\\cdot x_2 & c\\cdot x_3 \\ c\\cdot x_4 & c\\cdot x_5 & c\\cdot x_6\\end{bmatrix} $$ Matrix Multiplikation Wenn zwei Matrizen multipliziert werden, wie \\(A\\cdot B\\) , dann muss die Breite von \\(A\\) gleich die H\u00f6he von \\(B\\) sein. Das Resultat ist eine Matrix, welche so hoch ist, wie \\(A\\) und so breit ist, wie \\(B\\) . $$ \\begin{bmatrix}x_{11} & x_{21} & x_{31} \\ x_{12} & x_{22} & x_{32}\\end{bmatrix} \\cdot \\begin{bmatrix}y_{11} & y_{21} \\ y_{12} & y_{22} \\ y_{13} & y_{23}\\end{bmatrix} = \\begin{bmatrix} x_{11}\\cdot y_{11} + x_{21}\\cdot y_{12} + x_{31}\\cdot y_{13} & x_{11}\\cdot y_{21} + x_{21}\\cdot y_{22} + x_{21}\\cdot y_{23} \\ x_{12}\\cdot y_{12} + x_{22}\\cdot y_{12} + x_{32}\\cdot y_{13} & x_{12}\\cdot y_{21} + x_{22}\\cdot y_{22} + x_{22}\\cdot y_{23} \\end{bmatrix} $$ Oder in Worte, in das Feld (1/1) wird jeder Wert der Zeile 1 von A mit jedem Wert der Spalte 1 von B gerechnet. In den Wert (1/2), wird Zeile 1 mit der Spalten 2 gerchnet. Das Feld (2/1) wird berechnet, in dem die Reihe 2 mit der Spalte 1 multipliziert wird und das Feld (2/2) wird berechnet in dem, die Reihe 2 mit der Spalte 2 gerechnet wird. Wegen dieser Rechnenart, ist die Multiplikation mit zwei Matrizen nicht kommunikativ. Mit dem TR und Ein-Bit Arithmethik, kann modulo 2 gerechnet werden, um das korrekte Resultat zu bekommen. Einheitsmatrix Eine Einheitsmatrix, ist eine quadratische Matrix, welche Diagonal \u00fcberall eine 1 hat und sonst 0 : $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ Diese Matrix hat die Eigenschaft, dass wenn eine Matrix \\(A\\) mit einer Identit\u00e4tsmatrix multipliziert wird, dass wieder die Matrix \\(A\\) herauskommt. Inverse Matrix Die Inverse Matrix, ist die Matrix \\(A^{-1}\\) , welche mit der Matrix \\(A\\) , eine Identit\u00e4tsmatrix \\(I\\) ergibt: \\(A\\cdot A^{-1}=I\\) Transponierte Matrix Eine transponierte Matrix \\(A^T\\) von \\(A\\) ist, wenn die Spalten in \\(A\\) zu Reihen werden und die Reihen in \\(A\\) zu Spalten werden: $$ B= \\begin{bmatrix} 1 & 2 & 3\\ 3 & 4 & 5 \\end{bmatrix}\\ B^T= \\begin{bmatrix} 1 & 3 \\ 2 & 4\\ 3 & 5 \\end{bmatrix} $$","title":"Matrix"},{"location":"21HS/INCO/8_Matrix.html#matrix","text":"Eine Matrix ist ein rechteckiges Zahlenfeld, wie z.B. diese 3x2 Matrix: \\(\\begin{bmatrix}7 & 6 & 2\\\\2 & 3 & 3\\end{bmatrix}\\)","title":"Matrix"},{"location":"21HS/INCO/8_Matrix.html#addition-und-subtraktion","text":"Matrizen addieren und subtrahieren ist denkbar einfach. Jede Zahl wird mir der Zahl an der gleichen Stelle in der anderen Matrix addiert, bzw. subtrahiert. $$ \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix} - \\begin{bmatrix}y_1 & y_2 & y_3 \\ y_4 & y_5 & y_6\\end{bmatrix} = \\begin{bmatrix}x_1-y_1 & x_2-y_2 & x_3-y_3 \\ x_4-y_4 & x_5-y_5 & x_6-y_6\\end{bmatrix} $$ Dasselbe gilt auch f\u00fcr die Addition.","title":"Addition und Subtraktion"},{"location":"21HS/INCO/8_Matrix.html#skalar-multiplikation","text":"Wenn eine Matrix mit einem Wert, wie 3 multipliziert wird, entsteht eine neue Matrix, in welcher alle Werte mit diesem Wert multipliziert wurden: $$ c \\cdot \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix}= \\begin{bmatrix}c\\cdot x_1 & c\\cdot x_2 & c\\cdot x_3 \\ c\\cdot x_4 & c\\cdot x_5 & c\\cdot x_6\\end{bmatrix} $$","title":"Skalar Multiplikation"},{"location":"21HS/INCO/8_Matrix.html#matrix-multiplikation","text":"Wenn zwei Matrizen multipliziert werden, wie \\(A\\cdot B\\) , dann muss die Breite von \\(A\\) gleich die H\u00f6he von \\(B\\) sein. Das Resultat ist eine Matrix, welche so hoch ist, wie \\(A\\) und so breit ist, wie \\(B\\) . $$ \\begin{bmatrix}x_{11} & x_{21} & x_{31} \\ x_{12} & x_{22} & x_{32}\\end{bmatrix} \\cdot \\begin{bmatrix}y_{11} & y_{21} \\ y_{12} & y_{22} \\ y_{13} & y_{23}\\end{bmatrix} = \\begin{bmatrix} x_{11}\\cdot y_{11} + x_{21}\\cdot y_{12} + x_{31}\\cdot y_{13} & x_{11}\\cdot y_{21} + x_{21}\\cdot y_{22} + x_{21}\\cdot y_{23} \\ x_{12}\\cdot y_{12} + x_{22}\\cdot y_{12} + x_{32}\\cdot y_{13} & x_{12}\\cdot y_{21} + x_{22}\\cdot y_{22} + x_{22}\\cdot y_{23} \\end{bmatrix} $$ Oder in Worte, in das Feld (1/1) wird jeder Wert der Zeile 1 von A mit jedem Wert der Spalte 1 von B gerechnet. In den Wert (1/2), wird Zeile 1 mit der Spalten 2 gerchnet. Das Feld (2/1) wird berechnet, in dem die Reihe 2 mit der Spalte 1 multipliziert wird und das Feld (2/2) wird berechnet in dem, die Reihe 2 mit der Spalte 2 gerechnet wird. Wegen dieser Rechnenart, ist die Multiplikation mit zwei Matrizen nicht kommunikativ. Mit dem TR und Ein-Bit Arithmethik, kann modulo 2 gerechnet werden, um das korrekte Resultat zu bekommen.","title":"Matrix Multiplikation"},{"location":"21HS/INCO/8_Matrix.html#einheitsmatrix","text":"Eine Einheitsmatrix, ist eine quadratische Matrix, welche Diagonal \u00fcberall eine 1 hat und sonst 0 : $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ Diese Matrix hat die Eigenschaft, dass wenn eine Matrix \\(A\\) mit einer Identit\u00e4tsmatrix multipliziert wird, dass wieder die Matrix \\(A\\) herauskommt.","title":"Einheitsmatrix"},{"location":"21HS/INCO/8_Matrix.html#inverse-matrix","text":"Die Inverse Matrix, ist die Matrix \\(A^{-1}\\) , welche mit der Matrix \\(A\\) , eine Identit\u00e4tsmatrix \\(I\\) ergibt: \\(A\\cdot A^{-1}=I\\)","title":"Inverse Matrix"},{"location":"21HS/INCO/8_Matrix.html#transponierte-matrix","text":"Eine transponierte Matrix \\(A^T\\) von \\(A\\) ist, wenn die Spalten in \\(A\\) zu Reihen werden und die Reihen in \\(A\\) zu Spalten werden: $$ B= \\begin{bmatrix} 1 & 2 & 3\\ 3 & 4 & 5 \\end{bmatrix}\\ B^T= \\begin{bmatrix} 1 & 3 \\ 2 & 4\\ 3 & 5 \\end{bmatrix} $$","title":"Transponierte Matrix"},{"location":"21HS/INCO/9_Faltungscode.html","text":"Faltungscode Ein Faltungscode ist ein Linearer code. Der Input wird dabei durch Flip-Flops gesendet, welche bewirken, dass ein Bit sich auf die n\u00e4chsten Outputs auswirken. So wird eine Redundantz geschaffen. (Im Beispiel unten sind die gelben Elemente die Flip-Flops, die Plus im Kreis sind XOR-Gates) Wichtig zu erw\u00e4hnen ist, dass nach einem Codewort m\u00fcssen noch so viele \"0\" gesendet werden, wie die Anzahl Bits des Ged\u00e4chnis, da sonst das vorherige Codewort auf das n\u00e4chste Codewort einfluss nehmen w\u00fcrde. Diese Nullen nennt man \"Tail-Bits\". Diese sind in der unterigen Tabelle eingezeichnet. Ein solche Schaltung kann man auch als Statemachine anschauen. In der unteren Tabelle sieht man, wie der aktuellen Zustand der Statemachine zum m\u00e4chsten Zustand wird. Die Output Spalte kann an der \"Present State\" Spalten abgelesen werden. Das Zustanddiagramm unten ist eine Abbildung der Tabelle oben. Dabei kann jeder Zu Eigenschaften Die Coderate kann folgendermassen ausgerechnet werden: \\(R=\\frac N {2\\cdot(N+m)}\\) Dabei ist \\(N\\) die Anzahl Inputs und \\(m\\) die Anzahl Tailbits, bzw. wie gross das Ged\u00e4chniss des Faltungscode ist. Freie Hamming-Distanz Das ist der Pfad im Zustandsdiagramm mit m\u00f6glichst wenig 1 (aber nicht nur 0 ) beim Output des Encoders. Im oberen Zustandsdiagram h\u00e4tten wir eine Freie Hamming-Distanz von 5 (Von 00 zu 10 (dabei hat man 2 1 ); von 10 zu 01 (dabei hat man 1x 1 ); von 01 zu 00 (nochmals 2x 1 ); Im gesammten kommt man auf 5). Dies funktioniert auch im Tellis-Diagramm. Aus dies kann ausgerechnet werden, wie viel Fehler behoben werden k\u00f6nnen: \\(\\lfloor\\frac{d_{free}-1}2\\rfloor\\) Generatoren Unten sieht man die Schaltung f\u00fcr die Generatoren \\((1101b;1111b)\\) Hier k\u00f6nnen die XOR-Gates, welche zu Null verbinden, weggelassen werden und zu folgendem Diagramm optimiert werden: In dem Beispiel von oben, waren es immer zwei Generatoren, da zwei Linien von mit XOR von \\(U_K\\) weggingen. \\[ g_1=(111)=z^2+1\\\\ g_2=(101)=z^2+z+1\\\\ u=(1011)=z^3+z+1\\\\ \\\\ g_2\\cdot u=(z^2 + 1) \\cdot (z^3 + z + 1)=z^5+z^3+z^2+z^3+z+1=z^5+z^2+z+1)\\\\ \\rightarrow c_{2k}=(100111) \\] Achtung: wir rechnen mit 1-Bit Arithmetik Decodieren Beim Decodieren wird jeden m\u00f6glichen Pfad durch gerechnet und dabei die Bitfehler gez\u00e4hlt, welche auftretten m\u00fcssten. Wenn zwei Pfade sich treffen, wird der Pfad mit den kleinsten Bitfehler gew\u00e4hlt. Am Ende bleibt ein Pfad mit den wenigsten Bitfehler, welcher am Wahrscheinlichsten ist. Tail-Bits Dies sind Bits, welche am Ende eines Inputs noch angeh\u00e4ngt werden m\u00fcssen um die Schaltung wieder in den 0 -Zustand zur\u00fcck zu setzten. Dass heisst, wenn die Schaltung des Faltungscodes zwei Bits, bzw. zwei Flip-Flops enth\u00e4lt, dann werden zwei Tail-Bits ben\u00f6tigt.","title":"9 Faltungscode"},{"location":"21HS/INCO/9_Faltungscode.html#faltungscode","text":"Ein Faltungscode ist ein Linearer code. Der Input wird dabei durch Flip-Flops gesendet, welche bewirken, dass ein Bit sich auf die n\u00e4chsten Outputs auswirken. So wird eine Redundantz geschaffen. (Im Beispiel unten sind die gelben Elemente die Flip-Flops, die Plus im Kreis sind XOR-Gates) Wichtig zu erw\u00e4hnen ist, dass nach einem Codewort m\u00fcssen noch so viele \"0\" gesendet werden, wie die Anzahl Bits des Ged\u00e4chnis, da sonst das vorherige Codewort auf das n\u00e4chste Codewort einfluss nehmen w\u00fcrde. Diese Nullen nennt man \"Tail-Bits\". Diese sind in der unterigen Tabelle eingezeichnet. Ein solche Schaltung kann man auch als Statemachine anschauen. In der unteren Tabelle sieht man, wie der aktuellen Zustand der Statemachine zum m\u00e4chsten Zustand wird. Die Output Spalte kann an der \"Present State\" Spalten abgelesen werden. Das Zustanddiagramm unten ist eine Abbildung der Tabelle oben. Dabei kann jeder Zu","title":"Faltungscode"},{"location":"21HS/INCO/9_Faltungscode.html#eigenschaften","text":"Die Coderate kann folgendermassen ausgerechnet werden: \\(R=\\frac N {2\\cdot(N+m)}\\) Dabei ist \\(N\\) die Anzahl Inputs und \\(m\\) die Anzahl Tailbits, bzw. wie gross das Ged\u00e4chniss des Faltungscode ist.","title":"Eigenschaften"},{"location":"21HS/INCO/9_Faltungscode.html#freie-hamming-distanz","text":"Das ist der Pfad im Zustandsdiagramm mit m\u00f6glichst wenig 1 (aber nicht nur 0 ) beim Output des Encoders. Im oberen Zustandsdiagram h\u00e4tten wir eine Freie Hamming-Distanz von 5 (Von 00 zu 10 (dabei hat man 2 1 ); von 10 zu 01 (dabei hat man 1x 1 ); von 01 zu 00 (nochmals 2x 1 ); Im gesammten kommt man auf 5). Dies funktioniert auch im Tellis-Diagramm. Aus dies kann ausgerechnet werden, wie viel Fehler behoben werden k\u00f6nnen: \\(\\lfloor\\frac{d_{free}-1}2\\rfloor\\)","title":"Freie Hamming-Distanz"},{"location":"21HS/INCO/9_Faltungscode.html#generatoren","text":"Unten sieht man die Schaltung f\u00fcr die Generatoren \\((1101b;1111b)\\) Hier k\u00f6nnen die XOR-Gates, welche zu Null verbinden, weggelassen werden und zu folgendem Diagramm optimiert werden: In dem Beispiel von oben, waren es immer zwei Generatoren, da zwei Linien von mit XOR von \\(U_K\\) weggingen. \\[ g_1=(111)=z^2+1\\\\ g_2=(101)=z^2+z+1\\\\ u=(1011)=z^3+z+1\\\\ \\\\ g_2\\cdot u=(z^2 + 1) \\cdot (z^3 + z + 1)=z^5+z^3+z^2+z^3+z+1=z^5+z^2+z+1)\\\\ \\rightarrow c_{2k}=(100111) \\] Achtung: wir rechnen mit 1-Bit Arithmetik","title":"Generatoren"},{"location":"21HS/INCO/9_Faltungscode.html#decodieren","text":"Beim Decodieren wird jeden m\u00f6glichen Pfad durch gerechnet und dabei die Bitfehler gez\u00e4hlt, welche auftretten m\u00fcssten. Wenn zwei Pfade sich treffen, wird der Pfad mit den kleinsten Bitfehler gew\u00e4hlt. Am Ende bleibt ein Pfad mit den wenigsten Bitfehler, welcher am Wahrscheinlichsten ist.","title":"Decodieren"},{"location":"21HS/INCO/9_Faltungscode.html#tail-bits","text":"Dies sind Bits, welche am Ende eines Inputs noch angeh\u00e4ngt werden m\u00fcssen um die Schaltung wieder in den 0 -Zustand zur\u00fcck zu setzten. Dass heisst, wenn die Schaltung des Faltungscodes zwei Bits, bzw. zwei Flip-Flops enth\u00e4lt, dann werden zwei Tail-Bits ben\u00f6tigt.","title":"Tail-Bits"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html","tags":["summary","INCO"],"text":"INCO Summary - 20.01.2022 INCO Summary - 20.01.2022 Kombinatorische Logik Digitaltechnik Addierer Flip-Flops Zahlensystem Zahlen Umwandeln Negative Zahlen Codes Gray Code ASCII Code UTF-8 Endiannes Informationstheorie Quellenencoding Laufenl\u00e4ngen Encoding Huffman Codes LZ77 & LZW JPEG Audiocodierung Kanalcodierung Fehlererkennung Fehlerkorrigierende Codes CRC Faltunscode Kombinatorische Logik Gatter Name Formel NOT-Gate \\(!A\\) AND-Gate \\(A\\&B=A\\wedge B\\) NAND-Gate \\(!(A\\&B)\\) OR-Gate \\(A\\#B=A\\vee B\\) NOR-Gate \\(!(A\\#B)\\) XOR-Gate \\(A\\$B\\) XNOR-Gate \\(!(A\\$B)\\) Disjunktive Normalform \\((A\\&B)\\#(C\\&D)\\#..\\) \\(!(A\\&B)=!A\\#!B\\) \\(A\\&(B\\#C)=(A\\&B)\\#(A\\&C)\\) Wenn man aus einer Wahrheitstabelle eine Formel bilden muss, kann man f\u00fcr jedes 1 im Output einen Ausdruck aus den Inputs bilden, welche in diesem Fall 1 ergeben. Diese Ausdr\u00fccken werden mit OR-Gates verbunden. Digitaltechnik Addierer Halbaddierer Ein Addierer, welcher nur mit 1Bit ohne Eingang-Carry-Bit umgehen kann. Aus einem Halbaddierer kann einen Volladdierer erstellt werden, welcher zus\u00e4tzlich auch noch ein \u00dcbetrag der Vorheriger Addition ben\u00fctzen kann. Mehrere Volladdierer k\u00f6nnen hintereinander gesetzt werden und so beliebig viel stellen berechnet werden. Flip-Flops Wenn an C eine \"Rising-Edge\" anliegt, dann wird D gelesen, gepseichert und auf Q ausgegeben, bis auf C die n\u00e4chste \"Rising-Edge\" anliegt. Mit Flip-Flops werden oft Sequentielle Logik gebaut. Dabei werden mehrere Flip-Flips in serie geh\u00e4ngt. Beipiele: Bild Erkl\u00e4rung Frequenzteiler Gesetuerter Frequenzteiler Flankendeketor Erkennt Flanken bei einer st Synchronschaltung : Eine Schaltung, welche sich nur bei einer positiven Clock-Flanke \u00e4ndert (oder anderes Clocksignal). Zahlensystem Zahlen Umwandeln \\[ \\begin{alignat} {6} \\text{Zu konvertieren:}12.6875\\\\ 12 &: 2 &= 6 \\text{ Rest } 0 && 0.6875 \\cdot 2 &= 0.375 + 1\\\\ 6 &: 2 &= 3 \\text{ Rest } 0 && 0.375 \\cdot 2 &= 0.750 + 0\\\\ 3 &: 2 &= 1 \\text{ Rest } 1&& 0.750 \\cdot 2 &=0.500 + 1\\\\ 1 &: 2 &= 0 \\text{ Rest } 1&&0.500\\cdot 2 &= 0 + 1\\\\ \\text{Ergebniss: } 1100_b&&&\\hspace{2cm}&&\\text{Ergebniss: }0.1011_b\\\\ \\text{Zusammen: } 1100.1011_b \\end{alignat} \\] (Achtung Reihenfolge : bei Nicht-Kommastellen, von unten nach oben; bei Kommastellen: von oben nach unten) Negative Zahlen System Verfahren Beispiel 9er-Komplement Jede Ziffer von 9 abziehen \\(0022\\to 9977\\) 10er-Komplement Jede Ziffer von 9 abziehen und das Result +1 rechnen \\(0022 \\to 9977 \\to 9978\\) 1er-Komplement Jede Ziffer von 1 abziehen \\(0011_b \\to 1100_b\\) 2er-Kompelemnt Jede Ziffer von 1 abziehen und das Resultat +1 rechnen \\(0011_b \\to 1100_b \\to 1101_b\\) Mit und Ohne Vorzeichen: Codes DEZ HEX BIN Dez Hex Bin DEZ HEX BIN 0 0 0000 6 6 0110 12 C 1100 1 1 0001 7 7 0111 13 D 1101 2 2 0010 8 8 1000 14 E 1110 3 3 0011 9 9 1001 15 F 1111 4 4 0100 10 A 1010 5 5 0101 11 B 1011 Gray Code Ein Code, welcher f\u00fcr Schleifkontakte be\u00fctzt wird und es \u00e4ndert sich maximal 1 Bit f\u00fcr benachbarte Codew\u00f6rter. ASCII Code UTF-8 Unicode-Bereicht Utf-8 Codierung Anzahl Code-Bits 0000'0000 - 0000'007F 0xxxxxxx 7 0000'0080-0000'07FF 110xxxxx 10xxxxxx 11 (5 + 1*6) 0000'0800-0000'FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 (4 + 2*6) 0001'0000-0010'FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 (3 + 3*6) Endiannes Name Beschreibung Darstellung Little Endian Das niederstwertige Byte wird zuerst geschickt FEDCBA9 87654321 Big Endian Das h\u00f6chstwertige Byte wird zuerst geschickt 87654321 FEDCBA9 Informationstheorie Discrete Memoryless Source (DMS) gibt einzelne unabh\u00e4ngige Nachrichten aus. Ein Beispiel w\u00e4re einen W\u00fcrfel. Formel Erkl\u00e4rung \\(I(x_n)=\\log_2(\\frac 1 {P(x_n)}) [Bits]\\) \\(I\\) ist der Informationsgehalt von der Nachricht \\(x_n\\) \\(H(X)=\\sum^{N-1}_{n=0}P(x_n)\\cdot \\log_2(\\frac 1 {P(x_n)}) [Bit/Symbol]\\) \\(H\\) ist die Entropie der Quelle \\(X\\) Quellenencoding Formel/Wort Erkl\u00e4rung Codwortl\u00e4nge \\(l_n\\) Die Anzahl Bits eines Codewortes \\(L=\\sum^{N-1}_{n=0} P(x_n)\\cdot l_n [Bits/Symbol]\\) Die Codewortl\u00e4nge \\(L\\) einer Quelle \\(R(X)=L(X)-H(X) [Bits/Symbol]\\) Redundanz: Wie viele Bits pro Symbol in einer Quelle redundant sind \\(R(X)=\\frac{\\text{komprimierte Bits}}{\\text{unkombrimierte Bits}}\\) Die Coderate \\(R\\) ; besagt, wie fest komprimiert wurde }So lange die Redundanz \\(R\\) eines Codes gr\u00f6sser als 0 ist, kann noch verlustfrei komprimiert werden. Laufenl\u00e4ngen Encoding Anstatt \"AAAABDEFGG\" speichert man \"B04A B01B DEFGG\". Hier wurde B als Token genutzt, da es am seltesten vorkommt. Ebenfalls wurde der Z\u00e4hler auf eine zweistellige Zahl festgelegt. Bei Schwarzweiss Bilder kann zwischen Schwarz und Weiss gewechselt weden (10, 5, 3), w\u00e4ren 10 schwarze Pixel, 5 weisse Pixel, gefolgt von 3 schwarzen Pixeln. Huffman Codes Codes mit dem Huffmanverfahren sind automatisch pr\u00e4frixfrei und optimal (es gibt keinen besseren pr\u00e4fixfreien Code) Folgendes ist das Vorgehen: Ordne alle Symbole nach aufsteigenen Auftretenswahrscheinlichkeiten auf einer Zeile. Dies sind die Bl\u00e4tter Notiere unter jedes Blatt seine Wahrscheinlichkeit Schliesse die beiden Bl\u00e4tter mit der kleinsten Wahrscheinlichekit an einer gemeinsamen Astgabel an und ordne dem Ast die Summe der Wahrscheinlichkeiten zu Wiederhole Schritt 2 es nur noch ein Stamm gibt Jedem Ast wird nun ein eine 0, wenn man links geht und eine 1 wenn man rechts geht, zugewiessen Die Pfade zu allen Bl\u00e4tter aufschreiben. Das ist der Huffmancode LZ77 & LZW Wenn keine Sequenz gefunden wird, wird der Token (0, 0, T) , wobei T der n\u00e4chste Buchstabe ist. LZW : Die l\u00e4ngste Zeichenkette im W\u00f6rterbuch f\u00fcr die n\u00e4chsten Zeichen finden und ein neuen W\u00f6rterbucheintrag erstellen, mit dem aktuellen Token + das n\u00e4chste Zeichen. Empfangener Token ausgeben und im W\u00f6rterbuch eintragen mit einem Blank am Ende. Beim n\u00e4chsten Token wird die Blank des letzten W\u00f6rterbuch erg\u00e4nzt JPEG YCrCb (Y=Helligkeit, Cb=Blau Anteil, Cr=Rot Anteil) \\(\\begin{bmatrix} Y \\\\ C_B \\\\ C_R \\end{bmatrix} = \\begin{bmatrix}0.299 & 0.587 & 0.114\\\\ -0.1687 & -0.3313 & 0.5\\\\ 0.5 & -0.4187 & -0.0813\\end{bmatrix} \\cdot \\begin{bmatrix} R\\\\G\\\\B \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 128 \\\\ 128 \\end{bmatrix}\\) \\(\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix}1 & 0 & 1.402\\\\ 1 & -0.34414 & -0.71414\\\\ 1 & 1.772 & 0\\end{bmatrix} \\cdot \\begin{bmatrix} Y\\\\C_B - 128\\\\C_R - 128\\end{bmatrix}\\) Nur die Farbkan\u00e4le werden \"gedownsamplet\", der Helligkeitskanal bleibt bei der vollen Aufl\u00f6sung. $$ F_{vu}=\\frac 1 4 C_u C_v \\sum^7_{x=0}\\sum^7_{y=0}B_{yx} \\cos(\\frac {(2x+1)u\\pi} {16})\\cos(\\frac{(2y+1)v\\pi} {16})\\ B_{yx}=\\frac 1 4 \\sum^7_{u=0}\\sum^7_{v=0}C_uC_vF_{vu}\\cos(\\frac{(2x+1)u\\pi}{16})\\cos(\\frac{(2y+1)v\\pi}{16}) $$ Audiocodierung Pro Verdoppelung in Schalldruck, nimmt es 6.0206dB zu: \\(L=20\\cdot log_{10}(\\frac p {p_0})\\) ( \\(p\\) =Schalldruck; \\(p_0\\) =Bezugsschalldruck) \\(f_{abtast} > 2\\cdot f_{max}\\) Um jede erh\u00f6hung um 1 Bit nimmt das Rauschen um 6dB ab PCM : Absolut: Jeder Wert wird als absoluter Wert gespeichert Differential-PCM (DPCM): Es werden die Differenzen gespeichert Adaptive Differenztial-PCM (ADPCM): Es wird die Differenz der Differenz gespeichert. Kanalcodierung \\(\\varepsilon\\) (Epsilon) ist die Wahrscheinlichkeit, wie oft ein Fehlerauftritt (Bit Error Ratio = BER) Coderate: \\(R=\\frac{K}{N}\\) \\(K\\) =Informationsbits; \\(N\\) =Totale Bits KanalKapazit\u00e4t: \\(C_{BSC}(\\varepsilon)=1-H(\\varepsilon)=1-(\\varepsilon \\cdot log_2 \\frac 1 \\varepsilon + (1-\\varepsilon )\\cdot log_2 \\frac 1 {1 - \\varepsilon}) [Bits/Bits]\\) Formel Erkl\u00e4rung \\(P_{F,N}=\\begin{pmatrix}N \\\\ F\\end{pmatrix} \\cdot \\varepsilon^F \\cdot (1-\\varepsilon)^{N-F}\\) (N=L\u00e4nge des Block-Codes, F=Anzahl Fehler, \\(\\varepsilon\\) =Bit Error Ratio des Kanales). Rechnet die Wahrscheinlichkeit aus, dass \\(F\\) Fehler bei einem \\(N\\) langem Block-Code auftreten \\(P_{\\le1,N}=\\sum^1_{t=0}\\begin{pmatrix}N \\\\ t\\end{pmatrix} \\cdot \\varepsilon^t \\cdot (1-\\varepsilon)^{N-t}\\) Die Wahrscheinlichkeit, dass ein Codewort korrekt \u00fcbertragen wurde \\(I(X,Y)=H(Y)-H(\\varepsilon) [bit/bit]\\) Die bleibende Informationen im Kanal Fehlererkennung Backward Error Correction: Fehler kann erkennt werden und die Daten neuangefordert werden Forward Error Correction: Die Fehler k\u00f6nnen erkennt und zu einem gewissen Punkt korrigiert werden Blockcodes : Systematischer Block-Code: Informationsbits und Fehlerschutsbits sind klar getrennt (N=Anzahl CodeBits, K= InformationsBits) Linearer Block-Code: Jedes mit Jedem geXored Codewort gibt ein Codewort (jeder Code mit einer Generatormatrix ist linear) Zyklischer Block-Code: Rotierbar ( 110 \\(\\rightarrow\\) 011 \\(\\rightarrow\\) 101 \\(\\rightarrow\\) 110 ) Perfekter Block-Code: gleiche Hammingdistanz zwischen allen Codew\u00f6rtern Das Hamming-Gewicht=die kleinste Anzahl 1 auf einer Linie der Generator-Matrix Das Hamming-Gewicht ist gleich die Hamming Distanz \\(d_{min}\\) Erkennbare Fehler: \\(d_{min}-1\\) und korrigierbare Fehler: \\(\\frac{d_{min}-1}2\\) Fehlerkorrigierende Codes \\(\\frac {d_{min}-1}2\\) korrigierbar Generatormatrix Bedinungen: f\u00fcr \\(d_{min}=3\\) muss jeder Code (ausser dem 0-Code) min. 3x 1 haben Mindestens eine 1 muss in der Einheitsmatrix sein Jede Pari\u00e4tsmatrix-Zeile muss 2x 1 beinhalten CRC Das Datenpolynom wird um die Anzahl Stellen des Generatorpolynoms verschoben und anschliessend durch das Generatorpolynom geteilt. Das Resultat wird zum Datenpolynom hinzu addiert. Dabei werden die entstandenen 0 des Datenpolynoms gef\u00fcllt. Der Empf\u00e4nger kann den empfangenen Wert durch das Generatorpolynom teilen und muss 0 erhalten. Faltunscode Die Freie Distanz \\(d_{free}=w_{min}\\) und kann bestimmt werden, in dem der Pfad mit den wenigsten Ausgang 1 stehen (aber nicht nur 0 ). Die Anzahl 1 beim Ausgang ist die minimale freie Distanz. Die Coderate \\(R=\\frac K N = \\frac{K}{2\\cdot(K+m)}\\) , wobei \\(m\\) die Anzahl Tail-Bits sind.","title":"INCO Summary"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#inco-summary-20012022","text":"INCO Summary - 20.01.2022 Kombinatorische Logik Digitaltechnik Addierer Flip-Flops Zahlensystem Zahlen Umwandeln Negative Zahlen Codes Gray Code ASCII Code UTF-8 Endiannes Informationstheorie Quellenencoding Laufenl\u00e4ngen Encoding Huffman Codes LZ77 & LZW JPEG Audiocodierung Kanalcodierung Fehlererkennung Fehlerkorrigierende Codes CRC Faltunscode","title":"INCO Summary - 20.01.2022"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#kombinatorische-logik","text":"Gatter Name Formel NOT-Gate \\(!A\\) AND-Gate \\(A\\&B=A\\wedge B\\) NAND-Gate \\(!(A\\&B)\\) OR-Gate \\(A\\#B=A\\vee B\\) NOR-Gate \\(!(A\\#B)\\) XOR-Gate \\(A\\$B\\) XNOR-Gate \\(!(A\\$B)\\) Disjunktive Normalform \\((A\\&B)\\#(C\\&D)\\#..\\) \\(!(A\\&B)=!A\\#!B\\) \\(A\\&(B\\#C)=(A\\&B)\\#(A\\&C)\\) Wenn man aus einer Wahrheitstabelle eine Formel bilden muss, kann man f\u00fcr jedes 1 im Output einen Ausdruck aus den Inputs bilden, welche in diesem Fall 1 ergeben. Diese Ausdr\u00fccken werden mit OR-Gates verbunden.","title":"Kombinatorische Logik"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#digitaltechnik","text":"","title":"Digitaltechnik"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#addierer","text":"Halbaddierer Ein Addierer, welcher nur mit 1Bit ohne Eingang-Carry-Bit umgehen kann. Aus einem Halbaddierer kann einen Volladdierer erstellt werden, welcher zus\u00e4tzlich auch noch ein \u00dcbetrag der Vorheriger Addition ben\u00fctzen kann. Mehrere Volladdierer k\u00f6nnen hintereinander gesetzt werden und so beliebig viel stellen berechnet werden.","title":"Addierer"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#flip-flops","text":"Wenn an C eine \"Rising-Edge\" anliegt, dann wird D gelesen, gepseichert und auf Q ausgegeben, bis auf C die n\u00e4chste \"Rising-Edge\" anliegt. Mit Flip-Flops werden oft Sequentielle Logik gebaut. Dabei werden mehrere Flip-Flips in serie geh\u00e4ngt. Beipiele: Bild Erkl\u00e4rung Frequenzteiler Gesetuerter Frequenzteiler Flankendeketor Erkennt Flanken bei einer st Synchronschaltung : Eine Schaltung, welche sich nur bei einer positiven Clock-Flanke \u00e4ndert (oder anderes Clocksignal).","title":"Flip-Flops"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#zahlensystem","text":"","title":"Zahlensystem"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#zahlen-umwandeln","text":"\\[ \\begin{alignat} {6} \\text{Zu konvertieren:}12.6875\\\\ 12 &: 2 &= 6 \\text{ Rest } 0 && 0.6875 \\cdot 2 &= 0.375 + 1\\\\ 6 &: 2 &= 3 \\text{ Rest } 0 && 0.375 \\cdot 2 &= 0.750 + 0\\\\ 3 &: 2 &= 1 \\text{ Rest } 1&& 0.750 \\cdot 2 &=0.500 + 1\\\\ 1 &: 2 &= 0 \\text{ Rest } 1&&0.500\\cdot 2 &= 0 + 1\\\\ \\text{Ergebniss: } 1100_b&&&\\hspace{2cm}&&\\text{Ergebniss: }0.1011_b\\\\ \\text{Zusammen: } 1100.1011_b \\end{alignat} \\] (Achtung Reihenfolge : bei Nicht-Kommastellen, von unten nach oben; bei Kommastellen: von oben nach unten)","title":"Zahlen Umwandeln"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#negative-zahlen","text":"System Verfahren Beispiel 9er-Komplement Jede Ziffer von 9 abziehen \\(0022\\to 9977\\) 10er-Komplement Jede Ziffer von 9 abziehen und das Result +1 rechnen \\(0022 \\to 9977 \\to 9978\\) 1er-Komplement Jede Ziffer von 1 abziehen \\(0011_b \\to 1100_b\\) 2er-Kompelemnt Jede Ziffer von 1 abziehen und das Resultat +1 rechnen \\(0011_b \\to 1100_b \\to 1101_b\\) Mit und Ohne Vorzeichen:","title":"Negative Zahlen"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#codes","text":"DEZ HEX BIN Dez Hex Bin DEZ HEX BIN 0 0 0000 6 6 0110 12 C 1100 1 1 0001 7 7 0111 13 D 1101 2 2 0010 8 8 1000 14 E 1110 3 3 0011 9 9 1001 15 F 1111 4 4 0100 10 A 1010 5 5 0101 11 B 1011","title":"Codes"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#gray-code","text":"Ein Code, welcher f\u00fcr Schleifkontakte be\u00fctzt wird und es \u00e4ndert sich maximal 1 Bit f\u00fcr benachbarte Codew\u00f6rter.","title":"Gray Code"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#ascii-code","text":"","title":"ASCII Code"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#utf-8","text":"Unicode-Bereicht Utf-8 Codierung Anzahl Code-Bits 0000'0000 - 0000'007F 0xxxxxxx 7 0000'0080-0000'07FF 110xxxxx 10xxxxxx 11 (5 + 1*6) 0000'0800-0000'FFFF 1110xxxx 10xxxxxx 10xxxxxx 16 (4 + 2*6) 0001'0000-0010'FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 21 (3 + 3*6)","title":"UTF-8"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#endiannes","text":"Name Beschreibung Darstellung Little Endian Das niederstwertige Byte wird zuerst geschickt FEDCBA9 87654321 Big Endian Das h\u00f6chstwertige Byte wird zuerst geschickt 87654321 FEDCBA9","title":"Endiannes"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#informationstheorie","text":"Discrete Memoryless Source (DMS) gibt einzelne unabh\u00e4ngige Nachrichten aus. Ein Beispiel w\u00e4re einen W\u00fcrfel. Formel Erkl\u00e4rung \\(I(x_n)=\\log_2(\\frac 1 {P(x_n)}) [Bits]\\) \\(I\\) ist der Informationsgehalt von der Nachricht \\(x_n\\) \\(H(X)=\\sum^{N-1}_{n=0}P(x_n)\\cdot \\log_2(\\frac 1 {P(x_n)}) [Bit/Symbol]\\) \\(H\\) ist die Entropie der Quelle \\(X\\)","title":"Informationstheorie"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#quellenencoding","text":"Formel/Wort Erkl\u00e4rung Codwortl\u00e4nge \\(l_n\\) Die Anzahl Bits eines Codewortes \\(L=\\sum^{N-1}_{n=0} P(x_n)\\cdot l_n [Bits/Symbol]\\) Die Codewortl\u00e4nge \\(L\\) einer Quelle \\(R(X)=L(X)-H(X) [Bits/Symbol]\\) Redundanz: Wie viele Bits pro Symbol in einer Quelle redundant sind \\(R(X)=\\frac{\\text{komprimierte Bits}}{\\text{unkombrimierte Bits}}\\) Die Coderate \\(R\\) ; besagt, wie fest komprimiert wurde }So lange die Redundanz \\(R\\) eines Codes gr\u00f6sser als 0 ist, kann noch verlustfrei komprimiert werden.","title":"Quellenencoding"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#laufenlangen-encoding","text":"Anstatt \"AAAABDEFGG\" speichert man \"B04A B01B DEFGG\". Hier wurde B als Token genutzt, da es am seltesten vorkommt. Ebenfalls wurde der Z\u00e4hler auf eine zweistellige Zahl festgelegt. Bei Schwarzweiss Bilder kann zwischen Schwarz und Weiss gewechselt weden (10, 5, 3), w\u00e4ren 10 schwarze Pixel, 5 weisse Pixel, gefolgt von 3 schwarzen Pixeln.","title":"Laufenl\u00e4ngen Encoding"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#huffman-codes","text":"Codes mit dem Huffmanverfahren sind automatisch pr\u00e4frixfrei und optimal (es gibt keinen besseren pr\u00e4fixfreien Code) Folgendes ist das Vorgehen: Ordne alle Symbole nach aufsteigenen Auftretenswahrscheinlichkeiten auf einer Zeile. Dies sind die Bl\u00e4tter Notiere unter jedes Blatt seine Wahrscheinlichkeit Schliesse die beiden Bl\u00e4tter mit der kleinsten Wahrscheinlichekit an einer gemeinsamen Astgabel an und ordne dem Ast die Summe der Wahrscheinlichkeiten zu Wiederhole Schritt 2 es nur noch ein Stamm gibt Jedem Ast wird nun ein eine 0, wenn man links geht und eine 1 wenn man rechts geht, zugewiessen Die Pfade zu allen Bl\u00e4tter aufschreiben. Das ist der Huffmancode","title":"Huffman Codes"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#lz77-lzw","text":"Wenn keine Sequenz gefunden wird, wird der Token (0, 0, T) , wobei T der n\u00e4chste Buchstabe ist. LZW : Die l\u00e4ngste Zeichenkette im W\u00f6rterbuch f\u00fcr die n\u00e4chsten Zeichen finden und ein neuen W\u00f6rterbucheintrag erstellen, mit dem aktuellen Token + das n\u00e4chste Zeichen. Empfangener Token ausgeben und im W\u00f6rterbuch eintragen mit einem Blank am Ende. Beim n\u00e4chsten Token wird die Blank des letzten W\u00f6rterbuch erg\u00e4nzt","title":"LZ77 &amp; LZW"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#jpeg","text":"YCrCb (Y=Helligkeit, Cb=Blau Anteil, Cr=Rot Anteil) \\(\\begin{bmatrix} Y \\\\ C_B \\\\ C_R \\end{bmatrix} = \\begin{bmatrix}0.299 & 0.587 & 0.114\\\\ -0.1687 & -0.3313 & 0.5\\\\ 0.5 & -0.4187 & -0.0813\\end{bmatrix} \\cdot \\begin{bmatrix} R\\\\G\\\\B \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 128 \\\\ 128 \\end{bmatrix}\\) \\(\\begin{bmatrix} R \\\\ G \\\\ B \\end{bmatrix} = \\begin{bmatrix}1 & 0 & 1.402\\\\ 1 & -0.34414 & -0.71414\\\\ 1 & 1.772 & 0\\end{bmatrix} \\cdot \\begin{bmatrix} Y\\\\C_B - 128\\\\C_R - 128\\end{bmatrix}\\) Nur die Farbkan\u00e4le werden \"gedownsamplet\", der Helligkeitskanal bleibt bei der vollen Aufl\u00f6sung. $$ F_{vu}=\\frac 1 4 C_u C_v \\sum^7_{x=0}\\sum^7_{y=0}B_{yx} \\cos(\\frac {(2x+1)u\\pi} {16})\\cos(\\frac{(2y+1)v\\pi} {16})\\ B_{yx}=\\frac 1 4 \\sum^7_{u=0}\\sum^7_{v=0}C_uC_vF_{vu}\\cos(\\frac{(2x+1)u\\pi}{16})\\cos(\\frac{(2y+1)v\\pi}{16}) $$","title":"JPEG"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#audiocodierung","text":"Pro Verdoppelung in Schalldruck, nimmt es 6.0206dB zu: \\(L=20\\cdot log_{10}(\\frac p {p_0})\\) ( \\(p\\) =Schalldruck; \\(p_0\\) =Bezugsschalldruck) \\(f_{abtast} > 2\\cdot f_{max}\\) Um jede erh\u00f6hung um 1 Bit nimmt das Rauschen um 6dB ab PCM : Absolut: Jeder Wert wird als absoluter Wert gespeichert Differential-PCM (DPCM): Es werden die Differenzen gespeichert Adaptive Differenztial-PCM (ADPCM): Es wird die Differenz der Differenz gespeichert.","title":"Audiocodierung"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#kanalcodierung","text":"\\(\\varepsilon\\) (Epsilon) ist die Wahrscheinlichkeit, wie oft ein Fehlerauftritt (Bit Error Ratio = BER) Coderate: \\(R=\\frac{K}{N}\\) \\(K\\) =Informationsbits; \\(N\\) =Totale Bits KanalKapazit\u00e4t: \\(C_{BSC}(\\varepsilon)=1-H(\\varepsilon)=1-(\\varepsilon \\cdot log_2 \\frac 1 \\varepsilon + (1-\\varepsilon )\\cdot log_2 \\frac 1 {1 - \\varepsilon}) [Bits/Bits]\\) Formel Erkl\u00e4rung \\(P_{F,N}=\\begin{pmatrix}N \\\\ F\\end{pmatrix} \\cdot \\varepsilon^F \\cdot (1-\\varepsilon)^{N-F}\\) (N=L\u00e4nge des Block-Codes, F=Anzahl Fehler, \\(\\varepsilon\\) =Bit Error Ratio des Kanales). Rechnet die Wahrscheinlichkeit aus, dass \\(F\\) Fehler bei einem \\(N\\) langem Block-Code auftreten \\(P_{\\le1,N}=\\sum^1_{t=0}\\begin{pmatrix}N \\\\ t\\end{pmatrix} \\cdot \\varepsilon^t \\cdot (1-\\varepsilon)^{N-t}\\) Die Wahrscheinlichkeit, dass ein Codewort korrekt \u00fcbertragen wurde \\(I(X,Y)=H(Y)-H(\\varepsilon) [bit/bit]\\) Die bleibende Informationen im Kanal","title":"Kanalcodierung"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#fehlererkennung","text":"Backward Error Correction: Fehler kann erkennt werden und die Daten neuangefordert werden Forward Error Correction: Die Fehler k\u00f6nnen erkennt und zu einem gewissen Punkt korrigiert werden Blockcodes : Systematischer Block-Code: Informationsbits und Fehlerschutsbits sind klar getrennt (N=Anzahl CodeBits, K= InformationsBits) Linearer Block-Code: Jedes mit Jedem geXored Codewort gibt ein Codewort (jeder Code mit einer Generatormatrix ist linear) Zyklischer Block-Code: Rotierbar ( 110 \\(\\rightarrow\\) 011 \\(\\rightarrow\\) 101 \\(\\rightarrow\\) 110 ) Perfekter Block-Code: gleiche Hammingdistanz zwischen allen Codew\u00f6rtern Das Hamming-Gewicht=die kleinste Anzahl 1 auf einer Linie der Generator-Matrix Das Hamming-Gewicht ist gleich die Hamming Distanz \\(d_{min}\\) Erkennbare Fehler: \\(d_{min}-1\\) und korrigierbare Fehler: \\(\\frac{d_{min}-1}2\\)","title":"Fehlererkennung"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#fehlerkorrigierende-codes","text":"\\(\\frac {d_{min}-1}2\\) korrigierbar Generatormatrix Bedinungen: f\u00fcr \\(d_{min}=3\\) muss jeder Code (ausser dem 0-Code) min. 3x 1 haben Mindestens eine 1 muss in der Einheitsmatrix sein Jede Pari\u00e4tsmatrix-Zeile muss 2x 1 beinhalten","title":"Fehlerkorrigierende Codes"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#crc","text":"Das Datenpolynom wird um die Anzahl Stellen des Generatorpolynoms verschoben und anschliessend durch das Generatorpolynom geteilt. Das Resultat wird zum Datenpolynom hinzu addiert. Dabei werden die entstandenen 0 des Datenpolynoms gef\u00fcllt. Der Empf\u00e4nger kann den empfangenen Wert durch das Generatorpolynom teilen und muss 0 erhalten.","title":"CRC"},{"location":"21HS/INCO/summaries/summary_2022-01-20.html#faltunscode","text":"Die Freie Distanz \\(d_{free}=w_{min}\\) und kann bestimmt werden, in dem der Pfad mit den wenigsten Ausgang 1 stehen (aber nicht nur 0 ). Die Anzahl 1 beim Ausgang ist die minimale freie Distanz. Die Coderate \\(R=\\frac K N = \\frac{K}{2\\cdot(K+m)}\\) , wobei \\(m\\) die Anzahl Tail-Bits sind.","title":"Faltunscode"},{"location":"21HS/PM1/Beschlussprotokoll.html","text":"Retrospektive (m\u00fcndliches Gespr\u00e4ch) & Beschlussprotokoll von Retrospektive Teamreflexion (Wie funktioniert unser Team) Beschlussprotokoll Funktion: Man Informiert Teammitglieder und Aussenstehende Aufgabenverteilung Man kann in Protokoll klar definieren, wer, was, auf wann macht und sp\u00e4ter auf das zur\u00fcck verweissen Ged\u00e4chnisst\u00fcze (Juristischer Beweis) Protokollarten: Ergebnissprotokoll H\u00e4lt nur das Ergebniss fest Verlaufsprotokoll W\u00f6rtliches Protokoll Jedes Wort wird festgehalten (wie z.B. in Gericht) Ausf\u00fchrliches Protokoll In unserem Protokoll m\u00fcssen folgenedes festgehaltet werden: Dokumentation der Ergebnisse Die Logik hinter den Entscheidngen (Ist das logisch verst\u00e4ndlich?) keine Redebeitr\u00e4ge Vor der Sitzung soll ein Protokoll schreiber festgelegt werden, welcher sich w\u00e4hrend der Sitzung Notizen erstellt und danach das Protokoll davon erstellt.","title":"Beschlussprotokoll"},{"location":"21HS/PM1/Beschlussprotokoll.html#beschlussprotokoll","text":"Funktion: Man Informiert Teammitglieder und Aussenstehende Aufgabenverteilung Man kann in Protokoll klar definieren, wer, was, auf wann macht und sp\u00e4ter auf das zur\u00fcck verweissen Ged\u00e4chnisst\u00fcze (Juristischer Beweis) Protokollarten: Ergebnissprotokoll H\u00e4lt nur das Ergebniss fest Verlaufsprotokoll W\u00f6rtliches Protokoll Jedes Wort wird festgehalten (wie z.B. in Gericht) Ausf\u00fchrliches Protokoll In unserem Protokoll m\u00fcssen folgenedes festgehaltet werden: Dokumentation der Ergebnisse Die Logik hinter den Entscheidngen (Ist das logisch verst\u00e4ndlich?) keine Redebeitr\u00e4ge Vor der Sitzung soll ein Protokoll schreiber festgelegt werden, welcher sich w\u00e4hrend der Sitzung Notizen erstellt und danach das Protokoll davon erstellt.","title":"Beschlussprotokoll"},{"location":"21HS/PM1/Feedback.html","text":"","title":"Feedback"},{"location":"21HS/PM1/Projekt%203%20-%20Siedler%20von%20Catan.html","text":"Projekt 3 - Siedler von Catan Handeln und Bauen in beliebigereren Reihenfolge Hexboard nicht bearbeiten Config darf nicht angepasst werden Die \u00f6ffentliche Schnittstelle der SiedlerGame darf nicht angepasst werden Dummy kann am Ende gel\u00f6scht werden L\u00e4ngste Strasse ODER R\u00e4uber","title":"Projekt 3 - Siedler von Catan"},{"location":"21HS/PM1/Projekt%203%20-%20Siedler%20von%20Catan.html#projekt-3-siedler-von-catan","text":"Handeln und Bauen in beliebigereren Reihenfolge Hexboard nicht bearbeiten Config darf nicht angepasst werden Die \u00f6ffentliche Schnittstelle der SiedlerGame darf nicht angepasst werden Dummy kann am Ende gel\u00f6scht werden L\u00e4ngste Strasse ODER R\u00e4uber","title":"Projekt 3 - Siedler von Catan"},{"location":"21HS/PM1/Retrospektive.html","text":"Erfolge (was hat gut geklappt) Herausforderungen, die L\u00f6sung und die Probleml\u00f6sungsstrategie Umgang mit Herausforderungen Wichtigste Erkenntnisse aus der Teamreflexion Pers\u00f6nliche Ziele und Teamziele (Massnahmen) f\u00fcr das n\u00e4chste Projekt Feedback von Tech-doz zum Code und Projekt allgemein Besprechung der Erkenntnise f\u00fcr das n\u00e4chste Projekt Jeder sollte etwas sagen . Allerdings ist es sinnvoll einen Sitzungsleiter zu definiert. Es kann eine Presentation als Strukturierung (mit max. 10 Folien) erstellt werden. Die Slides k\u00f6nnen von allen Teammitglieder beigetragen werden. Things to remember: Struktur geben Traktandenliste Sitzungsleiter Wenn jemand von einem Thema abschweift, soll der Sitzungsleiter, oder jemand anders vom Team, wieder auf das eigentliche Thema zur\u00fcckf\u00fchren. Wenn das Thema allerdings f\u00fcr alle wichtig ist, dann kann es sinnvoll sein, auf das Thema einzugehen.","title":"Retrospektive"},{"location":"21HS/PM1/Retrospektive.html#things-to-remember","text":"Struktur geben Traktandenliste Sitzungsleiter Wenn jemand von einem Thema abschweift, soll der Sitzungsleiter, oder jemand anders vom Team, wieder auf das eigentliche Thema zur\u00fcckf\u00fchren. Wenn das Thema allerdings f\u00fcr alle wichtig ist, dann kann es sinnvoll sein, auf das Thema einzugehen.","title":"Things to remember:"},{"location":"22FS/AN2/summary_2022_06_20.html","tags":["summary","AN"],"text":"AN2 Summary 26.01.2022 AN2 Summary 26.01.2022 Reihen & Folgen Grenzwert Stetigkeit Nullstellen finden mit Stetigkeit Hornerschema Polynomdivision Extremwerte (ev. l\u00f6schen) Wendepunkte und Sattelpunkte (ev. l\u00f6schen) Fragen f\u00fcr die Kurvendiskussion (ev. l\u00f6schen) Extremaufgaben (ev. l\u00f6schen) Ableiten Newton Verfahren Integrieren Substition Partielle-Integration Partielbruchzerlergung Uneigentliche Integrale Differentialgleichungen Gew\u00f6hliche Differentialgleichung 1. Ordnung Richtungsfeld Euler-Schritte Separierbare Differentialgleichungen Autonome Differentialgleichung Lineare Differentialgleichungen Anwendung von Integrale Mittelwert Arbeitsintegral Rotationsk\u00f6rper Bogenl\u00e4nge Mantelfl\u00e4che eines Rotationsk\u00f6rpers Schwerpunkt einer Fl\u00e4che von zwischen zwei Kurven Schwerpunkt eines Rotationosk\u00f6rper Taylor-Reihen Komposition Konvergenz Hopital-Regel Begriff Erkl\u00e4rung gerade Funktion Wenn der Graph achsensymmetrisch mit der y-Achse ist (wie bei \\(x^2\\) ) ungerade Funktion Wenn der Graph punktsymmetrisch mit dem Nullpunkt ist (wie bei \\(x^3\\) ) Komposition \\((g\\circ f)(x)=g(f(x))\\) Injektive Funktion Keine zwei \\(x\\) f\u00fchren zum selben \\(y\\) . Von einer injektiven Funktion gibt es eine Umkehrfunktion. \\(\\sum^5_{k=1}a_k\\) Addiert \\(a_k\\) bis (inklusiv) \\(5\\) : \\(a_1+a_2+a_3+a_4+a_5\\) \u00dcbliche Summenformeln \\(\\sum^n_{k=1}k=\\frac{n(n+1)}2\\) \\(\\sum^n_{k=1}k^2=\\frac{n(n+1)(2n+1)}6\\) Polynomfunktion \\(f(x)=a_n\\cdot x^n+a_{n-1}\\cdot x^{n-1}+..+a_1\\cdot x + a_0\\) Komposition \\((g\\circ f)(2)=g(f(2))\\) Funktion Mapt vom Definitionsbereich \\(D\\) zum Wertebereich \\(W\\) Mitternachtsformel \\(D=b^2-4ac\\) und \\(x=\\frac{-b\\pm \\sqrt D}{2a}\\) Reihen & Folgen Name explizite Darstellung implizite Darstellung aufz\u00e4hlende Darstellung Arithmetische Folge \\(a_n=c+(n-1)\\cdot d\\) \\(a_1=c\\\\a_{n+1}=a_n+d\\) \\(c,c+d,c+2d,c+3d,...\\) Geometrische Folge \\(a_n=c\\cdot q^{n-1}\\) \\(a_1=c\\\\a_{n+1}=q\\cdot a_n\\) \\(c, c\\cdot q, c\\cdot q^2, c\\cdot q^3, ...\\) Harmonische Folge \\(a_n=\\frac 1 n\\) (nicht \u00fcblich) \\(1, \\frac 1 2, \\frac 1 3, \\frac 1 4, ...\\) Fibonacci-Folge (nicht elementar) \\(a_1=1, a_2=1\\\\a_{n+1}=a_n+a_{n+1}\\) \\(1, 1, 2, 3, 5, 8, ...\\) Arithmetische Reihee \\(a_k=a_1+(k-1)\\cdot d\\) \\(s_n=n\\cdot a_1+\\frac{n(n-1)}2 \\cdot d\\) \\(\\sum^n_{k=0}(k^2)=\\frac{n(n+1)(2n+1)}{6}\\) \\(\\sum^n_{k=0}k=\\frac{n(n+1)}{2}\\) Strebt immer geben \\(\\infty\\) oder \\(-\\infty\\) Geometrische Reihe \\(a_n=q^{(k-1)}\\cdot a_1\\) \\(s_n=\\frac{a_1(q^n-1)}{q-1}\\) Wenn \\(|q|<1\\) ist, dann ist der Grenzwert \\(\\frac {a_1}{1-q}\\) Grenzwert \\(\\lim_{n\\to\\infty}(c\\cdot a_n)=c\\cdot \\lim_{n\\to \\infty} a_n\\) \\(\\lim_{n\\to \\infty}(a_n+b_n)=\\lim_{n\\to \\infty}=\\lim_{n\\to \\infty}a_n + \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(a_b\\cdot b_n)=\\lim_{n\\to \\infty}a_b \\cdot \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(\\frac {a_n} {b_n})=\\lim_{n\\to \\infty} a_n : \\lim_{n\\to \\infty}b_n\\) \\(\\lim_{n\\to\\infty}(\\sqrt a - \\sqrt b)=\\lim_{n\\to\\infty}(\\frac{(\\sqrt a-\\sqrt b)(\\sqrt a + \\sqrt b)}{\\sqrt a + \\sqrt b})=\\lim_{n\\to\\infty}(\\frac{a-b}{\\sqrt a + \\sqrt b})\\) Wenn man einen Bruch in einem \\(\\lim\\) hat, dann kann mit dem h\u00f6chsten \\(n^k\\) mit dem h\u00f6chsten \\(k\\) gek\u00fcrzt werden Beispiel: $$ \\lim_{n\\to \\infty}=\\frac{3n^2+7n-3}{n^2+4n-11}=\\lim_{n\\to \\infty}\\frac{n^2(3+\\frac 7 n-\\frac 3 {n^2})}{n^2(1+\\frac 4 n - \\frac {11} {n^2})}\\rightarrow\\frac {3+0+0}{1+0+0}=\\frac 3 1 = 3 $$ Spezialfall: \\(\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\) $$ \\text{Speziallfall: }\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\ \\text{Beispiel: } \\lim_{n\\to\\infty}(1+\\frac{9}{4n})^{-5n}\\ (1+\\frac{9}{4n})^{-5n}=(1+\\frac{9}{4n}\\cdot\\frac{\\frac 1 9}{\\frac 1 9})^{-5n}=(1+\\frac 1 {\\frac {4n} 9})^{-5n}\\=(1+\\frac 1 {\\frac {4n} 9})^{-5n\\cdot\\frac{\\frac{4n} 9}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9\\cdot \\frac{-5n}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac {4n} 9\\cdot \\frac{-45} 4}\\=((1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9})^{\\frac{-45} 4}=e^{\\frac{-45} 4} $$ Typ Funktionswert Beispiel Typ 1 : Hebbare Definitionsl\u00fccke Das Z\u00e4hler- und Nennerpolynom haben dieselbe Nullstelle. Diese kann gek\u00fcrzt werden Strebt gegen den gek\u00fcrzten Bruch Typ 2: Polstelle Nur das Nennerpolynom hat die Nullstelle. Dies kann nicht gek\u00fcrzt werden Strebt gegen \\(\\infty\\) oder \\(-\\infty\\) Stetigkeit Eine Funktion ist stetig, wenn man sie zeichnen kann, ohne den Stift abzusetetzen. Eine stetige Funktion hat keine Spr\u00fcnge in der ersten Ableitung und keine Spr\u00fcnge in der eigentlichen Funktion. Nullstellen finden mit Stetigkeit Zwei Punkte, bei denen der Y-Wert ein verschiedenes Vorzeichen hat Den Mittelwert zischen den Punkten bilden Zu 1. gehen, aber diesem mit dem Mittelpunkt als Punkt, so dass die zwei P\u00fcnkte ein verschiedenes Vorzeichen haben Hornerschema Die Werte ( \\(b_n\\) ), welche unter dem Strich stehen, sind die Koeffizenten f\u00fcr das \\(q(x)\\) in \\(f(x)=(x-x_0)\\cdot q(x)\\) . In diesem fall also \\(q(x)=3x^3-8x^2+21x-49\\) . Daf\u00fcr muss das Resultat/Rest 0 sein! Polynomdivision Extremwerte (ev. l\u00f6schen) 1. Ableitung 2. Ableitung Beschreibung Bild \\(f'(x)>0\\) \\(f''(x_0)>0\\) \\(f\\) macht eine Linkskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)>0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)>0\\) \\(f\\) nmacht eine Linkskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)<0\\) \\(f\\) hat ein lokales Maximum bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)>0\\) \\(f\\) hat ein lokales Minimum bei \\((x_0, y_0)\\) \\(x_0\\) heisst \\(f(x_0)\\) heisst \\((x_0, y_0)\\) heisst Maxiumum (relative) Maximalstelle (relatives) Maximum/Maximalwert (relativer) Hochpunkt Minimum (relative) Minimalstelle (relatives) Minimum/Minimalwert (relativer) Tiefpunkt Oberbegriff (relative) Extremalstelle (relatives) Extremum/Extremalwert (relativer) Extremalpunkt Wendepunkte und Sattelpunkte (ev. l\u00f6schen) Eine Wendepunkt, ist wenn eine Rechtskurve in eine Linkskurve, oder umgekehrt, geht. Ein Spezialfall ist es, wenn \\(f'(x)=0\\) ist, dann spricht man von einem Sattelpunkt . Wenn \\(f''(x_0)=0\\) und \\(f'''(x_0)\\neq 0\\) ist, dann ist es sicherlich einen Wendepunkt . Wenn zus\u00e4tzlich noch \\(f'(x_0)=0\\) gilt, dann ist es ein Sattelpunkt Fragen f\u00fcr die Kurvendiskussion (ev. l\u00f6schen) Definitionsbereich? Symmetrieeigenschaften (gerade/ungerade), Periode? Schnittpunkte mit Achsen, Polstellen? Randpunkte, bzw. Verhalten, wenn \\(x\\) gegen die Grenzen des Definitionsbereichs strebt? Kandidaten f\u00fcr Extrema bestimmen und untersuchen Wendepunkte suchen Tabelle von Werten aufstellen (falls noch n\u00f6tig) Extremaufgaben (ev. l\u00f6schen) Zielgr\u00f6sse identifizieren Unabh\u00e4ngige Variable identifizieren Definitionsbereich bestimmen Zielgr\u00f6sse als Funktion mit unabh\u00e4ngigen Variabeln als Argument ausdr\u00fccken Relative Maxima/Minima bestimmen; Randpunkte auch ber\u00fcrcksichtigen! Welche relative Extrema sind auch absolute? Ableiten Name Formel \\(x^k=k\\cdot x^{k-1}\\) Faktorregel \\((c\\cdot f)'(x)=c\\cdot f'(x)\\) Summenregel \\((f+g)'(x)=f'(x)+g'(x)\\) Produktregel \\((u\\cdot v)'(x)=u'(x)\\cdot v(x)+u(x)\\cdot v'(x)\\) Quotientenregel \\((\\frac u v)'(x)=\\frac{u'(x)\\cdot v(x)-u(x)\\cdot v'(x)}{v(x)^2}\\) Kettenregel \\((F\\circ u)'(x)=F'(x)\\cdot u'(x)\\) sin \\(sin(x)'=cos(x)\\) cos \\(cos(x)'=-sin(x)\\) tan \\(\\tan(x)'=\\frac 1 v{\\cos^2(x)}\\) arcsin \\(\\arcsin(x)'=\\frac 1 {\\sqrt{1 - x^2}}\\) arccos \\(\\arccos(x)'=-\\frac 1 {\\sqrt{1-x^2}}\\) arctan \\(\\arctan(x)'=\\frac 1 {1+x^2}\\) \\(e^x\\) \\((e^x)'=e^x\\) \\((a^x)'\\) \\((a^x)'=a^x\\cdot \\ln(a)\\) \\(\\ln(x)'\\) \\(\\ln(x)'=\\frac 1 x\\) \\(\\log_a(x)'\\) \\(\\log_a(x)'=\\frac 1 {x\\cdot \\ln(a)}\\) Funktionsgleichung f\u00fcr Tangente \\(y(x)=f'(x_0)\\cdot (x-x_0)+f(x_0)\\) Achtung : Nicht jede Funktion ist differenzierbar. Die Ableitung einer Funktion darf keine pl\u00f6tzliche Spr\u00fcnge machen Newton Verfahren \\(x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\) Integrieren Ableiten: \\(a\\cdot x^n\\rightarrow \\frac{a}{n+1}\\cdot x^{n+1}\\) Schreibweise von Integral von der Fl\u00e4che zwischen \\([a;b]\\) : \\(\\int^b_a f(x) \\mathrm d x =F(b)-F(a)\\) $ \\(\\int a^x \\mathrm d x =\\frac {a^x}{\\ln(a)} + C\\) \\(\\int e^{ax}=ae^{ax}\\) \\(\\int \\ln(x)\\mathrm dx=x\\cdot \\ln(x)-x + C\\) \\(\\int \\log_a(x)\\mathrm dx=\\frac 1 {\\ln(a)}\\cdot (x \\cdot \\ln(x) -x) + C\\) \\(\\int \\sin(x)\\mathrm dx=-\\cos(x)+C\\) \\(\\int \\cos(x)\\mathrm dx=\\sin(x)+C\\) \\(\\int \\tan(x)\\mathrm dx = -\\ln |\\cos(x)|+C\\) \\(\\int u^{-1}\\mathrm dx=\\ln(|u|)\\) Substition Substitutionsgleichung f\u00fcr \\(x: u = g(x)\\) Substitionsgleichung f\u00fcr \\(\\mathrm dx: \\frac {\\mathrm du}{\\mathrm dx}=g'(x) \\Rightarrow \\mathrm dx = \\frac{\\mathrm du}{g'(x)}\\) Integralsubstition: \\(\\mathrm dx\\) und \\(x\\) durch \\(\\mathrm du\\) und \\(u\\) ersetzen (Es darf nach dem k\u00fcrzen kein \\(x\\) im Integral mehr haben) Integration: Bei bestimmten Integralen m\u00fcssen die Integralsgrenzen auch durch \\(u(x)\\) gelassen werden R\u00fccksubstition (nur bei unbestimmten Integralen): Alle \\(u\\) s m\u00fcssen durch \\(u(x)\\) ersetzt werden Wenn \\(u(x)\\) linear ist, kann der Satz \\(\\int f(ax + b)\\mathrm dx =\\frac 1 a\\cdot F(ax + b)\\) f\u00fcr das integrieren genutzt werden. (Dabei muss \\(f(x)\\) nicht gleich \\(u(x)\\) sein) Partielle-Integration \\(\\int u(x)\\cdot v'(x)\\mathrm dx = u(x)\\cdot v(x) - \\int u'(x)\\cdot v(x)\\mathrm dx\\) oder \\(\\int^b_a u(x)\\cdot v'(x)\\mathrm dx = \\left[u(x)\\cdot v(x)\\right]^b_a - \\int^b_a u'(x)\\cdot v(x)\\mathrm dx\\) \\(u(x)\\) muss einfach abgeleitet werden k\u00f6nnen und \\(v(x)\\) sollte nicht komplizierter in der Stammfunktion werden. Partielbruchzerlergung Es braucht ein Integral der Form \\(\\int \\frac {g(x)}{h(x)}\\mathrm dx=\\int f(x)\\mathrm dx\\) Nullstellen in \\(h(x)\\) bestimmen: Erraten, mit Hornerschema oder faktorisieren Jeder Nullstelle eine Summe von Br\u00fcchen zuweissen \\(x_1\\) ist eine einfache Nullstelle \\(\\rightarrow \\frac A {x-x_1}\\) \\(x_2\\) ist eine doppelte Nullstelle \\(\\rightarrow \\frac{B_1}{x-x_2}+\\frac{B_2}{(x-x_2)^2}\\) \\(x_3\\) ist eine r-fache Nullstelle \\(\\rightarrow \\frac {C_1}{x-x_3}+\\frac{C_2}{(x-x_3)^2}+...+\\frac{C_r}{(x-x_3)^r}\\) \\(f(x)\\) mit der Summe aller Partialbr\u00fcche gleichgesetzt Konstante ( \\(A_i\\) , \\(B_i\\) , \\(C_i\\) , ...) bestimmen Alle Partialbr\u00fcche auf den selben Nenner bringen. Da auf beiden Seiten derselbe Nenner steht, m\u00fcssen die Z\u00e4hler auch gleich sein F\u00fcr das Gleichungssystem der Z\u00e4hler die Nulstellen in \\(x\\) einsetzen Lineares Gleichungssystem l\u00f6sen Integrieren \\(\\int \\frac 1 {x-x_0}\\mathrm dx=\\ln\\vert x-x_0\\vert + C\\) \\(\\int \\frac 1 {(x-x_0)^2}\\mathrm dx=-\\frac 1 {1(x-x_0)}+C\\) \\(\\int \\frac 1 {(x-x_0)^3}\\mathrm dx=-\\frac 1 {2(x-x_0)^{2}}+C\\) \\(\\int \\frac 1 {(x-x_0)^r}\\mathrm dx=\\frac 1 {(1 - r)(x-x_0)^{r-1}}+C\\) Uneigentliche Integrale \\(\\int ^\\infty_a f(x)\\mathrm dx = \\lim_{t\\to \\infty}\\int ^t_a f(x) \\mathrm dx=\\lim_{t\\to \\infty}F(t)-F(a)\\) Zuerst die Stammfunktion berechnen und danach \\(F(t)-F(a)\\) berechnen mit \\(t\\) nach \\(\\infty\\) gehen lassen \\(\\int^b_a f(x)\\mathrm dx=\\lim_{t \\to a} f(x)\\mathrm dx=\\lim_{t\\to a}F(b) - F(a)\\) Differentialgleichungen Eine Funktion, in welcher die die gesuchte Funktion \\(f\\) und die Ableitung dieser Funktion \\(f'\\) Beispiel: \\(y'=0\\rightarrow y=c\\) \\(y'=y\\rightarrow y=c\\cdot e^x\\) \\(y'=7y\\rightarrow y=e^{7x}\\) Ordnung einer Ableitung ist die Ordnung der h\u00f6chsten vorkommenden Ableitung Die Partikul\u00e4re L\u00f6sung ? : Anfangsbedingungen: vorgegebene Werte f\u00fcr \\(y(x_0), y'(x_0),...,y^{(n-1)}(x_0)\\) Randbedinungen: vorgegebene Werte f\u00fcr \\(y(x_1), y(x_2),...,y(x_n)\\) Gew\u00f6hliche Differentialgleichung 1. Ordnung \\(y'=F(x, y)\\) Richtungsfeld Euler-Schritte \\(x_n=x_{n-1}+h\\) und \\(y_n=y_{n-1}+h\\cdot F(x_{n-1}, y_{n-1})\\) Dabei ist \\(h\\) die Schrittgr\u00f6sse. Je kleiner, desto genauer ist die Approximation Separierbare Differentialgleichungen \\[ y'=f(x)\\cdot g(y) \\] Die Differentialgleichung darf umgeformt werden, damit sie in diese Form passt ( \\(x+y\\cdot y'=0 \\Rightarrow y\\cdot y'=-x\\Rightarrow y'=-x\\cdot \\frac 1 y\\) ) \\(y'=\\frac{\\mathrm dy}{\\mathrm dx}=f(x)\\cdot g(y)\\) Trennung der Variablen: \\(\\frac {\\mathrm dy}{g(y)}=f(x)\\cdot \\mathrm dx\\) Integration auf beiden Sieten( \\(+C\\) nicht vergessen): \\(\\int \\frac 1{g(y)}\\mathrm dy=\\int f(x)\\mathrm dx\\) Aufl\u00f6sen nach \\(y\\) Autonome Differentialgleichung \\[ y'=f(y) \\] Autonome Differentialgleichungen sind separierbar. autonom: \\(y'=y^2 + 6\\) \\(y'=y^2\\cdot \\sqrt{1 - \\sin(y)}-\\ln(y)\\) nicht autonom \\(y' = x + y\\) \\(y'=\\frac y x\\) Lineare Differentialgleichungen \\[ y'+f(x)\\cdot y=g(x) \\] \\(f(x)\\) und \\(g(x)\\) bestimmen Stammfunktion \\(F(x)\\) und \\(G(x)\\) bestimmen In die Formel \\(y_0=C\\cdot e^{-F(x)}\\) einsetzen \\(C\\) durch \\(K(x)\\) ersetzen: \\(y=K(x)\\cdot e^{-F(x)}\\) \\(K(x)\\) berechnen ( \\(+C\\) nicht vergessen): \\(K(x)=\\int g(x)\\cdot e^{F(x)}\\mathrm dx\\) Einstezen von \\(K(x)\\) in \\(y=K(x)\\cdot e^{-F(x)}\\) Anwendung von Integrale Mittelwert \\(\\mu=\\frac 1 {b - a}\\cdot \\int^b_a f(x)\\mathrm dx\\) Arbeitsintegral Die Formel f\u00fcr die Arbeit ist: \\(Arbeit=Kraft \\cdot Weg\\) . Somit kann mit der Funktion \\(f(x)\\) , welche die Kraft an einer Strecke zur\u00fcck gibt, integriert werden. Rotationsk\u00f6rper $$ \\text{Horizontal: } & V=\\pi \\cdot \\int^b_a(f(x))^2\\mathrm dx\\ \\text{Vertikal: } & V=\\pi\\cdot \\int^d_c(g(y))^2 \\mathrm dx\\ \\text{wobei gilt: } &c \\le y \\le d \\text{ und } g(y)=x \\text{ ist die Umkehr-Funktion von } f(x) $$ Bogenl\u00e4nge $$ s=\\int^b_a\\sqrt{1+(y')^2}\\mathrm dx $$ Mantelfl\u00e4che eines Rotationsk\u00f6rpers \\[ M=2\\pi \\cdot \\int^b_a y\\cdot \\sqrt{1 + (y')^2}\\mathrm dx \\] Schwerpunkt einer Fl\u00e4che von zwischen zwei Kurven $$ x_s=&\\frac 1 A \\int^b_a x\\cdot (f_o(x) - f_u(x))\\mathrm dx\\ y_s=&\\frac 1 {2A}\\int^b_a(f^2_o(x)-f^2_u(x))\\mathrm dx $$ Schwerpunkt eines Rotationosk\u00f6rper $$ x_s=&\\frac \\pi V \\int^b_a x\\cdot f^2(x) \\mathrm dx\\ y_s=&0\\ z_s=&0 $$ Taylor-Reihen \\[ p_n=\\sum^n_{k=0}\\frac{f^{(k)}(x_0)}{k!}\\cdot (x-x_0)^k \\] Funktion \\(x_0\\) Taylor-Reihe Radius \\(e^x\\) 0 \\(\\sum^\\infty_{k=0}\\frac {x^k}{k!}=1+x+\\frac {x^2} {2!} + \\frac{x^3}{3!}+...\\) \\(\\infty\\) \\(e^{-2x}\\) 0 \\(\\sum^\\infty_{k=0}\\frac{-x^{2k}}{k!}=1-x^2-\\frac {x^4}{2!} - \\frac{x^6}{3!}+...\\) \\(\\infty\\) \\(\\sin(x)\\) 0 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot\\frac{x^{2k+1}}{(2k+1)!}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}\\) q \\(\\cos(x)\\) 0 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot \\frac{x^{2k}}{(2k)!}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+...\\) \\(\\ln(x)\\) 1 \\(\\sum^\\infty_{k=0}(-1)^{k}\\cdot\\tfrac 1 {k+1}(x-1)^{k+1}=(x-1)-\\tfrac 1 2(x-1)^2+\\tfrac 1 3(x-1)^3-\\tfrac 1 4 (x-1)^4+...\\) \\(x^{-1}=\\frac 1 x\\) 1 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot(x-1)^k=1-(x-1)+(x-1)^2-(x-1)^3+(x-1)^4-...\\) Komposition \\[ T_{h,x_0}\\text{ bezeichnet die Taylor-Reihe von } h(x) \\text{ um } x_0\\\\ T_{g,f(x_0)}(f(x))=T_{g\\circ f),x_0}(x_0) \\] Beispiel: $$ f(x)=-x^2\\ g(x)=e^x\\ x_0=0\\ g(x)=e^2\\approx T_{g,0}(z)=1+z+\\frac {z^2}{2!}+\\frac{z^3}{3!}+...\\ g(f(x))=e^{-x^2}\\approx T_{(g\\circ f), x_0}=T_{g, f(x_0)}=1+(-x^2)+\\frac{(-x^2)^2}{2!} \\frac{(-x^2)^3}{3!}+...=1-x^2+\\frac{x^4}{2!}-\\frac{x^6}{3!}+... $$ Konvergenz \\[ f(x)=\\sum^\\infty_{k=0}a_k(x-x_0)^k\\\\ r=\\lim_{k\\to\\infty}\\left\\vert\\frac{a_k}{a_{k+1}}\\right\\vert\\\\ x_1=\\vert x - x_0\\vert\\\\ x_2 = \\vert x + x_0\\vert \\] \\(r\\) ist der Radius um \\(x_0\\) , in welchem das Taylor-Polynom genau ist, wenn \\(k\\) gegen Unendlich geht. \\(x_1\\) und \\(x_2\\) stellen die \u00e4usserst m\u00f6glichsten Punkte, welche vom Taylor-Polynom genau bestimmt werden k\u00f6nnen. Hopital-Regel \\[ \\lim_{x\\to x_0}\\frac{f(x)}{g(x)}=\\lim_{x\\to x_0}\\frac{f'(x)}{g'(x)} \\]","title":"AN2 Summary"},{"location":"22FS/AN2/summary_2022_06_20.html#an2-summary-26012022","text":"AN2 Summary 26.01.2022 Reihen & Folgen Grenzwert Stetigkeit Nullstellen finden mit Stetigkeit Hornerschema Polynomdivision Extremwerte (ev. l\u00f6schen) Wendepunkte und Sattelpunkte (ev. l\u00f6schen) Fragen f\u00fcr die Kurvendiskussion (ev. l\u00f6schen) Extremaufgaben (ev. l\u00f6schen) Ableiten Newton Verfahren Integrieren Substition Partielle-Integration Partielbruchzerlergung Uneigentliche Integrale Differentialgleichungen Gew\u00f6hliche Differentialgleichung 1. Ordnung Richtungsfeld Euler-Schritte Separierbare Differentialgleichungen Autonome Differentialgleichung Lineare Differentialgleichungen Anwendung von Integrale Mittelwert Arbeitsintegral Rotationsk\u00f6rper Bogenl\u00e4nge Mantelfl\u00e4che eines Rotationsk\u00f6rpers Schwerpunkt einer Fl\u00e4che von zwischen zwei Kurven Schwerpunkt eines Rotationosk\u00f6rper Taylor-Reihen Komposition Konvergenz Hopital-Regel Begriff Erkl\u00e4rung gerade Funktion Wenn der Graph achsensymmetrisch mit der y-Achse ist (wie bei \\(x^2\\) ) ungerade Funktion Wenn der Graph punktsymmetrisch mit dem Nullpunkt ist (wie bei \\(x^3\\) ) Komposition \\((g\\circ f)(x)=g(f(x))\\) Injektive Funktion Keine zwei \\(x\\) f\u00fchren zum selben \\(y\\) . Von einer injektiven Funktion gibt es eine Umkehrfunktion. \\(\\sum^5_{k=1}a_k\\) Addiert \\(a_k\\) bis (inklusiv) \\(5\\) : \\(a_1+a_2+a_3+a_4+a_5\\) \u00dcbliche Summenformeln \\(\\sum^n_{k=1}k=\\frac{n(n+1)}2\\) \\(\\sum^n_{k=1}k^2=\\frac{n(n+1)(2n+1)}6\\) Polynomfunktion \\(f(x)=a_n\\cdot x^n+a_{n-1}\\cdot x^{n-1}+..+a_1\\cdot x + a_0\\) Komposition \\((g\\circ f)(2)=g(f(2))\\) Funktion Mapt vom Definitionsbereich \\(D\\) zum Wertebereich \\(W\\) Mitternachtsformel \\(D=b^2-4ac\\) und \\(x=\\frac{-b\\pm \\sqrt D}{2a}\\)","title":"AN2 Summary 26.01.2022"},{"location":"22FS/AN2/summary_2022_06_20.html#reihen-folgen","text":"Name explizite Darstellung implizite Darstellung aufz\u00e4hlende Darstellung Arithmetische Folge \\(a_n=c+(n-1)\\cdot d\\) \\(a_1=c\\\\a_{n+1}=a_n+d\\) \\(c,c+d,c+2d,c+3d,...\\) Geometrische Folge \\(a_n=c\\cdot q^{n-1}\\) \\(a_1=c\\\\a_{n+1}=q\\cdot a_n\\) \\(c, c\\cdot q, c\\cdot q^2, c\\cdot q^3, ...\\) Harmonische Folge \\(a_n=\\frac 1 n\\) (nicht \u00fcblich) \\(1, \\frac 1 2, \\frac 1 3, \\frac 1 4, ...\\) Fibonacci-Folge (nicht elementar) \\(a_1=1, a_2=1\\\\a_{n+1}=a_n+a_{n+1}\\) \\(1, 1, 2, 3, 5, 8, ...\\) Arithmetische Reihee \\(a_k=a_1+(k-1)\\cdot d\\) \\(s_n=n\\cdot a_1+\\frac{n(n-1)}2 \\cdot d\\) \\(\\sum^n_{k=0}(k^2)=\\frac{n(n+1)(2n+1)}{6}\\) \\(\\sum^n_{k=0}k=\\frac{n(n+1)}{2}\\) Strebt immer geben \\(\\infty\\) oder \\(-\\infty\\) Geometrische Reihe \\(a_n=q^{(k-1)}\\cdot a_1\\) \\(s_n=\\frac{a_1(q^n-1)}{q-1}\\) Wenn \\(|q|<1\\) ist, dann ist der Grenzwert \\(\\frac {a_1}{1-q}\\)","title":"Reihen &amp; Folgen"},{"location":"22FS/AN2/summary_2022_06_20.html#grenzwert","text":"\\(\\lim_{n\\to\\infty}(c\\cdot a_n)=c\\cdot \\lim_{n\\to \\infty} a_n\\) \\(\\lim_{n\\to \\infty}(a_n+b_n)=\\lim_{n\\to \\infty}=\\lim_{n\\to \\infty}a_n + \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(a_b\\cdot b_n)=\\lim_{n\\to \\infty}a_b \\cdot \\lim_{n\\to \\infty} b_n\\) \\(\\lim_{n\\to \\infty}(\\frac {a_n} {b_n})=\\lim_{n\\to \\infty} a_n : \\lim_{n\\to \\infty}b_n\\) \\(\\lim_{n\\to\\infty}(\\sqrt a - \\sqrt b)=\\lim_{n\\to\\infty}(\\frac{(\\sqrt a-\\sqrt b)(\\sqrt a + \\sqrt b)}{\\sqrt a + \\sqrt b})=\\lim_{n\\to\\infty}(\\frac{a-b}{\\sqrt a + \\sqrt b})\\) Wenn man einen Bruch in einem \\(\\lim\\) hat, dann kann mit dem h\u00f6chsten \\(n^k\\) mit dem h\u00f6chsten \\(k\\) gek\u00fcrzt werden Beispiel: $$ \\lim_{n\\to \\infty}=\\frac{3n^2+7n-3}{n^2+4n-11}=\\lim_{n\\to \\infty}\\frac{n^2(3+\\frac 7 n-\\frac 3 {n^2})}{n^2(1+\\frac 4 n - \\frac {11} {n^2})}\\rightarrow\\frac {3+0+0}{1+0+0}=\\frac 3 1 = 3 $$ Spezialfall: \\(\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\) $$ \\text{Speziallfall: }\\lim_{n\\to\\infty}(1+\\frac 1 n)^n=e=2.718\\ \\text{Beispiel: } \\lim_{n\\to\\infty}(1+\\frac{9}{4n})^{-5n}\\ (1+\\frac{9}{4n})^{-5n}=(1+\\frac{9}{4n}\\cdot\\frac{\\frac 1 9}{\\frac 1 9})^{-5n}=(1+\\frac 1 {\\frac {4n} 9})^{-5n}\\=(1+\\frac 1 {\\frac {4n} 9})^{-5n\\cdot\\frac{\\frac{4n} 9}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9\\cdot \\frac{-5n}{\\frac{4n} 9}}=(1+\\frac 1 {\\frac {4n} 9})^{\\frac {4n} 9\\cdot \\frac{-45} 4}\\=((1+\\frac 1 {\\frac {4n} 9})^{\\frac{4n} 9})^{\\frac{-45} 4}=e^{\\frac{-45} 4} $$ Typ Funktionswert Beispiel Typ 1 : Hebbare Definitionsl\u00fccke Das Z\u00e4hler- und Nennerpolynom haben dieselbe Nullstelle. Diese kann gek\u00fcrzt werden Strebt gegen den gek\u00fcrzten Bruch Typ 2: Polstelle Nur das Nennerpolynom hat die Nullstelle. Dies kann nicht gek\u00fcrzt werden Strebt gegen \\(\\infty\\) oder \\(-\\infty\\)","title":"Grenzwert"},{"location":"22FS/AN2/summary_2022_06_20.html#stetigkeit","text":"Eine Funktion ist stetig, wenn man sie zeichnen kann, ohne den Stift abzusetetzen. Eine stetige Funktion hat keine Spr\u00fcnge in der ersten Ableitung und keine Spr\u00fcnge in der eigentlichen Funktion.","title":"Stetigkeit"},{"location":"22FS/AN2/summary_2022_06_20.html#nullstellen-finden-mit-stetigkeit","text":"Zwei Punkte, bei denen der Y-Wert ein verschiedenes Vorzeichen hat Den Mittelwert zischen den Punkten bilden Zu 1. gehen, aber diesem mit dem Mittelpunkt als Punkt, so dass die zwei P\u00fcnkte ein verschiedenes Vorzeichen haben","title":"Nullstellen finden mit Stetigkeit"},{"location":"22FS/AN2/summary_2022_06_20.html#hornerschema","text":"Die Werte ( \\(b_n\\) ), welche unter dem Strich stehen, sind die Koeffizenten f\u00fcr das \\(q(x)\\) in \\(f(x)=(x-x_0)\\cdot q(x)\\) . In diesem fall also \\(q(x)=3x^3-8x^2+21x-49\\) . Daf\u00fcr muss das Resultat/Rest 0 sein!","title":"Hornerschema"},{"location":"22FS/AN2/summary_2022_06_20.html#polynomdivision","text":"","title":"Polynomdivision"},{"location":"22FS/AN2/summary_2022_06_20.html#extremwerte-ev-loschen","text":"1. Ableitung 2. Ableitung Beschreibung Bild \\(f'(x)>0\\) \\(f''(x_0)>0\\) \\(f\\) macht eine Linkskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)>0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach oben bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)>0\\) \\(f\\) nmacht eine Linkskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)<0\\) \\(f''(x_0)<0\\) \\(f\\) macht eine Rechtskurve nach unten bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)<0\\) \\(f\\) hat ein lokales Maximum bei \\((x_0, y_0)\\) \\(f'(x)=0\\) \\(f''(x)>0\\) \\(f\\) hat ein lokales Minimum bei \\((x_0, y_0)\\) \\(x_0\\) heisst \\(f(x_0)\\) heisst \\((x_0, y_0)\\) heisst Maxiumum (relative) Maximalstelle (relatives) Maximum/Maximalwert (relativer) Hochpunkt Minimum (relative) Minimalstelle (relatives) Minimum/Minimalwert (relativer) Tiefpunkt Oberbegriff (relative) Extremalstelle (relatives) Extremum/Extremalwert (relativer) Extremalpunkt","title":"Extremwerte (ev. l\u00f6schen)"},{"location":"22FS/AN2/summary_2022_06_20.html#wendepunkte-und-sattelpunkte-ev-loschen","text":"Eine Wendepunkt, ist wenn eine Rechtskurve in eine Linkskurve, oder umgekehrt, geht. Ein Spezialfall ist es, wenn \\(f'(x)=0\\) ist, dann spricht man von einem Sattelpunkt . Wenn \\(f''(x_0)=0\\) und \\(f'''(x_0)\\neq 0\\) ist, dann ist es sicherlich einen Wendepunkt . Wenn zus\u00e4tzlich noch \\(f'(x_0)=0\\) gilt, dann ist es ein Sattelpunkt","title":"Wendepunkte und Sattelpunkte (ev. l\u00f6schen)"},{"location":"22FS/AN2/summary_2022_06_20.html#fragen-fur-die-kurvendiskussion-ev-loschen","text":"Definitionsbereich? Symmetrieeigenschaften (gerade/ungerade), Periode? Schnittpunkte mit Achsen, Polstellen? Randpunkte, bzw. Verhalten, wenn \\(x\\) gegen die Grenzen des Definitionsbereichs strebt? Kandidaten f\u00fcr Extrema bestimmen und untersuchen Wendepunkte suchen Tabelle von Werten aufstellen (falls noch n\u00f6tig)","title":"Fragen f\u00fcr die Kurvendiskussion (ev. l\u00f6schen)"},{"location":"22FS/AN2/summary_2022_06_20.html#extremaufgaben-ev-loschen","text":"Zielgr\u00f6sse identifizieren Unabh\u00e4ngige Variable identifizieren Definitionsbereich bestimmen Zielgr\u00f6sse als Funktion mit unabh\u00e4ngigen Variabeln als Argument ausdr\u00fccken Relative Maxima/Minima bestimmen; Randpunkte auch ber\u00fcrcksichtigen! Welche relative Extrema sind auch absolute?","title":"Extremaufgaben (ev. l\u00f6schen)"},{"location":"22FS/AN2/summary_2022_06_20.html#ableiten","text":"Name Formel \\(x^k=k\\cdot x^{k-1}\\) Faktorregel \\((c\\cdot f)'(x)=c\\cdot f'(x)\\) Summenregel \\((f+g)'(x)=f'(x)+g'(x)\\) Produktregel \\((u\\cdot v)'(x)=u'(x)\\cdot v(x)+u(x)\\cdot v'(x)\\) Quotientenregel \\((\\frac u v)'(x)=\\frac{u'(x)\\cdot v(x)-u(x)\\cdot v'(x)}{v(x)^2}\\) Kettenregel \\((F\\circ u)'(x)=F'(x)\\cdot u'(x)\\) sin \\(sin(x)'=cos(x)\\) cos \\(cos(x)'=-sin(x)\\) tan \\(\\tan(x)'=\\frac 1 v{\\cos^2(x)}\\) arcsin \\(\\arcsin(x)'=\\frac 1 {\\sqrt{1 - x^2}}\\) arccos \\(\\arccos(x)'=-\\frac 1 {\\sqrt{1-x^2}}\\) arctan \\(\\arctan(x)'=\\frac 1 {1+x^2}\\) \\(e^x\\) \\((e^x)'=e^x\\) \\((a^x)'\\) \\((a^x)'=a^x\\cdot \\ln(a)\\) \\(\\ln(x)'\\) \\(\\ln(x)'=\\frac 1 x\\) \\(\\log_a(x)'\\) \\(\\log_a(x)'=\\frac 1 {x\\cdot \\ln(a)}\\) Funktionsgleichung f\u00fcr Tangente \\(y(x)=f'(x_0)\\cdot (x-x_0)+f(x_0)\\) Achtung : Nicht jede Funktion ist differenzierbar. Die Ableitung einer Funktion darf keine pl\u00f6tzliche Spr\u00fcnge machen","title":"Ableiten"},{"location":"22FS/AN2/summary_2022_06_20.html#newton-verfahren","text":"\\(x_{n+1}=x_n-\\frac{f(x_n)}{f'(x_n)}\\)","title":"Newton Verfahren"},{"location":"22FS/AN2/summary_2022_06_20.html#integrieren","text":"Ableiten: \\(a\\cdot x^n\\rightarrow \\frac{a}{n+1}\\cdot x^{n+1}\\) Schreibweise von Integral von der Fl\u00e4che zwischen \\([a;b]\\) : \\(\\int^b_a f(x) \\mathrm d x =F(b)-F(a)\\) $ \\(\\int a^x \\mathrm d x =\\frac {a^x}{\\ln(a)} + C\\) \\(\\int e^{ax}=ae^{ax}\\) \\(\\int \\ln(x)\\mathrm dx=x\\cdot \\ln(x)-x + C\\) \\(\\int \\log_a(x)\\mathrm dx=\\frac 1 {\\ln(a)}\\cdot (x \\cdot \\ln(x) -x) + C\\) \\(\\int \\sin(x)\\mathrm dx=-\\cos(x)+C\\) \\(\\int \\cos(x)\\mathrm dx=\\sin(x)+C\\) \\(\\int \\tan(x)\\mathrm dx = -\\ln |\\cos(x)|+C\\) \\(\\int u^{-1}\\mathrm dx=\\ln(|u|)\\)","title":"Integrieren"},{"location":"22FS/AN2/summary_2022_06_20.html#substition","text":"Substitutionsgleichung f\u00fcr \\(x: u = g(x)\\) Substitionsgleichung f\u00fcr \\(\\mathrm dx: \\frac {\\mathrm du}{\\mathrm dx}=g'(x) \\Rightarrow \\mathrm dx = \\frac{\\mathrm du}{g'(x)}\\) Integralsubstition: \\(\\mathrm dx\\) und \\(x\\) durch \\(\\mathrm du\\) und \\(u\\) ersetzen (Es darf nach dem k\u00fcrzen kein \\(x\\) im Integral mehr haben) Integration: Bei bestimmten Integralen m\u00fcssen die Integralsgrenzen auch durch \\(u(x)\\) gelassen werden R\u00fccksubstition (nur bei unbestimmten Integralen): Alle \\(u\\) s m\u00fcssen durch \\(u(x)\\) ersetzt werden Wenn \\(u(x)\\) linear ist, kann der Satz \\(\\int f(ax + b)\\mathrm dx =\\frac 1 a\\cdot F(ax + b)\\) f\u00fcr das integrieren genutzt werden. (Dabei muss \\(f(x)\\) nicht gleich \\(u(x)\\) sein)","title":"Substition"},{"location":"22FS/AN2/summary_2022_06_20.html#partielle-integration","text":"\\(\\int u(x)\\cdot v'(x)\\mathrm dx = u(x)\\cdot v(x) - \\int u'(x)\\cdot v(x)\\mathrm dx\\) oder \\(\\int^b_a u(x)\\cdot v'(x)\\mathrm dx = \\left[u(x)\\cdot v(x)\\right]^b_a - \\int^b_a u'(x)\\cdot v(x)\\mathrm dx\\) \\(u(x)\\) muss einfach abgeleitet werden k\u00f6nnen und \\(v(x)\\) sollte nicht komplizierter in der Stammfunktion werden.","title":"Partielle-Integration"},{"location":"22FS/AN2/summary_2022_06_20.html#partielbruchzerlergung","text":"Es braucht ein Integral der Form \\(\\int \\frac {g(x)}{h(x)}\\mathrm dx=\\int f(x)\\mathrm dx\\) Nullstellen in \\(h(x)\\) bestimmen: Erraten, mit Hornerschema oder faktorisieren Jeder Nullstelle eine Summe von Br\u00fcchen zuweissen \\(x_1\\) ist eine einfache Nullstelle \\(\\rightarrow \\frac A {x-x_1}\\) \\(x_2\\) ist eine doppelte Nullstelle \\(\\rightarrow \\frac{B_1}{x-x_2}+\\frac{B_2}{(x-x_2)^2}\\) \\(x_3\\) ist eine r-fache Nullstelle \\(\\rightarrow \\frac {C_1}{x-x_3}+\\frac{C_2}{(x-x_3)^2}+...+\\frac{C_r}{(x-x_3)^r}\\) \\(f(x)\\) mit der Summe aller Partialbr\u00fcche gleichgesetzt Konstante ( \\(A_i\\) , \\(B_i\\) , \\(C_i\\) , ...) bestimmen Alle Partialbr\u00fcche auf den selben Nenner bringen. Da auf beiden Seiten derselbe Nenner steht, m\u00fcssen die Z\u00e4hler auch gleich sein F\u00fcr das Gleichungssystem der Z\u00e4hler die Nulstellen in \\(x\\) einsetzen Lineares Gleichungssystem l\u00f6sen Integrieren \\(\\int \\frac 1 {x-x_0}\\mathrm dx=\\ln\\vert x-x_0\\vert + C\\) \\(\\int \\frac 1 {(x-x_0)^2}\\mathrm dx=-\\frac 1 {1(x-x_0)}+C\\) \\(\\int \\frac 1 {(x-x_0)^3}\\mathrm dx=-\\frac 1 {2(x-x_0)^{2}}+C\\) \\(\\int \\frac 1 {(x-x_0)^r}\\mathrm dx=\\frac 1 {(1 - r)(x-x_0)^{r-1}}+C\\)","title":"Partielbruchzerlergung"},{"location":"22FS/AN2/summary_2022_06_20.html#uneigentliche-integrale","text":"\\(\\int ^\\infty_a f(x)\\mathrm dx = \\lim_{t\\to \\infty}\\int ^t_a f(x) \\mathrm dx=\\lim_{t\\to \\infty}F(t)-F(a)\\) Zuerst die Stammfunktion berechnen und danach \\(F(t)-F(a)\\) berechnen mit \\(t\\) nach \\(\\infty\\) gehen lassen \\(\\int^b_a f(x)\\mathrm dx=\\lim_{t \\to a} f(x)\\mathrm dx=\\lim_{t\\to a}F(b) - F(a)\\)","title":"Uneigentliche Integrale"},{"location":"22FS/AN2/summary_2022_06_20.html#differentialgleichungen","text":"Eine Funktion, in welcher die die gesuchte Funktion \\(f\\) und die Ableitung dieser Funktion \\(f'\\) Beispiel: \\(y'=0\\rightarrow y=c\\) \\(y'=y\\rightarrow y=c\\cdot e^x\\) \\(y'=7y\\rightarrow y=e^{7x}\\) Ordnung einer Ableitung ist die Ordnung der h\u00f6chsten vorkommenden Ableitung Die Partikul\u00e4re L\u00f6sung ? : Anfangsbedingungen: vorgegebene Werte f\u00fcr \\(y(x_0), y'(x_0),...,y^{(n-1)}(x_0)\\) Randbedinungen: vorgegebene Werte f\u00fcr \\(y(x_1), y(x_2),...,y(x_n)\\)","title":"Differentialgleichungen"},{"location":"22FS/AN2/summary_2022_06_20.html#gewohliche-differentialgleichung-1-ordnung","text":"\\(y'=F(x, y)\\)","title":"Gew\u00f6hliche Differentialgleichung 1. Ordnung"},{"location":"22FS/AN2/summary_2022_06_20.html#richtungsfeld","text":"","title":"Richtungsfeld"},{"location":"22FS/AN2/summary_2022_06_20.html#euler-schritte","text":"\\(x_n=x_{n-1}+h\\) und \\(y_n=y_{n-1}+h\\cdot F(x_{n-1}, y_{n-1})\\) Dabei ist \\(h\\) die Schrittgr\u00f6sse. Je kleiner, desto genauer ist die Approximation","title":"Euler-Schritte"},{"location":"22FS/AN2/summary_2022_06_20.html#separierbare-differentialgleichungen","text":"\\[ y'=f(x)\\cdot g(y) \\] Die Differentialgleichung darf umgeformt werden, damit sie in diese Form passt ( \\(x+y\\cdot y'=0 \\Rightarrow y\\cdot y'=-x\\Rightarrow y'=-x\\cdot \\frac 1 y\\) ) \\(y'=\\frac{\\mathrm dy}{\\mathrm dx}=f(x)\\cdot g(y)\\) Trennung der Variablen: \\(\\frac {\\mathrm dy}{g(y)}=f(x)\\cdot \\mathrm dx\\) Integration auf beiden Sieten( \\(+C\\) nicht vergessen): \\(\\int \\frac 1{g(y)}\\mathrm dy=\\int f(x)\\mathrm dx\\) Aufl\u00f6sen nach \\(y\\)","title":"Separierbare Differentialgleichungen"},{"location":"22FS/AN2/summary_2022_06_20.html#autonome-differentialgleichung","text":"\\[ y'=f(y) \\] Autonome Differentialgleichungen sind separierbar. autonom: \\(y'=y^2 + 6\\) \\(y'=y^2\\cdot \\sqrt{1 - \\sin(y)}-\\ln(y)\\) nicht autonom \\(y' = x + y\\) \\(y'=\\frac y x\\)","title":"Autonome Differentialgleichung"},{"location":"22FS/AN2/summary_2022_06_20.html#lineare-differentialgleichungen","text":"\\[ y'+f(x)\\cdot y=g(x) \\] \\(f(x)\\) und \\(g(x)\\) bestimmen Stammfunktion \\(F(x)\\) und \\(G(x)\\) bestimmen In die Formel \\(y_0=C\\cdot e^{-F(x)}\\) einsetzen \\(C\\) durch \\(K(x)\\) ersetzen: \\(y=K(x)\\cdot e^{-F(x)}\\) \\(K(x)\\) berechnen ( \\(+C\\) nicht vergessen): \\(K(x)=\\int g(x)\\cdot e^{F(x)}\\mathrm dx\\) Einstezen von \\(K(x)\\) in \\(y=K(x)\\cdot e^{-F(x)}\\)","title":"Lineare Differentialgleichungen"},{"location":"22FS/AN2/summary_2022_06_20.html#anwendung-von-integrale","text":"","title":"Anwendung von Integrale"},{"location":"22FS/AN2/summary_2022_06_20.html#mittelwert","text":"\\(\\mu=\\frac 1 {b - a}\\cdot \\int^b_a f(x)\\mathrm dx\\)","title":"Mittelwert"},{"location":"22FS/AN2/summary_2022_06_20.html#arbeitsintegral","text":"Die Formel f\u00fcr die Arbeit ist: \\(Arbeit=Kraft \\cdot Weg\\) . Somit kann mit der Funktion \\(f(x)\\) , welche die Kraft an einer Strecke zur\u00fcck gibt, integriert werden.","title":"Arbeitsintegral"},{"location":"22FS/AN2/summary_2022_06_20.html#rotationskorper","text":"$$ \\text{Horizontal: } & V=\\pi \\cdot \\int^b_a(f(x))^2\\mathrm dx\\ \\text{Vertikal: } & V=\\pi\\cdot \\int^d_c(g(y))^2 \\mathrm dx\\ \\text{wobei gilt: } &c \\le y \\le d \\text{ und } g(y)=x \\text{ ist die Umkehr-Funktion von } f(x) $$","title":"Rotationsk\u00f6rper"},{"location":"22FS/AN2/summary_2022_06_20.html#bogenlange","text":"$$ s=\\int^b_a\\sqrt{1+(y')^2}\\mathrm dx $$","title":"Bogenl\u00e4nge"},{"location":"22FS/AN2/summary_2022_06_20.html#mantelflache-eines-rotationskorpers","text":"\\[ M=2\\pi \\cdot \\int^b_a y\\cdot \\sqrt{1 + (y')^2}\\mathrm dx \\]","title":"Mantelfl\u00e4che eines Rotationsk\u00f6rpers"},{"location":"22FS/AN2/summary_2022_06_20.html#schwerpunkt-einer-flache-von-zwischen-zwei-kurven","text":"$$ x_s=&\\frac 1 A \\int^b_a x\\cdot (f_o(x) - f_u(x))\\mathrm dx\\ y_s=&\\frac 1 {2A}\\int^b_a(f^2_o(x)-f^2_u(x))\\mathrm dx $$","title":"Schwerpunkt einer Fl\u00e4che von zwischen zwei Kurven"},{"location":"22FS/AN2/summary_2022_06_20.html#schwerpunkt-eines-rotationoskorper","text":"$$ x_s=&\\frac \\pi V \\int^b_a x\\cdot f^2(x) \\mathrm dx\\ y_s=&0\\ z_s=&0 $$","title":"Schwerpunkt eines Rotationosk\u00f6rper"},{"location":"22FS/AN2/summary_2022_06_20.html#taylor-reihen","text":"\\[ p_n=\\sum^n_{k=0}\\frac{f^{(k)}(x_0)}{k!}\\cdot (x-x_0)^k \\] Funktion \\(x_0\\) Taylor-Reihe Radius \\(e^x\\) 0 \\(\\sum^\\infty_{k=0}\\frac {x^k}{k!}=1+x+\\frac {x^2} {2!} + \\frac{x^3}{3!}+...\\) \\(\\infty\\) \\(e^{-2x}\\) 0 \\(\\sum^\\infty_{k=0}\\frac{-x^{2k}}{k!}=1-x^2-\\frac {x^4}{2!} - \\frac{x^6}{3!}+...\\) \\(\\infty\\) \\(\\sin(x)\\) 0 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot\\frac{x^{2k+1}}{(2k+1)!}=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}\\) q \\(\\cos(x)\\) 0 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot \\frac{x^{2k}}{(2k)!}=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+...\\) \\(\\ln(x)\\) 1 \\(\\sum^\\infty_{k=0}(-1)^{k}\\cdot\\tfrac 1 {k+1}(x-1)^{k+1}=(x-1)-\\tfrac 1 2(x-1)^2+\\tfrac 1 3(x-1)^3-\\tfrac 1 4 (x-1)^4+...\\) \\(x^{-1}=\\frac 1 x\\) 1 \\(\\sum^\\infty_{k=0}(-1)^k\\cdot(x-1)^k=1-(x-1)+(x-1)^2-(x-1)^3+(x-1)^4-...\\)","title":"Taylor-Reihen"},{"location":"22FS/AN2/summary_2022_06_20.html#komposition","text":"\\[ T_{h,x_0}\\text{ bezeichnet die Taylor-Reihe von } h(x) \\text{ um } x_0\\\\ T_{g,f(x_0)}(f(x))=T_{g\\circ f),x_0}(x_0) \\] Beispiel: $$ f(x)=-x^2\\ g(x)=e^x\\ x_0=0\\ g(x)=e^2\\approx T_{g,0}(z)=1+z+\\frac {z^2}{2!}+\\frac{z^3}{3!}+...\\ g(f(x))=e^{-x^2}\\approx T_{(g\\circ f), x_0}=T_{g, f(x_0)}=1+(-x^2)+\\frac{(-x^2)^2}{2!} \\frac{(-x^2)^3}{3!}+...=1-x^2+\\frac{x^4}{2!}-\\frac{x^6}{3!}+... $$","title":"Komposition"},{"location":"22FS/AN2/summary_2022_06_20.html#konvergenz","text":"\\[ f(x)=\\sum^\\infty_{k=0}a_k(x-x_0)^k\\\\ r=\\lim_{k\\to\\infty}\\left\\vert\\frac{a_k}{a_{k+1}}\\right\\vert\\\\ x_1=\\vert x - x_0\\vert\\\\ x_2 = \\vert x + x_0\\vert \\] \\(r\\) ist der Radius um \\(x_0\\) , in welchem das Taylor-Polynom genau ist, wenn \\(k\\) gegen Unendlich geht. \\(x_1\\) und \\(x_2\\) stellen die \u00e4usserst m\u00f6glichsten Punkte, welche vom Taylor-Polynom genau bestimmt werden k\u00f6nnen.","title":"Konvergenz"},{"location":"22FS/AN2/summary_2022_06_20.html#hopital-regel","text":"\\[ \\lim_{x\\to x_0}\\frac{f(x)}{g(x)}=\\lim_{x\\to x_0}\\frac{f'(x)}{g'(x)} \\]","title":"Hopital-Regel"},{"location":"22FS/Communication2/01_Presentation.html","text":"Presentation Presentation Too Much Don't present too much Too Complex Don't present a topic too complex Fachtext Ziel-Publikum Struktur von anderen Fachtext \"kopieren\" present findings of the research topic Der Text soll informieren (nicht einen anderen Text kommentieren oder appellieren): Informieren mit Neigkeiten (nicht durch Strenge) Form: 5-10 seitigen Bericht mit Autorenangaben, Titel, Abstract Fachtext: kein \"man\" Umformung ins Passiv Umformung ins Ersatzpassiv Nominalsierung statt Verbalisierung Poster Example? Coaching about Presentation? The poster has to contain the most important information. The presentation should add something Important points: What is the goal/aim of the presentation? What is the take-home message? Call-To-Action in Presentation Reader should be able to absorbe the main content in 2 min 50% text - 50% images ratio clear structure (columns, circles, rectangles, ...) Poster Critic Plaza","title":"Presentation"},{"location":"22FS/Communication2/01_Presentation.html#presentation","text":"","title":"Presentation"},{"location":"22FS/Communication2/01_Presentation.html#presentation_1","text":"Too Much Don't present too much Too Complex Don't present a topic too complex","title":"Presentation"},{"location":"22FS/Communication2/01_Presentation.html#fachtext","text":"Ziel-Publikum Struktur von anderen Fachtext \"kopieren\" present findings of the research topic Der Text soll informieren (nicht einen anderen Text kommentieren oder appellieren): Informieren mit Neigkeiten (nicht durch Strenge) Form: 5-10 seitigen Bericht mit Autorenangaben, Titel, Abstract Fachtext: kein \"man\" Umformung ins Passiv Umformung ins Ersatzpassiv Nominalsierung statt Verbalisierung","title":"Fachtext"},{"location":"22FS/Communication2/01_Presentation.html#poster","text":"Example? Coaching about Presentation? The poster has to contain the most important information. The presentation should add something Important points: What is the goal/aim of the presentation? What is the take-home message? Call-To-Action in Presentation Reader should be able to absorbe the main content in 2 min 50% text - 50% images ratio clear structure (columns, circles, rectangles, ...) Poster Critic Plaza","title":"Poster"},{"location":"22FS/Communication2/Presentation_Script.html","text":"Presentation Script Welcome to my presentation about 5G's adaptive antennas. Today, nearly everybody has a cellphone. Using it in public to browse social media sites, like Twitter and Facebook, or watch a Video on Netflix or YouTube, is socially accepted and a common occurrence. Because of this increase in usage of cellular data, new standards were developed. From 2G to 3G, which allowed mobile users to browse the internet with acceptable loading times, to 4G, with which, the populous could watch videos on the go. The most recent standard is 5G, which boasts up to 10Gbit/s in an optimal situation. As you can see on this graph, the data rates have increased exponentially. All of these standards are full duplex systems, meaning a device can send and receive simultaneously. As a side note: The maximum speed of 5G in Switzerland is lower than the theoretical maximum, which can also be seen on the graph. This is because the higher frequency bands used in other countries aren't permitted for use with 5G in Switzerland. Using a higher frequency band yields increased the speed, but comes at the cost of range. With the need for more speed, data through-put and broader coverage, its tempting to let the the antennas send with more power. But this would cause higher radiation levels for people around the antenna and wasting energy by blasting electromagnetic radiation everywhere instead of just the device of the user. The solution to these problems are adaptive antennas which can, thanks to multiple subarrays, steer their beam towards the receiving device. This enables operating these antennas at a higher power level but with similar radiation levels resulting in better coverage, higher data rates and improved energy efficiency. However, in Switzerland the law did not distinguish between \"normal\" antennas and adaptive antennas. To remedy this, the Swiss government instructed the BAFU to research adaptive antennas and find a correction factor which can be applied to the power level of an antenna. This would enable the antenna to send at a higher power level as the actual power level is corrected to a lower level while simultaneously reducing the consumed energy. Because the maximal power level is multiplied with a correction factor, the law which specifies the maximum permitted energy levels does not need to be modified, which should help these laws getting through parlament. As you can see in this graph, the more sub-arrays an antenna has, the lower the correction factor gets. This is because as the number of sub-arrays increases the amount of control over the direction of the beam becomes more accurate, resulting in lower radiation levels. The correction factor is between 0.4 and 0.1. Because the power level is multiplied with a number between one and zero, the result will be less then the original power level. To address the safety of these antennas, an automated limiter needs to be installed which will reduce the power level if it is too higher over a span of 6 minute. This will ensure that the radiation threshold isn't exceeded by an antenna. Another important detail of the provision specifies that applying the correction factor to an already existing antenna doesn't count as modifying the antenna resulting in hopefully lower administrative burden. An other obstacle towards adaptive antennas comes from the federalistic structure of the Swiss government. Each canton has its own law regarding the accepted radiation level of antennas and how companies apply for building and changing antennas. The report does lay the legal foundation to allow the cantons to change their law without fearing legal repercussion. With the hype around 5G, companies, like Swisscom, are anxious to build new antennas and will surly pressure the cantons to hurry up with these laws, however law-makers aren't known the be rapid. To monitor how effective these antennas are, the BAFU started to monitor the electromagnetic pollution and will publish a report later in 2022. It will be interesting to see, if the electromagnetic pollution will stay stable at the current level or will increase.","title":"Presentation Script"},{"location":"22FS/Communication2/Presentation_Script.html#presentation-script","text":"Welcome to my presentation about 5G's adaptive antennas. Today, nearly everybody has a cellphone. Using it in public to browse social media sites, like Twitter and Facebook, or watch a Video on Netflix or YouTube, is socially accepted and a common occurrence. Because of this increase in usage of cellular data, new standards were developed. From 2G to 3G, which allowed mobile users to browse the internet with acceptable loading times, to 4G, with which, the populous could watch videos on the go. The most recent standard is 5G, which boasts up to 10Gbit/s in an optimal situation. As you can see on this graph, the data rates have increased exponentially. All of these standards are full duplex systems, meaning a device can send and receive simultaneously. As a side note: The maximum speed of 5G in Switzerland is lower than the theoretical maximum, which can also be seen on the graph. This is because the higher frequency bands used in other countries aren't permitted for use with 5G in Switzerland. Using a higher frequency band yields increased the speed, but comes at the cost of range. With the need for more speed, data through-put and broader coverage, its tempting to let the the antennas send with more power. But this would cause higher radiation levels for people around the antenna and wasting energy by blasting electromagnetic radiation everywhere instead of just the device of the user. The solution to these problems are adaptive antennas which can, thanks to multiple subarrays, steer their beam towards the receiving device. This enables operating these antennas at a higher power level but with similar radiation levels resulting in better coverage, higher data rates and improved energy efficiency. However, in Switzerland the law did not distinguish between \"normal\" antennas and adaptive antennas. To remedy this, the Swiss government instructed the BAFU to research adaptive antennas and find a correction factor which can be applied to the power level of an antenna. This would enable the antenna to send at a higher power level as the actual power level is corrected to a lower level while simultaneously reducing the consumed energy. Because the maximal power level is multiplied with a correction factor, the law which specifies the maximum permitted energy levels does not need to be modified, which should help these laws getting through parlament. As you can see in this graph, the more sub-arrays an antenna has, the lower the correction factor gets. This is because as the number of sub-arrays increases the amount of control over the direction of the beam becomes more accurate, resulting in lower radiation levels. The correction factor is between 0.4 and 0.1. Because the power level is multiplied with a number between one and zero, the result will be less then the original power level. To address the safety of these antennas, an automated limiter needs to be installed which will reduce the power level if it is too higher over a span of 6 minute. This will ensure that the radiation threshold isn't exceeded by an antenna. Another important detail of the provision specifies that applying the correction factor to an already existing antenna doesn't count as modifying the antenna resulting in hopefully lower administrative burden. An other obstacle towards adaptive antennas comes from the federalistic structure of the Swiss government. Each canton has its own law regarding the accepted radiation level of antennas and how companies apply for building and changing antennas. The report does lay the legal foundation to allow the cantons to change their law without fearing legal repercussion. With the hype around 5G, companies, like Swisscom, are anxious to build new antennas and will surly pressure the cantons to hurry up with these laws, however law-makers aren't known the be rapid. To monitor how effective these antennas are, the BAFU started to monitor the electromagnetic pollution and will publish a report later in 2022. It will be interesting to see, if the electromagnetic pollution will stay stable at the current level or will increase.","title":"Presentation Script"},{"location":"22FS/KT/00_Glossar.html","text":"Glossar Begriff Definition Protokoll Definiert, wie Daten versendet werden Dienst Etwas, was eine Schicht, der n\u00e4chst h\u00f6hreren Schicht anbietet. Schittstelle SAP Service Application Point = eine Schnittstelle Schicht Peer-To-Peer Wenn zwei Ger\u00e4te direkt miteinander verbunden sind Shared-Medium Wenn mehrere Ger\u00e4te miteinander verbunden sind Simplex Die Kommunikation funktioniert nur in eine Richtung Half-Duplex Es kann Empfangen und Gesendet werden, aber nicht beides gleichzeitig Full-Duplex Es kann Empfangen und Gesendet weden zur selben Zeit","title":"Glossar"},{"location":"22FS/KT/00_Glossar.html#glossar","text":"Begriff Definition Protokoll Definiert, wie Daten versendet werden Dienst Etwas, was eine Schicht, der n\u00e4chst h\u00f6hreren Schicht anbietet. Schittstelle SAP Service Application Point = eine Schnittstelle Schicht Peer-To-Peer Wenn zwei Ger\u00e4te direkt miteinander verbunden sind Shared-Medium Wenn mehrere Ger\u00e4te miteinander verbunden sind Simplex Die Kommunikation funktioniert nur in eine Richtung Half-Duplex Es kann Empfangen und Gesendet werden, aber nicht beides gleichzeitig Full-Duplex Es kann Empfangen und Gesendet weden zur selben Zeit","title":"Glossar"},{"location":"22FS/KT/01_OSI-Modell.html","text":"OSI-Modell Die Schicht \\(i-1\\) bietet der h\u00f6hreren Schicht \\(i\\) einen Dienst an, w\u00e4hrend die Schicht \\(i\\) eine Schnittstellen oder Service Access Protocol (SAP) implementiert. Wenn sich die Schnittstelle/Dienst \u00e4ndert, hat dies auswirkungen auf die Schichten darum herum. Das Protokoll einer Schicht kann allerdings ge\u00e4ndert werden, da dies nur von derselben Schicht bei der anderen Anwendung ben\u00fctzt wird. Ein Protokol legt das Format und die Bedeugng von Nachrichten, welche zwischen denselben Schichten ausgetauscht werden. Die Schicht 1-4 wird \u00fcbllicherweisse vom OS abgedeckt. Die Schichten 5-7 werden oft zusammen gefasst als eine. Daten werden von jeder Schicht bearbeitet und an die n\u00e4chste Schicht weitergegeben. Wenn ein Packet verschickt wird, werden die Daten zuerst vom Layer 7 zum Layer 1 verpackt und beim Empf\u00e4nger vom Layer 1 wird bis zum Layer 7 enpackt. Veschiedene Protokolle weden in verschiedene Layers eingeteilt. Unten folgt ein Bild mit den meist verwendeten Protokolle. Physical Layer (Bit\u00fcbertragungsschicht) Das physikalische Medium, was die Ger\u00e4te verbindet. Dies kann ausgetauscht werden und die anderen Schichten bleiben umbetroffen. Data Link Layer (Sicherungsschicht) Stellt eine sichere Verbindung den h\u00f6hreren Schichten zu verf\u00fcgung. Dieser Layer muss folgendes sicherstellen: sichere Verbindung zwischen zwei Punkten. Daf\u00fcr braucht es Massnahmen zur Fehlererkennung und Fehlerkorrektur Framing bzw. Datenbl\u00f6cke vom Network Layer werden verpackt, um die Funktionalit\u00e4t des Layers sicherzustellen Fluss-Steuerung, dass der Sender nicht schneller sendet, als es der Empf\u00e4nger verstehen kann Wenn an das \u00dcbertragungsmedium mehr als zwei Teilnehmer angeschlossen sind, muss der Layer zus\u00e4tzlich auch noch: Jeder Teilnehmer adressieren. Hierbei werden die MAC-Adressen verwenden (IP-Adressen werden vom Layer 3 verwendet) Steuerung des Zugriffs auf das Medium. Wenn mehrere Teilnehmer auf das Medium zugreifen k\u00f6nnen, muss definiert werden, wann, wer darf. Kommunikations-Art Je nachdem wie das \u00dcbertragungsmedium aufgebaut ist, ist die Art der Kommunikation verschieden: Simples: Es ist nur einen Kanal in eine Richtung vorhanden (Radio, TV) Half-Duplex: Es ist nur ein Kanal vorhanden. Dieser wird aber abwechslungsweise genutzt (einfaches Funkger\u00e4t) Full-Duplex: Es sind f\u00fcr beide Richtungen ein Kanal vorhanden (Telefon) Network Layer (Vermittlungsschicht) Dieser Layer stellt sicher, dass das Packet vom Sender zum Empf\u00e4nger durch ein Netzwerk von Konten gesendet werden. Daf\u00fcr gibt es eine netzweite eindeutige Layer 3 Adressierung (IPv4 oder IPv6 im Fall des IP-Protokolls), wie auch ein Verfahren, mit welchem eine Route durchs Netzwerk gefunden wird. Verbindungsorientierter Dienst In einem verbindungsoritentierem Netzwerk Layer wird eine Verbindung f\u00fcr ein (oder mehrere) Packete aufgebaut. Durch diese Verbindung k\u00f6nnen Daten gesendet werden, welche in derselben Reihenfolge ankommen, wie sie gesendet werden. Nach dem alle Daten gesendet wurden, muss die Verbindung wieder abgebaut werden. Um dies zu bewerkstelligen kann jedes Paket mit einer Verbindungs-Nummer ausgestattet werden. Anhand dieser, wissen die Knoten im Netzwerk zu welcher Verbindung das Paket geh\u00f6rt und wohin es gesendet werden muss. Es gibt Verbindungen, welche permantent stehen. Diese werden Permanent Virtual Circuit (PVC) genannt. Eine Verbindung, welche jedes mal aufgebaut und danach abgebaut wird, nennt sich Switched Virtual Circuits (SVC). Diese Art von Dienst wird bei Provider Backbones mit dem Multi Protocol Label Switching (MPLS) Protkoll verwendet. Fragen Wie wird diese Pfad gefunden? Verbindungsloser Dienst Bei einem verbindungsloser Dienst wird die Zieladresse mit jedem Paket mit geschickt. Wie bei z.B. der Post gibt es keine Garantie in welcher Reihenfolge die Pakete ankommen. Jeder Knoten im Netzwerk muss das Netzwerk verstehen und wissen, wohin ein Paket gesendet werden muss, damit es beim Empf\u00e4nger ankommt. Daf\u00fcr gibt es Routing-Tables, in welchen diese Informationen stehen. Wenn sich das Netzwerk \u00e4ndert, kann es sein, dass ein Paket ein anderen Weg zum Ziel nimmt. Ein typisches Beispiel ist das IP-Protokoll. Vorteile und Nachteile Bei einem verbindungsorientiertem Dienst muss zuerst eine Verbindung aufgebaut werden, w\u00e4hrend bei einem verbindungsloser Dienst spontan ein Paket gesendet werden kann Da eine Verbindung bei einem verbindungsorientiertem Dienst aufgebaut wird, k\u00f6nnen geforderte Eigenschaften, wie Latenz oder Durchsatz, eingehalten werden. Bei einem verbindungslosem Dienst k\u00f6nnen diese Eigenschaften von Paket zu Paket anders sein. Verbindungsorienterte Dienste k\u00f6nnen Verkehrsstr\u00f6me gezielt lenken und so das Netzwerk verteilter auslasten Verbindslose Dienste k\u00f6nnen von selbst eine andere Route ben\u00fctzten, wenn eine Route ausgelastet oder unterbrochen ist Die Reihenfolge muss bei einem Verbindungslosem Dienst durch den Transport Layer sicher gestellt werden. Transport Layer (Transportschicht) Die Aufgabe des Transport Layers ist es, die ben\u00f6tigte Qualit\u00e4t des Netzwerks sicher zu stellen. Wenn die Layer 1-3 unzuverl\u00e4ssig arbeiten, muss der Transport Layer diese Zuverl\u00e4ssigkeit wiederherstellen. Wenn die Reihenfolge darauf ankommt und dies nicht von den unteren Layers sichergestellt wird, dann wird dies zur Aufgabe des Transport Layers. Das heisst auch, dass der Transport Layer auf die unteren und oberen Schichten abgestimmt werden muss. Im Transport Layer gibt es nur noch der Sender und den Empf\u00e4nger. Die weiteren Konten werden von den Layers 1-3 abstrahiert und werden daher von dem Transport Layer nicht mehr ben\u00f6tigt. Zwei wichtige Layer 4 Protokolle sind User Data Protocol (UDP), welches ein verbindungsloser, unsicherer Dienst sicherstellt und das Transmission Control Protocol (TCP), welches eine verbindungsorientierter sicherer Dienst sicherstellt. Session Layer (Kommunikationsschicht) Der Session Layer stellt eine sichere Verbindung bereit. Wenn der Transport Layer zusammen bricht, ist es die Aufgabe des Session Layers, diese Verbinung wieder aufzubauen und es f\u00fcr die Layers weiter oben, so auszusehen zu lassen, als ob nichts passiert w\u00e4re. Presentation Layer (Darstellungsschicht) Die Aufgabe des Presentations Layers ist es, die Informationen des Applikations Layers in eine neutrale Form zu bringen. Ein Beispiel w\u00e4re Unicode oder ASCII. Applikations Layer (Verarbeitungsschicht) Der Applikations Layer ist das Bindeglied zwischen dem Netzwerk und der Anwendung. Beispiele w\u00e4ren: File Transfer Protocol (FTP) Simple Mail Transfer Protocol (SMTP) Hyper Text Transport Protocol (HTTP) Domain Name System (DNS)","title":"OSI-Modell"},{"location":"22FS/KT/01_OSI-Modell.html#osi-modell","text":"Die Schicht \\(i-1\\) bietet der h\u00f6hreren Schicht \\(i\\) einen Dienst an, w\u00e4hrend die Schicht \\(i\\) eine Schnittstellen oder Service Access Protocol (SAP) implementiert. Wenn sich die Schnittstelle/Dienst \u00e4ndert, hat dies auswirkungen auf die Schichten darum herum. Das Protokoll einer Schicht kann allerdings ge\u00e4ndert werden, da dies nur von derselben Schicht bei der anderen Anwendung ben\u00fctzt wird. Ein Protokol legt das Format und die Bedeugng von Nachrichten, welche zwischen denselben Schichten ausgetauscht werden. Die Schicht 1-4 wird \u00fcbllicherweisse vom OS abgedeckt. Die Schichten 5-7 werden oft zusammen gefasst als eine. Daten werden von jeder Schicht bearbeitet und an die n\u00e4chste Schicht weitergegeben. Wenn ein Packet verschickt wird, werden die Daten zuerst vom Layer 7 zum Layer 1 verpackt und beim Empf\u00e4nger vom Layer 1 wird bis zum Layer 7 enpackt. Veschiedene Protokolle weden in verschiedene Layers eingeteilt. Unten folgt ein Bild mit den meist verwendeten Protokolle.","title":"OSI-Modell"},{"location":"22FS/KT/01_OSI-Modell.html#physical-layer-bitubertragungsschicht","text":"Das physikalische Medium, was die Ger\u00e4te verbindet. Dies kann ausgetauscht werden und die anderen Schichten bleiben umbetroffen.","title":"Physical Layer (Bit\u00fcbertragungsschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#data-link-layer-sicherungsschicht","text":"Stellt eine sichere Verbindung den h\u00f6hreren Schichten zu verf\u00fcgung. Dieser Layer muss folgendes sicherstellen: sichere Verbindung zwischen zwei Punkten. Daf\u00fcr braucht es Massnahmen zur Fehlererkennung und Fehlerkorrektur Framing bzw. Datenbl\u00f6cke vom Network Layer werden verpackt, um die Funktionalit\u00e4t des Layers sicherzustellen Fluss-Steuerung, dass der Sender nicht schneller sendet, als es der Empf\u00e4nger verstehen kann Wenn an das \u00dcbertragungsmedium mehr als zwei Teilnehmer angeschlossen sind, muss der Layer zus\u00e4tzlich auch noch: Jeder Teilnehmer adressieren. Hierbei werden die MAC-Adressen verwenden (IP-Adressen werden vom Layer 3 verwendet) Steuerung des Zugriffs auf das Medium. Wenn mehrere Teilnehmer auf das Medium zugreifen k\u00f6nnen, muss definiert werden, wann, wer darf.","title":"Data Link Layer (Sicherungsschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#kommunikations-art","text":"Je nachdem wie das \u00dcbertragungsmedium aufgebaut ist, ist die Art der Kommunikation verschieden: Simples: Es ist nur einen Kanal in eine Richtung vorhanden (Radio, TV) Half-Duplex: Es ist nur ein Kanal vorhanden. Dieser wird aber abwechslungsweise genutzt (einfaches Funkger\u00e4t) Full-Duplex: Es sind f\u00fcr beide Richtungen ein Kanal vorhanden (Telefon)","title":"Kommunikations-Art"},{"location":"22FS/KT/01_OSI-Modell.html#network-layer-vermittlungsschicht","text":"Dieser Layer stellt sicher, dass das Packet vom Sender zum Empf\u00e4nger durch ein Netzwerk von Konten gesendet werden. Daf\u00fcr gibt es eine netzweite eindeutige Layer 3 Adressierung (IPv4 oder IPv6 im Fall des IP-Protokolls), wie auch ein Verfahren, mit welchem eine Route durchs Netzwerk gefunden wird.","title":"Network Layer (Vermittlungsschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#verbindungsorientierter-dienst","text":"In einem verbindungsoritentierem Netzwerk Layer wird eine Verbindung f\u00fcr ein (oder mehrere) Packete aufgebaut. Durch diese Verbindung k\u00f6nnen Daten gesendet werden, welche in derselben Reihenfolge ankommen, wie sie gesendet werden. Nach dem alle Daten gesendet wurden, muss die Verbindung wieder abgebaut werden. Um dies zu bewerkstelligen kann jedes Paket mit einer Verbindungs-Nummer ausgestattet werden. Anhand dieser, wissen die Knoten im Netzwerk zu welcher Verbindung das Paket geh\u00f6rt und wohin es gesendet werden muss. Es gibt Verbindungen, welche permantent stehen. Diese werden Permanent Virtual Circuit (PVC) genannt. Eine Verbindung, welche jedes mal aufgebaut und danach abgebaut wird, nennt sich Switched Virtual Circuits (SVC). Diese Art von Dienst wird bei Provider Backbones mit dem Multi Protocol Label Switching (MPLS) Protkoll verwendet.","title":"Verbindungsorientierter Dienst"},{"location":"22FS/KT/01_OSI-Modell.html#fragen","text":"Wie wird diese Pfad gefunden?","title":"Fragen"},{"location":"22FS/KT/01_OSI-Modell.html#verbindungsloser-dienst","text":"Bei einem verbindungsloser Dienst wird die Zieladresse mit jedem Paket mit geschickt. Wie bei z.B. der Post gibt es keine Garantie in welcher Reihenfolge die Pakete ankommen. Jeder Knoten im Netzwerk muss das Netzwerk verstehen und wissen, wohin ein Paket gesendet werden muss, damit es beim Empf\u00e4nger ankommt. Daf\u00fcr gibt es Routing-Tables, in welchen diese Informationen stehen. Wenn sich das Netzwerk \u00e4ndert, kann es sein, dass ein Paket ein anderen Weg zum Ziel nimmt. Ein typisches Beispiel ist das IP-Protokoll.","title":"Verbindungsloser Dienst"},{"location":"22FS/KT/01_OSI-Modell.html#vorteile-und-nachteile","text":"Bei einem verbindungsorientiertem Dienst muss zuerst eine Verbindung aufgebaut werden, w\u00e4hrend bei einem verbindungsloser Dienst spontan ein Paket gesendet werden kann Da eine Verbindung bei einem verbindungsorientiertem Dienst aufgebaut wird, k\u00f6nnen geforderte Eigenschaften, wie Latenz oder Durchsatz, eingehalten werden. Bei einem verbindungslosem Dienst k\u00f6nnen diese Eigenschaften von Paket zu Paket anders sein. Verbindungsorienterte Dienste k\u00f6nnen Verkehrsstr\u00f6me gezielt lenken und so das Netzwerk verteilter auslasten Verbindslose Dienste k\u00f6nnen von selbst eine andere Route ben\u00fctzten, wenn eine Route ausgelastet oder unterbrochen ist Die Reihenfolge muss bei einem Verbindungslosem Dienst durch den Transport Layer sicher gestellt werden.","title":"Vorteile und Nachteile"},{"location":"22FS/KT/01_OSI-Modell.html#transport-layer-transportschicht","text":"Die Aufgabe des Transport Layers ist es, die ben\u00f6tigte Qualit\u00e4t des Netzwerks sicher zu stellen. Wenn die Layer 1-3 unzuverl\u00e4ssig arbeiten, muss der Transport Layer diese Zuverl\u00e4ssigkeit wiederherstellen. Wenn die Reihenfolge darauf ankommt und dies nicht von den unteren Layers sichergestellt wird, dann wird dies zur Aufgabe des Transport Layers. Das heisst auch, dass der Transport Layer auf die unteren und oberen Schichten abgestimmt werden muss. Im Transport Layer gibt es nur noch der Sender und den Empf\u00e4nger. Die weiteren Konten werden von den Layers 1-3 abstrahiert und werden daher von dem Transport Layer nicht mehr ben\u00f6tigt. Zwei wichtige Layer 4 Protokolle sind User Data Protocol (UDP), welches ein verbindungsloser, unsicherer Dienst sicherstellt und das Transmission Control Protocol (TCP), welches eine verbindungsorientierter sicherer Dienst sicherstellt.","title":"Transport Layer (Transportschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#session-layer-kommunikationsschicht","text":"Der Session Layer stellt eine sichere Verbindung bereit. Wenn der Transport Layer zusammen bricht, ist es die Aufgabe des Session Layers, diese Verbinung wieder aufzubauen und es f\u00fcr die Layers weiter oben, so auszusehen zu lassen, als ob nichts passiert w\u00e4re.","title":"Session Layer (Kommunikationsschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#presentation-layer-darstellungsschicht","text":"Die Aufgabe des Presentations Layers ist es, die Informationen des Applikations Layers in eine neutrale Form zu bringen. Ein Beispiel w\u00e4re Unicode oder ASCII.","title":"Presentation Layer (Darstellungsschicht)"},{"location":"22FS/KT/01_OSI-Modell.html#applikations-layer-verarbeitungsschicht","text":"Der Applikations Layer ist das Bindeglied zwischen dem Netzwerk und der Anwendung. Beispiele w\u00e4ren: File Transfer Protocol (FTP) Simple Mail Transfer Protocol (SMTP) Hyper Text Transport Protocol (HTTP) Domain Name System (DNS)","title":"Applikations Layer (Verarbeitungsschicht)"},{"location":"22FS/KT/02_Serielle-%C3%9Cbertragung.html","text":"","title":"02 Serielle \u00dcbertragung"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html","text":"\u00dcbertragungsmedien (Layer 1) Begriff Erkl\u00e4rung Freiraum \u00dcbertragung Medien, wie WLAN, 5G, welche ohne Kabel \u00fcbertragen symmetrische Leiter Twinax verdrillte Kupferader assymetrisch Physik - Ausbreitungsgeswindigkeit Die Lichtgeschwindigkeit im Glas mit dem Brechungsindex \\(n=1.5\\) ist: \\(c_{Glass}=\\frac{c_0}{n}=\\frac{299'792'458}{1.5}\\approx200'000\\frac{km} s\\) In einem elektrischen Leiter ist es ebenfalls \\(200'000\\frac{km}s\\) Signald\u00e4mpfung Wie viel Leistung (in Dezibel) geht auf dem Weg zwischen \\(U_1\\) und \\(U_2\\) verloren. Die D\u00e4mpfung ist \\(10\\cdot \\log(\\frac {P1}{P2})\\) . Dabei ist \\(P1\\) die Eingangsleistung und \\(P2\\) die Ausgangsleistung. Dies kann auch als \\(Signald\u00e4mpfung [dB] = 20\\cdot \\log(\\frac{U1}{U2})\\) , wobei \\(U1\\) die Eingangs- und \\(U2\\) die Ausgangsleistung ist. Ebenfalls gilt \\(\\frac{P1}{P2}=\\left(\\frac{U1}{U2}\\right)^2\\) CAT-Kabel Bei \u00dcbertragungsmedien wird die Signald\u00e4mpfung meistens in \\(\\left[\\frac{dB}{100m}\\right]\\) oder \\(\\left[\\frac{dB}{km}\\right]\\) angegben. Diese Gr\u00f6sse wird D\u00e4mpfungsbelag genannt. Bezeichung Frequenzberreich Erkl\u00f6rung CAT-1-4 0.4/4/16/20 MHz F\u00fcr Telefone und Modemleitungen oder langsames LAN CAT-5 100 MHz Weitverbreitet. Erlaubt eine max. Bitrate von 1000Mbit/s bis zu 100m CAT-6 250 MHz Wird meistens f\u00fcr Gigabit (1000 Mbit/s) ben\u00fctzt CAT-7 600 MHz Geeigent f\u00fcr 10 Gigabit. Es werden aber S/FTP Kabel ben\u00f6tigt CAT-8 2000 MHz Datenraten bis 40 Gigabit bis zu 30m Signal-Noise Nach einer gewissen Zeit nimmt die Signalst\u00e4rke ab Kabel-Arten Koaxialkabel Ein Koaxialkabel besteht aus einem Leiter. Sie sind geeignet f\u00fcr hochfrequente Signale und haben im Vergleich mit paarsymmetrischen Kabel einen kleinen D\u00e4mpfungsbelag und sind unempfindlicher gegen\u00fcber elektromagnetischen St\u00f6rungen. Die Kabel sind daf\u00fcr relativ empfindlich. Paarsymmetrische Kabel (Twisted Pair) Bei paarsymmetrischen Kabeln wird zwischen geschirmten Kabeln (Shielded Twisted Pair/STP) und ungeschirmten Kabeln (Unshielded Twisted Pair/UTP) unterschieden. Geschirmte Kabel sind st\u00f6rsicherer, aber auch teurer, schwerer und steifer. Das Namensschema von Twisted Pairs ist wie folgt: \\(xx/y\\text{TP}\\) (Beispiel: U/UTP, S/UTP, ...) Werte f\u00fcr \\(xx\\) Werte f\u00fcr \\(y\\) Erkl\u00e4rung U U ungeschirmt F F Folienschirm S S Geflechtschirm SF <gibt es nicht> Schirm aus Geflecht und Folie Schirme funktionieren nur, wenn sie gut geerdet sind! Twisted pair und St\u00f6rungen Zwei Leitungen, welche parallel gef\u00fchrt werden, verhalten sich, wie Sender und Empf\u00e4nger . Dies kann minimiert werden, in dem auf zwei Leitungen ein komplement\u00e4res Signal gesendet wird. Der Empf\u00e4nger kann danach die zwei Leitungen zusammen rechnen, und die herauskommende Spannung ist das St\u00f6rsignal. Wenn ein Magnetfeld eine St\u00f6rung induziert (Induktiver Effekt), wirkt sich diese auf die beide Leiter umgekehrt aus. Aus diesem Grund werden die Kabel verdreht. Dadurch entstehen kleinere Schleifen und in der benachbarten Schleife ist die St\u00f6rung verkehrt, was die St\u00f6rung gr\u00f6sstenteils aufhebt. Glassfaser Glassfaser-Kabel funktionieren dank der totalen Reflektio. Dispersion Es wird von Dispersion gesprochen, wenn das Signal verzert und nicht mehr erkannt wird. Es gibt mehrere Ursachen daf\u00fcr, die offensichtlichste die Modendispersion. Dies passiert, da unterschiedliche Lichtstrahlen einen k\u00fcrzeren oder l\u00e4ngeren Weg (je nachdem wie sie vom Kabel abprallen) haben und so zu verschiedenen Zeiten ankommen. Dieses wird auch Delay Skew genannt. Bei zu hoher Distanz oder zu hoher Pulsdichte kann dies zu Problemem f\u00fchren. Stufenfaser Kann mit einfachen Leuchtdioten angesprochen werden, hat aber viel Dispersion und Delay Skew (50 ns/km) Gradientenfasern Der \u00dcbergang zwischen Glaskern und Schirmung ist ein Verlauf. Dies bewirkt, dass die Moden mit dem k\u00fcrzesten Weg gebremst werden und sie gleichzeitig mit den L\u00e4ngeren ankommen. Gradientenfasern haben eine Delay Skew von ca. 0.5ns/km Monomode-Faser Es werden Laser-Dioden ben\u00f6tigt, da die Faser zu d\u00fcnn ist f\u00fcr eine Lichtdiode. Dies macht die Monomode-Fasern auch teuer.","title":"\u00dcbertragungsmedien (Layer 1)"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#ubertragungsmedien-layer-1","text":"Begriff Erkl\u00e4rung Freiraum \u00dcbertragung Medien, wie WLAN, 5G, welche ohne Kabel \u00fcbertragen symmetrische Leiter Twinax verdrillte Kupferader assymetrisch","title":"\u00dcbertragungsmedien (Layer 1)"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#physik-ausbreitungsgeswindigkeit","text":"Die Lichtgeschwindigkeit im Glas mit dem Brechungsindex \\(n=1.5\\) ist: \\(c_{Glass}=\\frac{c_0}{n}=\\frac{299'792'458}{1.5}\\approx200'000\\frac{km} s\\) In einem elektrischen Leiter ist es ebenfalls \\(200'000\\frac{km}s\\)","title":"Physik - Ausbreitungsgeswindigkeit"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#signaldampfung","text":"Wie viel Leistung (in Dezibel) geht auf dem Weg zwischen \\(U_1\\) und \\(U_2\\) verloren. Die D\u00e4mpfung ist \\(10\\cdot \\log(\\frac {P1}{P2})\\) . Dabei ist \\(P1\\) die Eingangsleistung und \\(P2\\) die Ausgangsleistung. Dies kann auch als \\(Signald\u00e4mpfung [dB] = 20\\cdot \\log(\\frac{U1}{U2})\\) , wobei \\(U1\\) die Eingangs- und \\(U2\\) die Ausgangsleistung ist. Ebenfalls gilt \\(\\frac{P1}{P2}=\\left(\\frac{U1}{U2}\\right)^2\\)","title":"Signald\u00e4mpfung"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#cat-kabel","text":"Bei \u00dcbertragungsmedien wird die Signald\u00e4mpfung meistens in \\(\\left[\\frac{dB}{100m}\\right]\\) oder \\(\\left[\\frac{dB}{km}\\right]\\) angegben. Diese Gr\u00f6sse wird D\u00e4mpfungsbelag genannt. Bezeichung Frequenzberreich Erkl\u00f6rung CAT-1-4 0.4/4/16/20 MHz F\u00fcr Telefone und Modemleitungen oder langsames LAN CAT-5 100 MHz Weitverbreitet. Erlaubt eine max. Bitrate von 1000Mbit/s bis zu 100m CAT-6 250 MHz Wird meistens f\u00fcr Gigabit (1000 Mbit/s) ben\u00fctzt CAT-7 600 MHz Geeigent f\u00fcr 10 Gigabit. Es werden aber S/FTP Kabel ben\u00f6tigt CAT-8 2000 MHz Datenraten bis 40 Gigabit bis zu 30m","title":"CAT-Kabel"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#signal-noise","text":"Nach einer gewissen Zeit nimmt die Signalst\u00e4rke ab","title":"Signal-Noise"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#kabel-arten","text":"","title":"Kabel-Arten"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#koaxialkabel","text":"Ein Koaxialkabel besteht aus einem Leiter. Sie sind geeignet f\u00fcr hochfrequente Signale und haben im Vergleich mit paarsymmetrischen Kabel einen kleinen D\u00e4mpfungsbelag und sind unempfindlicher gegen\u00fcber elektromagnetischen St\u00f6rungen. Die Kabel sind daf\u00fcr relativ empfindlich.","title":"Koaxialkabel"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#paarsymmetrische-kabel-twisted-pair","text":"Bei paarsymmetrischen Kabeln wird zwischen geschirmten Kabeln (Shielded Twisted Pair/STP) und ungeschirmten Kabeln (Unshielded Twisted Pair/UTP) unterschieden. Geschirmte Kabel sind st\u00f6rsicherer, aber auch teurer, schwerer und steifer. Das Namensschema von Twisted Pairs ist wie folgt: \\(xx/y\\text{TP}\\) (Beispiel: U/UTP, S/UTP, ...) Werte f\u00fcr \\(xx\\) Werte f\u00fcr \\(y\\) Erkl\u00e4rung U U ungeschirmt F F Folienschirm S S Geflechtschirm SF <gibt es nicht> Schirm aus Geflecht und Folie Schirme funktionieren nur, wenn sie gut geerdet sind!","title":"Paarsymmetrische Kabel (Twisted Pair)"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#twisted-pair-und-storungen","text":"Zwei Leitungen, welche parallel gef\u00fchrt werden, verhalten sich, wie Sender und Empf\u00e4nger . Dies kann minimiert werden, in dem auf zwei Leitungen ein komplement\u00e4res Signal gesendet wird. Der Empf\u00e4nger kann danach die zwei Leitungen zusammen rechnen, und die herauskommende Spannung ist das St\u00f6rsignal. Wenn ein Magnetfeld eine St\u00f6rung induziert (Induktiver Effekt), wirkt sich diese auf die beide Leiter umgekehrt aus. Aus diesem Grund werden die Kabel verdreht. Dadurch entstehen kleinere Schleifen und in der benachbarten Schleife ist die St\u00f6rung verkehrt, was die St\u00f6rung gr\u00f6sstenteils aufhebt.","title":"Twisted pair und St\u00f6rungen"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#glassfaser","text":"Glassfaser-Kabel funktionieren dank der totalen Reflektio.","title":"Glassfaser"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#dispersion","text":"Es wird von Dispersion gesprochen, wenn das Signal verzert und nicht mehr erkannt wird. Es gibt mehrere Ursachen daf\u00fcr, die offensichtlichste die Modendispersion. Dies passiert, da unterschiedliche Lichtstrahlen einen k\u00fcrzeren oder l\u00e4ngeren Weg (je nachdem wie sie vom Kabel abprallen) haben und so zu verschiedenen Zeiten ankommen. Dieses wird auch Delay Skew genannt. Bei zu hoher Distanz oder zu hoher Pulsdichte kann dies zu Problemem f\u00fchren.","title":"Dispersion"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#stufenfaser","text":"Kann mit einfachen Leuchtdioten angesprochen werden, hat aber viel Dispersion und Delay Skew (50 ns/km)","title":"Stufenfaser"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#gradientenfasern","text":"Der \u00dcbergang zwischen Glaskern und Schirmung ist ein Verlauf. Dies bewirkt, dass die Moden mit dem k\u00fcrzesten Weg gebremst werden und sie gleichzeitig mit den L\u00e4ngeren ankommen. Gradientenfasern haben eine Delay Skew von ca. 0.5ns/km","title":"Gradientenfasern"},{"location":"22FS/KT/03_%C3%9Cbertragunsmedien.html#monomode-faser","text":"Es werden Laser-Dioden ben\u00f6tigt, da die Faser zu d\u00fcnn ist f\u00fcr eine Lichtdiode. Dies macht die Monomode-Fasern auch teuer.","title":"Monomode-Faser"},{"location":"22FS/KT/04_Data%20Link.html","text":"Data Link Layer (Layer 2) Layer 2 Protokolle HDLC PPP X.25 / Frame Relay MPLS ATM \u00dcbertragungsverfahren Daten k\u00f6nen seriell oder parallel \u00fcbertragen werden. Bei der parallelen \u00dcbertragungen werden mehrere Bits gleichzeitig \u00fcbertragen. Dies funktioniert nur auf kurze Distanz, da sonst die Toleranzen zu gross w\u00e4ren. Bei der seriellen \u00dcbertragen werden die Bits nacheinander \u00fcbertragen. Hier sind sehr viel h\u00f6hrere Datenraten auf l\u00e4ngere Distanzen m\u00f6glich, da nicht mehrere Leitungen synchronisiert werden m\u00fcssen. Die serielle \u00dcbertragung kann noch weiter in synchrone und asynchrone serielle \u00dcbertragung unterteilt werden. Bei der asynchronen Verbindung wird kein Clock Signal \u00fcbertragen. Die Clock des Empf\u00e4nger und Senders sind daher nicht zusammen. Damit es trotzdem funktioniert, wird die Bitrate, die Start- und Stop-Bits abemacht. F\u00fcr jedes Zeichen wird ein Startbit gesendet und zum Abschluss ein Stopbit. Zu erst wird das niederwertigste (LSB = Least Significant Bit) \u00fcbertragen und zu letzt das h\u00f6chstwertige (MSB Most Significant Bit). (wirklich?) Der Emfp\u00e4nger tastet sehr schnell ab, bis das Startbit findet. Danach wird in der abgemachten Bitrate abgetastet. Der Takt darf nicht mehr als die halbe Bitzeit T abweichen, da sonst das falsche Bit gelesen w\u00fcrde werden. Dagegen steht die synchrone \u00dcbertragung. Bei dieser sendet der Sender ein Takt mit den Daten mit. Daher werden auch keine Start und Stop-Bits ben\u00f6tigt. Gleichspannungsfreiheit Der Sender und Empf\u00e4nger sind galvanisch (elektrisch nicht direkt verbunden) getrennt. Dies sch\u00fctzt die Ger\u00e4te davon, dass Falls beim anderen Ger\u00e4t ein Blitz einschl\u00e4gt oder es anderweitig eine \u00dcberspannung gibt. Da dies mit Capacitor gearbeitet wird, m\u00f6chte man, dass das Signal nicht immer bei 1 oder bei 0 ist, sondern m\u00f6glichst oft wechselt. Dies nennt sich gleichspannungsfrei. Daf\u00fcr kann z.B. eine Codierung, wie AMI, HDB3 oder PAM3 verwendet werden. Taktr\u00fcckgewinnung Das Ziel der Taktr\u00fcckgewinnung ist, ein Taktsignal aus dem normalen Datenstrom zu lesen. Daf\u00fcr darf der Datenstrom aber nicht zu lange nur 1 oder nur 0 senden, da sonst der Empf\u00e4nger kein Takt daraus lesen kann. AMI-Codierung Ein 0 wird in Ami als 0 encodiert. Ein 1 wird alternativ als U+ und U- gesendet. D Daher ist die Taktr\u00fcckgewinnung schwierig, wenn l\u00e4nger 0 gesendet werden. Daher ist AMI nicht f\u00fcr die Taktr\u00fcckgewinnung geignet. Es wird anstatt HDB3 ben\u00fctzt. Bei der HDB3-Encoding wird zus\u00e4tzlich nach 000 eine 1 gesendet. Diese 1 hat den selben Pegel, wie die letzte 1 , also entweder U+ oder U- . Da normalerweise immer zwischen U+ und U- gewechselt wird, kann der Empf\u00e4nger dieses Bit korrekt interpretieren. Bei langen Sequenzen von 0 w\u00fcrde dabei die Gleichspannungsfreiheit verletzt werden, daher wird wenn wenn weniger als zwei 1 seit dem letzten 000V gesendet wurden, anstatt 000V ein B00V gesendet. Dabei verhaltet sich das B wie ein normales Datenbit und wechselt zwischen U+ und U- hin und her. PAM3 (4B3T-Codierung) In dieser werden 4Bit Daten zu 3 ten\u00e4re Symbolen (Ein Symbol mit 3 Werten) \u00fcbersetzt Daten\u00fcbertragung Zehnerpotenzen: kBit = 103 Bit kbps = 103 bps MBit = 106 Bit Mbps = 106 bps GBit = 109 Bit Gbps = 109 bps Baud-Rate Die Anzahl Symbole pro Sekunde. Ein Symbol ist dabei ein Zustand im Datenstrom Bitrate (Nyquist) \\(f_s\\le2B\\) , dabei ist \\(f_s\\) die Symbolrate/Baudrate und \\(B\\) die Bandbreite des Kanals in Hz. Diese Formel besagt, dass die Symbolrate in Baud (oder Nyquist Rate) doppelt so gross, wie die Frequenz des \u00dcbertragungskanal ist. Maximale Bitrate (Hartley's Gesetzt) Die Bitrate \\(R [bit/s] \\le 2B [Hz] \\cdot \\log_2(M)\\) wobei \\(M\\) folgendermassen definiert ist: \\(M=1+\\frac A {\\Delta V}\\) TODO Kanalkapazit\u00e4t (Theorem von Shanon) \\(C_s=B\\cdot \\log_2(1+\\frac S N)\\) , wo bei \\(C_s\\) die Kanalkapazit\u00e4t, \\(B\\) die Baudrate, \\(S\\) die Signal-Aplitude und \\(N\\) die Noise-Aplitude ist. \\(\\frac S N\\) ist die Signal-to-Noise Ratio Synchrone \u00dcbertragung Bei der synchronen \u00dcbertragung wird immer gesendet, auch wenn keine Daten \u00fcbertragen werden. In diesem Fall werden konstant Flags \u00fcbertragen. Folgeadermassen wird eine M\u00f6glichkeit aufgezeichnet, wie dies gestaltet werden k\u00f6nnte. Ein Flag ist der Start bzw. Ende eines Datenrahmens. Da ein Flag 01111110 ist, kann dies nicht im Datenblock vorkommen. Daher wird nach f\u00fcnf 1 eine 0 eingesetzt. Diese 0 wird vom Empf\u00e4nger verworfen. Dies wird auch Bit-Stopfen (engl. \"Bit-Stuffing\") Asynchrone \u00dcbertrage/Ethernet Wieso immer noch Ethernet? Alle Ethernet-Standard ben\u00fctzten den RJ45 Stecker von 10MBit/s bis zu 10Gbit/s. Diese R\u00fcckwarts-Kompatibilit\u00e4t ist enorm wertvoll. Ethernet-Standard Das prominentiste Beispiel der asynchronen \u00dcbertragung ist Ethernet, daher wird die asynchrone \u00dcbertragung an Ethernet vorgestellt. Preamble Die Preamble werden 7 Bytes, welche aus Abwechslungsweise 0 und 1 bestehen. Das 8 Byte hat die Form 10101011 . Bytes korrekt lesen Daten werden Umgekehrt gesendet (Zuerst das LSB und dann das MSB). Wenn man es von Hand lesen m\u00f6chte, m\u00fcssen die Bits umgedreht werden. Frame-Gr\u00f6sse Da der Overhead fix ist, wird der Overhead eine kleinere Prozentanteil, je mehr Daten gesendet werden. Auf der anderen Seite, je gr\u00f6sser der Frame, desto h\u00f6her die Wahrscheinlichkeit, dass ein Fehler bei der \u00dcbertragung auftritt. Wenn ein Medium von mehreren Nutzer genutzt wird, m\u00fcssen die anderen Nutzer lange warten, wenn grosse Frames \u00fcbertragen werden. Sende Zeit Es braucht die Zeit \\(t_{frame}>2\\cdot(n\\cdot t_{transfer}+ n\\cdot t_{forwarding})\\) und \\(t_{frame}>2\\cdot t_{transfer}\\) Dabei ist \\(t_{frame}=\\frac{Framesize_{min}}{Bitrate}\\) und \\(t_{transfer}=\\frac{d_{max}}{c_{line}}\\) Aus dem allen geht herfor: \\(\\frac{Framesize_{min}}{Bitrate}>2\\cdot \\frac{d_{max}}{c_{line}}\\) F\u00fcr die Framerate gilt: \\(Framerate = \\frac{Preabmle + SFD+DestinationAddress + SourceAddress+LT+Data+FCS+InterFrameGap}{Bitrate}\\) Die Interfrace Gap muss nur dazu gerechnet werden, wenn die Framerate berechet wird. Collission Domain und Broadcasat Domain Repeater vs L2-Switch/Bridge wegen kollision, k\u00f6nnen nicht beliebig Repeater hintereinander geh\u00e4nkt werden. Es verk\u00fcrzt die Collision Der Switch verk\u00fcrzt die Collision Domain Bit-/Rahmenfehlerwahrscheinlichkeit \\[ P_{Erfolg}=(1-p_e)\\\\ P_{Erfolg,Frame}=(1-p_e)^N\\\\ P_{Fehler,Frame}=1-(1-p_e)^N \\] Kollision bei Shared-Medium Autonegotiation Dieses Protokoll wird ab 100BASE-T unterst\u00fctzt und schaut, dass der Empf\u00e4nger und Sender die selbe Geschwindigkeit unterst\u00fctzt. VLAN Mit einem VLAN k\u00f6nnen seperate virtuelle Gruppen in einem LAN erstellen. Die Kommunikation zwischen VLANs sind meistens eingeschr\u00e4nkt oder nicht m\u00f6glich. VLAN-Tag Damit dies auch in einem Netzwerk mit mehreren Switches m\u00f6glich ist, wird in VLAN-Tag im Ethernet-Frame eingef\u00fchrt. Dieser Tag besteht aus: Tag Protocol Identifier : User Priority : (3 Bit), Cannonical Format Identifier VLAN-Identifier : (12-Bit)","title":"Data Link Layer (Layer 2)"},{"location":"22FS/KT/04_Data%20Link.html#data-link-layer-layer-2","text":"","title":"Data Link Layer (Layer 2)"},{"location":"22FS/KT/04_Data%20Link.html#layer-2-protokolle","text":"HDLC PPP X.25 / Frame Relay MPLS ATM","title":"Layer 2 Protokolle"},{"location":"22FS/KT/04_Data%20Link.html#ubertragungsverfahren","text":"Daten k\u00f6nen seriell oder parallel \u00fcbertragen werden. Bei der parallelen \u00dcbertragungen werden mehrere Bits gleichzeitig \u00fcbertragen. Dies funktioniert nur auf kurze Distanz, da sonst die Toleranzen zu gross w\u00e4ren. Bei der seriellen \u00dcbertragen werden die Bits nacheinander \u00fcbertragen. Hier sind sehr viel h\u00f6hrere Datenraten auf l\u00e4ngere Distanzen m\u00f6glich, da nicht mehrere Leitungen synchronisiert werden m\u00fcssen. Die serielle \u00dcbertragung kann noch weiter in synchrone und asynchrone serielle \u00dcbertragung unterteilt werden. Bei der asynchronen Verbindung wird kein Clock Signal \u00fcbertragen. Die Clock des Empf\u00e4nger und Senders sind daher nicht zusammen. Damit es trotzdem funktioniert, wird die Bitrate, die Start- und Stop-Bits abemacht. F\u00fcr jedes Zeichen wird ein Startbit gesendet und zum Abschluss ein Stopbit. Zu erst wird das niederwertigste (LSB = Least Significant Bit) \u00fcbertragen und zu letzt das h\u00f6chstwertige (MSB Most Significant Bit). (wirklich?) Der Emfp\u00e4nger tastet sehr schnell ab, bis das Startbit findet. Danach wird in der abgemachten Bitrate abgetastet. Der Takt darf nicht mehr als die halbe Bitzeit T abweichen, da sonst das falsche Bit gelesen w\u00fcrde werden. Dagegen steht die synchrone \u00dcbertragung. Bei dieser sendet der Sender ein Takt mit den Daten mit. Daher werden auch keine Start und Stop-Bits ben\u00f6tigt.","title":"\u00dcbertragungsverfahren"},{"location":"22FS/KT/04_Data%20Link.html#gleichspannungsfreiheit","text":"Der Sender und Empf\u00e4nger sind galvanisch (elektrisch nicht direkt verbunden) getrennt. Dies sch\u00fctzt die Ger\u00e4te davon, dass Falls beim anderen Ger\u00e4t ein Blitz einschl\u00e4gt oder es anderweitig eine \u00dcberspannung gibt. Da dies mit Capacitor gearbeitet wird, m\u00f6chte man, dass das Signal nicht immer bei 1 oder bei 0 ist, sondern m\u00f6glichst oft wechselt. Dies nennt sich gleichspannungsfrei. Daf\u00fcr kann z.B. eine Codierung, wie AMI, HDB3 oder PAM3 verwendet werden.","title":"Gleichspannungsfreiheit"},{"location":"22FS/KT/04_Data%20Link.html#taktruckgewinnung","text":"Das Ziel der Taktr\u00fcckgewinnung ist, ein Taktsignal aus dem normalen Datenstrom zu lesen. Daf\u00fcr darf der Datenstrom aber nicht zu lange nur 1 oder nur 0 senden, da sonst der Empf\u00e4nger kein Takt daraus lesen kann.","title":"Taktr\u00fcckgewinnung"},{"location":"22FS/KT/04_Data%20Link.html#ami-codierung","text":"Ein 0 wird in Ami als 0 encodiert. Ein 1 wird alternativ als U+ und U- gesendet. D Daher ist die Taktr\u00fcckgewinnung schwierig, wenn l\u00e4nger 0 gesendet werden. Daher ist AMI nicht f\u00fcr die Taktr\u00fcckgewinnung geignet. Es wird anstatt HDB3 ben\u00fctzt. Bei der HDB3-Encoding wird zus\u00e4tzlich nach 000 eine 1 gesendet. Diese 1 hat den selben Pegel, wie die letzte 1 , also entweder U+ oder U- . Da normalerweise immer zwischen U+ und U- gewechselt wird, kann der Empf\u00e4nger dieses Bit korrekt interpretieren. Bei langen Sequenzen von 0 w\u00fcrde dabei die Gleichspannungsfreiheit verletzt werden, daher wird wenn wenn weniger als zwei 1 seit dem letzten 000V gesendet wurden, anstatt 000V ein B00V gesendet. Dabei verhaltet sich das B wie ein normales Datenbit und wechselt zwischen U+ und U- hin und her.","title":"AMI-Codierung"},{"location":"22FS/KT/04_Data%20Link.html#pam3-4b3t-codierung","text":"In dieser werden 4Bit Daten zu 3 ten\u00e4re Symbolen (Ein Symbol mit 3 Werten) \u00fcbersetzt","title":"PAM3 (4B3T-Codierung)"},{"location":"22FS/KT/04_Data%20Link.html#datenubertragung","text":"Zehnerpotenzen: kBit = 103 Bit kbps = 103 bps MBit = 106 Bit Mbps = 106 bps GBit = 109 Bit Gbps = 109 bps","title":"Daten\u00fcbertragung"},{"location":"22FS/KT/04_Data%20Link.html#baud-rate","text":"Die Anzahl Symbole pro Sekunde. Ein Symbol ist dabei ein Zustand im Datenstrom","title":"Baud-Rate"},{"location":"22FS/KT/04_Data%20Link.html#bitrate-nyquist","text":"\\(f_s\\le2B\\) , dabei ist \\(f_s\\) die Symbolrate/Baudrate und \\(B\\) die Bandbreite des Kanals in Hz. Diese Formel besagt, dass die Symbolrate in Baud (oder Nyquist Rate) doppelt so gross, wie die Frequenz des \u00dcbertragungskanal ist.","title":"Bitrate (Nyquist)"},{"location":"22FS/KT/04_Data%20Link.html#maximale-bitrate-hartleys-gesetzt","text":"Die Bitrate \\(R [bit/s] \\le 2B [Hz] \\cdot \\log_2(M)\\) wobei \\(M\\) folgendermassen definiert ist: \\(M=1+\\frac A {\\Delta V}\\) TODO","title":"Maximale Bitrate (Hartley's Gesetzt)"},{"location":"22FS/KT/04_Data%20Link.html#kanalkapazitat-theorem-von-shanon","text":"\\(C_s=B\\cdot \\log_2(1+\\frac S N)\\) , wo bei \\(C_s\\) die Kanalkapazit\u00e4t, \\(B\\) die Baudrate, \\(S\\) die Signal-Aplitude und \\(N\\) die Noise-Aplitude ist. \\(\\frac S N\\) ist die Signal-to-Noise Ratio","title":"Kanalkapazit\u00e4t (Theorem von Shanon)"},{"location":"22FS/KT/04_Data%20Link.html#synchrone-ubertragung","text":"Bei der synchronen \u00dcbertragung wird immer gesendet, auch wenn keine Daten \u00fcbertragen werden. In diesem Fall werden konstant Flags \u00fcbertragen. Folgeadermassen wird eine M\u00f6glichkeit aufgezeichnet, wie dies gestaltet werden k\u00f6nnte. Ein Flag ist der Start bzw. Ende eines Datenrahmens. Da ein Flag 01111110 ist, kann dies nicht im Datenblock vorkommen. Daher wird nach f\u00fcnf 1 eine 0 eingesetzt. Diese 0 wird vom Empf\u00e4nger verworfen. Dies wird auch Bit-Stopfen (engl. \"Bit-Stuffing\")","title":"Synchrone \u00dcbertragung"},{"location":"22FS/KT/04_Data%20Link.html#asynchrone-ubertrageethernet","text":"","title":"Asynchrone \u00dcbertrage/Ethernet"},{"location":"22FS/KT/04_Data%20Link.html#wieso-immer-noch-ethernet","text":"Alle Ethernet-Standard ben\u00fctzten den RJ45 Stecker von 10MBit/s bis zu 10Gbit/s. Diese R\u00fcckwarts-Kompatibilit\u00e4t ist enorm wertvoll.","title":"Wieso immer noch Ethernet?"},{"location":"22FS/KT/04_Data%20Link.html#ethernet-standard","text":"Das prominentiste Beispiel der asynchronen \u00dcbertragung ist Ethernet, daher wird die asynchrone \u00dcbertragung an Ethernet vorgestellt.","title":"Ethernet-Standard"},{"location":"22FS/KT/04_Data%20Link.html#preamble","text":"Die Preamble werden 7 Bytes, welche aus Abwechslungsweise 0 und 1 bestehen. Das 8 Byte hat die Form 10101011 .","title":"Preamble"},{"location":"22FS/KT/04_Data%20Link.html#bytes-korrekt-lesen","text":"Daten werden Umgekehrt gesendet (Zuerst das LSB und dann das MSB). Wenn man es von Hand lesen m\u00f6chte, m\u00fcssen die Bits umgedreht werden.","title":"Bytes korrekt lesen"},{"location":"22FS/KT/04_Data%20Link.html#frame-grosse","text":"Da der Overhead fix ist, wird der Overhead eine kleinere Prozentanteil, je mehr Daten gesendet werden. Auf der anderen Seite, je gr\u00f6sser der Frame, desto h\u00f6her die Wahrscheinlichkeit, dass ein Fehler bei der \u00dcbertragung auftritt. Wenn ein Medium von mehreren Nutzer genutzt wird, m\u00fcssen die anderen Nutzer lange warten, wenn grosse Frames \u00fcbertragen werden.","title":"Frame-Gr\u00f6sse"},{"location":"22FS/KT/04_Data%20Link.html#sende-zeit","text":"Es braucht die Zeit \\(t_{frame}>2\\cdot(n\\cdot t_{transfer}+ n\\cdot t_{forwarding})\\) und \\(t_{frame}>2\\cdot t_{transfer}\\) Dabei ist \\(t_{frame}=\\frac{Framesize_{min}}{Bitrate}\\) und \\(t_{transfer}=\\frac{d_{max}}{c_{line}}\\) Aus dem allen geht herfor: \\(\\frac{Framesize_{min}}{Bitrate}>2\\cdot \\frac{d_{max}}{c_{line}}\\) F\u00fcr die Framerate gilt: \\(Framerate = \\frac{Preabmle + SFD+DestinationAddress + SourceAddress+LT+Data+FCS+InterFrameGap}{Bitrate}\\) Die Interfrace Gap muss nur dazu gerechnet werden, wenn die Framerate berechet wird.","title":"Sende Zeit"},{"location":"22FS/KT/04_Data%20Link.html#collission-domain-und-broadcasat-domain","text":"","title":"Collission Domain und Broadcasat Domain"},{"location":"22FS/KT/04_Data%20Link.html#repeater-vs-l2-switchbridge","text":"wegen kollision, k\u00f6nnen nicht beliebig Repeater hintereinander geh\u00e4nkt werden. Es verk\u00fcrzt die Collision Der Switch verk\u00fcrzt die Collision Domain","title":"Repeater vs L2-Switch/Bridge"},{"location":"22FS/KT/04_Data%20Link.html#bit-rahmenfehlerwahrscheinlichkeit","text":"\\[ P_{Erfolg}=(1-p_e)\\\\ P_{Erfolg,Frame}=(1-p_e)^N\\\\ P_{Fehler,Frame}=1-(1-p_e)^N \\]","title":"Bit-/Rahmenfehlerwahrscheinlichkeit"},{"location":"22FS/KT/04_Data%20Link.html#kollision-bei-shared-medium","text":"","title":"Kollision bei Shared-Medium"},{"location":"22FS/KT/04_Data%20Link.html#autonegotiation","text":"Dieses Protokoll wird ab 100BASE-T unterst\u00fctzt und schaut, dass der Empf\u00e4nger und Sender die selbe Geschwindigkeit unterst\u00fctzt.","title":"Autonegotiation"},{"location":"22FS/KT/04_Data%20Link.html#vlan","text":"Mit einem VLAN k\u00f6nnen seperate virtuelle Gruppen in einem LAN erstellen. Die Kommunikation zwischen VLANs sind meistens eingeschr\u00e4nkt oder nicht m\u00f6glich.","title":"VLAN"},{"location":"22FS/KT/04_Data%20Link.html#vlan-tag","text":"Damit dies auch in einem Netzwerk mit mehreren Switches m\u00f6glich ist, wird in VLAN-Tag im Ethernet-Frame eingef\u00fchrt. Dieser Tag besteht aus: Tag Protocol Identifier : User Priority : (3 Bit), Cannonical Format Identifier VLAN-Identifier : (12-Bit)","title":"VLAN-Tag"},{"location":"22FS/KT/05_LAN.html","text":"LAN LAN steht f\u00fcr Local Area Network ist ein r\u00e4umliches begrenztes Netzwer. Topologien Bus-Topologie Alle Ger\u00e4te sind direkt am \u00dcbertragungsmedium angeschlossen und werden nur aktiv, wenn sie senden. Linien-Topologie Bei der Linien-Topologie sind die jeweils benachbarten Knoten miteinander verbunden. Wenn eine Nachricht von A zu D geschickt wird, muss sie von B und C weiter geleitet werden. Diese Topologie ist zudem recht anf\u00e4llig, da wenn ein Knoten aussteigt, die Verbindung unterbrochen ist. Ring-Topologie Eine Ring-Topologie wurde eine Linien-Topologie an den Enden verbunden. Dies verbessert die Redundanz, da bei einem Ausfall, jeder Knoten von der anderen Seite erreichbar ist. Um die Redundanz noch weiter zu erh\u00f6hen, wird manchmal auch eine doppelte Ring-Topologie verwendet. Bei der Ring-Topologie muss sichergestellt werden, dass sich eine Nachricht nicht im Kreis dreht. Stern-Topologie Bei der Stern-Topologie geht alles \u00fcber einen Switch oder Hub. Dies hat zur folge, dass ein Knoten aussteigen kann ohne, dass das ganze Netzwerk lahm gelegt wird. Allerdings wenn der Switch oder Hub aussteigt, kann nicht mehr kommuniziert werden. Baum-Topologie Die Baum-Topologie kann aus mehreren Stern-Topologien hergestellt werden. \u00dcbertragungsarten Art Erkl\u00e4rung Unicast Ein Paket hat wird genau an ein Ziel gesendet. Das Paket wird mit einer Adresse ausgestattet, so dass es am Ziel sicher ankommt. (Netflix) Broadcast Das Paket wird an alle Knoten im Netzwerk gesendet. Das Paket wird mit einer Broadcast-Adresse ausgestattet (Live-Stream/Twitch) Multicast Das Paket wird an eine Gruppen von Knoten gesendet. (Radio) (Anycast) Mehrere Server mit den selben Adressen. Der Knoten davor entscheidet, an welchen Knoten \u00fcbertragen wird IEEE Namensgebung 1000BASE-T = Ethernet mit Basisband-Kanalcodierung mit einer Bitrate von 1Gbit/s mit Twisted-Pairs 10BASE5 = 10Mbit/s Basisband-Ethernet mit max 500m Segmentenl\u00e4nge Manchester-Codierung (10Mbit/s) In Ethernet wird die Manchester-Codierung zwischen 0V und -2V angewendet. Eine steigene Flanke ist eine 1 eine sinkende Flanke ist eine 0 Um z.B. zwei 1 senden zu k\u00f6nnen, muss nach dem ersten 1 zuerst auf -2V gehen, damit eine zweite steigende Flanke gebildet werden kann. Da diese sinkende Flanke ausserhalb des Clocksignal ist, erkennt der Sender dies nicht. Ein Nachteil der Manchester-Codierung ist, dass nur die H\u00e4lfte der Bandbreite genutzt werden kann, da f\u00fcr zwei 1 das Signal 4 Flanken machen muss. Daher wird bei Geschwindigkeit h\u00f6her als 10Mbit/s keine Manchester-Codierung verwendet NRZ-I (100Mbit/s) bei einer 1 wechselt der Pegel bei einer 0 bleibt der Pegel Shared-Ethernet Das urspr\u00fcngliche Ethernet wurde f\u00fcr eine Bus-Topologie entwickelt. Dabei wurden Koaxial-Kabel verwendet, welche angebohrt wurden (Daher auch der Name Tick-Wire-Ethernet) MAC-Adresse Individual/Group 0 = individual address 1 = group address Universally / Locally 0 = universally administrated address (Normalfall) 1 = locally administrated address Ethernet Frame Format","title":"LAN"},{"location":"22FS/KT/05_LAN.html#lan","text":"LAN steht f\u00fcr Local Area Network ist ein r\u00e4umliches begrenztes Netzwer.","title":"LAN"},{"location":"22FS/KT/05_LAN.html#topologien","text":"","title":"Topologien"},{"location":"22FS/KT/05_LAN.html#bus-topologie","text":"Alle Ger\u00e4te sind direkt am \u00dcbertragungsmedium angeschlossen und werden nur aktiv, wenn sie senden.","title":"Bus-Topologie"},{"location":"22FS/KT/05_LAN.html#linien-topologie","text":"Bei der Linien-Topologie sind die jeweils benachbarten Knoten miteinander verbunden. Wenn eine Nachricht von A zu D geschickt wird, muss sie von B und C weiter geleitet werden. Diese Topologie ist zudem recht anf\u00e4llig, da wenn ein Knoten aussteigt, die Verbindung unterbrochen ist.","title":"Linien-Topologie"},{"location":"22FS/KT/05_LAN.html#ring-topologie","text":"Eine Ring-Topologie wurde eine Linien-Topologie an den Enden verbunden. Dies verbessert die Redundanz, da bei einem Ausfall, jeder Knoten von der anderen Seite erreichbar ist. Um die Redundanz noch weiter zu erh\u00f6hen, wird manchmal auch eine doppelte Ring-Topologie verwendet. Bei der Ring-Topologie muss sichergestellt werden, dass sich eine Nachricht nicht im Kreis dreht.","title":"Ring-Topologie"},{"location":"22FS/KT/05_LAN.html#stern-topologie","text":"Bei der Stern-Topologie geht alles \u00fcber einen Switch oder Hub. Dies hat zur folge, dass ein Knoten aussteigen kann ohne, dass das ganze Netzwerk lahm gelegt wird. Allerdings wenn der Switch oder Hub aussteigt, kann nicht mehr kommuniziert werden.","title":"Stern-Topologie"},{"location":"22FS/KT/05_LAN.html#baum-topologie","text":"Die Baum-Topologie kann aus mehreren Stern-Topologien hergestellt werden.","title":"Baum-Topologie"},{"location":"22FS/KT/05_LAN.html#ubertragungsarten","text":"Art Erkl\u00e4rung Unicast Ein Paket hat wird genau an ein Ziel gesendet. Das Paket wird mit einer Adresse ausgestattet, so dass es am Ziel sicher ankommt. (Netflix) Broadcast Das Paket wird an alle Knoten im Netzwerk gesendet. Das Paket wird mit einer Broadcast-Adresse ausgestattet (Live-Stream/Twitch) Multicast Das Paket wird an eine Gruppen von Knoten gesendet. (Radio) (Anycast) Mehrere Server mit den selben Adressen. Der Knoten davor entscheidet, an welchen Knoten \u00fcbertragen wird","title":"\u00dcbertragungsarten"},{"location":"22FS/KT/05_LAN.html#ieee-namensgebung","text":"1000BASE-T = Ethernet mit Basisband-Kanalcodierung mit einer Bitrate von 1Gbit/s mit Twisted-Pairs 10BASE5 = 10Mbit/s Basisband-Ethernet mit max 500m Segmentenl\u00e4nge","title":"IEEE Namensgebung"},{"location":"22FS/KT/05_LAN.html#manchester-codierung-10mbits","text":"In Ethernet wird die Manchester-Codierung zwischen 0V und -2V angewendet. Eine steigene Flanke ist eine 1 eine sinkende Flanke ist eine 0 Um z.B. zwei 1 senden zu k\u00f6nnen, muss nach dem ersten 1 zuerst auf -2V gehen, damit eine zweite steigende Flanke gebildet werden kann. Da diese sinkende Flanke ausserhalb des Clocksignal ist, erkennt der Sender dies nicht. Ein Nachteil der Manchester-Codierung ist, dass nur die H\u00e4lfte der Bandbreite genutzt werden kann, da f\u00fcr zwei 1 das Signal 4 Flanken machen muss. Daher wird bei Geschwindigkeit h\u00f6her als 10Mbit/s keine Manchester-Codierung verwendet","title":"Manchester-Codierung (10Mbit/s)"},{"location":"22FS/KT/05_LAN.html#nrz-i-100mbits","text":"bei einer 1 wechselt der Pegel bei einer 0 bleibt der Pegel","title":"NRZ-I (100Mbit/s)"},{"location":"22FS/KT/05_LAN.html#shared-ethernet","text":"Das urspr\u00fcngliche Ethernet wurde f\u00fcr eine Bus-Topologie entwickelt. Dabei wurden Koaxial-Kabel verwendet, welche angebohrt wurden (Daher auch der Name Tick-Wire-Ethernet)","title":"Shared-Ethernet"},{"location":"22FS/KT/05_LAN.html#mac-adresse","text":"Individual/Group 0 = individual address 1 = group address Universally / Locally 0 = universally administrated address (Normalfall) 1 = locally administrated address","title":"MAC-Adresse"},{"location":"22FS/KT/05_LAN.html#ethernet-frame-format","text":"","title":"Ethernet Frame Format"},{"location":"22FS/KT/06_Network%20Layer.html","text":"Network Layer (Layer 3) IP-Adressen Mit hilfe von IP-Adressen routen Router die Pakete umher. IP-Adressen sind hirarchisch aufgebaut. Classful vs Classless Klassen Adressbereich Anzahl Netze Interfaces pro netz A 1.0.0.0 - 127.255.255.255 127 16'777'214 B 128.0.0.0 - 191.255.255.255 16'384 65'534 C 192.0.0.0-223.255.255.255 2'097'152 254 Die Klasse D (224.0.0.0 - 239.255.255.255) sind f\u00fcr Multicast-Adressen vorgesehen. Dies ist ein separates Protokoll mit separaten Adressierung. Die Klasse E (224.0.0.0 - 255.255.255.255) ist reserviert f\u00fcr zuk\u00fcnftige Netzwerke. Die folgenden privaten Netzwerke gibt es: Klasse Netzadresse Subnetmaske A 10.0.0.0 255.0.0.0 B 172.16.0.0 - 172.31.0.0 255.255.0.0 C 192.168.0.0 - 192.168.255.0 255.255.255.0 Netmask Die IP-Adresse ist in zwei Teile aufgeteilt: Die Netzadresse und Host-Adressen. Die Netzmaske unterteilt eine IP-Adresse in die Netzadresse und Hostadresse. Alternativ schreibweisse ist \"/24\" f\u00fcr eine Subnetzmaske mit 24 1 und 8 0 . Daher gibt es \\((32-24)^2-2=255-2=254\\) addressierbare Hosts. Es werden noch zwei Adressen abgezogen, da zwei Adressen f\u00fcr die Broadcast- und Netzwerk-Adresse ben\u00f6tigt werden. Routing Dank routing weiss ein Router wohin ein Paket gesendet werden muss. Dies wird anhand der IP-Adresse gemacht. Routing-Tabelle In der Routing-Tabelle steht, \u00fcber welcher Port welches Netzwerk ansprechbar ist. Darin steht der Port, an dem das Netzwerk erreichbar ist, die Netzwerkadresse und Netzmaske. Zus\u00e4tzlich gibt es ein Default-Gateway. \u00dcber diesen werden alle Pakete weitergeleitet, welche zu keinem anderen Netzwerk passt. Es kann f\u00fcr ein Netzwerk mehrere Eintr\u00e4ge geben. Die Routing-Tabelle ist geordnet nach der Netzmaske. Dabei ist das kleinste Netzwerk zu oberst (die h\u00f6chste Subnetz). Die Routing-Tabelle wird von oben nach unten durch geschafft. Zum ersten Hit wird das Paket gesendet. Flaches- vs Hirarchisches- Routing Bei Flachem-Routing kennt jeder Router jedes m\u00f6gliche Ziel im Netzwerk und andere Zielnetzwerke. Das Netzwerk Verhalten kann besser vorausgesagt werden und es k\u00f6nnen alternative Routings festgelegt werden, welche verwendet werden, wenn die schnellste Route ausf\u00e4llt. Die Routing-Tabellen aktuell zu halten, ist allerdings ein sehr grossen Aufwand. Beim Hirarchieschen-Routing hat jeder Host zwei Eintr\u00e4ge in der Routing-Tabelle. Ein Eintrag f\u00fcr das lokale Netz und ein Eintrag f\u00fcr alles andere, was an Router weitergeleitet wird. Internet Protokoll (IP) Format Das folgende Diagramm zeigt der Header des IP-Protokolles: Version (4 Bit) Gibt die Version des IP-Headers an. Es ist somit m\u00f6glich mehrere IP-Version (IPv4 oder IPv6) zu betreiben. Internet Header Length (IHL) (4 Bit) Gibt die L\u00e4nge allen Headers an. Der gelesene Wert wird mit dem Faktor 4 multipliziert. Wenn also 5 gelesen wird, sind die Headers 20 Bytes lang. IHL muss zwiscehn 5 (20 Bytes) und 15 (60 Bytes) sein. Der fixe Teil eines IP-Headers sind 20 Bytes, also bleiben 40 Bytes f\u00fcr Optionale Felder. Type of Service (8 Bit) Gibt an, was f\u00fcr eine Art von Leitung es ist. Ein Sender kann danach entscheiden, ob er eine Leitung, welche eine hoche Bandbreite hat, daf\u00fcr ein schlechten Ping (wie eine Satelitenverbindung) oder lieber eine \"normale\" Glassfasserleitung ben\u00fctzt. Dies wurde nie von allen Service-Providern unterst\u00fctzt. Total Length (16 Bit) Die totale L\u00e4nget des IP-Paketes mit Headers und Daten. Identifiaction (16 Bit) Ein Wert, welches ein Paket eindeutig identifiziert. Dieser Wert wird ben\u00fctzt, um fragmentierte Pakete wieder zu einem Paket zusammen zusetzen. Flags (3 Bit) Beinhaltet Kontrollflags f\u00fcr die Fragmentierung Feld Position Wert Funktion Erkl\u00e4rung Bit 0 reserved, must be zero Reserviert, immer Null DF Bit 1 0/1 May / Don't Fragment keine Fragmentierung MF Bit 2 0/1 Last / More Fragments Ob ein Folgefragment kommt Fragment Offset (13 Bit) An welcher stelle ein fragmentiertes Paket in das ganze Paket gesetzt werden soll. Der gelesen Wert wird mit dem Faktor 8 multipliziert. (Aus 90 wird 720 Bytes) Time to Live (TTL) (8 Bit) Gibt die Anzahl Sekunden an, welche das Paket noch im Netz sein darf. Wenn der Wert 0 wird, wird das Paket verworfen. In der Praxis ist es schwierig zu messen, wie lange ein Paket unterwegs ist und daher dekrementiert der Router der Wert um 1 wenn er es weiter sendet. Wenn ein Router ein Paket mit TTL=1 erhaltet, dekrementiert er es zu 0 und verwirft es. Protocol (8Bit) Das Protokol, welches im Datenteil \u00fcbertragen wird. Folgendes sind die wichtigsten Beispiele: Protocol Keyword Protokollbezeichnung 1 ICMP Internet Control Message 6 TCP Transmission Controll Protocol 17 UDP User Datagram Protocol Header Checksum (16 Bit) Eine Pr\u00fcfsumme, welche nur \u00fcber den IP-Header gebildet wird. Diese muss von jedem Router neu berechnet werden, da gewisse Felder vom Router modifiziert werden. Source Address (32 Bit) Die IP-Adresse des Senders Destination Address (32 Bit) Die IP-Adresse des Empf\u00e4ngers Options und Padding (max. 40 Bytes) Optionale Felder Maximum Transfer Unit (MTU) Die MTU gibt an, wie viel Bytes \u00fcber eine Leitung geschickt werden k\u00f6nnen. Dabei werden aber nur die Daten-Bytes des Ethernet-Frames gez\u00e4hlt. Die Bytes des Ethernet-Headers gelten nicht. Headers von gekapselten Protokollen, wie IP oder ICMP, m\u00fcssen nat\u00fcrlich mit gez\u00e4hlt werden, da sie teil der Daten-Bytes des Ethernet-Frames sind. Addressaufl\u00f6sung TODO Address Resolution Protocoll (ARP) ARP ist ein Layer 2 Protokoll, da es die Namensaufl\u00f6sung von IP-Adressen zu MAC-Adressen zul\u00e4sst. Ger\u00e4te haben typischerweisse eine ARP-Tabelle, in welcher ARP-Responses gecachet weden. TODO: Beispiel Gratuitous ARP Gratuitous heisst unn\u00f6tigt/unbegr\u00fcndet. TODO Fragmentieren und Reassembly Fragmentieren wird gebraucht, wenn ein Paket \u00fcber eine Leitung geschickt werden soll, welche eine kleinere Maximum Transfer Unit (MTU) hat, als die Gr\u00f6sse des Paketes. In diesem Fall wird das Paket aufgeteilt/fragmentiert. TODO Internet Control Message Protocol (ICMP) ICMP Pakete werden der Schicht 3 zugeordnet, obwohl sie in einem IP-Paket gekapselt werden. Es gibt einige Typen von ICMP Paketen: (4 - Source Quench ist depricated - hiess, dass der Sender langs\u00e4mer soll senden. Hat sich er\u00fcbrigt, da es in TCP eingebaut w) ICMP-Type Bedeutung Beispiel 3 Destination Unreachable Wenn der Router ein Node nicht erreiche kann, weil z.B. die MTU zu klein ist, das h\u00f6here Protokoll deaktiviert ist beim Host, das Paket fragmentiert werden muss aber DF gesetzt ist oder der Node ausgesteckt wurde: TODO Code Protocol Unreachable=Node kommuniziert nicht \u00fcber das Protokol; Port Unreachable = Kein Program h\u00f6rt auf diesen Port; 13 Communication adminstrativvely prohibited = Die Firewall blockiert etwas. Destination Unreachable kann auch genutzt werden, um die MTU einer Leitung zu finden 4 Source Quench Der Puffer des Routers ist voll 5 Redirct Wird an ein Host geschickt, wenn der Router feststellt, dass ein Paket an den falschen Router geschickt wurde 11 Time Exceeded Wenn das TTL-Feld =0 ist, wird es vom Router nicht mehr weitergesendet. Dies kann f\u00fcr Trace-Rout genutzt weden. Jeder Router reduziert das TTL-Feld um 1. Wenn der Router ein Paket mit TTL=1 bekommt wird dies um 1 reduziert und danach verworfen. 12 Parameter Problem Falls der Host oder Router im IP-Header einen ung\u00fcltigen Wert hat 0 Echo Reply Die Antowort auf ein Echo Request 8 Echo (-Request) Pingt ein Knoten an, welcher ein Echo Reply senden sollte 13 Timestamp Verhalten sich gleich wie Echo-Requests/-Replies aber senden noch die Zeit des Senders und Empf\u00e4ngers 14 Timestamp Reply Siehe 13 - Timestamp Destination Unreachable (Type 3) Code-Feld : 0 = net unreachable; 1 = host unreachable; 2= protocol unreachable; 3 = port unreachable; 4 fragmentation needed and DF set; 5 source route failed; 13 = communication administratively prohibited Internet Header + 64 Bits of Original Datagram enth\u00e4lt den ersten Teil des Datagramms, das die ICMP-Meldung ausgel\u00f6st hat. Damit ist der urspr\u00fcngliche Absender in der Lage, den Fehler genauer zu bestimmen. Time Exceeded Message (Type 11) Das Format ist gleich, wie bei Destination Unreachable (Type 3). Das Code-Feld kann folgende Werte haben: 0 = time to live exceeded in transit; 1 = fragment reassembly time exceeded. Echo-Request/-Reply Message (Type 8 / Type 0) Identifier : ID, damit der Sender die Echo-Reply zu einem Prozess kann. In der Reply steht die selbe Zahl Sequence Number : Wird bei jedem Echo-Request inkrementiert. In der Reply steht die selbe Zahl. Code-Feld : ist null Struktur von ICMP-Pakete Das ICMP Paket wird in einem IP-Paket verschachtelt ( Protocol=1 steht f\u00fcr den IP-Header). Anwendungen MTU einer Leitung finden Daf\u00fcr kann das Don't Fragment auf 1 gesetzt werden und versucht werden, wie hoch Traceroute ping IPv6 IPv6 bnutzt 128 Bits, bzw. 16 Bytes und erm\u00f6glicht es \\(2^{128}\\) Adressen zu generieren. IPv6 bringt zus\u00e4tzlich noch mehr Vorteile: Entlastung der Router Quality of Service: Flow Labels Verbessertes Routing: Routing Header Verbesserte Sicherheitsmechanismen Die MTU wird durch den Absender ermittelt und es gibt daher keine Fragmentierung, was den Router weiter entlastet Ein Interface kann mehrere IPv6 Adressen haben Eine IPv6 Adresse wird Hexadezimal dargestellt: 2001:0620:0000:0004:0A00:20FF:FE9C:7E4A . Dabei k\u00f6nnen Nullen zu begin von Zahlen weggelassen werden ( ...:0620:... = ...:620:... ). Aus dem ergibt sich 2001:620:0:4:A00:20FF:FE9C:7E4A . Zus\u00e4tzlich k\u00f6nnen lange Nullfolgen durch 2 Doppelpunkte ersetzt weden: 1023:0000:0000:0000:1736:a673:88a0:a620 = 1023::1736:a673:88a0:a620 . Der Doppelpunkt darf nur einmal genutzt werden. IPv6 Adressr\u00e4ume Es gibt eine Loopback Adresse: ::1/28 IPv6 Header Ein IPv6 Header ist 40 Bytes lang (ein IPv4 hat nur 20 Bytes) Header Extension Im Next Header Feld kann angegeben, was der n\u00e4chste Header oder Protokol ist. Dies reduziert die Gr\u00f6sse, da nur die n\u00f6tigen Headers geschickt werden m\u00fcssen. Ebenfalls gibt es f\u00fcr den Router weniger zu tun, da es weniger Felder zu verarbeiten gibt. In der folgenden Tabele sind die Header-Extension Types und Protokol-Types f\u00fcr das Next Header -Feld im IPv6 Header Hop-by-hop (typ=0) enth\u00e4lt Optionen, die von allen IPv6-Knoten auf der Strecke vom Sender zum Empf\u00e4nger beachtet werden m\u00fcssen. Typisches Beispiel ist die Jumbogram Option. Dieser Extension Header muss immer zuerst stehen. Routing Header (type = 43) Wird vom Sender verwendet, um den Pfad zum Empf\u00e4nger zu bestimmen. Er enth\u00e4lt eine Liste von Routern, \u00fcber die das betreffende IPv6 Paket geleitet wird. Diese Option wurde als Sicherheitsrisiko erkannt und wird nur noch in modifizierter Form f\u00fcr \u00abMobile IPv6\u00bb eingesetzt. Fragment Header (type = 44) Enth\u00e4lt Informationen f\u00fcr das Reassembly analog zu IP V4 Authentication Header AH (type = 51) und Encapsulating Security Payload Header (Type =51) Enthalten Daten, welche die Vertraulichkeit eines IPv6 Pakets sicherstellen (RFC 4302). Destination Options (type = 60) Dieser Header enth\u00e4lt Optionen, welche nur vom Endger\u00e4t beachtet werden m\u00fcssen (im Gegensatz zu den Hop-by-Hop Options). Im folgenden Bild ist ein Beisiel f\u00fcr das Next Header -Feld: Neigbor Discovery Protcol (NDP) ICMPv6 Autokonfigurieren","title":"Network Layer (Layer 3)"},{"location":"22FS/KT/06_Network%20Layer.html#network-layer-layer-3","text":"","title":"Network Layer (Layer 3)"},{"location":"22FS/KT/06_Network%20Layer.html#ip-adressen","text":"Mit hilfe von IP-Adressen routen Router die Pakete umher. IP-Adressen sind hirarchisch aufgebaut.","title":"IP-Adressen"},{"location":"22FS/KT/06_Network%20Layer.html#classful-vs-classless","text":"Klassen Adressbereich Anzahl Netze Interfaces pro netz A 1.0.0.0 - 127.255.255.255 127 16'777'214 B 128.0.0.0 - 191.255.255.255 16'384 65'534 C 192.0.0.0-223.255.255.255 2'097'152 254 Die Klasse D (224.0.0.0 - 239.255.255.255) sind f\u00fcr Multicast-Adressen vorgesehen. Dies ist ein separates Protokoll mit separaten Adressierung. Die Klasse E (224.0.0.0 - 255.255.255.255) ist reserviert f\u00fcr zuk\u00fcnftige Netzwerke. Die folgenden privaten Netzwerke gibt es: Klasse Netzadresse Subnetmaske A 10.0.0.0 255.0.0.0 B 172.16.0.0 - 172.31.0.0 255.255.0.0 C 192.168.0.0 - 192.168.255.0 255.255.255.0","title":"Classful vs Classless"},{"location":"22FS/KT/06_Network%20Layer.html#netmask","text":"Die IP-Adresse ist in zwei Teile aufgeteilt: Die Netzadresse und Host-Adressen. Die Netzmaske unterteilt eine IP-Adresse in die Netzadresse und Hostadresse. Alternativ schreibweisse ist \"/24\" f\u00fcr eine Subnetzmaske mit 24 1 und 8 0 . Daher gibt es \\((32-24)^2-2=255-2=254\\) addressierbare Hosts. Es werden noch zwei Adressen abgezogen, da zwei Adressen f\u00fcr die Broadcast- und Netzwerk-Adresse ben\u00f6tigt werden.","title":"Netmask"},{"location":"22FS/KT/06_Network%20Layer.html#routing","text":"Dank routing weiss ein Router wohin ein Paket gesendet werden muss. Dies wird anhand der IP-Adresse gemacht.","title":"Routing"},{"location":"22FS/KT/06_Network%20Layer.html#routing-tabelle","text":"In der Routing-Tabelle steht, \u00fcber welcher Port welches Netzwerk ansprechbar ist. Darin steht der Port, an dem das Netzwerk erreichbar ist, die Netzwerkadresse und Netzmaske. Zus\u00e4tzlich gibt es ein Default-Gateway. \u00dcber diesen werden alle Pakete weitergeleitet, welche zu keinem anderen Netzwerk passt. Es kann f\u00fcr ein Netzwerk mehrere Eintr\u00e4ge geben. Die Routing-Tabelle ist geordnet nach der Netzmaske. Dabei ist das kleinste Netzwerk zu oberst (die h\u00f6chste Subnetz). Die Routing-Tabelle wird von oben nach unten durch geschafft. Zum ersten Hit wird das Paket gesendet.","title":"Routing-Tabelle"},{"location":"22FS/KT/06_Network%20Layer.html#flaches-vs-hirarchisches-routing","text":"Bei Flachem-Routing kennt jeder Router jedes m\u00f6gliche Ziel im Netzwerk und andere Zielnetzwerke. Das Netzwerk Verhalten kann besser vorausgesagt werden und es k\u00f6nnen alternative Routings festgelegt werden, welche verwendet werden, wenn die schnellste Route ausf\u00e4llt. Die Routing-Tabellen aktuell zu halten, ist allerdings ein sehr grossen Aufwand. Beim Hirarchieschen-Routing hat jeder Host zwei Eintr\u00e4ge in der Routing-Tabelle. Ein Eintrag f\u00fcr das lokale Netz und ein Eintrag f\u00fcr alles andere, was an Router weitergeleitet wird.","title":"Flaches- vs Hirarchisches- Routing"},{"location":"22FS/KT/06_Network%20Layer.html#internet-protokoll-ip-format","text":"Das folgende Diagramm zeigt der Header des IP-Protokolles: Version (4 Bit) Gibt die Version des IP-Headers an. Es ist somit m\u00f6glich mehrere IP-Version (IPv4 oder IPv6) zu betreiben. Internet Header Length (IHL) (4 Bit) Gibt die L\u00e4nge allen Headers an. Der gelesene Wert wird mit dem Faktor 4 multipliziert. Wenn also 5 gelesen wird, sind die Headers 20 Bytes lang. IHL muss zwiscehn 5 (20 Bytes) und 15 (60 Bytes) sein. Der fixe Teil eines IP-Headers sind 20 Bytes, also bleiben 40 Bytes f\u00fcr Optionale Felder. Type of Service (8 Bit) Gibt an, was f\u00fcr eine Art von Leitung es ist. Ein Sender kann danach entscheiden, ob er eine Leitung, welche eine hoche Bandbreite hat, daf\u00fcr ein schlechten Ping (wie eine Satelitenverbindung) oder lieber eine \"normale\" Glassfasserleitung ben\u00fctzt. Dies wurde nie von allen Service-Providern unterst\u00fctzt. Total Length (16 Bit) Die totale L\u00e4nget des IP-Paketes mit Headers und Daten. Identifiaction (16 Bit) Ein Wert, welches ein Paket eindeutig identifiziert. Dieser Wert wird ben\u00fctzt, um fragmentierte Pakete wieder zu einem Paket zusammen zusetzen. Flags (3 Bit) Beinhaltet Kontrollflags f\u00fcr die Fragmentierung Feld Position Wert Funktion Erkl\u00e4rung Bit 0 reserved, must be zero Reserviert, immer Null DF Bit 1 0/1 May / Don't Fragment keine Fragmentierung MF Bit 2 0/1 Last / More Fragments Ob ein Folgefragment kommt Fragment Offset (13 Bit) An welcher stelle ein fragmentiertes Paket in das ganze Paket gesetzt werden soll. Der gelesen Wert wird mit dem Faktor 8 multipliziert. (Aus 90 wird 720 Bytes) Time to Live (TTL) (8 Bit) Gibt die Anzahl Sekunden an, welche das Paket noch im Netz sein darf. Wenn der Wert 0 wird, wird das Paket verworfen. In der Praxis ist es schwierig zu messen, wie lange ein Paket unterwegs ist und daher dekrementiert der Router der Wert um 1 wenn er es weiter sendet. Wenn ein Router ein Paket mit TTL=1 erhaltet, dekrementiert er es zu 0 und verwirft es. Protocol (8Bit) Das Protokol, welches im Datenteil \u00fcbertragen wird. Folgendes sind die wichtigsten Beispiele: Protocol Keyword Protokollbezeichnung 1 ICMP Internet Control Message 6 TCP Transmission Controll Protocol 17 UDP User Datagram Protocol Header Checksum (16 Bit) Eine Pr\u00fcfsumme, welche nur \u00fcber den IP-Header gebildet wird. Diese muss von jedem Router neu berechnet werden, da gewisse Felder vom Router modifiziert werden. Source Address (32 Bit) Die IP-Adresse des Senders Destination Address (32 Bit) Die IP-Adresse des Empf\u00e4ngers Options und Padding (max. 40 Bytes) Optionale Felder","title":"Internet Protokoll (IP) Format"},{"location":"22FS/KT/06_Network%20Layer.html#maximum-transfer-unit-mtu","text":"Die MTU gibt an, wie viel Bytes \u00fcber eine Leitung geschickt werden k\u00f6nnen. Dabei werden aber nur die Daten-Bytes des Ethernet-Frames gez\u00e4hlt. Die Bytes des Ethernet-Headers gelten nicht. Headers von gekapselten Protokollen, wie IP oder ICMP, m\u00fcssen nat\u00fcrlich mit gez\u00e4hlt werden, da sie teil der Daten-Bytes des Ethernet-Frames sind.","title":"Maximum Transfer Unit (MTU)"},{"location":"22FS/KT/06_Network%20Layer.html#addressauflosung","text":"TODO","title":"Addressaufl\u00f6sung"},{"location":"22FS/KT/06_Network%20Layer.html#address-resolution-protocoll-arp","text":"ARP ist ein Layer 2 Protokoll, da es die Namensaufl\u00f6sung von IP-Adressen zu MAC-Adressen zul\u00e4sst. Ger\u00e4te haben typischerweisse eine ARP-Tabelle, in welcher ARP-Responses gecachet weden. TODO: Beispiel","title":"Address Resolution Protocoll (ARP)"},{"location":"22FS/KT/06_Network%20Layer.html#gratuitous-arp","text":"Gratuitous heisst unn\u00f6tigt/unbegr\u00fcndet. TODO","title":"Gratuitous ARP"},{"location":"22FS/KT/06_Network%20Layer.html#fragmentieren-und-reassembly","text":"Fragmentieren wird gebraucht, wenn ein Paket \u00fcber eine Leitung geschickt werden soll, welche eine kleinere Maximum Transfer Unit (MTU) hat, als die Gr\u00f6sse des Paketes. In diesem Fall wird das Paket aufgeteilt/fragmentiert. TODO","title":"Fragmentieren und Reassembly"},{"location":"22FS/KT/06_Network%20Layer.html#internet-control-message-protocol-icmp","text":"ICMP Pakete werden der Schicht 3 zugeordnet, obwohl sie in einem IP-Paket gekapselt werden. Es gibt einige Typen von ICMP Paketen: (4 - Source Quench ist depricated - hiess, dass der Sender langs\u00e4mer soll senden. Hat sich er\u00fcbrigt, da es in TCP eingebaut w) ICMP-Type Bedeutung Beispiel 3 Destination Unreachable Wenn der Router ein Node nicht erreiche kann, weil z.B. die MTU zu klein ist, das h\u00f6here Protokoll deaktiviert ist beim Host, das Paket fragmentiert werden muss aber DF gesetzt ist oder der Node ausgesteckt wurde: TODO Code Protocol Unreachable=Node kommuniziert nicht \u00fcber das Protokol; Port Unreachable = Kein Program h\u00f6rt auf diesen Port; 13 Communication adminstrativvely prohibited = Die Firewall blockiert etwas. Destination Unreachable kann auch genutzt werden, um die MTU einer Leitung zu finden 4 Source Quench Der Puffer des Routers ist voll 5 Redirct Wird an ein Host geschickt, wenn der Router feststellt, dass ein Paket an den falschen Router geschickt wurde 11 Time Exceeded Wenn das TTL-Feld =0 ist, wird es vom Router nicht mehr weitergesendet. Dies kann f\u00fcr Trace-Rout genutzt weden. Jeder Router reduziert das TTL-Feld um 1. Wenn der Router ein Paket mit TTL=1 bekommt wird dies um 1 reduziert und danach verworfen. 12 Parameter Problem Falls der Host oder Router im IP-Header einen ung\u00fcltigen Wert hat 0 Echo Reply Die Antowort auf ein Echo Request 8 Echo (-Request) Pingt ein Knoten an, welcher ein Echo Reply senden sollte 13 Timestamp Verhalten sich gleich wie Echo-Requests/-Replies aber senden noch die Zeit des Senders und Empf\u00e4ngers 14 Timestamp Reply Siehe 13 - Timestamp","title":"Internet Control Message Protocol (ICMP)"},{"location":"22FS/KT/06_Network%20Layer.html#destination-unreachable-type-3","text":"Code-Feld : 0 = net unreachable; 1 = host unreachable; 2= protocol unreachable; 3 = port unreachable; 4 fragmentation needed and DF set; 5 source route failed; 13 = communication administratively prohibited Internet Header + 64 Bits of Original Datagram enth\u00e4lt den ersten Teil des Datagramms, das die ICMP-Meldung ausgel\u00f6st hat. Damit ist der urspr\u00fcngliche Absender in der Lage, den Fehler genauer zu bestimmen.","title":"Destination Unreachable (Type 3)"},{"location":"22FS/KT/06_Network%20Layer.html#time-exceeded-message-type-11","text":"Das Format ist gleich, wie bei Destination Unreachable (Type 3). Das Code-Feld kann folgende Werte haben: 0 = time to live exceeded in transit; 1 = fragment reassembly time exceeded.","title":"Time Exceeded Message (Type 11)"},{"location":"22FS/KT/06_Network%20Layer.html#echo-request-reply-message-type-8-type-0","text":"Identifier : ID, damit der Sender die Echo-Reply zu einem Prozess kann. In der Reply steht die selbe Zahl Sequence Number : Wird bei jedem Echo-Request inkrementiert. In der Reply steht die selbe Zahl. Code-Feld : ist null","title":"Echo-Request/-Reply Message (Type 8 / Type 0)"},{"location":"22FS/KT/06_Network%20Layer.html#struktur-von-icmp-pakete","text":"Das ICMP Paket wird in einem IP-Paket verschachtelt ( Protocol=1 steht f\u00fcr den IP-Header).","title":"Struktur von ICMP-Pakete"},{"location":"22FS/KT/06_Network%20Layer.html#anwendungen","text":"MTU einer Leitung finden Daf\u00fcr kann das Don't Fragment auf 1 gesetzt werden und versucht werden, wie hoch Traceroute ping","title":"Anwendungen"},{"location":"22FS/KT/06_Network%20Layer.html#ipv6","text":"IPv6 bnutzt 128 Bits, bzw. 16 Bytes und erm\u00f6glicht es \\(2^{128}\\) Adressen zu generieren. IPv6 bringt zus\u00e4tzlich noch mehr Vorteile: Entlastung der Router Quality of Service: Flow Labels Verbessertes Routing: Routing Header Verbesserte Sicherheitsmechanismen Die MTU wird durch den Absender ermittelt und es gibt daher keine Fragmentierung, was den Router weiter entlastet Ein Interface kann mehrere IPv6 Adressen haben Eine IPv6 Adresse wird Hexadezimal dargestellt: 2001:0620:0000:0004:0A00:20FF:FE9C:7E4A . Dabei k\u00f6nnen Nullen zu begin von Zahlen weggelassen werden ( ...:0620:... = ...:620:... ). Aus dem ergibt sich 2001:620:0:4:A00:20FF:FE9C:7E4A . Zus\u00e4tzlich k\u00f6nnen lange Nullfolgen durch 2 Doppelpunkte ersetzt weden: 1023:0000:0000:0000:1736:a673:88a0:a620 = 1023::1736:a673:88a0:a620 . Der Doppelpunkt darf nur einmal genutzt werden.","title":"IPv6"},{"location":"22FS/KT/06_Network%20Layer.html#ipv6-adressraume","text":"Es gibt eine Loopback Adresse: ::1/28","title":"IPv6 Adressr\u00e4ume"},{"location":"22FS/KT/06_Network%20Layer.html#ipv6-header","text":"Ein IPv6 Header ist 40 Bytes lang (ein IPv4 hat nur 20 Bytes)","title":"IPv6 Header"},{"location":"22FS/KT/06_Network%20Layer.html#header-extension","text":"Im Next Header Feld kann angegeben, was der n\u00e4chste Header oder Protokol ist. Dies reduziert die Gr\u00f6sse, da nur die n\u00f6tigen Headers geschickt werden m\u00fcssen. Ebenfalls gibt es f\u00fcr den Router weniger zu tun, da es weniger Felder zu verarbeiten gibt. In der folgenden Tabele sind die Header-Extension Types und Protokol-Types f\u00fcr das Next Header -Feld im IPv6 Header Hop-by-hop (typ=0) enth\u00e4lt Optionen, die von allen IPv6-Knoten auf der Strecke vom Sender zum Empf\u00e4nger beachtet werden m\u00fcssen. Typisches Beispiel ist die Jumbogram Option. Dieser Extension Header muss immer zuerst stehen. Routing Header (type = 43) Wird vom Sender verwendet, um den Pfad zum Empf\u00e4nger zu bestimmen. Er enth\u00e4lt eine Liste von Routern, \u00fcber die das betreffende IPv6 Paket geleitet wird. Diese Option wurde als Sicherheitsrisiko erkannt und wird nur noch in modifizierter Form f\u00fcr \u00abMobile IPv6\u00bb eingesetzt. Fragment Header (type = 44) Enth\u00e4lt Informationen f\u00fcr das Reassembly analog zu IP V4 Authentication Header AH (type = 51) und Encapsulating Security Payload Header (Type =51) Enthalten Daten, welche die Vertraulichkeit eines IPv6 Pakets sicherstellen (RFC 4302). Destination Options (type = 60) Dieser Header enth\u00e4lt Optionen, welche nur vom Endger\u00e4t beachtet werden m\u00fcssen (im Gegensatz zu den Hop-by-Hop Options). Im folgenden Bild ist ein Beisiel f\u00fcr das Next Header -Feld:","title":"Header Extension"},{"location":"22FS/KT/06_Network%20Layer.html#neigbor-discovery-protcol-ndp","text":"","title":"Neigbor Discovery Protcol (NDP)"},{"location":"22FS/KT/06_Network%20Layer.html#icmpv6","text":"","title":"ICMPv6"},{"location":"22FS/KT/06_Network%20Layer.html#autokonfigurieren","text":"","title":"Autokonfigurieren"},{"location":"22FS/KT/07_Transport%20Layer.html","text":"Transport Layer (Layer 4) [toc] Adressierung Im Layer 4 werden \"Teilnehmer\" bzw. Applikationen mit Ports adressiert. Es gibt dabei ein Source- und ein Destination-Port. E Ein Port ist eine Zahl zwischen 1 und 65'536 und sind folgendermassen unterteilt: 1-1023 : Well-Known Port Nummern, wie z.B. 80 f\u00fcr HTTP 1024-49'151 : Reservierte Bereiche f\u00fcr herstellerspezifischen Applikationen 49'152-65'536 : Dynamische/Private Ports, welche beliebig verwendet werden k\u00f6nnen Die folgende Tabelle enth\u00e4lt die wichtigsten Well-Known Ports: (465/TCP - SMTPS sollte heissen \"SMTP over SSL/TLS\") Um eine Kommunikationsbeziehung eindeutig zu bestimmen braucht es folgende 5 Parameter: Source Port Destination Port Source IP-Adresse Destination IP-Adresse Das Protokol (UDP oder TCP) TCP (Transmission Control Protocol) TCP bietet folgendes f\u00fcr eine Applikation: Verbindungsorientierte \u00dcbetragung : Eine Verbindung muss zuerst aufgebaut werden und eine TCP-Verbindung hat genau 2 Endpunkte (Multicast wird nicht unterst\u00fctzt) Hohe Zuverl\u00e4ssigkeit: TCP garantiert die Daten\u00fcbertragung ohne Verluste in der richtigen Reihenfolge Vollduplex\u00fcbertragung: In einer TCP Verbindung k\u00f6nnen Daten in beide Richtungen fliessen Stream-Schnittstelle: Eine Andwenung kann ein Stream von Bytes senden, welche vom Empf\u00e4nger in derselben Reihenfolge wieder empfangen werden. Zuverl\u00e4ssiger Verbindungsaufbau : Es muss zuerst eine Verbindung aufgebaut werden. Pakete von einer vorherigen Verbindungen sind danach nicht mehr g\u00fcltig Eleganter Verbindungsabbau : Beide Seiten k\u00f6nnen die Verbindung trennen und sie wird sauber abgebaut Siebes Merkmal: ? Im folgenden Diagramm wird aufgezeichnet, wie ein Verbindungsaufbau, das Senden/Empfangen von Nachrichten und der Verbindungsabbau beschreiben. Im folgenden Diagramm sind die feinen Zust\u00e4nde eines Clients oder Server aufgezeichnet: Probleme Die folgenden Probleme m\u00fcssen von TCP gel\u00f6st werden: Eine Verbindung soll zuverl\u00e4ssig auf- und abgebaut werden k\u00f6nnen Eine TCP-Nachricht k\u00f6nnen verloren, verf\u00e4lscht, dupliziert oder verstauscht werden. TCP muss diese Nachrichten trotzdem wieder korrekt zusammen setzen und der Applikationsschicht \u00fcbergeben. Hierf\u00fcr werden Techniken, wie Sequenznummern, Adaptiver Timeout, Sliding Window Protokoll ben\u00fctzt. Der Empf\u00e4nger soll nicht \u00fcberschwemmt werden. Hier f\u00fcr wird Flow Control mit Advertized Window Size gen\u00fctzt. Das Netzwerk dazwischen soll nicht \u00fcberlastet werden. Hier f\u00fcr gibt es Congestion Control mit Slow Start Algorithmus. TCP-Header TCP Source Port und Destination Port : Der genutzte Port auf dem Sender und Empf\u00e4nger Sequence Number : (Bezieht sich auf die Ausgangsdaten) Anhand dieser Zahl k\u00f6nnen Daten in der richtigen Reihenfolge der Applikation \u00fcbergeben werden und es wird die Acknowledgement Number damit berechnet Acknowledgment Number : (Bezieht sich auf die Eingangsdaten) Header Length/Data Offset : Gibt an, wo der TCP-Header mit optionalen Headers aufh\u00f6rt und die Daten beginnen Control Bits : Flags, welche z.B. den Verbindungsaufbau und -abbau einleiten Diese Flags haben die folgende bedeutung: URG : Urgent-Pointer-Feld enh\u00e4lt einen g\u00fcltigen Wert ACK : Acknowledgment Feld enh\u00e4lt einen g\u00fcltigen Wert PSH : (= Push) Empf\u00e4nger soll Daten sofort an die Applikation weiterleiten RST (=Reset) Verbindung zur\u00fccksetzen SYN (=Synchronize) Verbindung aufbauen FIN : Der Sender hat keine Daten mehr zu \u00fcbertragen. Verbindung abbauen Window : Gibt die noch verf\u00fcgbare Buffer-Gr\u00f6sse des Senders an. Wenn ein Empf\u00e4nger 0 im Window-Feld erh\u00e4lt, stoppt er zu senden, bis eine Retransmission mit einem gr\u00f6sseren Window-Feld ankommt. Checksum : Die Checksume des TCP-Pakets Urgent Pointer : Falls URG gesetzt ist, zeigt dieses Feld an, wo die \"Urgent-Daten\" im Datenblock gefunden werden k\u00f6nnen Options : Optionen, wie \"SACK\" oder die maximale Segmentl\u00e4nge (MSS) k\u00f6nnen als optionale Option \u00fcbertragen werden Verbindungsaufbau Im folgenden Sequenz-Diagramm ist der 3-Way-Handshake eines TCP-Verbindungsaufbaus. Ein 3-Way-Handshake ist n\u00f6tig, da der Client, wie auch der Server sicher sein m\u00fcssen, dass sie eine Verbindung hat. Bei einem 2-Way-Handshake (mit nur 2 Nachrichten), weiss nur der Client sicher, dass eine Verbindung steht. Das Sequenzdiagram von oben ist auch noch in folgendem Zustandsdiagram abgebildet. Datenaustausch Im folgenden Diagram sieht man ein Austausch von Datenpaketen, nach dem letzten ACK Paket. Eine Nachricht vom Sender m\u00fcssen vom Client immer mit einem Paket, welches das ACK -Flag Gesetzt hat, best\u00e4tigen werden. Vor dem senden startet der Sender ein Timer. Falls dieser abl\u00e4uft, bevor der Empf\u00e4nger das Paket best\u00e4tigt hat, wird das Paket erneut versendet. Es gibt eine Retransmission . Die Seq Zahl der Antwort des Servers ist die Ack Zahl des Requests. Die Ack Zahl der Antwort des Servers ist die Seq -Zahl + die Anzahl empfangenen Bytes. Der Server kann zur Best\u00e4tigung ein leeres Datenpaket zur\u00fcck senden oder selber Daten senden, welche vom Client best\u00e4tigt werden m\u00fcssen. Verbindungsabbau Im folgenden Sequenzdiagram ist ein Verbinungsabbau aufgezeichnet. Dies ist nur noch ein \"2-Way-Hanshake\" und kann vom Client, wie auch vom Server initialisiert werden. MSL=Maximum Segment Length Das Timeout am Ende ist n\u00f6tig, falls das letzte ACK b+m+1 nicht ankommt. In diesem Fall w\u00fcrde die Passive-Seite noch mals ein FIN b+m Paket senden. Das folgende Zustandsdiagram zeigt der Verbindungsabbau. Adaptive Elemente von TCP Adaptives Timeout Das Timeout von TCP wird adaptiv bestimmt und \u00e4ndert sich \u00fcber die Lebenszeit der Verbindung. Daf\u00fcr werden folgende Formeln ben\u00fctzt: $$ RTO_n=SRTT_n + 4\\cdot RTTVAR_n\\ SRTT_n = (1 - \\alpha )\\cdot SRTT_{n-1}+\\alpha\\cdot RTT_n\\ RTTVAR_n=(1 - \\beta)\\cdot RTTVAR_{n - 1}+\\beta \\cdot \\vert SRTT_n - RTT_n \\vert $$ Dabei steht \\(RTO\\) f\u00fcr Retransmission Time-Out , \\(SRTT\\) f\u00fcr Smoothed Round-Trip-Time und ist ein gewichteter Mittelwert, \\(RTT\\) f\u00fcr Round-Trip-Time und \\(RTTAV\\) f\u00fcr Round-Trip-Time Variance und ist der gewichteter Mittelwert der Abweichung, bzw. die Streuung. Wenn die Roud-Trip-Time \u00fcberschritten wird, wird der Sender das Paket erneut senden. Best\u00e4tigung von Paketen In TCP wird das Sliding-Window Verfahren f\u00fcr die Best\u00e4tigung von Paketen gen\u00fctzt. Der Sender sendet alle Pakete im Fenster und schiebt das Fenster weiter, wenn die \u00e4lteste Nachricht best\u00e4tigt wurde. Im folgenden Bild sieht man auf der linken Seite ein Verfahren, bei dem auf die Best\u00e4tigung des Empf\u00e4ngers gewartet wird. Auf der rechten Seite wird das Sliding-Window Verfahren bent\u00fczt. Sliding Fluss-Steuerung Im folgenden Paket wird angenommen, dass der Empf\u00e4nger mit einer Buffergr\u00f6sse von 2'500 Bytes hat. Der Empf\u00e4nger sendet die verbleibende Buffergr\u00f6sse im Window Feld zur\u00fcck. Wenn der Sender eine Best\u00e4tigung mit Window=0 empf\u00e4ngt, wartet er, bis er dieselbe Best\u00e4tigung mit einer h\u00f6heren Window Feld empf\u00e4ngt. \u00dcberlastung des Netzwerks vermeiden Beim Slow-Start Algorithmus beginnt der Sender mit einer kleinen vordefinierten Gr\u00f6sse und verdoppelt dies mit jedem gesendetem Paket bis er die erste Schwelle erreicht. Danach wird die Paketgr\u00f6sse linear vergr\u00f6ssert bis ein Timeout entsteht. Bei einem Timeout wird die n\u00e4chste Schwelle auf die H\u00e4lfte des Paketes, bei welchem das Timeout entstand. Danach wird wieder ein Slow-Start ausgef\u00fchrt. Es gibt f\u00fcr den Slow-Start Algorithmus folgende Kritikpunkte Die \"S\u00e4gezahnkurven\" verschiedener TCP-Sessions tendieren dazu, sich zu synchronisieren Die Annahme gilt f\u00fcr Wireless-Netze nicht mehr unbedingt, wo relativ viel Paketverlust durch Bitfehler w\u00e4hrend der \u00dcbertragung vorkommt Slow-Start bei kurzen Transfers immer slow (www) Abh\u00e4ngig von Round Trip Time UDP (User Datagram Protocol) UDP, wie auch TCP, ist ein Layer 4 Protokol und ben\u00fctzt Ports zur adressierung. Es ist aber nicht zuverl\u00e4ssig und erledigt nichts gegen Paket Verluste oder vertauschte Pakete. Header Der UDP Header besteht aus 8 Bytes und beinhaltet folgendes:","title":"Transport Layer (Layer 4)"},{"location":"22FS/KT/07_Transport%20Layer.html#transport-layer-layer-4","text":"[toc]","title":"Transport Layer (Layer 4)"},{"location":"22FS/KT/07_Transport%20Layer.html#adressierung","text":"Im Layer 4 werden \"Teilnehmer\" bzw. Applikationen mit Ports adressiert. Es gibt dabei ein Source- und ein Destination-Port. E Ein Port ist eine Zahl zwischen 1 und 65'536 und sind folgendermassen unterteilt: 1-1023 : Well-Known Port Nummern, wie z.B. 80 f\u00fcr HTTP 1024-49'151 : Reservierte Bereiche f\u00fcr herstellerspezifischen Applikationen 49'152-65'536 : Dynamische/Private Ports, welche beliebig verwendet werden k\u00f6nnen Die folgende Tabelle enth\u00e4lt die wichtigsten Well-Known Ports: (465/TCP - SMTPS sollte heissen \"SMTP over SSL/TLS\") Um eine Kommunikationsbeziehung eindeutig zu bestimmen braucht es folgende 5 Parameter: Source Port Destination Port Source IP-Adresse Destination IP-Adresse Das Protokol (UDP oder TCP)","title":"Adressierung"},{"location":"22FS/KT/07_Transport%20Layer.html#tcp-transmission-control-protocol","text":"TCP bietet folgendes f\u00fcr eine Applikation: Verbindungsorientierte \u00dcbetragung : Eine Verbindung muss zuerst aufgebaut werden und eine TCP-Verbindung hat genau 2 Endpunkte (Multicast wird nicht unterst\u00fctzt) Hohe Zuverl\u00e4ssigkeit: TCP garantiert die Daten\u00fcbertragung ohne Verluste in der richtigen Reihenfolge Vollduplex\u00fcbertragung: In einer TCP Verbindung k\u00f6nnen Daten in beide Richtungen fliessen Stream-Schnittstelle: Eine Andwenung kann ein Stream von Bytes senden, welche vom Empf\u00e4nger in derselben Reihenfolge wieder empfangen werden. Zuverl\u00e4ssiger Verbindungsaufbau : Es muss zuerst eine Verbindung aufgebaut werden. Pakete von einer vorherigen Verbindungen sind danach nicht mehr g\u00fcltig Eleganter Verbindungsabbau : Beide Seiten k\u00f6nnen die Verbindung trennen und sie wird sauber abgebaut Siebes Merkmal: ? Im folgenden Diagramm wird aufgezeichnet, wie ein Verbindungsaufbau, das Senden/Empfangen von Nachrichten und der Verbindungsabbau beschreiben. Im folgenden Diagramm sind die feinen Zust\u00e4nde eines Clients oder Server aufgezeichnet:","title":"TCP (Transmission Control Protocol)"},{"location":"22FS/KT/07_Transport%20Layer.html#probleme","text":"Die folgenden Probleme m\u00fcssen von TCP gel\u00f6st werden: Eine Verbindung soll zuverl\u00e4ssig auf- und abgebaut werden k\u00f6nnen Eine TCP-Nachricht k\u00f6nnen verloren, verf\u00e4lscht, dupliziert oder verstauscht werden. TCP muss diese Nachrichten trotzdem wieder korrekt zusammen setzen und der Applikationsschicht \u00fcbergeben. Hierf\u00fcr werden Techniken, wie Sequenznummern, Adaptiver Timeout, Sliding Window Protokoll ben\u00fctzt. Der Empf\u00e4nger soll nicht \u00fcberschwemmt werden. Hier f\u00fcr wird Flow Control mit Advertized Window Size gen\u00fctzt. Das Netzwerk dazwischen soll nicht \u00fcberlastet werden. Hier f\u00fcr gibt es Congestion Control mit Slow Start Algorithmus.","title":"Probleme"},{"location":"22FS/KT/07_Transport%20Layer.html#tcp-header","text":"TCP Source Port und Destination Port : Der genutzte Port auf dem Sender und Empf\u00e4nger Sequence Number : (Bezieht sich auf die Ausgangsdaten) Anhand dieser Zahl k\u00f6nnen Daten in der richtigen Reihenfolge der Applikation \u00fcbergeben werden und es wird die Acknowledgement Number damit berechnet Acknowledgment Number : (Bezieht sich auf die Eingangsdaten) Header Length/Data Offset : Gibt an, wo der TCP-Header mit optionalen Headers aufh\u00f6rt und die Daten beginnen Control Bits : Flags, welche z.B. den Verbindungsaufbau und -abbau einleiten Diese Flags haben die folgende bedeutung: URG : Urgent-Pointer-Feld enh\u00e4lt einen g\u00fcltigen Wert ACK : Acknowledgment Feld enh\u00e4lt einen g\u00fcltigen Wert PSH : (= Push) Empf\u00e4nger soll Daten sofort an die Applikation weiterleiten RST (=Reset) Verbindung zur\u00fccksetzen SYN (=Synchronize) Verbindung aufbauen FIN : Der Sender hat keine Daten mehr zu \u00fcbertragen. Verbindung abbauen Window : Gibt die noch verf\u00fcgbare Buffer-Gr\u00f6sse des Senders an. Wenn ein Empf\u00e4nger 0 im Window-Feld erh\u00e4lt, stoppt er zu senden, bis eine Retransmission mit einem gr\u00f6sseren Window-Feld ankommt. Checksum : Die Checksume des TCP-Pakets Urgent Pointer : Falls URG gesetzt ist, zeigt dieses Feld an, wo die \"Urgent-Daten\" im Datenblock gefunden werden k\u00f6nnen Options : Optionen, wie \"SACK\" oder die maximale Segmentl\u00e4nge (MSS) k\u00f6nnen als optionale Option \u00fcbertragen werden","title":"TCP-Header"},{"location":"22FS/KT/07_Transport%20Layer.html#verbindungsaufbau","text":"Im folgenden Sequenz-Diagramm ist der 3-Way-Handshake eines TCP-Verbindungsaufbaus. Ein 3-Way-Handshake ist n\u00f6tig, da der Client, wie auch der Server sicher sein m\u00fcssen, dass sie eine Verbindung hat. Bei einem 2-Way-Handshake (mit nur 2 Nachrichten), weiss nur der Client sicher, dass eine Verbindung steht. Das Sequenzdiagram von oben ist auch noch in folgendem Zustandsdiagram abgebildet.","title":"Verbindungsaufbau"},{"location":"22FS/KT/07_Transport%20Layer.html#datenaustausch","text":"Im folgenden Diagram sieht man ein Austausch von Datenpaketen, nach dem letzten ACK Paket. Eine Nachricht vom Sender m\u00fcssen vom Client immer mit einem Paket, welches das ACK -Flag Gesetzt hat, best\u00e4tigen werden. Vor dem senden startet der Sender ein Timer. Falls dieser abl\u00e4uft, bevor der Empf\u00e4nger das Paket best\u00e4tigt hat, wird das Paket erneut versendet. Es gibt eine Retransmission . Die Seq Zahl der Antwort des Servers ist die Ack Zahl des Requests. Die Ack Zahl der Antwort des Servers ist die Seq -Zahl + die Anzahl empfangenen Bytes. Der Server kann zur Best\u00e4tigung ein leeres Datenpaket zur\u00fcck senden oder selber Daten senden, welche vom Client best\u00e4tigt werden m\u00fcssen.","title":"Datenaustausch"},{"location":"22FS/KT/07_Transport%20Layer.html#verbindungsabbau","text":"Im folgenden Sequenzdiagram ist ein Verbinungsabbau aufgezeichnet. Dies ist nur noch ein \"2-Way-Hanshake\" und kann vom Client, wie auch vom Server initialisiert werden. MSL=Maximum Segment Length Das Timeout am Ende ist n\u00f6tig, falls das letzte ACK b+m+1 nicht ankommt. In diesem Fall w\u00fcrde die Passive-Seite noch mals ein FIN b+m Paket senden. Das folgende Zustandsdiagram zeigt der Verbindungsabbau.","title":"Verbindungsabbau"},{"location":"22FS/KT/07_Transport%20Layer.html#adaptive-elemente-von-tcp","text":"","title":"Adaptive Elemente von TCP"},{"location":"22FS/KT/07_Transport%20Layer.html#adaptives-timeout","text":"Das Timeout von TCP wird adaptiv bestimmt und \u00e4ndert sich \u00fcber die Lebenszeit der Verbindung. Daf\u00fcr werden folgende Formeln ben\u00fctzt: $$ RTO_n=SRTT_n + 4\\cdot RTTVAR_n\\ SRTT_n = (1 - \\alpha )\\cdot SRTT_{n-1}+\\alpha\\cdot RTT_n\\ RTTVAR_n=(1 - \\beta)\\cdot RTTVAR_{n - 1}+\\beta \\cdot \\vert SRTT_n - RTT_n \\vert $$ Dabei steht \\(RTO\\) f\u00fcr Retransmission Time-Out , \\(SRTT\\) f\u00fcr Smoothed Round-Trip-Time und ist ein gewichteter Mittelwert, \\(RTT\\) f\u00fcr Round-Trip-Time und \\(RTTAV\\) f\u00fcr Round-Trip-Time Variance und ist der gewichteter Mittelwert der Abweichung, bzw. die Streuung. Wenn die Roud-Trip-Time \u00fcberschritten wird, wird der Sender das Paket erneut senden.","title":"Adaptives Timeout"},{"location":"22FS/KT/07_Transport%20Layer.html#bestatigung-von-paketen","text":"In TCP wird das Sliding-Window Verfahren f\u00fcr die Best\u00e4tigung von Paketen gen\u00fctzt. Der Sender sendet alle Pakete im Fenster und schiebt das Fenster weiter, wenn die \u00e4lteste Nachricht best\u00e4tigt wurde. Im folgenden Bild sieht man auf der linken Seite ein Verfahren, bei dem auf die Best\u00e4tigung des Empf\u00e4ngers gewartet wird. Auf der rechten Seite wird das Sliding-Window Verfahren bent\u00fczt. Sliding","title":"Best\u00e4tigung von Paketen"},{"location":"22FS/KT/07_Transport%20Layer.html#fluss-steuerung","text":"Im folgenden Paket wird angenommen, dass der Empf\u00e4nger mit einer Buffergr\u00f6sse von 2'500 Bytes hat. Der Empf\u00e4nger sendet die verbleibende Buffergr\u00f6sse im Window Feld zur\u00fcck. Wenn der Sender eine Best\u00e4tigung mit Window=0 empf\u00e4ngt, wartet er, bis er dieselbe Best\u00e4tigung mit einer h\u00f6heren Window Feld empf\u00e4ngt.","title":"Fluss-Steuerung"},{"location":"22FS/KT/07_Transport%20Layer.html#uberlastung-des-netzwerks-vermeiden","text":"Beim Slow-Start Algorithmus beginnt der Sender mit einer kleinen vordefinierten Gr\u00f6sse und verdoppelt dies mit jedem gesendetem Paket bis er die erste Schwelle erreicht. Danach wird die Paketgr\u00f6sse linear vergr\u00f6ssert bis ein Timeout entsteht. Bei einem Timeout wird die n\u00e4chste Schwelle auf die H\u00e4lfte des Paketes, bei welchem das Timeout entstand. Danach wird wieder ein Slow-Start ausgef\u00fchrt. Es gibt f\u00fcr den Slow-Start Algorithmus folgende Kritikpunkte Die \"S\u00e4gezahnkurven\" verschiedener TCP-Sessions tendieren dazu, sich zu synchronisieren Die Annahme gilt f\u00fcr Wireless-Netze nicht mehr unbedingt, wo relativ viel Paketverlust durch Bitfehler w\u00e4hrend der \u00dcbertragung vorkommt Slow-Start bei kurzen Transfers immer slow (www) Abh\u00e4ngig von Round Trip Time","title":"\u00dcberlastung des Netzwerks vermeiden"},{"location":"22FS/KT/07_Transport%20Layer.html#udp-user-datagram-protocol","text":"UDP, wie auch TCP, ist ein Layer 4 Protokol und ben\u00fctzt Ports zur adressierung. Es ist aber nicht zuverl\u00e4ssig und erledigt nichts gegen Paket Verluste oder vertauschte Pakete.","title":"UDP (User Datagram Protocol)"},{"location":"22FS/KT/07_Transport%20Layer.html#header","text":"Der UDP Header besteht aus 8 Bytes und beinhaltet folgendes:","title":"Header"},{"location":"22FS/KT/08_Application_Layer.html","text":"Application Layer Application Layer DNS Record Arten Root Servers Ablauf eines Namensaufl\u00f6sung Reverse DNS BOOTP / DHCP Nachteile DHCP TFTP NAT Port Mapping NAT und OSI SMTP Befehle Nachrichten MIME Base 64 Quote Printable HTTP DNS Jeder Full Qualified Domain Name (FQDN) muss eindeutig sein. Dass heisst, Geschwister-Knoten d\u00fcrfen nicht den selben Namen haben. Record Arten Es gibt mehrere Typen von Records, welche verschiedene Informationen enthalten. Root Servers Ein Root Server ist ein DNS-Server, welcher weiss wo z.B. der ch DNS-Server ist. Er ist auf der obersten Stufe. Weltweit gibt es fast 4000 Root Servers. Ablauf eines Namensaufl\u00f6sung Reverse DNS BOOTP / DHCP BOOTP l\u00e4uft auf dem UDP Port 67 f\u00fcr den Server und 68 f\u00fcr den Client. Zu begin kenn ein BOOTP-Client nur seine eigene Mac-Adresse (nicht aber seine IP-Adresse). Daher sendet er ein Broadcast-Adresse mit seiner Mac-Addresse. Der BootP-Server empf\u00e4ngt dieser und sendet die n\u00f6tigen Netzwerk-Daten zur\u00fcck und wo das Image-File liegt, dass der Client dies herunter laden kann. BOOTP ben\u00f6tigt zwei Ports, da der Client ein Brodcast auf dem Port 67 schickt und der Server eine Antwort als Broadcast an den Port 68. Wenn dies \u00fcber Netzwerkgrenzen funktionieren soll, muss der Router wissen, dass Pakete an den Port 67 und 68 weiter geleitet werden soll. Ein BootP-Server kann ein Broadcast an alle Clients senden, wenn ein Update des Boot-Image gibt und so die Client benachrichtigen. Dies kann auch vom Server kommen ohne das ein Client anfragt. Folgenden Screenshot ist das Paket Format gezeigt: (fortsetzung des oberen Screenshots) Nachteile Nachteile: Alles Statisch: Eine gesetzte IP-Adresse ist besetzt, auch wenn das Ger\u00e4t nicht online ist Manuelle Verwaltung: Alles muss manuell eingetragen werden DHCP DHCP (Dynamic Host Configuration Protocol) ist r\u00fcckw\u00e4rtskompatibel mit BOOTP und benutzt dasselbe Paketformat und dieselben Ports. Damit der DHCP-Server noch weiss, ob ein Client noch gibt, m\u00fcssen Clients ein DHCP-Response senden, bevor die Lease-Time ablauft. Sonst w\u00fcrde die Adresse wieder freigegeben werden. Ein DHCP schickt mindestens: IP-Adresse Subnetzmaske Default Gateway Adresse DNS-Server Adresse Dynamischer Hostname Domain Name (z.B. \"zhaw.ch\") Optional k\u00f6nnte unter anderem auch noch ein TFTP-Server und ein Boot Image File gesendet werden. Ablauf eines DHCP-Reuqests. TFTP TFTP ist der \"sehr kleine Bruder\" zu FTP und ben\u00fctzt den UDP Port 69. TODO NAT NAT steht f\u00fcr Network Address Translation und wird ben\u00fctzt, da es zu wenig IPv4 Adressen hat, um jeden eine solche Adresse zu verteilen. Dabei hat nur noch der Router eine \u00f6ffentliche IP Adresse. Interne IP-Adressen sind in einem privaten Adressen bereich (wie 192.168.X.X, 172.X.X.X oder 10.X.X.X). TODO: Genaues vorgehen beschreiben Port Mapping TODO NAT und OSI NAT folgt nicht dem OSI-Schichten Model, da der Router die TCP/UDP Pakete lesen und schreiben muss. Daher muss die IP-Adresse und Port unverschl\u00fcsselt bleiben. SMTP SMTP steht f\u00fcr Simple Mail Protocol und ben\u00fctzt den TCP Port 25. Befehle Es gibt mehrere Befehle, welche an den Server geschickt werden. Der Server Antwortet mit Status-Codes, \u00e4hnlich wie in HTTP. HELLO ethz.ch Client meldet sich beim Server MAIL FROM max.muster@ethz.ch Client meldet den Sender RCPT TO hans.muster@zhaw.ch Client meldet den Empf\u00e4nger. Es k\u00f6nnen mehrere RCPT TO versendet werden. DATA Client m\u00f6chte Mail versenden. Die Daten sind fertig, wenn ein einzelnen . auf einer Zeile steht QUIT Baut die SMTP Verbindung ab Hier nun ein Beispiel: > telnet mail.zhaw.ch 25 S: 220 mail.zhaw.ch ESMTP \u2026 ready C: HELO zhaw.ch S: 250 mail.zhaw.ch C: MAIL FROM: <muth@zhaw.ch> S: 250 OK C: RCPT TO: <klsr@zhaw.ch> S: 250 <klsr@zhaw.ch>... Recipient ok C: RCPT TO: <ksha@zhaw.ch> S: 250 <ksha@zhaw.ch>... Recipient ok C: DATA S: 354 Enter mail, end with \".\" on a line by itself C: Date: Sat,6 Jan 2099 16:34:25 +0100 C: To: klsr@zhaw.ch C: Cc: ksha@zhaw.ch C: Subject: Test einer Mail. C: C: Damit ist der SMTP-Teil beendet. C: C: Gruss Thomas -- und jetzt? C: . S: 250 OK C: QUIT S: 221 mail.zhaw.ch closing connection Nachrichten Nachrichten in SMTP werden mit 7-Bit ASCII verschickt. Dabei gibt es mehrere Header-Zeilen, welche von zwei Carriage Return und Line Feeds ( \\r\\n\\r\\n ) von der Nachricht getrennt sind. MIME MIME steht f\u00fcr Multipurpose Internet Mail Extensions und stellt eine Codierung da, beliebige Daten \u00fcber 7-Bit ASCII zu verschicken. Dabei gibt es ein Mime-Separator, welcher die verschiedene MIME Teile teilt. Dieser wird mit dem Header Boundary angegeben. Der Content-Type der ganzen Nachricht ist multipart/mixed . Nach jedem Mime-Seperator gibt es zudem noch ein Content-Type Header, welcher die Art der Daten zwischen den Seperator darstellt. Die Nachrichten selbst kann als Base64 oder Quote-Printable enkodiert werden. MIME-Version: 1.0 Content-Type: Multipart/Mixed ; Boundary=\"Mime-Separator-WAB02622.926626671\" Mime-Separator-WAB02622.926626671 Content-Type: text/plain Hier folgt der Text... bla... fasel Mime-Separator-WAB02622.926626671 Content-Type: text/html <HTML>...</HTML> TODO: SMTP Status Codes Base 64 TODO Quote Printable TODO HTTP HTTP steht f\u00fcr Hypertext Transfer Protocol und funktioniert auf dem TCP Port 80. TODO: HTTP","title":"Application Layer"},{"location":"22FS/KT/08_Application_Layer.html#application-layer","text":"Application Layer DNS Record Arten Root Servers Ablauf eines Namensaufl\u00f6sung Reverse DNS BOOTP / DHCP Nachteile DHCP TFTP NAT Port Mapping NAT und OSI SMTP Befehle Nachrichten MIME Base 64 Quote Printable HTTP","title":"Application Layer"},{"location":"22FS/KT/08_Application_Layer.html#dns","text":"Jeder Full Qualified Domain Name (FQDN) muss eindeutig sein. Dass heisst, Geschwister-Knoten d\u00fcrfen nicht den selben Namen haben.","title":"DNS"},{"location":"22FS/KT/08_Application_Layer.html#record-arten","text":"Es gibt mehrere Typen von Records, welche verschiedene Informationen enthalten.","title":"Record Arten"},{"location":"22FS/KT/08_Application_Layer.html#root-servers","text":"Ein Root Server ist ein DNS-Server, welcher weiss wo z.B. der ch DNS-Server ist. Er ist auf der obersten Stufe. Weltweit gibt es fast 4000 Root Servers.","title":"Root Servers"},{"location":"22FS/KT/08_Application_Layer.html#ablauf-eines-namensauflosung","text":"","title":"Ablauf eines Namensaufl\u00f6sung"},{"location":"22FS/KT/08_Application_Layer.html#reverse-dns","text":"","title":"Reverse DNS"},{"location":"22FS/KT/08_Application_Layer.html#bootp-dhcp","text":"BOOTP l\u00e4uft auf dem UDP Port 67 f\u00fcr den Server und 68 f\u00fcr den Client. Zu begin kenn ein BOOTP-Client nur seine eigene Mac-Adresse (nicht aber seine IP-Adresse). Daher sendet er ein Broadcast-Adresse mit seiner Mac-Addresse. Der BootP-Server empf\u00e4ngt dieser und sendet die n\u00f6tigen Netzwerk-Daten zur\u00fcck und wo das Image-File liegt, dass der Client dies herunter laden kann. BOOTP ben\u00f6tigt zwei Ports, da der Client ein Brodcast auf dem Port 67 schickt und der Server eine Antwort als Broadcast an den Port 68. Wenn dies \u00fcber Netzwerkgrenzen funktionieren soll, muss der Router wissen, dass Pakete an den Port 67 und 68 weiter geleitet werden soll. Ein BootP-Server kann ein Broadcast an alle Clients senden, wenn ein Update des Boot-Image gibt und so die Client benachrichtigen. Dies kann auch vom Server kommen ohne das ein Client anfragt. Folgenden Screenshot ist das Paket Format gezeigt: (fortsetzung des oberen Screenshots)","title":"BOOTP / DHCP"},{"location":"22FS/KT/08_Application_Layer.html#nachteile","text":"Nachteile: Alles Statisch: Eine gesetzte IP-Adresse ist besetzt, auch wenn das Ger\u00e4t nicht online ist Manuelle Verwaltung: Alles muss manuell eingetragen werden","title":"Nachteile"},{"location":"22FS/KT/08_Application_Layer.html#dhcp","text":"DHCP (Dynamic Host Configuration Protocol) ist r\u00fcckw\u00e4rtskompatibel mit BOOTP und benutzt dasselbe Paketformat und dieselben Ports. Damit der DHCP-Server noch weiss, ob ein Client noch gibt, m\u00fcssen Clients ein DHCP-Response senden, bevor die Lease-Time ablauft. Sonst w\u00fcrde die Adresse wieder freigegeben werden. Ein DHCP schickt mindestens: IP-Adresse Subnetzmaske Default Gateway Adresse DNS-Server Adresse Dynamischer Hostname Domain Name (z.B. \"zhaw.ch\") Optional k\u00f6nnte unter anderem auch noch ein TFTP-Server und ein Boot Image File gesendet werden. Ablauf eines DHCP-Reuqests.","title":"DHCP"},{"location":"22FS/KT/08_Application_Layer.html#tftp","text":"TFTP ist der \"sehr kleine Bruder\" zu FTP und ben\u00fctzt den UDP Port 69. TODO","title":"TFTP"},{"location":"22FS/KT/08_Application_Layer.html#nat","text":"NAT steht f\u00fcr Network Address Translation und wird ben\u00fctzt, da es zu wenig IPv4 Adressen hat, um jeden eine solche Adresse zu verteilen. Dabei hat nur noch der Router eine \u00f6ffentliche IP Adresse. Interne IP-Adressen sind in einem privaten Adressen bereich (wie 192.168.X.X, 172.X.X.X oder 10.X.X.X). TODO: Genaues vorgehen beschreiben","title":"NAT"},{"location":"22FS/KT/08_Application_Layer.html#port-mapping","text":"TODO","title":"Port Mapping"},{"location":"22FS/KT/08_Application_Layer.html#nat-und-osi","text":"NAT folgt nicht dem OSI-Schichten Model, da der Router die TCP/UDP Pakete lesen und schreiben muss. Daher muss die IP-Adresse und Port unverschl\u00fcsselt bleiben.","title":"NAT und OSI"},{"location":"22FS/KT/08_Application_Layer.html#smtp","text":"SMTP steht f\u00fcr Simple Mail Protocol und ben\u00fctzt den TCP Port 25.","title":"SMTP"},{"location":"22FS/KT/08_Application_Layer.html#befehle","text":"Es gibt mehrere Befehle, welche an den Server geschickt werden. Der Server Antwortet mit Status-Codes, \u00e4hnlich wie in HTTP. HELLO ethz.ch Client meldet sich beim Server MAIL FROM max.muster@ethz.ch Client meldet den Sender RCPT TO hans.muster@zhaw.ch Client meldet den Empf\u00e4nger. Es k\u00f6nnen mehrere RCPT TO versendet werden. DATA Client m\u00f6chte Mail versenden. Die Daten sind fertig, wenn ein einzelnen . auf einer Zeile steht QUIT Baut die SMTP Verbindung ab Hier nun ein Beispiel: > telnet mail.zhaw.ch 25 S: 220 mail.zhaw.ch ESMTP \u2026 ready C: HELO zhaw.ch S: 250 mail.zhaw.ch C: MAIL FROM: <muth@zhaw.ch> S: 250 OK C: RCPT TO: <klsr@zhaw.ch> S: 250 <klsr@zhaw.ch>... Recipient ok C: RCPT TO: <ksha@zhaw.ch> S: 250 <ksha@zhaw.ch>... Recipient ok C: DATA S: 354 Enter mail, end with \".\" on a line by itself C: Date: Sat,6 Jan 2099 16:34:25 +0100 C: To: klsr@zhaw.ch C: Cc: ksha@zhaw.ch C: Subject: Test einer Mail. C: C: Damit ist der SMTP-Teil beendet. C: C: Gruss Thomas -- und jetzt? C: . S: 250 OK C: QUIT S: 221 mail.zhaw.ch closing connection","title":"Befehle"},{"location":"22FS/KT/08_Application_Layer.html#nachrichten","text":"Nachrichten in SMTP werden mit 7-Bit ASCII verschickt. Dabei gibt es mehrere Header-Zeilen, welche von zwei Carriage Return und Line Feeds ( \\r\\n\\r\\n ) von der Nachricht getrennt sind.","title":"Nachrichten"},{"location":"22FS/KT/08_Application_Layer.html#mime","text":"MIME steht f\u00fcr Multipurpose Internet Mail Extensions und stellt eine Codierung da, beliebige Daten \u00fcber 7-Bit ASCII zu verschicken. Dabei gibt es ein Mime-Separator, welcher die verschiedene MIME Teile teilt. Dieser wird mit dem Header Boundary angegeben. Der Content-Type der ganzen Nachricht ist multipart/mixed . Nach jedem Mime-Seperator gibt es zudem noch ein Content-Type Header, welcher die Art der Daten zwischen den Seperator darstellt. Die Nachrichten selbst kann als Base64 oder Quote-Printable enkodiert werden. MIME-Version: 1.0 Content-Type: Multipart/Mixed ; Boundary=\"Mime-Separator-WAB02622.926626671\" Mime-Separator-WAB02622.926626671 Content-Type: text/plain Hier folgt der Text... bla... fasel Mime-Separator-WAB02622.926626671 Content-Type: text/html <HTML>...</HTML> TODO: SMTP Status Codes","title":"MIME"},{"location":"22FS/KT/08_Application_Layer.html#base-64","text":"TODO","title":"Base 64"},{"location":"22FS/KT/08_Application_Layer.html#quote-printable","text":"TODO","title":"Quote Printable"},{"location":"22FS/KT/08_Application_Layer.html#http","text":"HTTP steht f\u00fcr Hypertext Transfer Protocol und funktioniert auf dem TCP Port 80. TODO: HTTP","title":"HTTP"},{"location":"22FS/KT/summary.html","tags":["summary","KT"],"text":"Summary Hex Dez Bin Hex Dez Bin 0 0 0 8 8 1000 1 1 1 9 9 1001 2 2 10 A 10 1010 3 3 11 B 11 1011 4 4 100 C 12 1100 5 5 101 D 13 1101 6 6 110 E 14 1110 7 7 111 F 15 1111 Physical Layer (Bit\u00fcbertragungsschicht) (Layer 1) Das physikalische Medium, was die Ger\u00e4te verbindet. Dies kann ausgetauscht werden und die anderen Schichten bleiben umbetroffen. Formeln Begriff Erkl\u00e4rung Baud-Rate Anzahl Symbole pro Sekunde. Ein Symbol ist ein Zustand im Datenstrom Bitrate (Nyquist) \\(f_s \\le 2B\\) Dabei ist \\(f_S\\) die Baud-Rate und \\(B\\) die Bandbreite des Kanals in Hz Frame-Rate \\(F\\) \\(F=\\frac B {(7+1+6+6+2+P+4+12)\\cdot 8}=\\frac B {38\\cdot 8 + P\\cdot 8}\\) Die Anzahl Ethernet-Frames pro Sekunde (wobei \\(P\\) die Payload-Bytes ist) (min. Datenblock 46 Bytes) Nutz Bitrate \\(N\\) \\(N=F\\cdot P=\\frac{P\\cdot 8 \\cdot B}{38\\cdot 8 + P \\cdot 8}\\) - Die Bitrate, welche f\u00fcr Daten nutzbar ist Delay von Store-Forwards Switch \\(t_{delay}\\) \\(t_{delay}=t_{frame}=\\frac{Framesize}{Bitrate}\\) - Wie lange das Senden eines Frames ben\u00f6tigt Transfer Delay \\(t_{transfer}\\) \\(t_{transfer}=\\frac d {C_{wire}}\\) , wobei \\(d\\) die Distanz ist und \\(C_{wire}\\) Lichtgeschwindigkeit im Kabel ist. Wie lange die Daten im Transfer sind Zeichenrate \\(\\frac{Bitrate}{Bits/Zeichen}\\) : Wieviel Zeichen pro Sekunde durch die Leitung passen Zust\u00e4nde \\(M=1+\\frac A {\\Delta V}\\) wobei gilt: \\(A\\) ist die max. Amplitude \\(\\Delta V\\) die Ungenauigkeit des Empf\u00e4ngers Max Bitrate (Hartley's Gesetzt) \\(R [bit/s] \\le 2B [Hz] \\cdot \\log_2(M)\\) , wobei \\(R\\) die max. Bitrate und \\(M\\) die Anzahl Zust\u00e4nde ist Informationsgehalt (Bit) \\(\\log_2(M)\\) Der Informationsgehalt eines Symboles ( \\(M\\) = Anzahl Symbole) Kanalkapazit\u00e4t ( \\(C\\) ) \\(C=B\\cdot \\log_2\\left(1+\\frac S N\\right)\\) , wobei \\(B\\) die Kanal-Bandbreite in Hz ist, \\(S\\) die Signalleistung und \\(N\\) die Rauschleistung Nettobitrate \\(Nettobitrate=Brutobitrate\\cdot\\frac{Nutzdaten}{Nutzdaten + Header}\\) Hamming-Distanz TODO Beispiel: Mit AMI k\u00f6nnen 3 Werte pro Symbol \u00fcbertragen werden. Informationsgehalt: \\(I_S=\\log_2(3)=1.58 \\left[\\frac{Bit}{Symbol}\\right]\\) , da aber nur ein Bit pro Symbol \u00fcbertragen wird, liegt die Effizienz bei \\(\\frac 1 {1.58}=63\\%\\) Physik - Ausbreitungsgeswindigkeit Die Lichtgeschwindigkeit im Glas mit dem Brechungsindex \\(n=1.5\\) ist: \\(c_{Glass}=\\frac{c_0}{n}=\\frac{299'792'458}{1.5}\\approx200'000\\frac{km} s\\) In einem elektrischen Leiter ist es ebenfalls \\(200'000\\frac{km}s\\) Signald\u00e4mpfung Die D\u00e4mpfung ist \\(Signald\u00e4mpfung [dB] = 10\\cdot \\log\\left(\\frac {P1}{P2}\\right)=20\\cdot \\log\\left(\\frac {U1}{U2}\\right)\\) , Dabei ist \\(P\\) die Leistung und \\(U\\) die Anzahl Spannung (Volt). Die D\u00e4mpfung von 6dB heisst eine Leistungsabnahme von 4 und eine Spannungsabnahme von 2 Der D\u00e4mpfungsbelag ist wieviel D\u00e4mpfung \u00fcber 100m oder 1km statfindet (Masseinheit: db/100m oder db/km ) Kabel-Arten Koaxialkabel Bestehen aus einem Leiter und sind geeignet f\u00fcr hochfrequente Signale, haben einen kleinen D\u00e4mpfungsbelag und sind unempfindlich gegen\u00fcber von elektromagnetischen St\u00f6rungen. Die Kabel selbst sind daf\u00fcr relative empfindlich. Paarsymetrische Kabel (Twisted Pair) Das Namensschema von Twisted Pairs ist wie folgt: \\(xx/y\\text{TP}\\) . Werte f\u00fcr \\(xx\\) Werte f\u00fcr \\(y\\) Erkl\u00e4rung U U ungeschirmt F F Folienschirm S S Geflechtschirm SF <gibt es nicht> Schirm aus Geflecht und Folie Schirme funktionieren nur, wenn sie gut geerdet sind! St\u00f6rsignale werden minimiert, in dem auf zwei Kabeln das invertierte gesendet wird. F\u00fcr Elektromagnetische Str\u00f6ungen, sind die Kabel verdrillt. So heben sich die St\u00f6rungen auf Zudem werden noch die Leitung geschirmt. Diese Schirme m\u00fcssen geerdet sein und galvanisch getrennt sein CAT-Kabel Bezeichung Frequenzberreich Data Rate Erkl\u00e4rung CAT-1-4 0.4/4/16/20 MHz 1 / 4 / 10 / 16 Mbps F\u00fcr Telefone und Modemleitungen oder langsames LAN CAT-5 100 MHz 100 Mbps Weitverbreitet. Erlaubt eine max. Bitrate von 1000Mbit/s bis zu 100m CAT-5e 1 Gbps Ethernet, Fastether, Gigabit Ethernet CAT-6 250 MHz 10 Gbps Wird meistens f\u00fcr Gigabit (1000 Mbit/s) ben\u00fctzt CAT-7 600 MHz 10Gbps Geeigent f\u00fcr 10 Gigabit. Es werden aber S/FTP Kabel ben\u00f6tigt CAT-8 2000 MHz 40 Gbps Datenraten bis 40 Gigabit bis zu 30m Glassfasser Vorteile von Glassfasser: Vollst\u00e4nstig unempfindlich gegen\u00fcber elektromagnetischen St\u00f6rungen Kleine Signald\u00e4mpfung und grosse Distanzen Grosse Bandbreite und somit grosse \u00dcbertragunsraten Nachteil: Dispersion (gewisse Photonen sind schneller und l\u00e4ngs\u00e4mer, was das Signal verzerrt.) Delay Skew: Die Zeitabweichung, welche durch die verschiedene Laufzeiten zustande kommen Multimode Stufenfasern : Das Kabel und Mantel ist klar abgegrenzt (ca. Delay Skew 50ns/km) Multimode Gradientenfasern : Der Kern und Mantel haben einen Gradient (ca. Delay Skew 0.5 ns/km) Monomod (Asynchrone und synchrone) Serial vs Parallel Bei der paralleln \u00dcbertragung werden mehrere Signale aufsmal \u00fcbertragen. Bei hohen Takten m\u00fcssen alle Leitungen genau Lange sein und daher kommt es nur auf kurze Distanzen zum einsatz. Bei serieln Verbindungen wird zuerst das LSB (= Least Significant Bit) \u00fcbertragen und zuletzt das MSB (=Most Significant Bit) Bei der synchronen serieln \u00dcbertragung wird ein Clock-Signal \u00fcbertragen. Es werden daher keine Start- und Stop-Bits ben\u00f6tigt Bei der asynchroner serieln \u00dcbertragung wird kein Clock-Signal \u00fcbertragen. Anstatt gibt es ein Start und Stop bit. Wenn der Empf\u00e4nger das Start-Bit erh\u00e4lt. stellt er seine eigene Clock auf diese Zeit ein. Der Takt darf nicht mehr als die halbe Bitzeit T abweichen ( \\(\\text{Frequenz Abweichung in Prozent}=\\frac{0.5T}{9.5T}\\) ). Die Clock startet nach dem Start-Flag. (Zuerst wird das LSB und zuletzt das MSB verschickt) Gleichspannungsfreei Der Sende rund Empf\u00e4nger sind galvanisch getrennt. Dies sch\u00fctzt die Ger\u00e4te, falls beim anderen ein Blitz einschl\u00e4gt. Da hierbei oft mit Capacitors umgesetzt wird, sollte das Signal nicht immer bei 1 oder 0 sein, sonder m\u00f6glicht oft wechseln. Codierungen Bei der AMI-Codierung wird ein 0 als 0V encodiert und 1 abwechslungsweise als U+ und U- Bei der HDB3 Codierung wird zus\u00e4tzlich nach 000 eine 1 mit demselben Pegel wie die letzte 1 gesendet ( 0001 ist gr\u00fcn in der Grafik) . Wenn die Anzahl 1 seit der letzten Regelverletztung gerade ist, wird anstelle 1001 (rot in der Grafik) versendet Manchester-Codierung (10Mbit/s) In Ethernet wird die Manchester-Codierung zwischen 0V und -2V angewendet und daher nicht gleichspannungsfrei. Eine steigene Flanke ist eine 1 eine sinkende Flanke ist eine 0 NRZI-Codierung (Non Return to Zero, Invert on Ones) Diese Codierung wird bei 100BASE-TX verwendet. Bei einer 0 bleibt der Pegel, bei einer 1 wechselt der Pegel. Data Link Layer (Layer 2) Aufgaben: Sichere Verbindung zwischen zwei Teilnehmer (Fehlerkorrektur und erkennung) Verpacking der Daten in Frames (Framing) Frame Erkennung Flow-Controll (Fluss Steuerung) Adresseriung der Teilnehmer (wenn mehrere Teilnehmer im Netz sind) Medium Zugriff (wenn meherere Teilnhemer das Medium teilen) In der Regel wird immer zuerst das MSB und zu letzt das LSB versendet (als wenn auf dem Kabel 010011 gesendet wird, wird das Zeichen 110010 empfangen) Ethernet Frame Preamble und Start Frame Delimiter (SFD) Die Preamble werden 7 Bytes, welche aus Abwechslungsweise 0 und 1 bestehen ( 01010101 = \\(84_{10}=55_{16}\\) , 10101010 = \\(170_{10}=AA_{16}\\) ). Das 8 Byte (das SFD) hat die Form 10101011 (= \\(171_{10}=AB_{16}\\) ) Length/Type Wenn der Wert \\(\\le 1500_{10}=05DC_{16}\\) ist, stellt es die Anzahl von Bytes im Data Feld dar (ohne PAD ). Sonst wird angegeben, was f\u00fcr ein h\u00f6heres Protokoll im Datenfeld enthalten ist. 0x8100 (=33024) ist der VLAN-Tag Typ. 0x0800 (=2048) ist IP. Data/PAD Die Daten (zwischen 0 - 1500 Bytes). Falls die Daten kleiner als 46 Bytes sind, wird dies mit PAD aufgef\u00fcllt Frame Check Sequence CRC32 Checksume Interframe Gap minimaler zeitlichen Abstand zwischen zwei Frames Framing - synchrone und asynchrone \u00dcbertragung asynchroner \u00dcbertragung Es wird ein Frame (Anzahl Elemente; Datenblock mit \\(n\\) Elementen; Fehlererkennung) gesendet und danach ist Ruhe, bis zum n\u00e4chsten Frame synchroner \u00dcbertragung Es wird kontinuierlich Frames gesendet, falls n\u00f6tig auch leere. Es gibt ein Start- und End Flag (meist 01111110 ). Es wird bit-stuffing verwendet, um zu verhindern, dass das Flag im Daten-Block vorkommt. Wenn 5x 1 gesendet wurde, wird eine 0 gesendet, welche vom Empf\u00e4nger ignoriert wird L\u00e4nge eines Frames \\(Nettobitrate=Brutobitrate\\cdot\\frac{Nutzdaten}{Nutzdaten + Header}\\) Je l\u00e4nger ein Frame ist, desto h\u00f6her ist die Nettobitrate. Nachteile: Durchsatz (Wahrscheinlichkeit, dass ein Fehler w\u00e4hrend eines Frames auftritt); Effizienz (Wenn ein Fehler auftritt, ist das es verloren); Zuverl\u00e4ssigkeit (Wahrscheinlichkeit, dass ein undetektierbarer Fehler auftritt steigt); Jitter (Variation der Zeitabst\u00e4nde zwischen Frames) Durchsatz h\u00e4ngt von der Nettobitrate und der Frame-Fehlerwarscheinlichkeit ab $$ \\text{Frame-Erfolgswahrscheinlichkeit: } (1-p_e)^N\\ \\text{Frame-Fehlerwahrscheinlichkeit: } 1-(1-p_e)^N\\ \\text{Optimale Frame-L\u00e4nge: } \\sqrt{\\frac{H}{p_e}}\\ $$ Dabei ist \\(N\\) die L\u00e4nge des Frames, \\(H\\) die L\u00e4nge des Headers und \\(p_e\\) die Bitfehlerwahrscienlichkeit. Flusskontrolle Start-Stop-Meldungen : Wenn der Emp\u00e4ngerbuffer voll l\u00e4uft wird eine Stop-Meldung verschickt. Wenn der Buffer leer wird, wird eine Start-Meldung verschickt Stop-and-Wait : Jede Meldung wird quitiert. Wenn der Buffer voll l\u00e4uft, wird die Quitierung erst sp\u00e4ter gesendet. Fehlererkennung Backward Error Correction: Fehler kann erkennt werden und die Daten neuangefordert werden Forward Error Correction: Die Fehler k\u00f6nnen erkennt und zu einem gewissen Punkt korrigiert werden Blockcodes : Das Hamming-Gewicht=die kleinste Anzahl 1 auf einer Linie der Generator-Matrix Das Hamming-Gewicht ist gleich die Hamming Distanz \\(d_{min}\\) Erkennbare Fehler: \\(d_{min}-1\\) und korrigierbare Fehler: \\(\\frac{d_{min}-1}2\\) Fehlerkorrigierende Codes \\(\\frac {d_{min}-1}2\\) korrigierbar Generatormatrix Bedinungen: f\u00fcr \\(d_{min}=3\\) muss jeder Code (ausser dem 0-Code) min. 3x 1 haben Mindestens eine 1 muss in der Einheitsmatrix sein Jede Pari\u00e4tsmatrix-Zeile muss 2x 1 beinhalten CRC Das Datenpolynom wird um die Anzahl Stellen des Generatorpolynoms verschoben und anschliessend durch das Generatorpolynom geteilt. Das Resultat wird zum Datenpolynom hinzu addiert. Dabei werden die entstandenen 0 des Datenpolynoms gef\u00fcllt. Der Empf\u00e4nger kann den empfangenen Wert durch das Generatorpolynom teilen und muss 0 erhalten.Flusssteuerung LAN Art Erkl\u00e4rung Unicast Ein Paket hat wird genau an ein Ziel gesendet. Das Paket wird mit einer Adresse ausgestattet, so dass es am Ziel sicher ankommt. (Netflix) Broadcast Das Paket wird an alle Knoten im Netzwerk gesendet. Das Paket wird mit einer Broadcast-Adresse ausgestattet (Live-Stream/Twitch) Multicast Das Paket wird an eine Gruppen von Knoten gesendet. (Radio) (Anycast) Mehrere Server mit den selben Adressen. Der Knoten davor entscheidet, an welchen Knoten \u00fcbertragen wird Topologien Topologie Beschreibung Bustopologie Alle Knoten sind an einer Leitung angeschlossen Linientopologie Ein Knoten ist mit dem N\u00e4chsten verbunden. Ringtopologie Eine Linientopologie, mit zusammen gef\u00fcgte Enden Sterntopologie Alle Knoten h\u00e4ngen an einem Hub/Switch Baumtopologie Entsteht, wenn die Sterntopologie hirarchisch kombiniert wird RJ-45 Der Stecker beseitzt 4 Adernpaar, bzw. 8 Adern. IEEE Namensgebung (Bitrate in Mbit/s) (BASE|BROAD)-(Art/Medium L\u00e4nge) 1000BASE-T = Ethernet mit Basisband-Kanalcodierung mit einer Bitrate von 1Gbit/s mit Twisted-Pairs (T) 10BASE5 = 10Mbit/s Basisband-Ethernet mit max 500m (5) Segmentenl\u00e4nge und bis zu 100 Knoten. Es braucht ein dickes Kabel als Shared-Medium 10BASE2 = Thin-Wire-Ethernet, was eine flexiblere und billigere Alternative zu 10BASE5 ist. Der BNC-T \"Stecker\" wurde benutzt. 100BASE-XX: 100 MBit/s Standardt 100BASE-TX: 2 Paar UTP Cat 5 mit max Segmentl\u00e4nge 100m 100BASE-FX: 2 MMF (62.5 \\(\\mu\\) m) mit 2000m Segmentl\u00e4nge 100BASE-T4/2: 4 Paar UTP Cat. 3 mit 100m Segmentl\u00e4nge Fast-Ethernet vs 10Mbit/s Es wird das selbe Frame-Format und Fehlererkennung ben\u00fctzt wie f\u00fcr 10MBit/s. Die Kollisiondomain ist 10 mal kleiner, da die Geschwindikgeit 10 mal gr\u00f6sser ist. Shared-Ethernet Bevor ein Knoten sendet, wartet er, bis die Leitung frei ist. W\u00e4hrend dem Senden wird der Pegel auf der Leitung kontroliert, um kollisisionen fest zu stellen. Wenn eine Kollision festgestellt wurde, wird ein Jamming Signal gesendet und ein zuf\u00e4lliges Vielfache von der Slot-Zeit \\(t_s\\) . Bei der 1. Kollision wird 0x oder 1x gewartet, bei jedem n\u00e4chsten wird der Zeitbereich verdoppelt. Bis zu 16 Versuche, danach wird die \u00dcbertragung abgebrochen. Der andere Sender erkennt nur, dass ein Signal eine Kollision verursacht hat, wenn er w\u00e4hrend des Sendens ein Jamming Signal erhaltet. Medium Access Control (MAC) Master/Slave-Verfahren : (deterministisch) Der Master fragt zyklisch jeden Slave ab und der Slave antwortet mit den vorhanden Daten. So gibt es nie Kollisionen und das Verfahren ist deterministisch, aber der Master ist der single point of failure. Token Passing :(deterministisch) Es wird ein Token von Node zu Node Peer-to-Peer gereicht. Ein Node darf nur senden, wenn er der Token hat. Da der Token verloreren gehen kann, muss es eine M\u00f6glichkeit geben, diesen zu regenerieren. Zeitgesteuerter Zugriff : (deterministisch) Jeder Node hat ein Sende-Slot. Mit diesem Verfahren kann eine hoche Auslastung des Netzes erreicht werden, allerdings muss jeder Node den \"Fahrplan\" und die genaue Zeit kennen. Carrier Sense Multiple Access (CSMA) (undeterministisch): Jeder Knoten pr\u00fcft zuerst ob der Bus frei ist und sendet, wann er will. Carrier Sense Multiple Access / Collision Detection (CSMA/CD) (undeterministisch): Zus\u00e4tzlich werden Kollisionen festgestellt und danach nach einer zuf\u00e4lligen Zeit wieder versucht Carrier Sense Multiple Access with Collision Resolution (CSMA/CR) (undeterministisch): Es gibt ein dominateter Pegel (1 oder 0), welcher gewinnt bei Konflikten. Nur der Verlierer kann dies allerdings feststellen und bricht die \u00dcbertragung ab. Collision Domain Collision Domain Die Collision Domain ist der Bereich des Netzwerks, in welchem ein Fehler erkennt wird. Da der urspr\u00fcngliche Sender nur die Kollision erkennt, wenn er das Jamming Signal w\u00e4hrend des Sendens empf\u00e4ngt, muss die Collision-Domain kleiner als die Halbe-Ausbreitungsdistanz des k\u00fcrzesten Paket (46Bytes Daten) $$ t_{frame} > 2\\cdot t_{transfer}\\ t_{frame} = \\frac{Framesize_{min}}{Bitrate} \\ t_{transfer}=\\frac{d_{max}}{C_{Medium}}\\ d_{max}<\\frac 1 2 \\frac{Framesize_{min}}{Bitrate}\\cdot C_{Medium} $$ Dabei ist \\(d_{max}\\) die Maximale Distanz der Collision Domain Wenn ein Repeater/Hub im Spiel ist, muss die Formel \\(t_{frame} > 2\\left(\\sum t_{transfer} + \\sum t_{forwarding}\\right)\\) benutzen, da der Router das eigentliche Signal, wie auch das Jamming Signal verz\u00f6gert. Die Broadcast-Domain ist der Bereich im Netzwerk, in welcher ein Broadcast-Frame ankommt. Hub vs L-2 Switch (Bridge) Ein Hub ist ein \"dummes\" Ger\u00e4t, welcher alle Informationen an alle Ports senden. Ein Switch liest die Layer 2 Headers and sendet das Paket nur an die n\u00f6tigen Ports. Dadurch wird die Collision Domain unterbrochen. Dies wird auch Transparent Bridging genannt, da die Sender und Empf\u00e4nger nichts davon wissen. Ein Switch merkt sich die Mac-Adressen der Sender und speichert diese mit dem Port in der Filtering Database ab. Dank dieser Datenbank, muss der Switch ein Paket nur an einen Port senden (ausser Broadcast-Frames). Nach einer gewissen Zeit wird ein Eintrag wieder gel\u00f6scht. ( Address Learning ) Ein Switch hat folgende Leistungsmerkmale: Filterrate, Transferrate, Gr\u00f6sse der MAC-Adresstabelle VLAN Bei VLAN wird ein VLAN-Tag zwischen Source-Adress und Length/Type eingef\u00fcgt. Mit diesem Tag kann ein Switch ein Paket einem bestimmten Virtuellen LAN zuordnen. Diese Zuordnung wird in einer Tabelle geregelt. Ein Virtuelles Lan bildet eine Broadcast Domain. Dieser Tag besteht aus: Tag Protocol Identifier : User Priority/Priority Code Point : (3 Bit) Eine Priorit\u00e4t, um z.B. gewisse Applikationen zu priorisieren Cannonical Format Identifier VLAN-Identifier : (12-Bit) (Rapid) Spanning Tree Protocol Beim Rapid Spanning Tree Protocol werden einige Pfade deaktiviert, um Loops zu \"entfernen\". Es muss ein Root-Switch im Baum gefunden werden. Der Root ist der Switch mit der tiefsten Bridge Identifier. Falls zwei die gleiche Haben, entscheided die Mac-Adresse. Zu begin preist jeder Switch sich selbst als Root-Switch an. \u00dcbernimmt aber ein anderen Root-Switch, sobald er eine Nachricht erhaltet, in welchem ein \"besseren\" Root-Switch erw\u00e4hnt wird. In diesen Bridge Protocol Data Unit (BPDU) Nachrichten teilt jeder Switch seinen Nachbarn mit, welches nach seiner Wissen, der n\u00e4chste Root-Switch ist und wie viel der Weg dorthin kostet. Der Root-Port eines Switches ist der Port, \u00fcber welcher der Root-Switch \u00fcber den k\u00fcrzesten Weg erreichbar ist. Alle Bridges senden BPDU-Nachrichten all 2 Sekunden. Falls diese Ausbleiben, wird das Netzwerk neu konfiguriert. Mac-Adresse 04-0A-E0-13-14-26 Im ersten Byte (oben 04 ) 0000 00xy , ist \\(x\\) , ob es eine Group Adress ( 1 ) oder individual Address ( 0 ) ist und \\(y\\) , ob es eine Locally administered Address ( 1 ) oder Universally adinistered address ( 0 ) ist. Die ersten 3 Bytes ist die ID der Hersteller, die letzten 3 Bytes eine Laufnummer ( aa-aa-aa-bb-bb-bb , a ist die ID des Herstellers, b die Laufnummer) Network Layer (Layer 3) Die Aufgabe des Layer 3 ist es die Kommunikation zwischen zwei Konten bereit zu stellen. Dies soll m\u00f6glich sein, unabh\u00e4ngig von den Layern 1 und 2. Daher wird eine netzweite Adressierung (IP-Adressen) ben\u00f6tigt. Grob kann der Layer 2 in verbindungsorientierte Dienste und verbindungslose Dienste unterteilt werden. Ein verbindungsorientierter Dienst muss zuerst eine Verbindung aufbauen und kann sich wie ein Schlauch vorgestellt werden. Alle Daten gehen durch diesen Schlauch. Ein verbindungsloser Dienst funktioniert wie die Post. Klassen Adressbereich Anzahl Netze Interfaces pro netz A 1.0.0.0 - 127.255.255.255 127 16'777'214 B 128.0.0.0 - 191.255.255.255 16'384 65'534 C 192.0.0.0-223.255.255.255 2'097'152 254 Die folgenden privaten Netzwerke gibt es: Klasse Netzadresse Subnetmaske A 10.0.0.0 255.0.0.0 B 172.16.0.0 - 172.31.0.0 255.255.0.0 C 192.168.0.0 - 192.168.255.0 255.255.255.0 APIPA-Netz 169.254.1.0 - 169.254.244.255 255.255.0.0 Anzahl addressierbare Hosts: \\(2^{(32 - subnet)} - 2\\) (f\u00fcr \"/24\" \\(2^{(32-24)}-2=2^8-2=254\\) ) Die Netzadresse ist die tiefste Adresse, die Broadcast-Adresse ist die h\u00f6chste Adresse IP Header Version (4 Bit) Gibt die Version des IP-Headers an. Es ist somit m\u00f6glich mehrere IP-Version (IPv4 oder IPv6) zu betreiben. Internet Header Length (IHL) (4 Bit) Gibt die L\u00e4nge allen Headers an. Der gelesene Wert wird mit dem Faktor 4 multipliziert. Wenn also 5 gelesen wird, sind die Headers 20 Bytes lang. IHL muss zwiscehn 5 (20 Bytes) und 15 (60 Bytes) sein. Der fixe Teil eines IP-Headers sind 20 Bytes, also bleiben 40 Bytes f\u00fcr Optionale Felder. Type of Service (8 Bit) Gibt an, was f\u00fcr eine Art von Leitung es ist. Ein Sender kann danach entscheiden, ob er eine Leitung, welche eine hoche Bandbreite hat, daf\u00fcr ein schlechten Ping (wie eine Satelitenverbindung) oder lieber eine \"normale\" Glassfasserleitung ben\u00fctzt. Dies wurde nie von allen Service-Providern unterst\u00fctzt. Total Length (16 Bit) Die totale L\u00e4nget des IP-Paketes mit Headers und Daten. Identifiaction (16 Bit) Ein Wert, welches ein Paket eindeutig identifiziert. Dieser Wert wird ben\u00fctzt, um fragmentierte Pakete wieder zu einem Paket zusammen zusetzen. Flags (3 Bit) Beinhaltet Kontrollflags f\u00fcr die Fragmentierung Feld Position Wert Funktion Erkl\u00e4rung Bit 0 reserved, must be zero Reserviert, immer Null DF Bit 1 0/1 May / Don't Fragment keine Fragmentierung ( 1 ) MF Bit 2 0/1 Last / More Fragments Ob ein Folgefragment kommt ( 1 ) Fragment Offset (13 Bit) An welcher stelle ein fragmentiertes Paket in das ganze Paket gesetzt werden soll. Der gelesen Wert wird mit dem Faktor 8 multipliziert. (Aus 90 wird 720 Bytes) Time to Live (TTL) (8 Bit) Gibt die Anzahl Sekunden an, welche das Paket noch im Netz sein darf. Wenn der Wert 0 wird, wird das Paket verworfen. In der Praxis ist es schwierig zu messen, wie lange ein Paket unterwegs ist und daher dekrementiert der Router der Wert um 1 wenn er es weiter sendet. Wenn ein Router ein Paket mit TTL=1 erhaltet, dekrementiert er es zu 0 und verwirft es. Protocol (8Bit) Das Protokol, welches im Datenteil \u00fcbertragen wird. Folgendes sind die wichtigsten Beispiele: Protocol Keyword Protokollbezeichnung 1 ICMP Internet Control Message 6 TCP Transmission Controll Protocol 17 UDP User Datagram Protocol Header Checksum (16 Bit) Eine Pr\u00fcfsumme, welche nur \u00fcber den IP-Header gebildet wird. Diese muss von jedem Router neu berechnet werden, da gewisse Felder vom Router modifiziert werden. Source Address (32 Bit) Die IP-Adresse des Senders Destination Address (32 Bit) Die IP-Adresse des Empf\u00e4ngers Options und Padding (max. 40 Bytes) Optionale Felder Maximum Transfer Unit (MTU) Die MTU gibt an, wie viel Bytes \u00fcber eine Leitung geschickt werden k\u00f6nnen. Dabei werden aber nur die Daten-Bytes des Ethernet-Frames gez\u00e4hlt. Die Bytes des Ethernet-Headers gelten nicht. Fragmentation und Reassembly Es gibt folgende F\u00e4lle beim Reassembly: Flag MF =0 und Fragment Offset =0: Es wurde nicht fragmentiert Flag MF =1 und Fragment Offset =0: Dies ist das erste Fragment Flag MF =1 und Fragment Offset >0: Dies ist ein Zwischen-Fragment Flag MF =0 und Fragment Offset >0: Dies ist das letzte Fragment Reassembly wird erst beim Ziel-Host erledigt, um Routers zu entlasten und es zu erm\u00f6glichen, dass Fragmente verschiedene Pfade durchs Netzwerk nehmen k\u00f6nnten. Address Resolution Protocol (ARP) [Layer 2] Ein ARP-Request wird als Broadcast-Message verschickt, die Antwort hingegen nicht. F\u00fcr Requests (Bild von oben), ist die Ethernet-Hardware-Address auf die Broadcast-Adresse angegeben und das Feld Hardware Address of Traget ist null , da es nicht bekannt ist. Bei der Reply ist die Ethernet Address of Destintation) und Hardware Address of Target gesetzt. In einem ARP-Cache werden die Mac-Ip Paare gecached. Ein Gratuitous ARP Request wird von einem Konten beim Booten oder Adresse-Ver\u00e4nderung versendet. Wenn keine Antwort zur\u00fcck kommt, ist die IP-Adresse nicht vergeben. So k\u00f6nnen Adress-Konflikte erkannt werden. Ein Gratuitous ARP Reply wird von Knoten beim Booten oder Adress-Ver\u00e4ndrung versendet um den ARP-Cache anderer Knoten zu berechtigen oder setzen. Da die Reply ohne Request verschickt wurde, wird sie an die Broadcast-Adresse geschickt. Reverse Address Resolution Protocol (RARP) kann genutzt werden, um von einer MAC-Adresse die IP-Adresse zu bekommen von einem zentralen Server. Z.B. von einer Maschine nach einem Reboot. Internet Control Message Protocol (ICMP) [Layer 3] ICMP Pakete werden der Schicht 3 zugeordnet, obwohl sie in einem IP-Paket gekapselt werden. ICMP-Type Bedeutung Beispiel 3 Destination Unreachable Wenn der Router ein Node nicht erreiche kann, weil z.B. die MTU zu klein ist, das h\u00f6here Protokoll deaktiviert ist beim Host, das Paket fragmentiert werden muss aber DF gesetzt ist oder der Node ausgesteckt wurde: TODO Code Protocol Unreachable=Node kommuniziert nicht \u00fcber das Protokol; Port Unreachable = Kein Program h\u00f6rt auf diesen Port; 13 Communication adminstrativvely prohibited = Die Firewall blockiert etwas. Destination Unreachable kann auch genutzt werden, um die MTU einer Leitung zu finden 4 Source Quench Der Puffer des Routers ist voll 5 Redirct Wird an ein Host geschickt, wenn der Router feststellt, dass ein Paket an den falschen Router geschickt wurde 11 Time Exceeded Wenn das TTL-Feld =0 ist, wird es vom Router nicht mehr weitergesendet. Dies kann f\u00fcr Trace-Rout genutzt weden. Jeder Router reduziert das TTL-Feld um 1. Wenn der Router ein Paket mit TTL=1 bekommt wird dies um 1 reduziert und danach verworfen. 12 Parameter Problem Falls der Host oder Router im IP-Header einen ung\u00fcltigen Wert hat 0 Echo Reply Die Antowort auf ein Echo Request 8 Echo (-Request) Pingt ein Knoten an, welcher ein Echo Reply senden sollte 13 Timestamp Verhalten sich gleich wie Echo-Requests/-Replies aber senden noch die Zeit des Senders und Empf\u00e4ngers 14 Timestamp Reply Siehe 13 - Timestamp Destination Unreachable (Type 3) Code-Feld : 0 = net unreachable; 1 = host unreachable; 2= protocol unreachable; 3 = port unreachable; 4 fragmentation needed and DF set; 5 source route failed; 13 = communication administratively prohibited Internet Header + 64 Bits of Original Datagram enth\u00e4lt den ersten Teil des Datagramms, das die ICMP-Meldung ausgel\u00f6st hat. Damit ist der urspr\u00fcngliche Absender in der Lage, den Fehler genauer zu bestimmen. Time Exceeded Message (Type 11) Das Format ist gleich, wie bei Destination Unreachable (Type 3). Das Code-Feld kann folgende Werte haben: 0 = time to live exceeded in transit; 1 = fragment reassembly time exceeded. Echo-Request/-Reply Message (Type 8 / Type 0) Identifier : ID, damit der Sender die Echo-Reply zu einem Prozess kann. In der Reply steht die selbe Zahl Sequence Number : Wird bei jedem Echo-Request inkrementiert. In der Reply steht die selbe Zahl. Code-Feld : ist null Transport Layer (Layer 4) Die Aufgabe des Layer 4 ist es eine effiziente Verbindung zwischen zwei Knoten f\u00fcr den Session Layer (Layer 5) zu bereit stellen. Dabei soll die Qualit\u00e4t der Verbindung gew\u00e4hrgeleistet sein Adressierung Ein Port ist eine Zahl zwischen 1 und 65'536 und sind folgendermassen unterteilt: 1-1023 : Well-Known Port Nummern, wie z.B. 80 f\u00fcr HTTP 1024-49'151 : Reservierte Bereiche f\u00fcr herstellerspezifischen Applikationen 49'152-65'536 : Dynamische/Private Ports, welche beliebig verwendet werden k\u00f6nnen Die folgende Tabelle enth\u00e4lt die wichtigsten Well-Known Ports: (465/TCP - SMTPS sollte heissen \"SMTP over SSL/TLS\") Um eine Kommunikationsbeziehung eindeutig zu bestimmen braucht es folgende 5 Parameter: Source Port; Destination Port; Source IP-Adresse; Destination IP-Adresse; Das Protokol (UDP oder TCP) TCP (Transmission Control Protocol) TCP bietet folgendes f\u00fcr eine Applikation: Verbindungsorientierte \u00dcbetragung : Eine Verbindung muss zuerst aufgebaut werden und eine TCP-Verbindung hat genau 2 Endpunkte (Multicast wird nicht unterst\u00fctzt) Hohe Zuverl\u00e4ssigkeit: TCP garantiert die Daten\u00fcbertragung ohne Verluste in der richtigen Reihenfolge Vollduplex\u00fcbertragung: In einer TCP Verbindung k\u00f6nnen Daten in beide Richtungen fliessen Stream-Schnittstelle: Eine Andwenung kann ein Stream von Bytes senden, welche vom Empf\u00e4nger in derselben Reihenfolge wieder empfangen werden. Zuverl\u00e4ssiger Verbindungsaufbau : Es muss zuerst eine Verbindung aufgebaut werden. Pakete von einer vorherigen Verbindungen sind danach nicht mehr g\u00fcltig Eleganter Verbindungsabbau : Beide Seiten k\u00f6nnen die Verbindung trennen und sie wird sauber abgebaut Im folgenden Diagramm wird aufgezeichnet, wie ein Verbindungsaufbau, das Senden/Empfangen von Nachrichten und der Verbindungsabbau beschreiben. Im folgenden Diagramm sind die feinen Zust\u00e4nde eines Clients oder Server aufgezeichnet: Probleme Die folgenden Probleme m\u00fcssen von TCP gel\u00f6st werden: Eine Verbindung soll zuverl\u00e4ssig auf- und abgebaut werden k\u00f6nnen Eine TCP-Nachricht k\u00f6nnen verloren, verf\u00e4lscht, dupliziert oder verstauscht werden. TCP muss diese Nachrichten trotzdem wieder korrekt zusammen setzen und der Applikationsschicht \u00fcbergeben. Hierf\u00fcr werden Techniken, wie Sequenznummern, Adaptiver Timeout, Sliding Window Protokoll ben\u00fctzt. Der Empf\u00e4nger soll nicht \u00fcberschwemmt werden. Hier f\u00fcr wird Flow Control mit Advertized Window Size gen\u00fctzt. Das Netzwerk dazwischen soll nicht \u00fcberlastet werden. Hier f\u00fcr gibt es Congestion Control mit Slow Start Algorithmus. TCP-Header TCP Source Port und Destination Port : Der genutzte Port auf dem Sender und Empf\u00e4nger Sequence Number : (Bezieht sich auf die Ausgangsdaten) Anhand dieser Zahl k\u00f6nnen Daten in der richtigen Reihenfolge der Applikation \u00fcbergeben werden und es wird die Acknowledgement Number damit berechnet Acknowledgment Number : (Bezieht sich auf die Eingangsdaten) Header Length/Data Offset : Gibt an, wo der TCP-Header mit optionalen Headers aufh\u00f6rt und die Daten beginnen Control Bits : Flags, welche z.B. den Verbindungsaufbau und -abbau einleiten Diese Flags haben die folgende bedeutung: URG : Urgent-Pointer-Feld enh\u00e4lt einen g\u00fcltigen Wert ACK : Acknowledgment Feld enh\u00e4lt einen g\u00fcltigen Wert PSH : (= Push) Empf\u00e4nger soll Daten sofort an die Applikation weiterleiten RST (=Reset) Verbindung zur\u00fccksetzen SYN (=Synchronize) Verbindung aufbauen FIN : Der Sender hat keine Daten mehr zu \u00fcbertragen. Verbindung abbauen Window : Gibt die noch verf\u00fcgbare Buffer-Gr\u00f6sse des Senders an. Wenn ein Empf\u00e4nger 0 im Window-Feld erh\u00e4lt, stoppt er zu senden, bis eine Retransmission mit einem gr\u00f6sseren Window-Feld ankommt. Checksum : Die Checksume des TCP-Pakets Urgent Pointer : Falls URG gesetzt ist, zeigt dieses Feld an, wo die \"Urgent-Daten\" im Datenblock gefunden werden k\u00f6nnen Options : Optionen, wie \"SACK\" oder die maximale Segmentl\u00e4nge (MSS) k\u00f6nnen als optionale Option \u00fcbertragen werden Verbindungsaufbau Datenaustausch Eine Nachricht vom Sender m\u00fcssen vom Client immer mit einem Paket, welches das ACK -Flag Gesetzt hat, best\u00e4tigen werden. Vor dem senden startet der Sender ein Timer. Falls dieser abl\u00e4uft, bevor der Empf\u00e4nger das Paket best\u00e4tigt hat, wird das Paket erneut versendet. Es gibt eine Retransmission . Die Seq Zahl der Antwort des Servers ist die Ack Zahl des Requests. Die Ack Zahl der Antwort des Servers ist die Seq -Zahl + die Anzahl empfangenen Bytes. Verbindungsabbau MSL=Maximum Segment Length Das Timeout am Ende ist n\u00f6tig, falls das letzte ACK b+m+1 nicht ankommt. In diesem Fall w\u00fcrde die Passive-Seite noch mals ein FIN b+m Paket senden. Sliding Window Adaptive Elemente von TCP Adaptives Timeout Das Timeout von TCP wird adaptiv bestimmt und \u00e4ndert sich \u00fcber die Lebenszeit der Verbindung. Daf\u00fcr werden folgende Formeln ben\u00fctzt: $$ RTO_n=SRTT_n + 4\\cdot RTTVAR_n\\ SRTT_n = (1 - \\alpha )\\cdot SRTT_{n-1}+\\alpha\\cdot RTT_n\\ RTTVAR_n=(1 - \\beta)\\cdot RTTVAR_{n - 1}+\\beta \\cdot \\vert SRTT_n - RTT_n \\vert $$ Dabei steht \\(RTO\\) f\u00fcr Retransmission Time-Out , \\(SRTT\\) f\u00fcr Smoothed Round-Trip-Time und ist ein gewichteter Mittelwert, \\(RTT\\) f\u00fcr Round-Trip-Time und \\(RTTAV\\) f\u00fcr Round-Trip-Time Variance und ist der gewichteter Mittelwert der Abweichung, bzw. die Streuung. Wenn die Roud-Trip-Time \u00fcberschritten wird, wird der Sender das Paket erneut senden. Best\u00e4tigung von Paketen In TCP wird das Sliding-Window Verfahren f\u00fcr die Best\u00e4tigung von Paketen gen\u00fctzt. Der Sender sendet alle Pakete im Fenster und schiebt das Fenster weiter, wenn die \u00e4lteste Nachricht best\u00e4tigt wurde. Ohne Sliding-Window Verfahren muss der Sender immer auf eine Best\u00e4tigung warten. Mit dem Sliding-Window k\u00f6nnen mehrere Pakete versendet werden. Fluss-Steuerung Im folgenden Paket wird angenommen, dass der Empf\u00e4nger mit einer Buffergr\u00f6sse von 2'500 Bytes hat. Der Empf\u00e4nger sendet die verbleibende Buffergr\u00f6sse im Window Feld zur\u00fcck. Wenn der Sender eine Best\u00e4tigung mit Window=0 empf\u00e4ngt, wartet er, bis er dieselbe Best\u00e4tigung mit einer h\u00f6heren Window Feld empf\u00e4ngt. \u00dcberlastung des Netzwerks vermeiden Beim Slow-Start Algorithmus beginnt der Sender mit einer kleinen vordefinierten Gr\u00f6sse und verdoppelt dies mit jedem gesendetem Paket bis er die erste Schwelle erreicht. Danach wird die Paketgr\u00f6sse linear vergr\u00f6ssert bis ein Timeout entsteht. Bei einem Timeout wird die n\u00e4chste Schwelle auf die H\u00e4lfte des Paketes, bei welchem das Timeout entstand. Danach wird wieder ein Slow-Start ausgef\u00fchrt. Es gibt f\u00fcr den Slow-Start Algorithmus folgende Kritikpunkte Die \"S\u00e4gezahnkurven\" verschiedener TCP-Sessions tendieren dazu, sich zu synchronisieren Die Annahme gilt f\u00fcr Wireless-Netze nicht mehr unbedingt, wo relativ viel Paketverlust durch Bitfehler w\u00e4hrend der \u00dcbertragung vorkommt Slow-Start bei kurzen Transfers immer slow (www) Abh\u00e4ngig von Round Trip Time UDP (User Datagram Protocol) UDP, wie auch TCP, ist ein Layer 4 Protokol und ben\u00fctzt Ports zur adressierung. Es ist aber nicht zuverl\u00e4ssig und erledigt nichts gegen Paket Verluste oder vertauschte Pakete. Daf\u00fcr kann ein Knoten sofort senden, da es keinen Verbindungsaufbau gibt, es gibt weniger Overhead und ist weniger rechnungsintensiv. Es kann, wie auch TCP, Daten anhand von einer Port-Nummer der richtigen Anwendung zuweissen (Demultiplexing) und umgekehrt (Multiplexing). Header Der UDP Header besteht aus 8 Bytes und beinhaltet folgendes: Application Layer (Layer 7) DNS (UDP/53) Type Beschreibung A IPv4 Adresse des gesuchten Hosts (32 Bit) AAAA IPv6 Adresse des gesuchten Hosts (128 Bit) MX Mail Exchange (Mail Server) NS Name Server f\u00fcr eine Zone CNAME Canonical Name; Alias zum Host TXT Text Record; in Antowrten f\u00fcr verschiedenste Angaben verwendet Die 13 Root Server wissen wo die NS-Server der Top-Level Domains sind. Ablauf einer Namensaufl\u00f6sung Resolver ist die lokale Software. Host fragt DNS-Server nach einer Adresse hello.example.com. DNS Server fragt Root-Server nach dem com. NS DNS Server fragt .com -NS nach example.com. DNS Server fragt example.com. -NS nach hello.example.com F\u00fcr Reverse DNS werden dieselben Schritte ausgef\u00fchrt, aber mit einer IP Adresse. DHCP / BOOTP (UDP/67; UDP/68) Der Client fragt den Server nach einer Konfiguration auf dem UDP Port 67 als Broadcast-Nachricht. Die Antwort wird an die MAC-Adresse des Client gesendet. BOOTP funktioniert auch \u00fcber Netzwerk-Grenzen. Dabei ist der Router so konfiguriert, dass er den BOOTP-Request liest und per Unicast an den BOOTP-Server sendet. Die Antwort wird wieder an den Client zur\u00fcck geleitet. Es werden folgende Infos gesendet: Netzwerk Configuration: IP-Adresse; Subnet; Gateway IP Boot File Name Nachteile von BootP sind: Bei grossen Anzahl von Knoten, m\u00f6chte man IP-Adressen gemeinsam nutzen, was mit BootP nicht praktikabel ist Mehraufwand, da f\u00fcr jeden Knoten eine Konfiguration eingetragen werden muss DHCP ist abw\u00e4rtskompatibel mit BootP. Network Address Translation (NAT) Wenn ein Paket gesendet wird, wird die Source-Adresse und ev. den Port durch die des Gateways ersetzt und an den Server weitergeleitet. Anhand des Ports kann der Gateway eingehende Pakete unterscheiden und dem korrekten Client senden. Daf\u00fcr wird wieder der Header modifiziert. Probleme von NAT: OSI-Model wird verletzt, da die IP und Port ver\u00e4ndert werden und auch Checksummen neu gerechnet werden m\u00fcssen Die Verbindung kann nicht auf Layer 1-3 Verschl\u00fcsselt werden, da die Informationen vom Gateway ben\u00f6tigt werden Autoconfiguration mit IPv4 - Automatic Private IP Addressing (APIPA) Wenn kein DHCP-Server gefunden wird, wird eine zuf\u00e4lle IP-Adresse zwischen 169.254.1.0 bis 169.254.244.255 (Netzwerk 169.254.0.0/16) gew\u00e4hlt und mit einem Gratuious ARP-Request \u00fcberpr\u00fcft, ob die IP-Adresse bereits besetzt ist. Um mit dieser IP-Adresse ins Internet zu kommen, muss der Router ARP-Requests f\u00fcr alle IP-Adressen ausserhalb des Netzwerks erkennen und auf sich leiten. Der Router kann die Pakete danach an den korrekten Host weiterleiten. Um Ger\u00e4te ohne DHCP und DNS Server zu finden, kann multicast DNS (mDNS) verwendet werden, welches ein verteilter DNS Server ist. Es wird ein \"normalen\" DNS Request an 244.0.0.251 mit dem UDP Port 5353 geschickt. Wenn nach services.dns-sd.udp.local. gefragt wird, antworten alle mDNS f\u00e4higen Ger\u00e4te. Trivial File Transfer Protocol (TFTP) [UDP/69] Es gibt f\u00fcnf Operationen: Read Request (RRQ) : Fordert eine Datei an Write Request (WRQ) : Shickt eine Datei an den Host Acknowledgment (ACK) : Best\u00e4tigt das korrekte Empfangen von WRQ- oder DATA-Pakete. Es wird die Block-Nummer angegeben Data (DATA) : \u00dcbermittelt die eigentlichen Daten-Bl\u00f6cke. Ein Block ist 512 Bytes (wenn nicht anderst angegeben in WRQ oder RRQ Request). Wenn ein Block kleiner ist, wird das als Ende der Datei interpretiert. Error (ERROR) : Beschreibt den aufgetretener Fehler Wird ein ACK oder DATA Paket nicht innerhalbs einer Zeit empfangen, wird die letzte ACK- oder DATA Nachricht nochmals versendet. Simple Mail Transfer Protocol (SMTP) [TCP/25] Sendet ein Mal zu einem Mail-Server, welcher das Mail ebenfalls weiterleitet oder zwischen Speichert damit der Nutzer dies via POP3 oder IMAP abholen kann. Ablauf: Verbinden mit dem Server und identifizieren und authentifizieren Client sendet MAIL FROM <absender> und RCPT TO <empf\u00e4nger> um die Empf\u00e4nger zu definieren Mit DATA wird das Mail versendet QUIT wird vom Client gesendet, was vom Server mit Bye-Bye quitiert wird Der Server-Antwortet auf die Befehle mit 3-stelligen Zahlen Codes (wie HTTP-Status Codes) S: 220 mail.zhaw.ch ESMTP Sendmail 8.8.8/8.8.8 C: HELO zhaw.ch S: 250 mail.zhaw.ch Hello mth@mail.zhaw.ch, pleased to meet you C: MAIL FROM:<mth@zhaw.ch> S: 250 OK C: RCPT TO:<kls@zhaw.ch> S: 250 <kls@zhaw.ch>... Recipient ok C: DATA S: 354 Enter mail, end with \".\" on a line by itself C: Date: 06 Jan 2099 16:34:25 +0100 C: To: kls@zhaw.ch C: Subject: Test einer Mail. C: C: Damit ist der SMTP-Teil beendet. C: . S: 250 OK C: QUIT S: 221 mail.zhaw.ch closing connection Zeichensatz SMTP ben\u00fctzt ein 7-Bit ASCII Zeichen-Satz. Folgende Headers werden gesetzt, um MIME zu verwenden. Der Mime-Seperator wird eingesetzt wenn MIME-Version: 1.0 Content-Type: Multipart/Mixed; Boundary=\"Mime-Separator-WAB02622.926626671\" Mime-Separator-WAB02622.926626671 Content-Type: text/plain Hallo! Hier folgt der Text. Quoted-Printable Jedes 8-bit Zeichen wird durch =xx ersetzt, wobei xx eine Hex-Zahl ist. ( 1 -> =31 ). Dies ist sehr ineffizient (Effizienz: 30%) Base64 Alle Texte werden auf 6-Bit Zeichen aufgeteilt. Wenn es nicht aufgeht, wird mit = ein (6-Bit) null-Byte eingesetzt. Ausdem folgt, das ein Vielfaches von drei 8-Bit Bytes kein Padding ben\u00f6tigten. (Effiizienz: 73%)","title":"KT Summary"},{"location":"22FS/KT/summary.html#summary","text":"Hex Dez Bin Hex Dez Bin 0 0 0 8 8 1000 1 1 1 9 9 1001 2 2 10 A 10 1010 3 3 11 B 11 1011 4 4 100 C 12 1100 5 5 101 D 13 1101 6 6 110 E 14 1110 7 7 111 F 15 1111","title":"Summary"},{"location":"22FS/KT/summary.html#physical-layer-bitubertragungsschicht-layer-1","text":"Das physikalische Medium, was die Ger\u00e4te verbindet. Dies kann ausgetauscht werden und die anderen Schichten bleiben umbetroffen.","title":"Physical Layer (Bit\u00fcbertragungsschicht) (Layer 1)"},{"location":"22FS/KT/summary.html#formeln","text":"Begriff Erkl\u00e4rung Baud-Rate Anzahl Symbole pro Sekunde. Ein Symbol ist ein Zustand im Datenstrom Bitrate (Nyquist) \\(f_s \\le 2B\\) Dabei ist \\(f_S\\) die Baud-Rate und \\(B\\) die Bandbreite des Kanals in Hz Frame-Rate \\(F\\) \\(F=\\frac B {(7+1+6+6+2+P+4+12)\\cdot 8}=\\frac B {38\\cdot 8 + P\\cdot 8}\\) Die Anzahl Ethernet-Frames pro Sekunde (wobei \\(P\\) die Payload-Bytes ist) (min. Datenblock 46 Bytes) Nutz Bitrate \\(N\\) \\(N=F\\cdot P=\\frac{P\\cdot 8 \\cdot B}{38\\cdot 8 + P \\cdot 8}\\) - Die Bitrate, welche f\u00fcr Daten nutzbar ist Delay von Store-Forwards Switch \\(t_{delay}\\) \\(t_{delay}=t_{frame}=\\frac{Framesize}{Bitrate}\\) - Wie lange das Senden eines Frames ben\u00f6tigt Transfer Delay \\(t_{transfer}\\) \\(t_{transfer}=\\frac d {C_{wire}}\\) , wobei \\(d\\) die Distanz ist und \\(C_{wire}\\) Lichtgeschwindigkeit im Kabel ist. Wie lange die Daten im Transfer sind Zeichenrate \\(\\frac{Bitrate}{Bits/Zeichen}\\) : Wieviel Zeichen pro Sekunde durch die Leitung passen Zust\u00e4nde \\(M=1+\\frac A {\\Delta V}\\) wobei gilt: \\(A\\) ist die max. Amplitude \\(\\Delta V\\) die Ungenauigkeit des Empf\u00e4ngers Max Bitrate (Hartley's Gesetzt) \\(R [bit/s] \\le 2B [Hz] \\cdot \\log_2(M)\\) , wobei \\(R\\) die max. Bitrate und \\(M\\) die Anzahl Zust\u00e4nde ist Informationsgehalt (Bit) \\(\\log_2(M)\\) Der Informationsgehalt eines Symboles ( \\(M\\) = Anzahl Symbole) Kanalkapazit\u00e4t ( \\(C\\) ) \\(C=B\\cdot \\log_2\\left(1+\\frac S N\\right)\\) , wobei \\(B\\) die Kanal-Bandbreite in Hz ist, \\(S\\) die Signalleistung und \\(N\\) die Rauschleistung Nettobitrate \\(Nettobitrate=Brutobitrate\\cdot\\frac{Nutzdaten}{Nutzdaten + Header}\\) Hamming-Distanz TODO Beispiel: Mit AMI k\u00f6nnen 3 Werte pro Symbol \u00fcbertragen werden. Informationsgehalt: \\(I_S=\\log_2(3)=1.58 \\left[\\frac{Bit}{Symbol}\\right]\\) , da aber nur ein Bit pro Symbol \u00fcbertragen wird, liegt die Effizienz bei \\(\\frac 1 {1.58}=63\\%\\)","title":"Formeln"},{"location":"22FS/KT/summary.html#physik-ausbreitungsgeswindigkeit","text":"Die Lichtgeschwindigkeit im Glas mit dem Brechungsindex \\(n=1.5\\) ist: \\(c_{Glass}=\\frac{c_0}{n}=\\frac{299'792'458}{1.5}\\approx200'000\\frac{km} s\\) In einem elektrischen Leiter ist es ebenfalls \\(200'000\\frac{km}s\\)","title":"Physik - Ausbreitungsgeswindigkeit"},{"location":"22FS/KT/summary.html#signaldampfung","text":"Die D\u00e4mpfung ist \\(Signald\u00e4mpfung [dB] = 10\\cdot \\log\\left(\\frac {P1}{P2}\\right)=20\\cdot \\log\\left(\\frac {U1}{U2}\\right)\\) , Dabei ist \\(P\\) die Leistung und \\(U\\) die Anzahl Spannung (Volt). Die D\u00e4mpfung von 6dB heisst eine Leistungsabnahme von 4 und eine Spannungsabnahme von 2 Der D\u00e4mpfungsbelag ist wieviel D\u00e4mpfung \u00fcber 100m oder 1km statfindet (Masseinheit: db/100m oder db/km )","title":"Signald\u00e4mpfung"},{"location":"22FS/KT/summary.html#kabel-arten","text":"","title":"Kabel-Arten"},{"location":"22FS/KT/summary.html#koaxialkabel","text":"Bestehen aus einem Leiter und sind geeignet f\u00fcr hochfrequente Signale, haben einen kleinen D\u00e4mpfungsbelag und sind unempfindlich gegen\u00fcber von elektromagnetischen St\u00f6rungen. Die Kabel selbst sind daf\u00fcr relative empfindlich.","title":"Koaxialkabel"},{"location":"22FS/KT/summary.html#paarsymetrische-kabel-twisted-pair","text":"Das Namensschema von Twisted Pairs ist wie folgt: \\(xx/y\\text{TP}\\) . Werte f\u00fcr \\(xx\\) Werte f\u00fcr \\(y\\) Erkl\u00e4rung U U ungeschirmt F F Folienschirm S S Geflechtschirm SF <gibt es nicht> Schirm aus Geflecht und Folie Schirme funktionieren nur, wenn sie gut geerdet sind! St\u00f6rsignale werden minimiert, in dem auf zwei Kabeln das invertierte gesendet wird. F\u00fcr Elektromagnetische Str\u00f6ungen, sind die Kabel verdrillt. So heben sich die St\u00f6rungen auf Zudem werden noch die Leitung geschirmt. Diese Schirme m\u00fcssen geerdet sein und galvanisch getrennt sein","title":"Paarsymetrische Kabel (Twisted Pair)"},{"location":"22FS/KT/summary.html#cat-kabel","text":"Bezeichung Frequenzberreich Data Rate Erkl\u00e4rung CAT-1-4 0.4/4/16/20 MHz 1 / 4 / 10 / 16 Mbps F\u00fcr Telefone und Modemleitungen oder langsames LAN CAT-5 100 MHz 100 Mbps Weitverbreitet. Erlaubt eine max. Bitrate von 1000Mbit/s bis zu 100m CAT-5e 1 Gbps Ethernet, Fastether, Gigabit Ethernet CAT-6 250 MHz 10 Gbps Wird meistens f\u00fcr Gigabit (1000 Mbit/s) ben\u00fctzt CAT-7 600 MHz 10Gbps Geeigent f\u00fcr 10 Gigabit. Es werden aber S/FTP Kabel ben\u00f6tigt CAT-8 2000 MHz 40 Gbps Datenraten bis 40 Gigabit bis zu 30m","title":"CAT-Kabel"},{"location":"22FS/KT/summary.html#glassfasser","text":"Vorteile von Glassfasser: Vollst\u00e4nstig unempfindlich gegen\u00fcber elektromagnetischen St\u00f6rungen Kleine Signald\u00e4mpfung und grosse Distanzen Grosse Bandbreite und somit grosse \u00dcbertragunsraten Nachteil: Dispersion (gewisse Photonen sind schneller und l\u00e4ngs\u00e4mer, was das Signal verzerrt.) Delay Skew: Die Zeitabweichung, welche durch die verschiedene Laufzeiten zustande kommen Multimode Stufenfasern : Das Kabel und Mantel ist klar abgegrenzt (ca. Delay Skew 50ns/km) Multimode Gradientenfasern : Der Kern und Mantel haben einen Gradient (ca. Delay Skew 0.5 ns/km) Monomod","title":"Glassfasser"},{"location":"22FS/KT/summary.html#asynchrone-und-synchrone-serial-vs-parallel","text":"Bei der paralleln \u00dcbertragung werden mehrere Signale aufsmal \u00fcbertragen. Bei hohen Takten m\u00fcssen alle Leitungen genau Lange sein und daher kommt es nur auf kurze Distanzen zum einsatz. Bei serieln Verbindungen wird zuerst das LSB (= Least Significant Bit) \u00fcbertragen und zuletzt das MSB (=Most Significant Bit) Bei der synchronen serieln \u00dcbertragung wird ein Clock-Signal \u00fcbertragen. Es werden daher keine Start- und Stop-Bits ben\u00f6tigt Bei der asynchroner serieln \u00dcbertragung wird kein Clock-Signal \u00fcbertragen. Anstatt gibt es ein Start und Stop bit. Wenn der Empf\u00e4nger das Start-Bit erh\u00e4lt. stellt er seine eigene Clock auf diese Zeit ein. Der Takt darf nicht mehr als die halbe Bitzeit T abweichen ( \\(\\text{Frequenz Abweichung in Prozent}=\\frac{0.5T}{9.5T}\\) ). Die Clock startet nach dem Start-Flag. (Zuerst wird das LSB und zuletzt das MSB verschickt)","title":"(Asynchrone und synchrone) Serial vs Parallel"},{"location":"22FS/KT/summary.html#gleichspannungsfreei","text":"Der Sende rund Empf\u00e4nger sind galvanisch getrennt. Dies sch\u00fctzt die Ger\u00e4te, falls beim anderen ein Blitz einschl\u00e4gt. Da hierbei oft mit Capacitors umgesetzt wird, sollte das Signal nicht immer bei 1 oder 0 sein, sonder m\u00f6glicht oft wechseln.","title":"Gleichspannungsfreei"},{"location":"22FS/KT/summary.html#codierungen","text":"Bei der AMI-Codierung wird ein 0 als 0V encodiert und 1 abwechslungsweise als U+ und U- Bei der HDB3 Codierung wird zus\u00e4tzlich nach 000 eine 1 mit demselben Pegel wie die letzte 1 gesendet ( 0001 ist gr\u00fcn in der Grafik) . Wenn die Anzahl 1 seit der letzten Regelverletztung gerade ist, wird anstelle 1001 (rot in der Grafik) versendet","title":"Codierungen"},{"location":"22FS/KT/summary.html#manchester-codierung-10mbits","text":"In Ethernet wird die Manchester-Codierung zwischen 0V und -2V angewendet und daher nicht gleichspannungsfrei. Eine steigene Flanke ist eine 1 eine sinkende Flanke ist eine 0","title":"Manchester-Codierung (10Mbit/s)"},{"location":"22FS/KT/summary.html#nrzi-codierung-non-return-to-zero-invert-on-ones","text":"Diese Codierung wird bei 100BASE-TX verwendet. Bei einer 0 bleibt der Pegel, bei einer 1 wechselt der Pegel.","title":"NRZI-Codierung (Non Return to Zero, Invert on Ones)"},{"location":"22FS/KT/summary.html#data-link-layer-layer-2","text":"Aufgaben: Sichere Verbindung zwischen zwei Teilnehmer (Fehlerkorrektur und erkennung) Verpacking der Daten in Frames (Framing) Frame Erkennung Flow-Controll (Fluss Steuerung) Adresseriung der Teilnehmer (wenn mehrere Teilnehmer im Netz sind) Medium Zugriff (wenn meherere Teilnhemer das Medium teilen) In der Regel wird immer zuerst das MSB und zu letzt das LSB versendet (als wenn auf dem Kabel 010011 gesendet wird, wird das Zeichen 110010 empfangen)","title":"Data Link Layer (Layer 2)"},{"location":"22FS/KT/summary.html#ethernet-frame","text":"Preamble und Start Frame Delimiter (SFD) Die Preamble werden 7 Bytes, welche aus Abwechslungsweise 0 und 1 bestehen ( 01010101 = \\(84_{10}=55_{16}\\) , 10101010 = \\(170_{10}=AA_{16}\\) ). Das 8 Byte (das SFD) hat die Form 10101011 (= \\(171_{10}=AB_{16}\\) ) Length/Type Wenn der Wert \\(\\le 1500_{10}=05DC_{16}\\) ist, stellt es die Anzahl von Bytes im Data Feld dar (ohne PAD ). Sonst wird angegeben, was f\u00fcr ein h\u00f6heres Protokoll im Datenfeld enthalten ist. 0x8100 (=33024) ist der VLAN-Tag Typ. 0x0800 (=2048) ist IP. Data/PAD Die Daten (zwischen 0 - 1500 Bytes). Falls die Daten kleiner als 46 Bytes sind, wird dies mit PAD aufgef\u00fcllt Frame Check Sequence CRC32 Checksume Interframe Gap minimaler zeitlichen Abstand zwischen zwei Frames","title":"Ethernet Frame"},{"location":"22FS/KT/summary.html#framing-synchrone-und-asynchrone-ubertragung","text":"asynchroner \u00dcbertragung Es wird ein Frame (Anzahl Elemente; Datenblock mit \\(n\\) Elementen; Fehlererkennung) gesendet und danach ist Ruhe, bis zum n\u00e4chsten Frame synchroner \u00dcbertragung Es wird kontinuierlich Frames gesendet, falls n\u00f6tig auch leere. Es gibt ein Start- und End Flag (meist 01111110 ). Es wird bit-stuffing verwendet, um zu verhindern, dass das Flag im Daten-Block vorkommt. Wenn 5x 1 gesendet wurde, wird eine 0 gesendet, welche vom Empf\u00e4nger ignoriert wird","title":"Framing - synchrone und asynchrone \u00dcbertragung"},{"location":"22FS/KT/summary.html#lange-eines-frames","text":"\\(Nettobitrate=Brutobitrate\\cdot\\frac{Nutzdaten}{Nutzdaten + Header}\\) Je l\u00e4nger ein Frame ist, desto h\u00f6her ist die Nettobitrate. Nachteile: Durchsatz (Wahrscheinlichkeit, dass ein Fehler w\u00e4hrend eines Frames auftritt); Effizienz (Wenn ein Fehler auftritt, ist das es verloren); Zuverl\u00e4ssigkeit (Wahrscheinlichkeit, dass ein undetektierbarer Fehler auftritt steigt); Jitter (Variation der Zeitabst\u00e4nde zwischen Frames) Durchsatz h\u00e4ngt von der Nettobitrate und der Frame-Fehlerwarscheinlichkeit ab $$ \\text{Frame-Erfolgswahrscheinlichkeit: } (1-p_e)^N\\ \\text{Frame-Fehlerwahrscheinlichkeit: } 1-(1-p_e)^N\\ \\text{Optimale Frame-L\u00e4nge: } \\sqrt{\\frac{H}{p_e}}\\ $$ Dabei ist \\(N\\) die L\u00e4nge des Frames, \\(H\\) die L\u00e4nge des Headers und \\(p_e\\) die Bitfehlerwahrscienlichkeit.","title":"L\u00e4nge eines Frames"},{"location":"22FS/KT/summary.html#flusskontrolle","text":"Start-Stop-Meldungen : Wenn der Emp\u00e4ngerbuffer voll l\u00e4uft wird eine Stop-Meldung verschickt. Wenn der Buffer leer wird, wird eine Start-Meldung verschickt Stop-and-Wait : Jede Meldung wird quitiert. Wenn der Buffer voll l\u00e4uft, wird die Quitierung erst sp\u00e4ter gesendet.","title":"Flusskontrolle"},{"location":"22FS/KT/summary.html#fehlererkennung","text":"Backward Error Correction: Fehler kann erkennt werden und die Daten neuangefordert werden Forward Error Correction: Die Fehler k\u00f6nnen erkennt und zu einem gewissen Punkt korrigiert werden Blockcodes : Das Hamming-Gewicht=die kleinste Anzahl 1 auf einer Linie der Generator-Matrix Das Hamming-Gewicht ist gleich die Hamming Distanz \\(d_{min}\\) Erkennbare Fehler: \\(d_{min}-1\\) und korrigierbare Fehler: \\(\\frac{d_{min}-1}2\\)","title":"Fehlererkennung"},{"location":"22FS/KT/summary.html#fehlerkorrigierende-codes","text":"\\(\\frac {d_{min}-1}2\\) korrigierbar Generatormatrix Bedinungen: f\u00fcr \\(d_{min}=3\\) muss jeder Code (ausser dem 0-Code) min. 3x 1 haben Mindestens eine 1 muss in der Einheitsmatrix sein Jede Pari\u00e4tsmatrix-Zeile muss 2x 1 beinhalten","title":"Fehlerkorrigierende Codes"},{"location":"22FS/KT/summary.html#crc","text":"Das Datenpolynom wird um die Anzahl Stellen des Generatorpolynoms verschoben und anschliessend durch das Generatorpolynom geteilt. Das Resultat wird zum Datenpolynom hinzu addiert. Dabei werden die entstandenen 0 des Datenpolynoms gef\u00fcllt. Der Empf\u00e4nger kann den empfangenen Wert durch das Generatorpolynom teilen und muss 0 erhalten.Flusssteuerung","title":"CRC"},{"location":"22FS/KT/summary.html#lan","text":"Art Erkl\u00e4rung Unicast Ein Paket hat wird genau an ein Ziel gesendet. Das Paket wird mit einer Adresse ausgestattet, so dass es am Ziel sicher ankommt. (Netflix) Broadcast Das Paket wird an alle Knoten im Netzwerk gesendet. Das Paket wird mit einer Broadcast-Adresse ausgestattet (Live-Stream/Twitch) Multicast Das Paket wird an eine Gruppen von Knoten gesendet. (Radio) (Anycast) Mehrere Server mit den selben Adressen. Der Knoten davor entscheidet, an welchen Knoten \u00fcbertragen wird","title":"LAN"},{"location":"22FS/KT/summary.html#topologien","text":"Topologie Beschreibung Bustopologie Alle Knoten sind an einer Leitung angeschlossen Linientopologie Ein Knoten ist mit dem N\u00e4chsten verbunden. Ringtopologie Eine Linientopologie, mit zusammen gef\u00fcgte Enden Sterntopologie Alle Knoten h\u00e4ngen an einem Hub/Switch Baumtopologie Entsteht, wenn die Sterntopologie hirarchisch kombiniert wird","title":"Topologien"},{"location":"22FS/KT/summary.html#rj-45","text":"Der Stecker beseitzt 4 Adernpaar, bzw. 8 Adern.","title":"RJ-45"},{"location":"22FS/KT/summary.html#ieee-namensgebung","text":"(Bitrate in Mbit/s) (BASE|BROAD)-(Art/Medium L\u00e4nge) 1000BASE-T = Ethernet mit Basisband-Kanalcodierung mit einer Bitrate von 1Gbit/s mit Twisted-Pairs (T) 10BASE5 = 10Mbit/s Basisband-Ethernet mit max 500m (5) Segmentenl\u00e4nge und bis zu 100 Knoten. Es braucht ein dickes Kabel als Shared-Medium 10BASE2 = Thin-Wire-Ethernet, was eine flexiblere und billigere Alternative zu 10BASE5 ist. Der BNC-T \"Stecker\" wurde benutzt. 100BASE-XX: 100 MBit/s Standardt 100BASE-TX: 2 Paar UTP Cat 5 mit max Segmentl\u00e4nge 100m 100BASE-FX: 2 MMF (62.5 \\(\\mu\\) m) mit 2000m Segmentl\u00e4nge 100BASE-T4/2: 4 Paar UTP Cat. 3 mit 100m Segmentl\u00e4nge","title":"IEEE Namensgebung"},{"location":"22FS/KT/summary.html#fast-ethernet-vs-10mbits","text":"Es wird das selbe Frame-Format und Fehlererkennung ben\u00fctzt wie f\u00fcr 10MBit/s. Die Kollisiondomain ist 10 mal kleiner, da die Geschwindikgeit 10 mal gr\u00f6sser ist.","title":"Fast-Ethernet vs 10Mbit/s"},{"location":"22FS/KT/summary.html#shared-ethernet","text":"Bevor ein Knoten sendet, wartet er, bis die Leitung frei ist. W\u00e4hrend dem Senden wird der Pegel auf der Leitung kontroliert, um kollisisionen fest zu stellen. Wenn eine Kollision festgestellt wurde, wird ein Jamming Signal gesendet und ein zuf\u00e4lliges Vielfache von der Slot-Zeit \\(t_s\\) . Bei der 1. Kollision wird 0x oder 1x gewartet, bei jedem n\u00e4chsten wird der Zeitbereich verdoppelt. Bis zu 16 Versuche, danach wird die \u00dcbertragung abgebrochen. Der andere Sender erkennt nur, dass ein Signal eine Kollision verursacht hat, wenn er w\u00e4hrend des Sendens ein Jamming Signal erhaltet.","title":"Shared-Ethernet"},{"location":"22FS/KT/summary.html#medium-access-control-mac","text":"Master/Slave-Verfahren : (deterministisch) Der Master fragt zyklisch jeden Slave ab und der Slave antwortet mit den vorhanden Daten. So gibt es nie Kollisionen und das Verfahren ist deterministisch, aber der Master ist der single point of failure. Token Passing :(deterministisch) Es wird ein Token von Node zu Node Peer-to-Peer gereicht. Ein Node darf nur senden, wenn er der Token hat. Da der Token verloreren gehen kann, muss es eine M\u00f6glichkeit geben, diesen zu regenerieren. Zeitgesteuerter Zugriff : (deterministisch) Jeder Node hat ein Sende-Slot. Mit diesem Verfahren kann eine hoche Auslastung des Netzes erreicht werden, allerdings muss jeder Node den \"Fahrplan\" und die genaue Zeit kennen. Carrier Sense Multiple Access (CSMA) (undeterministisch): Jeder Knoten pr\u00fcft zuerst ob der Bus frei ist und sendet, wann er will. Carrier Sense Multiple Access / Collision Detection (CSMA/CD) (undeterministisch): Zus\u00e4tzlich werden Kollisionen festgestellt und danach nach einer zuf\u00e4lligen Zeit wieder versucht Carrier Sense Multiple Access with Collision Resolution (CSMA/CR) (undeterministisch): Es gibt ein dominateter Pegel (1 oder 0), welcher gewinnt bei Konflikten. Nur der Verlierer kann dies allerdings feststellen und bricht die \u00dcbertragung ab.","title":"Medium Access Control (MAC)"},{"location":"22FS/KT/summary.html#collision-domain","text":"Collision Domain Die Collision Domain ist der Bereich des Netzwerks, in welchem ein Fehler erkennt wird. Da der urspr\u00fcngliche Sender nur die Kollision erkennt, wenn er das Jamming Signal w\u00e4hrend des Sendens empf\u00e4ngt, muss die Collision-Domain kleiner als die Halbe-Ausbreitungsdistanz des k\u00fcrzesten Paket (46Bytes Daten) $$ t_{frame} > 2\\cdot t_{transfer}\\ t_{frame} = \\frac{Framesize_{min}}{Bitrate} \\ t_{transfer}=\\frac{d_{max}}{C_{Medium}}\\ d_{max}<\\frac 1 2 \\frac{Framesize_{min}}{Bitrate}\\cdot C_{Medium} $$ Dabei ist \\(d_{max}\\) die Maximale Distanz der Collision Domain Wenn ein Repeater/Hub im Spiel ist, muss die Formel \\(t_{frame} > 2\\left(\\sum t_{transfer} + \\sum t_{forwarding}\\right)\\) benutzen, da der Router das eigentliche Signal, wie auch das Jamming Signal verz\u00f6gert. Die Broadcast-Domain ist der Bereich im Netzwerk, in welcher ein Broadcast-Frame ankommt.","title":"Collision Domain"},{"location":"22FS/KT/summary.html#hub-vs-l-2-switch-bridge","text":"Ein Hub ist ein \"dummes\" Ger\u00e4t, welcher alle Informationen an alle Ports senden. Ein Switch liest die Layer 2 Headers and sendet das Paket nur an die n\u00f6tigen Ports. Dadurch wird die Collision Domain unterbrochen. Dies wird auch Transparent Bridging genannt, da die Sender und Empf\u00e4nger nichts davon wissen. Ein Switch merkt sich die Mac-Adressen der Sender und speichert diese mit dem Port in der Filtering Database ab. Dank dieser Datenbank, muss der Switch ein Paket nur an einen Port senden (ausser Broadcast-Frames). Nach einer gewissen Zeit wird ein Eintrag wieder gel\u00f6scht. ( Address Learning ) Ein Switch hat folgende Leistungsmerkmale: Filterrate, Transferrate, Gr\u00f6sse der MAC-Adresstabelle","title":"Hub vs L-2 Switch (Bridge)"},{"location":"22FS/KT/summary.html#vlan","text":"Bei VLAN wird ein VLAN-Tag zwischen Source-Adress und Length/Type eingef\u00fcgt. Mit diesem Tag kann ein Switch ein Paket einem bestimmten Virtuellen LAN zuordnen. Diese Zuordnung wird in einer Tabelle geregelt. Ein Virtuelles Lan bildet eine Broadcast Domain. Dieser Tag besteht aus: Tag Protocol Identifier : User Priority/Priority Code Point : (3 Bit) Eine Priorit\u00e4t, um z.B. gewisse Applikationen zu priorisieren Cannonical Format Identifier VLAN-Identifier : (12-Bit)","title":"VLAN"},{"location":"22FS/KT/summary.html#rapid-spanning-tree-protocol","text":"Beim Rapid Spanning Tree Protocol werden einige Pfade deaktiviert, um Loops zu \"entfernen\". Es muss ein Root-Switch im Baum gefunden werden. Der Root ist der Switch mit der tiefsten Bridge Identifier. Falls zwei die gleiche Haben, entscheided die Mac-Adresse. Zu begin preist jeder Switch sich selbst als Root-Switch an. \u00dcbernimmt aber ein anderen Root-Switch, sobald er eine Nachricht erhaltet, in welchem ein \"besseren\" Root-Switch erw\u00e4hnt wird. In diesen Bridge Protocol Data Unit (BPDU) Nachrichten teilt jeder Switch seinen Nachbarn mit, welches nach seiner Wissen, der n\u00e4chste Root-Switch ist und wie viel der Weg dorthin kostet. Der Root-Port eines Switches ist der Port, \u00fcber welcher der Root-Switch \u00fcber den k\u00fcrzesten Weg erreichbar ist. Alle Bridges senden BPDU-Nachrichten all 2 Sekunden. Falls diese Ausbleiben, wird das Netzwerk neu konfiguriert.","title":"(Rapid) Spanning Tree Protocol"},{"location":"22FS/KT/summary.html#mac-adresse","text":"04-0A-E0-13-14-26 Im ersten Byte (oben 04 ) 0000 00xy , ist \\(x\\) , ob es eine Group Adress ( 1 ) oder individual Address ( 0 ) ist und \\(y\\) , ob es eine Locally administered Address ( 1 ) oder Universally adinistered address ( 0 ) ist. Die ersten 3 Bytes ist die ID der Hersteller, die letzten 3 Bytes eine Laufnummer ( aa-aa-aa-bb-bb-bb , a ist die ID des Herstellers, b die Laufnummer)","title":"Mac-Adresse"},{"location":"22FS/KT/summary.html#network-layer-layer-3","text":"Die Aufgabe des Layer 3 ist es die Kommunikation zwischen zwei Konten bereit zu stellen. Dies soll m\u00f6glich sein, unabh\u00e4ngig von den Layern 1 und 2. Daher wird eine netzweite Adressierung (IP-Adressen) ben\u00f6tigt. Grob kann der Layer 2 in verbindungsorientierte Dienste und verbindungslose Dienste unterteilt werden. Ein verbindungsorientierter Dienst muss zuerst eine Verbindung aufbauen und kann sich wie ein Schlauch vorgestellt werden. Alle Daten gehen durch diesen Schlauch. Ein verbindungsloser Dienst funktioniert wie die Post. Klassen Adressbereich Anzahl Netze Interfaces pro netz A 1.0.0.0 - 127.255.255.255 127 16'777'214 B 128.0.0.0 - 191.255.255.255 16'384 65'534 C 192.0.0.0-223.255.255.255 2'097'152 254 Die folgenden privaten Netzwerke gibt es: Klasse Netzadresse Subnetmaske A 10.0.0.0 255.0.0.0 B 172.16.0.0 - 172.31.0.0 255.255.0.0 C 192.168.0.0 - 192.168.255.0 255.255.255.0 APIPA-Netz 169.254.1.0 - 169.254.244.255 255.255.0.0 Anzahl addressierbare Hosts: \\(2^{(32 - subnet)} - 2\\) (f\u00fcr \"/24\" \\(2^{(32-24)}-2=2^8-2=254\\) ) Die Netzadresse ist die tiefste Adresse, die Broadcast-Adresse ist die h\u00f6chste Adresse","title":"Network Layer (Layer 3)"},{"location":"22FS/KT/summary.html#ip-header","text":"Version (4 Bit) Gibt die Version des IP-Headers an. Es ist somit m\u00f6glich mehrere IP-Version (IPv4 oder IPv6) zu betreiben. Internet Header Length (IHL) (4 Bit) Gibt die L\u00e4nge allen Headers an. Der gelesene Wert wird mit dem Faktor 4 multipliziert. Wenn also 5 gelesen wird, sind die Headers 20 Bytes lang. IHL muss zwiscehn 5 (20 Bytes) und 15 (60 Bytes) sein. Der fixe Teil eines IP-Headers sind 20 Bytes, also bleiben 40 Bytes f\u00fcr Optionale Felder. Type of Service (8 Bit) Gibt an, was f\u00fcr eine Art von Leitung es ist. Ein Sender kann danach entscheiden, ob er eine Leitung, welche eine hoche Bandbreite hat, daf\u00fcr ein schlechten Ping (wie eine Satelitenverbindung) oder lieber eine \"normale\" Glassfasserleitung ben\u00fctzt. Dies wurde nie von allen Service-Providern unterst\u00fctzt. Total Length (16 Bit) Die totale L\u00e4nget des IP-Paketes mit Headers und Daten. Identifiaction (16 Bit) Ein Wert, welches ein Paket eindeutig identifiziert. Dieser Wert wird ben\u00fctzt, um fragmentierte Pakete wieder zu einem Paket zusammen zusetzen. Flags (3 Bit) Beinhaltet Kontrollflags f\u00fcr die Fragmentierung Feld Position Wert Funktion Erkl\u00e4rung Bit 0 reserved, must be zero Reserviert, immer Null DF Bit 1 0/1 May / Don't Fragment keine Fragmentierung ( 1 ) MF Bit 2 0/1 Last / More Fragments Ob ein Folgefragment kommt ( 1 ) Fragment Offset (13 Bit) An welcher stelle ein fragmentiertes Paket in das ganze Paket gesetzt werden soll. Der gelesen Wert wird mit dem Faktor 8 multipliziert. (Aus 90 wird 720 Bytes) Time to Live (TTL) (8 Bit) Gibt die Anzahl Sekunden an, welche das Paket noch im Netz sein darf. Wenn der Wert 0 wird, wird das Paket verworfen. In der Praxis ist es schwierig zu messen, wie lange ein Paket unterwegs ist und daher dekrementiert der Router der Wert um 1 wenn er es weiter sendet. Wenn ein Router ein Paket mit TTL=1 erhaltet, dekrementiert er es zu 0 und verwirft es. Protocol (8Bit) Das Protokol, welches im Datenteil \u00fcbertragen wird. Folgendes sind die wichtigsten Beispiele: Protocol Keyword Protokollbezeichnung 1 ICMP Internet Control Message 6 TCP Transmission Controll Protocol 17 UDP User Datagram Protocol Header Checksum (16 Bit) Eine Pr\u00fcfsumme, welche nur \u00fcber den IP-Header gebildet wird. Diese muss von jedem Router neu berechnet werden, da gewisse Felder vom Router modifiziert werden. Source Address (32 Bit) Die IP-Adresse des Senders Destination Address (32 Bit) Die IP-Adresse des Empf\u00e4ngers Options und Padding (max. 40 Bytes) Optionale Felder","title":"IP Header"},{"location":"22FS/KT/summary.html#maximum-transfer-unit-mtu","text":"Die MTU gibt an, wie viel Bytes \u00fcber eine Leitung geschickt werden k\u00f6nnen. Dabei werden aber nur die Daten-Bytes des Ethernet-Frames gez\u00e4hlt. Die Bytes des Ethernet-Headers gelten nicht.","title":"Maximum Transfer Unit (MTU)"},{"location":"22FS/KT/summary.html#fragmentation-und-reassembly","text":"Es gibt folgende F\u00e4lle beim Reassembly: Flag MF =0 und Fragment Offset =0: Es wurde nicht fragmentiert Flag MF =1 und Fragment Offset =0: Dies ist das erste Fragment Flag MF =1 und Fragment Offset >0: Dies ist ein Zwischen-Fragment Flag MF =0 und Fragment Offset >0: Dies ist das letzte Fragment Reassembly wird erst beim Ziel-Host erledigt, um Routers zu entlasten und es zu erm\u00f6glichen, dass Fragmente verschiedene Pfade durchs Netzwerk nehmen k\u00f6nnten.","title":"Fragmentation und Reassembly"},{"location":"22FS/KT/summary.html#address-resolution-protocol-arp-layer-2","text":"Ein ARP-Request wird als Broadcast-Message verschickt, die Antwort hingegen nicht. F\u00fcr Requests (Bild von oben), ist die Ethernet-Hardware-Address auf die Broadcast-Adresse angegeben und das Feld Hardware Address of Traget ist null , da es nicht bekannt ist. Bei der Reply ist die Ethernet Address of Destintation) und Hardware Address of Target gesetzt. In einem ARP-Cache werden die Mac-Ip Paare gecached. Ein Gratuitous ARP Request wird von einem Konten beim Booten oder Adresse-Ver\u00e4nderung versendet. Wenn keine Antwort zur\u00fcck kommt, ist die IP-Adresse nicht vergeben. So k\u00f6nnen Adress-Konflikte erkannt werden. Ein Gratuitous ARP Reply wird von Knoten beim Booten oder Adress-Ver\u00e4ndrung versendet um den ARP-Cache anderer Knoten zu berechtigen oder setzen. Da die Reply ohne Request verschickt wurde, wird sie an die Broadcast-Adresse geschickt. Reverse Address Resolution Protocol (RARP) kann genutzt werden, um von einer MAC-Adresse die IP-Adresse zu bekommen von einem zentralen Server. Z.B. von einer Maschine nach einem Reboot.","title":"Address Resolution Protocol (ARP) [Layer 2]"},{"location":"22FS/KT/summary.html#internet-control-message-protocol-icmp-layer-3","text":"ICMP Pakete werden der Schicht 3 zugeordnet, obwohl sie in einem IP-Paket gekapselt werden. ICMP-Type Bedeutung Beispiel 3 Destination Unreachable Wenn der Router ein Node nicht erreiche kann, weil z.B. die MTU zu klein ist, das h\u00f6here Protokoll deaktiviert ist beim Host, das Paket fragmentiert werden muss aber DF gesetzt ist oder der Node ausgesteckt wurde: TODO Code Protocol Unreachable=Node kommuniziert nicht \u00fcber das Protokol; Port Unreachable = Kein Program h\u00f6rt auf diesen Port; 13 Communication adminstrativvely prohibited = Die Firewall blockiert etwas. Destination Unreachable kann auch genutzt werden, um die MTU einer Leitung zu finden 4 Source Quench Der Puffer des Routers ist voll 5 Redirct Wird an ein Host geschickt, wenn der Router feststellt, dass ein Paket an den falschen Router geschickt wurde 11 Time Exceeded Wenn das TTL-Feld =0 ist, wird es vom Router nicht mehr weitergesendet. Dies kann f\u00fcr Trace-Rout genutzt weden. Jeder Router reduziert das TTL-Feld um 1. Wenn der Router ein Paket mit TTL=1 bekommt wird dies um 1 reduziert und danach verworfen. 12 Parameter Problem Falls der Host oder Router im IP-Header einen ung\u00fcltigen Wert hat 0 Echo Reply Die Antowort auf ein Echo Request 8 Echo (-Request) Pingt ein Knoten an, welcher ein Echo Reply senden sollte 13 Timestamp Verhalten sich gleich wie Echo-Requests/-Replies aber senden noch die Zeit des Senders und Empf\u00e4ngers 14 Timestamp Reply Siehe 13 - Timestamp","title":"Internet Control Message Protocol (ICMP) [Layer 3]"},{"location":"22FS/KT/summary.html#destination-unreachable-type-3","text":"Code-Feld : 0 = net unreachable; 1 = host unreachable; 2= protocol unreachable; 3 = port unreachable; 4 fragmentation needed and DF set; 5 source route failed; 13 = communication administratively prohibited Internet Header + 64 Bits of Original Datagram enth\u00e4lt den ersten Teil des Datagramms, das die ICMP-Meldung ausgel\u00f6st hat. Damit ist der urspr\u00fcngliche Absender in der Lage, den Fehler genauer zu bestimmen.","title":"Destination Unreachable (Type 3)"},{"location":"22FS/KT/summary.html#time-exceeded-message-type-11","text":"Das Format ist gleich, wie bei Destination Unreachable (Type 3). Das Code-Feld kann folgende Werte haben: 0 = time to live exceeded in transit; 1 = fragment reassembly time exceeded.","title":"Time Exceeded Message (Type 11)"},{"location":"22FS/KT/summary.html#echo-request-reply-message-type-8-type-0","text":"Identifier : ID, damit der Sender die Echo-Reply zu einem Prozess kann. In der Reply steht die selbe Zahl Sequence Number : Wird bei jedem Echo-Request inkrementiert. In der Reply steht die selbe Zahl. Code-Feld : ist null","title":"Echo-Request/-Reply Message (Type 8 / Type 0)"},{"location":"22FS/KT/summary.html#transport-layer-layer-4","text":"Die Aufgabe des Layer 4 ist es eine effiziente Verbindung zwischen zwei Knoten f\u00fcr den Session Layer (Layer 5) zu bereit stellen. Dabei soll die Qualit\u00e4t der Verbindung gew\u00e4hrgeleistet sein","title":"Transport Layer (Layer 4)"},{"location":"22FS/KT/summary.html#adressierung","text":"Ein Port ist eine Zahl zwischen 1 und 65'536 und sind folgendermassen unterteilt: 1-1023 : Well-Known Port Nummern, wie z.B. 80 f\u00fcr HTTP 1024-49'151 : Reservierte Bereiche f\u00fcr herstellerspezifischen Applikationen 49'152-65'536 : Dynamische/Private Ports, welche beliebig verwendet werden k\u00f6nnen Die folgende Tabelle enth\u00e4lt die wichtigsten Well-Known Ports: (465/TCP - SMTPS sollte heissen \"SMTP over SSL/TLS\") Um eine Kommunikationsbeziehung eindeutig zu bestimmen braucht es folgende 5 Parameter: Source Port; Destination Port; Source IP-Adresse; Destination IP-Adresse; Das Protokol (UDP oder TCP)","title":"Adressierung"},{"location":"22FS/KT/summary.html#tcp-transmission-control-protocol","text":"TCP bietet folgendes f\u00fcr eine Applikation: Verbindungsorientierte \u00dcbetragung : Eine Verbindung muss zuerst aufgebaut werden und eine TCP-Verbindung hat genau 2 Endpunkte (Multicast wird nicht unterst\u00fctzt) Hohe Zuverl\u00e4ssigkeit: TCP garantiert die Daten\u00fcbertragung ohne Verluste in der richtigen Reihenfolge Vollduplex\u00fcbertragung: In einer TCP Verbindung k\u00f6nnen Daten in beide Richtungen fliessen Stream-Schnittstelle: Eine Andwenung kann ein Stream von Bytes senden, welche vom Empf\u00e4nger in derselben Reihenfolge wieder empfangen werden. Zuverl\u00e4ssiger Verbindungsaufbau : Es muss zuerst eine Verbindung aufgebaut werden. Pakete von einer vorherigen Verbindungen sind danach nicht mehr g\u00fcltig Eleganter Verbindungsabbau : Beide Seiten k\u00f6nnen die Verbindung trennen und sie wird sauber abgebaut Im folgenden Diagramm wird aufgezeichnet, wie ein Verbindungsaufbau, das Senden/Empfangen von Nachrichten und der Verbindungsabbau beschreiben. Im folgenden Diagramm sind die feinen Zust\u00e4nde eines Clients oder Server aufgezeichnet:","title":"TCP (Transmission Control Protocol)"},{"location":"22FS/KT/summary.html#probleme","text":"Die folgenden Probleme m\u00fcssen von TCP gel\u00f6st werden: Eine Verbindung soll zuverl\u00e4ssig auf- und abgebaut werden k\u00f6nnen Eine TCP-Nachricht k\u00f6nnen verloren, verf\u00e4lscht, dupliziert oder verstauscht werden. TCP muss diese Nachrichten trotzdem wieder korrekt zusammen setzen und der Applikationsschicht \u00fcbergeben. Hierf\u00fcr werden Techniken, wie Sequenznummern, Adaptiver Timeout, Sliding Window Protokoll ben\u00fctzt. Der Empf\u00e4nger soll nicht \u00fcberschwemmt werden. Hier f\u00fcr wird Flow Control mit Advertized Window Size gen\u00fctzt. Das Netzwerk dazwischen soll nicht \u00fcberlastet werden. Hier f\u00fcr gibt es Congestion Control mit Slow Start Algorithmus.","title":"Probleme"},{"location":"22FS/KT/summary.html#tcp-header","text":"TCP Source Port und Destination Port : Der genutzte Port auf dem Sender und Empf\u00e4nger Sequence Number : (Bezieht sich auf die Ausgangsdaten) Anhand dieser Zahl k\u00f6nnen Daten in der richtigen Reihenfolge der Applikation \u00fcbergeben werden und es wird die Acknowledgement Number damit berechnet Acknowledgment Number : (Bezieht sich auf die Eingangsdaten) Header Length/Data Offset : Gibt an, wo der TCP-Header mit optionalen Headers aufh\u00f6rt und die Daten beginnen Control Bits : Flags, welche z.B. den Verbindungsaufbau und -abbau einleiten Diese Flags haben die folgende bedeutung: URG : Urgent-Pointer-Feld enh\u00e4lt einen g\u00fcltigen Wert ACK : Acknowledgment Feld enh\u00e4lt einen g\u00fcltigen Wert PSH : (= Push) Empf\u00e4nger soll Daten sofort an die Applikation weiterleiten RST (=Reset) Verbindung zur\u00fccksetzen SYN (=Synchronize) Verbindung aufbauen FIN : Der Sender hat keine Daten mehr zu \u00fcbertragen. Verbindung abbauen Window : Gibt die noch verf\u00fcgbare Buffer-Gr\u00f6sse des Senders an. Wenn ein Empf\u00e4nger 0 im Window-Feld erh\u00e4lt, stoppt er zu senden, bis eine Retransmission mit einem gr\u00f6sseren Window-Feld ankommt. Checksum : Die Checksume des TCP-Pakets Urgent Pointer : Falls URG gesetzt ist, zeigt dieses Feld an, wo die \"Urgent-Daten\" im Datenblock gefunden werden k\u00f6nnen Options : Optionen, wie \"SACK\" oder die maximale Segmentl\u00e4nge (MSS) k\u00f6nnen als optionale Option \u00fcbertragen werden","title":"TCP-Header"},{"location":"22FS/KT/summary.html#verbindungsaufbau","text":"","title":"Verbindungsaufbau"},{"location":"22FS/KT/summary.html#datenaustausch","text":"Eine Nachricht vom Sender m\u00fcssen vom Client immer mit einem Paket, welches das ACK -Flag Gesetzt hat, best\u00e4tigen werden. Vor dem senden startet der Sender ein Timer. Falls dieser abl\u00e4uft, bevor der Empf\u00e4nger das Paket best\u00e4tigt hat, wird das Paket erneut versendet. Es gibt eine Retransmission . Die Seq Zahl der Antwort des Servers ist die Ack Zahl des Requests. Die Ack Zahl der Antwort des Servers ist die Seq -Zahl + die Anzahl empfangenen Bytes.","title":"Datenaustausch"},{"location":"22FS/KT/summary.html#verbindungsabbau","text":"MSL=Maximum Segment Length Das Timeout am Ende ist n\u00f6tig, falls das letzte ACK b+m+1 nicht ankommt. In diesem Fall w\u00fcrde die Passive-Seite noch mals ein FIN b+m Paket senden.","title":"Verbindungsabbau"},{"location":"22FS/KT/summary.html#sliding-window","text":"","title":"Sliding Window"},{"location":"22FS/KT/summary.html#adaptive-elemente-von-tcp","text":"","title":"Adaptive Elemente von TCP"},{"location":"22FS/KT/summary.html#adaptives-timeout","text":"Das Timeout von TCP wird adaptiv bestimmt und \u00e4ndert sich \u00fcber die Lebenszeit der Verbindung. Daf\u00fcr werden folgende Formeln ben\u00fctzt: $$ RTO_n=SRTT_n + 4\\cdot RTTVAR_n\\ SRTT_n = (1 - \\alpha )\\cdot SRTT_{n-1}+\\alpha\\cdot RTT_n\\ RTTVAR_n=(1 - \\beta)\\cdot RTTVAR_{n - 1}+\\beta \\cdot \\vert SRTT_n - RTT_n \\vert $$ Dabei steht \\(RTO\\) f\u00fcr Retransmission Time-Out , \\(SRTT\\) f\u00fcr Smoothed Round-Trip-Time und ist ein gewichteter Mittelwert, \\(RTT\\) f\u00fcr Round-Trip-Time und \\(RTTAV\\) f\u00fcr Round-Trip-Time Variance und ist der gewichteter Mittelwert der Abweichung, bzw. die Streuung. Wenn die Roud-Trip-Time \u00fcberschritten wird, wird der Sender das Paket erneut senden.","title":"Adaptives Timeout"},{"location":"22FS/KT/summary.html#bestatigung-von-paketen","text":"In TCP wird das Sliding-Window Verfahren f\u00fcr die Best\u00e4tigung von Paketen gen\u00fctzt. Der Sender sendet alle Pakete im Fenster und schiebt das Fenster weiter, wenn die \u00e4lteste Nachricht best\u00e4tigt wurde. Ohne Sliding-Window Verfahren muss der Sender immer auf eine Best\u00e4tigung warten. Mit dem Sliding-Window k\u00f6nnen mehrere Pakete versendet werden.","title":"Best\u00e4tigung von Paketen"},{"location":"22FS/KT/summary.html#fluss-steuerung","text":"Im folgenden Paket wird angenommen, dass der Empf\u00e4nger mit einer Buffergr\u00f6sse von 2'500 Bytes hat. Der Empf\u00e4nger sendet die verbleibende Buffergr\u00f6sse im Window Feld zur\u00fcck. Wenn der Sender eine Best\u00e4tigung mit Window=0 empf\u00e4ngt, wartet er, bis er dieselbe Best\u00e4tigung mit einer h\u00f6heren Window Feld empf\u00e4ngt.","title":"Fluss-Steuerung"},{"location":"22FS/KT/summary.html#uberlastung-des-netzwerks-vermeiden","text":"Beim Slow-Start Algorithmus beginnt der Sender mit einer kleinen vordefinierten Gr\u00f6sse und verdoppelt dies mit jedem gesendetem Paket bis er die erste Schwelle erreicht. Danach wird die Paketgr\u00f6sse linear vergr\u00f6ssert bis ein Timeout entsteht. Bei einem Timeout wird die n\u00e4chste Schwelle auf die H\u00e4lfte des Paketes, bei welchem das Timeout entstand. Danach wird wieder ein Slow-Start ausgef\u00fchrt. Es gibt f\u00fcr den Slow-Start Algorithmus folgende Kritikpunkte Die \"S\u00e4gezahnkurven\" verschiedener TCP-Sessions tendieren dazu, sich zu synchronisieren Die Annahme gilt f\u00fcr Wireless-Netze nicht mehr unbedingt, wo relativ viel Paketverlust durch Bitfehler w\u00e4hrend der \u00dcbertragung vorkommt Slow-Start bei kurzen Transfers immer slow (www) Abh\u00e4ngig von Round Trip Time","title":"\u00dcberlastung des Netzwerks vermeiden"},{"location":"22FS/KT/summary.html#udp-user-datagram-protocol","text":"UDP, wie auch TCP, ist ein Layer 4 Protokol und ben\u00fctzt Ports zur adressierung. Es ist aber nicht zuverl\u00e4ssig und erledigt nichts gegen Paket Verluste oder vertauschte Pakete. Daf\u00fcr kann ein Knoten sofort senden, da es keinen Verbindungsaufbau gibt, es gibt weniger Overhead und ist weniger rechnungsintensiv. Es kann, wie auch TCP, Daten anhand von einer Port-Nummer der richtigen Anwendung zuweissen (Demultiplexing) und umgekehrt (Multiplexing).","title":"UDP (User Datagram Protocol)"},{"location":"22FS/KT/summary.html#header","text":"Der UDP Header besteht aus 8 Bytes und beinhaltet folgendes:","title":"Header"},{"location":"22FS/KT/summary.html#application-layer-layer-7","text":"","title":"Application Layer (Layer 7)"},{"location":"22FS/KT/summary.html#dns-udp53","text":"Type Beschreibung A IPv4 Adresse des gesuchten Hosts (32 Bit) AAAA IPv6 Adresse des gesuchten Hosts (128 Bit) MX Mail Exchange (Mail Server) NS Name Server f\u00fcr eine Zone CNAME Canonical Name; Alias zum Host TXT Text Record; in Antowrten f\u00fcr verschiedenste Angaben verwendet Die 13 Root Server wissen wo die NS-Server der Top-Level Domains sind.","title":"DNS (UDP/53)"},{"location":"22FS/KT/summary.html#ablauf-einer-namensauflosung","text":"Resolver ist die lokale Software. Host fragt DNS-Server nach einer Adresse hello.example.com. DNS Server fragt Root-Server nach dem com. NS DNS Server fragt .com -NS nach example.com. DNS Server fragt example.com. -NS nach hello.example.com F\u00fcr Reverse DNS werden dieselben Schritte ausgef\u00fchrt, aber mit einer IP Adresse.","title":"Ablauf einer Namensaufl\u00f6sung"},{"location":"22FS/KT/summary.html#dhcp-bootp-udp67-udp68","text":"Der Client fragt den Server nach einer Konfiguration auf dem UDP Port 67 als Broadcast-Nachricht. Die Antwort wird an die MAC-Adresse des Client gesendet. BOOTP funktioniert auch \u00fcber Netzwerk-Grenzen. Dabei ist der Router so konfiguriert, dass er den BOOTP-Request liest und per Unicast an den BOOTP-Server sendet. Die Antwort wird wieder an den Client zur\u00fcck geleitet. Es werden folgende Infos gesendet: Netzwerk Configuration: IP-Adresse; Subnet; Gateway IP Boot File Name Nachteile von BootP sind: Bei grossen Anzahl von Knoten, m\u00f6chte man IP-Adressen gemeinsam nutzen, was mit BootP nicht praktikabel ist Mehraufwand, da f\u00fcr jeden Knoten eine Konfiguration eingetragen werden muss DHCP ist abw\u00e4rtskompatibel mit BootP.","title":"DHCP / BOOTP (UDP/67; UDP/68)"},{"location":"22FS/KT/summary.html#network-address-translation-nat","text":"Wenn ein Paket gesendet wird, wird die Source-Adresse und ev. den Port durch die des Gateways ersetzt und an den Server weitergeleitet. Anhand des Ports kann der Gateway eingehende Pakete unterscheiden und dem korrekten Client senden. Daf\u00fcr wird wieder der Header modifiziert. Probleme von NAT: OSI-Model wird verletzt, da die IP und Port ver\u00e4ndert werden und auch Checksummen neu gerechnet werden m\u00fcssen Die Verbindung kann nicht auf Layer 1-3 Verschl\u00fcsselt werden, da die Informationen vom Gateway ben\u00f6tigt werden","title":"Network Address Translation (NAT)"},{"location":"22FS/KT/summary.html#autoconfiguration-mit-ipv4-automatic-private-ip-addressing-apipa","text":"Wenn kein DHCP-Server gefunden wird, wird eine zuf\u00e4lle IP-Adresse zwischen 169.254.1.0 bis 169.254.244.255 (Netzwerk 169.254.0.0/16) gew\u00e4hlt und mit einem Gratuious ARP-Request \u00fcberpr\u00fcft, ob die IP-Adresse bereits besetzt ist. Um mit dieser IP-Adresse ins Internet zu kommen, muss der Router ARP-Requests f\u00fcr alle IP-Adressen ausserhalb des Netzwerks erkennen und auf sich leiten. Der Router kann die Pakete danach an den korrekten Host weiterleiten. Um Ger\u00e4te ohne DHCP und DNS Server zu finden, kann multicast DNS (mDNS) verwendet werden, welches ein verteilter DNS Server ist. Es wird ein \"normalen\" DNS Request an 244.0.0.251 mit dem UDP Port 5353 geschickt. Wenn nach services.dns-sd.udp.local. gefragt wird, antworten alle mDNS f\u00e4higen Ger\u00e4te.","title":"Autoconfiguration mit IPv4 - Automatic Private IP Addressing (APIPA)"},{"location":"22FS/KT/summary.html#trivial-file-transfer-protocol-tftp-udp69","text":"Es gibt f\u00fcnf Operationen: Read Request (RRQ) : Fordert eine Datei an Write Request (WRQ) : Shickt eine Datei an den Host Acknowledgment (ACK) : Best\u00e4tigt das korrekte Empfangen von WRQ- oder DATA-Pakete. Es wird die Block-Nummer angegeben Data (DATA) : \u00dcbermittelt die eigentlichen Daten-Bl\u00f6cke. Ein Block ist 512 Bytes (wenn nicht anderst angegeben in WRQ oder RRQ Request). Wenn ein Block kleiner ist, wird das als Ende der Datei interpretiert. Error (ERROR) : Beschreibt den aufgetretener Fehler Wird ein ACK oder DATA Paket nicht innerhalbs einer Zeit empfangen, wird die letzte ACK- oder DATA Nachricht nochmals versendet.","title":"Trivial File Transfer Protocol (TFTP) [UDP/69]"},{"location":"22FS/KT/summary.html#simple-mail-transfer-protocol-smtp-tcp25","text":"Sendet ein Mal zu einem Mail-Server, welcher das Mail ebenfalls weiterleitet oder zwischen Speichert damit der Nutzer dies via POP3 oder IMAP abholen kann. Ablauf: Verbinden mit dem Server und identifizieren und authentifizieren Client sendet MAIL FROM <absender> und RCPT TO <empf\u00e4nger> um die Empf\u00e4nger zu definieren Mit DATA wird das Mail versendet QUIT wird vom Client gesendet, was vom Server mit Bye-Bye quitiert wird Der Server-Antwortet auf die Befehle mit 3-stelligen Zahlen Codes (wie HTTP-Status Codes) S: 220 mail.zhaw.ch ESMTP Sendmail 8.8.8/8.8.8 C: HELO zhaw.ch S: 250 mail.zhaw.ch Hello mth@mail.zhaw.ch, pleased to meet you C: MAIL FROM:<mth@zhaw.ch> S: 250 OK C: RCPT TO:<kls@zhaw.ch> S: 250 <kls@zhaw.ch>... Recipient ok C: DATA S: 354 Enter mail, end with \".\" on a line by itself C: Date: 06 Jan 2099 16:34:25 +0100 C: To: kls@zhaw.ch C: Subject: Test einer Mail. C: C: Damit ist der SMTP-Teil beendet. C: . S: 250 OK C: QUIT S: 221 mail.zhaw.ch closing connection","title":"Simple Mail Transfer Protocol (SMTP) [TCP/25]"},{"location":"22FS/KT/summary.html#zeichensatz","text":"SMTP ben\u00fctzt ein 7-Bit ASCII Zeichen-Satz. Folgende Headers werden gesetzt, um MIME zu verwenden. Der Mime-Seperator wird eingesetzt wenn MIME-Version: 1.0 Content-Type: Multipart/Mixed; Boundary=\"Mime-Separator-WAB02622.926626671\" Mime-Separator-WAB02622.926626671 Content-Type: text/plain Hallo! Hier folgt der Text.","title":"Zeichensatz"},{"location":"22FS/KT/summary.html#quoted-printable","text":"Jedes 8-bit Zeichen wird durch =xx ersetzt, wobei xx eine Hex-Zahl ist. ( 1 -> =31 ). Dies ist sehr ineffizient (Effizienz: 30%)","title":"Quoted-Printable"},{"location":"22FS/KT/summary.html#base64","text":"Alle Texte werden auf 6-Bit Zeichen aufgeteilt. Wenn es nicht aufgeht, wird mit = ein (6-Bit) null-Byte eingesetzt. Ausdem folgt, das ein Vielfaches von drei 8-Bit Bytes kein Padding ben\u00f6tigten. (Effiizienz: 73%)","title":"Base64"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html","text":"Lineare Gleichungssystem Eine Gleichung ist lineare, wenn sie die folgende Form entspricht: \\(ax+by+cz=d\\) Koeffizienten Matrix Ein lineares Gleichungssystem kann als eine Matrize Multiplikation geschrieben werden. $$ \\text{} \\begin{cases} i_1x+i_2y=c_1\\ i_3x+i_4y=c_2\\ i_5x+i_6y=c_2 \\end{cases} \\ \\begin{pmatrix} i_1 & i_2 \\ i_3 & i_4\\ i_5 & i_6 \\end{pmatrix} \\cdot \\begin{pmatrix} x \\ y \\end{pmatrix} = \\begin{pmatrix} i_1x+i_2y\\ i_3x+i_4y\\ i_5x+i_5y \\end{pmatrix} = \\begin{pmatrix} c_1\\ c_2\\ c_3 \\end{pmatrix} $$ Dies kann vereinfacht als eine erweiterte Koeffizienten Matrix geschreiben werden: $$ \\left( \\begin{array}{cc|cr} i_1 & i_2 & c_1\\ i_3 & i_4 & c_2\\ i_5 & i_6 & c_3 \\end{array} \\right) $$ Homogene Gleichungssysteme Homogene Gleichungssysteme sind Gleichungssysteme bei denen das Resultat bei allen Gleichungen 0 ist. Es kann eine oder unendlich viele L\u00f6sungen haben. Es ist nicht m\u00f6glich, dass es keine L\u00f6sung hat. Zeilenstufenform Die Zeilenstufenform ist definiert durch die folgenden Regeln: Alle Zeilen mit nur 0 stehen zu unterst Wenn eine Zeile nicht nur aus 0 besteht, ist die erste Zahl, welche keine 0 ist, eine 1 . Diese 1 wird als f\u00fchrende Eins bezeichnet Eine f\u00fchrende Eins, welche weiter unten steht, muss auch weiter rechts stehen, als die anderen f\u00fchrenden Einsen Zus\u00e4tzlich gibt es noch die reduzierte Zeilenstufenform , bei welcher noch die Regel gilt, dass in den Spalten mit einer f\u00fchrenden Eins, die weiteren Elemente 0 sein m\u00fcssen. Bei der erweiterten Koeffizientenmatrix sind die Resultat-Werte (die \\(c_i\\) Werte) von den Regel ausgenommen werden. Folgendes Matrix ist in der Zeilenstufenform: L\u00f6sung aus der Zeilenstufenform Um aus einer Zeilenstufenform die L\u00f6sung zu lesen, werden die Variablen in f\u00fchrende Unbekannte und freie Unbekannte unterteilt. F\u00fchrende Unbekannte sind all diese Variable, welche in ihrer Spalte eine f\u00fchrende 1 haben, die anderen Variablen sind freie Unbekannte. F\u00fcr die freien Unbekannte werden nun eine beliebige Variable gleichgesetzt. Oft werden grichische Buchstaben verwendet, um die Verwechslungsgefahr gering zu halten. Im oberen Beispiel: $$ x_2=\\lambda\\ x_4=\\mu $$ Jede f\u00fchrende Unbekannte wird nun in eine Gleichung \u00fcbersetzt. Wieder f\u00fcr das Beispiel oben: $$ x_1-2x_2+3x_4=5 \\rightarrow x_1=5+2x_2-3x_4\\ x3-x4=3\\rightarrow x_3=3+x_4 $$ Nun kann das Gleichungssystem von unten (also \\(x_4\\) in diesem Fall) gel\u00f6st werden: $$ \\begin{align} x_4&=\\mu\\ x_3&=3+\\mu\\ x_2&=\\lambda\\ x_1&=5+2\\lambda-3\\mu \\end{align} $$ In diesem Fall gibt es zwei Unbekannte \\(\\lambda\\) und \\(\\mu\\) . Dank diesen gibt es unendlich viele L\u00f6sungen. Es kann auch eine spezifische L\u00f6sung oder gar keine L\u00f6sung geben. Parameterdarstellung Die Parameterdarstellung ist eine alternative Darstellungsm\u00f6glichkeit von des Resultats. Das untere Beispiel zeigt das Beispiels-Gleichungssystem von oben: $$ \\vec x=\\begin{pmatrix}x_1\\x_2\\x_3\\_x4\\end{pmatrix}= \\begin{pmatrix}5 \\0\\3\\0\\end{pmatrix} +\\lambda \\begin{pmatrix}2\\1\\0\\0\\end{pmatrix}+ \\mu\\begin{pmatrix}-3\\0\\1\\1\\end{pmatrix} $$ Anzumerken ist, dass \\(x_2\\) bei der \\(\\lambda\\) Matrix ein 1 hat. Dies liegt daran, dass \\(x_2=\\lambda\\) ist. Dasselbe gilt auch mit \\(x_4=\\mu\\) und der \\(\\mu\\) Spalte bei \\(x_4\\) Zeilenstufenform herleiten (Gauss-Verfahren und Gauss-Jordan-Verfahren) Ein Gleichungssystem, welches bereits in der Zeilenstufenform ist zu l\u00f6sen, ist einfach. Die Frage ist nun, wie jemand ein solches Form herleiten kann. Wir nennen die am weitesten links stehende Spalte mit Element \\(\\neq0\\) Pivot-Spalte Wenn die Zeile mit dem f\u00fchrenden Eins nicht zu oberst ist, wird sie mit der obersten Zeile getauscht Die oberste Zeile wird durch die erste Element \\(\\neq 0\\) in der Spalte geteilt. So wird eine f\u00fchrende Eins erzeugt Um 0 in der Pivot-Spalte unter der obersten Zeile zu erzeugen, wird jede Zeile unter der obersten Zeile mit einem Vielfachen der obersten Zeile addiert um 0 zu forderst zu erzeugen Schritte 1-5 wiederholen, bis eine Zeilenstufenform vorhanden ist Wenn eine reduzierte Zeilenstufenform verlangt wird, muss danach ein Vielfaches der unterste Zeile auf die oberen Zeile addiert werden, so dass diese 0 ergeben. Wenn man mithilfe der reduzierten Form die Gleichung l\u00f6st, spricht man vom Gauss-Jordan-Verfahren, ansonsten nur vom Gauss-Verfahren. Das folgende Beispiel wird an dem folgenden Gleichungssystem durchgef\u00fchrt: \\[ \\left(\\begin{array} {ccc|c} 1 & -1 & 1 & 0\\\\ 3 & 1 & 0 & 18\\\\ 0 & 1 & 2 & 10 \\end{array}\\right) \\] Schritt Beispiel A1. Die erste Spalte ist die Pivot-Spalte A2. Das oberste Element der Pivot-Spalte ist bereits \\(\\neq 0\\) A3. Es wird von der zweiten Zeile drei mal die erste Zeile abgezogen. Die dritte Zeile hat bereits eine 0 in der Pivot-Spalte $\\left(\\begin{array} {ccc B1. Die zweite Spalte ist nun die Pivot-Spalte B2. Das oberste Element (die erste Zeile wird ignoriert, daher ist dies in der zweiten Zeile), ist eine 4 , daher wird die zweite Zeile durch eine 4 geteilt $\\left(\\begin{array} {ccc B3. Es wird das \\((-1)\\) Fache von der Zeile 2 zu der Zeile 3 addiert $\\left(\\begin{array} {ccc C1. Die dritte Spalte ist nun die Pivot-Spalte C2. Die ersten zwei Zeilen werden ignoriert, daher wird die letzte Zeile durch 2.75 geteilt, damit eine 1 zu forderst steht. $\\left(\\begin{array} {ccc Die Matrix ist nun in der Zeilenstufenform. Wenn die reduzierte Stufenzeilenform verlangt wird, muss der f\u00fcnfte Schritt noch durch gef\u00fchrt werden: Schritt Beispiel A5. Die zweite Zeile wird mit dem \\((-0.75)\\) Fachen der Zeile drei addiert und die erste Zeile mit der Zeile drei addiert (also \\(\\cdot 1\\) ) $\\left(\\begin{array} {ccc B5. Die erste Zeile wird mit der zweiten Zeile addiert $\\left(\\begin{array} {ccc Nun ist die Matrix in der reduzierten Zeilenstufenform. L\u00f6sbarkeit von linearen Gleichungssystemen Ein lineares Gleichungssystem hat drei verschiedene L\u00f6sungsm\u00f6glichkeiten: Keine L\u00f6sung, eine L\u00f6sung, unendliche L\u00f6sungen. Graphisch gezeichnet, sieht dies so aus: Um nicht jedes mal ein Gleichungssystem zeichen zu m\u00fcssen, kann man den Rang des Gleichungssystems zu hilfe ziehen: Der Rang \\(rg(A)\\) des Gleichungssystems \\(A\\) ist definiert als \\(rg(A)=\\text{Gesamtanzahl Zeilen} - \\text{Anzahl Nullzeilen}\\) in der Zeilenstufenform \\(rg(A)\\) ist dabei die Matrix ohne die Koeffizienten \\(\\vec c\\) (also ohne die Zahlen nach dem langen Strich). \\(rg(A|\\vec c)\\) ist der Rang der kompletten Matrix (mit den Zahlen nach dem Strich inklusive) Ein lineares Gleichungssystem ist l\u00f6sbar, wenn \\(rg(A)=rg(A|\\vec c)\\) Es hat genau eine L\u00f6sung, wenn gilt: \\(rg(A)=n\\) , \\(n\\) ist die Anzahl Spalten von \\(A\\) Es hat unendlich viele L\u00f6sungen, wenn gilt: \\(rg(A)<n\\) , \\(n\\) ist die Anzahl Spalten von \\(A\\) Ein homogenes Gleichungssystem (alle Koeffizienten sind \\(0\\) ) ist immer l\u00f6sbar, da \\(rg(A)=rg(A|\\vec c)\\) immer gilt. Wenn mit Restklassen gearbeitet werden, kann es vorkommen, dass ein Gleichungssystem keine L\u00f6sung hat, da es kein multiplikatives Invers einer Restklasse gibt und somit die Zeilenstufenform nicht geformt werden kann.","title":"Lineare Gleichungssystem"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#lineare-gleichungssystem","text":"Eine Gleichung ist lineare, wenn sie die folgende Form entspricht: \\(ax+by+cz=d\\)","title":"Lineare Gleichungssystem"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#koeffizienten-matrix","text":"Ein lineares Gleichungssystem kann als eine Matrize Multiplikation geschrieben werden. $$ \\text{} \\begin{cases} i_1x+i_2y=c_1\\ i_3x+i_4y=c_2\\ i_5x+i_6y=c_2 \\end{cases} \\ \\begin{pmatrix} i_1 & i_2 \\ i_3 & i_4\\ i_5 & i_6 \\end{pmatrix} \\cdot \\begin{pmatrix} x \\ y \\end{pmatrix} = \\begin{pmatrix} i_1x+i_2y\\ i_3x+i_4y\\ i_5x+i_5y \\end{pmatrix} = \\begin{pmatrix} c_1\\ c_2\\ c_3 \\end{pmatrix} $$ Dies kann vereinfacht als eine erweiterte Koeffizienten Matrix geschreiben werden: $$ \\left( \\begin{array}{cc|cr} i_1 & i_2 & c_1\\ i_3 & i_4 & c_2\\ i_5 & i_6 & c_3 \\end{array} \\right) $$","title":"Koeffizienten Matrix"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#homogene-gleichungssysteme","text":"Homogene Gleichungssysteme sind Gleichungssysteme bei denen das Resultat bei allen Gleichungen 0 ist. Es kann eine oder unendlich viele L\u00f6sungen haben. Es ist nicht m\u00f6glich, dass es keine L\u00f6sung hat.","title":"Homogene Gleichungssysteme"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#zeilenstufenform","text":"Die Zeilenstufenform ist definiert durch die folgenden Regeln: Alle Zeilen mit nur 0 stehen zu unterst Wenn eine Zeile nicht nur aus 0 besteht, ist die erste Zahl, welche keine 0 ist, eine 1 . Diese 1 wird als f\u00fchrende Eins bezeichnet Eine f\u00fchrende Eins, welche weiter unten steht, muss auch weiter rechts stehen, als die anderen f\u00fchrenden Einsen Zus\u00e4tzlich gibt es noch die reduzierte Zeilenstufenform , bei welcher noch die Regel gilt, dass in den Spalten mit einer f\u00fchrenden Eins, die weiteren Elemente 0 sein m\u00fcssen. Bei der erweiterten Koeffizientenmatrix sind die Resultat-Werte (die \\(c_i\\) Werte) von den Regel ausgenommen werden. Folgendes Matrix ist in der Zeilenstufenform:","title":"Zeilenstufenform"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#losung-aus-der-zeilenstufenform","text":"Um aus einer Zeilenstufenform die L\u00f6sung zu lesen, werden die Variablen in f\u00fchrende Unbekannte und freie Unbekannte unterteilt. F\u00fchrende Unbekannte sind all diese Variable, welche in ihrer Spalte eine f\u00fchrende 1 haben, die anderen Variablen sind freie Unbekannte. F\u00fcr die freien Unbekannte werden nun eine beliebige Variable gleichgesetzt. Oft werden grichische Buchstaben verwendet, um die Verwechslungsgefahr gering zu halten. Im oberen Beispiel: $$ x_2=\\lambda\\ x_4=\\mu $$ Jede f\u00fchrende Unbekannte wird nun in eine Gleichung \u00fcbersetzt. Wieder f\u00fcr das Beispiel oben: $$ x_1-2x_2+3x_4=5 \\rightarrow x_1=5+2x_2-3x_4\\ x3-x4=3\\rightarrow x_3=3+x_4 $$ Nun kann das Gleichungssystem von unten (also \\(x_4\\) in diesem Fall) gel\u00f6st werden: $$ \\begin{align} x_4&=\\mu\\ x_3&=3+\\mu\\ x_2&=\\lambda\\ x_1&=5+2\\lambda-3\\mu \\end{align} $$ In diesem Fall gibt es zwei Unbekannte \\(\\lambda\\) und \\(\\mu\\) . Dank diesen gibt es unendlich viele L\u00f6sungen. Es kann auch eine spezifische L\u00f6sung oder gar keine L\u00f6sung geben.","title":"L\u00f6sung aus der Zeilenstufenform"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#parameterdarstellung","text":"Die Parameterdarstellung ist eine alternative Darstellungsm\u00f6glichkeit von des Resultats. Das untere Beispiel zeigt das Beispiels-Gleichungssystem von oben: $$ \\vec x=\\begin{pmatrix}x_1\\x_2\\x_3\\_x4\\end{pmatrix}= \\begin{pmatrix}5 \\0\\3\\0\\end{pmatrix} +\\lambda \\begin{pmatrix}2\\1\\0\\0\\end{pmatrix}+ \\mu\\begin{pmatrix}-3\\0\\1\\1\\end{pmatrix} $$ Anzumerken ist, dass \\(x_2\\) bei der \\(\\lambda\\) Matrix ein 1 hat. Dies liegt daran, dass \\(x_2=\\lambda\\) ist. Dasselbe gilt auch mit \\(x_4=\\mu\\) und der \\(\\mu\\) Spalte bei \\(x_4\\)","title":"Parameterdarstellung"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#zeilenstufenform-herleiten-gauss-verfahren-und-gauss-jordan-verfahren","text":"Ein Gleichungssystem, welches bereits in der Zeilenstufenform ist zu l\u00f6sen, ist einfach. Die Frage ist nun, wie jemand ein solches Form herleiten kann. Wir nennen die am weitesten links stehende Spalte mit Element \\(\\neq0\\) Pivot-Spalte Wenn die Zeile mit dem f\u00fchrenden Eins nicht zu oberst ist, wird sie mit der obersten Zeile getauscht Die oberste Zeile wird durch die erste Element \\(\\neq 0\\) in der Spalte geteilt. So wird eine f\u00fchrende Eins erzeugt Um 0 in der Pivot-Spalte unter der obersten Zeile zu erzeugen, wird jede Zeile unter der obersten Zeile mit einem Vielfachen der obersten Zeile addiert um 0 zu forderst zu erzeugen Schritte 1-5 wiederholen, bis eine Zeilenstufenform vorhanden ist Wenn eine reduzierte Zeilenstufenform verlangt wird, muss danach ein Vielfaches der unterste Zeile auf die oberen Zeile addiert werden, so dass diese 0 ergeben. Wenn man mithilfe der reduzierten Form die Gleichung l\u00f6st, spricht man vom Gauss-Jordan-Verfahren, ansonsten nur vom Gauss-Verfahren. Das folgende Beispiel wird an dem folgenden Gleichungssystem durchgef\u00fchrt: \\[ \\left(\\begin{array} {ccc|c} 1 & -1 & 1 & 0\\\\ 3 & 1 & 0 & 18\\\\ 0 & 1 & 2 & 10 \\end{array}\\right) \\] Schritt Beispiel A1. Die erste Spalte ist die Pivot-Spalte A2. Das oberste Element der Pivot-Spalte ist bereits \\(\\neq 0\\) A3. Es wird von der zweiten Zeile drei mal die erste Zeile abgezogen. Die dritte Zeile hat bereits eine 0 in der Pivot-Spalte $\\left(\\begin{array} {ccc B1. Die zweite Spalte ist nun die Pivot-Spalte B2. Das oberste Element (die erste Zeile wird ignoriert, daher ist dies in der zweiten Zeile), ist eine 4 , daher wird die zweite Zeile durch eine 4 geteilt $\\left(\\begin{array} {ccc B3. Es wird das \\((-1)\\) Fache von der Zeile 2 zu der Zeile 3 addiert $\\left(\\begin{array} {ccc C1. Die dritte Spalte ist nun die Pivot-Spalte C2. Die ersten zwei Zeilen werden ignoriert, daher wird die letzte Zeile durch 2.75 geteilt, damit eine 1 zu forderst steht. $\\left(\\begin{array} {ccc Die Matrix ist nun in der Zeilenstufenform. Wenn die reduzierte Stufenzeilenform verlangt wird, muss der f\u00fcnfte Schritt noch durch gef\u00fchrt werden: Schritt Beispiel A5. Die zweite Zeile wird mit dem \\((-0.75)\\) Fachen der Zeile drei addiert und die erste Zeile mit der Zeile drei addiert (also \\(\\cdot 1\\) ) $\\left(\\begin{array} {ccc B5. Die erste Zeile wird mit der zweiten Zeile addiert $\\left(\\begin{array} {ccc Nun ist die Matrix in der reduzierten Zeilenstufenform.","title":"Zeilenstufenform herleiten (Gauss-Verfahren und Gauss-Jordan-Verfahren)"},{"location":"22FS/LA/01_Lineare%20Gleichungssysteme.html#losbarkeit-von-linearen-gleichungssystemen","text":"Ein lineares Gleichungssystem hat drei verschiedene L\u00f6sungsm\u00f6glichkeiten: Keine L\u00f6sung, eine L\u00f6sung, unendliche L\u00f6sungen. Graphisch gezeichnet, sieht dies so aus: Um nicht jedes mal ein Gleichungssystem zeichen zu m\u00fcssen, kann man den Rang des Gleichungssystems zu hilfe ziehen: Der Rang \\(rg(A)\\) des Gleichungssystems \\(A\\) ist definiert als \\(rg(A)=\\text{Gesamtanzahl Zeilen} - \\text{Anzahl Nullzeilen}\\) in der Zeilenstufenform \\(rg(A)\\) ist dabei die Matrix ohne die Koeffizienten \\(\\vec c\\) (also ohne die Zahlen nach dem langen Strich). \\(rg(A|\\vec c)\\) ist der Rang der kompletten Matrix (mit den Zahlen nach dem Strich inklusive) Ein lineares Gleichungssystem ist l\u00f6sbar, wenn \\(rg(A)=rg(A|\\vec c)\\) Es hat genau eine L\u00f6sung, wenn gilt: \\(rg(A)=n\\) , \\(n\\) ist die Anzahl Spalten von \\(A\\) Es hat unendlich viele L\u00f6sungen, wenn gilt: \\(rg(A)<n\\) , \\(n\\) ist die Anzahl Spalten von \\(A\\) Ein homogenes Gleichungssystem (alle Koeffizienten sind \\(0\\) ) ist immer l\u00f6sbar, da \\(rg(A)=rg(A|\\vec c)\\) immer gilt. Wenn mit Restklassen gearbeitet werden, kann es vorkommen, dass ein Gleichungssystem keine L\u00f6sung hat, da es kein multiplikatives Invers einer Restklasse gibt und somit die Zeilenstufenform nicht geformt werden kann.","title":"L\u00f6sbarkeit von linearen Gleichungssystemen"},{"location":"22FS/LA/02_Vektoren.html","text":"Vektoren \\[ \\DeclareMathOperator{\\orth}{\\bot} \\] Vektor Ein Vektor wird durch seine Richtung und Betrag definiert ( Nicht aber der Ort ) Nullvektor Ein Nullvektor \\(\\vec 0\\) hat den Betrag 0 und hat keine Richtung Einheitsvektor/normierter Vektor Ein Vektor \\(\\vec e\\) oder \\(\\vec e_a\\) , welchen der Betrag 1 hat und kann folgendermassen berechnet werden: \\(\\vec e_a=\\frac{\\vec a}{\\vert a \\vert}\\) Gegenvektor Der Gegenvektor zum Vektor \\(\\vec a\\) ist \\(-\\vec a\\) . Es ist also ein Vektor welcher parallel zu \\(\\vec a\\) ist, denselben Betrag hat, aber in die entgegengesetzte Richtung zeigt. Addition Wenn zwei Vektoren addiert werden, werden sie graphisch aneinander geh\u00e4ngt. Diese Operation ist kommutativ und assoziativ: Skalare Multiplikation Wenn ein Vektor mit einer Zahl multipliziert wird, wird der Vektor gestreckt, bzw. geschrumpft. Oft wird der Faktor als griechischen Buchstaben ausgedr\u00fcckt, um Verwechslung zwischen Vektoren und Faktoren zu vermeiden. Linearkombination Eine Linearkombination ist das kombinieren von mehreren skallierten Vektoren: $$ \\lambda_1\\cdot\\vec a_1+\\lambda_2\\cdot\\vec a_2+...+\\lambda_n\\cdot\\vec a_n $$ Betrag Der Betrag eines Vektores ist seine L\u00e4nge. $$ \\begin{align} \\left\\vert\\begin{pmatrix}x\\y\\end{pmatrix}\\right\\vert&=\\sqrt{x^2 + y^2}\\ \\left\\vert\\begin{pmatrix}x\\y\\z\\end{pmatrix}\\right\\vert&=\\sqrt{x^2 + y^2+z^2}\\ \\end{align} $$ Kollinear Zwei Vektoren sind kollinear, wenn es eine Gerade gibt, zu der beide parallel sind. Mathematisch kann dies als \\(\\vec a = \\lambda\\cdot\\vec b\\) ausgedr\u00fcckt werden Komplanar Drei Vektoren heissen komplanar, wenn es eine Ebene gibt, zu der alle drei parallel sind. Linear (Un)abh\u00e4ngig Vektoren werden linear unabh\u00e4ngig genannt, wenn es nur eine M\u00f6glichkeit gibt, mit einer Linearkombination den \\(\\vec 0\\) zu bekommen. $$ \\lambda_1 \\cdot \\vec a_1+\\lambda_2\\cdot \\vec a_2 +...+\\lambda_n\\cdot \\vec a_n=\\vec 0 $$ Diese Definition ist kompatible mit Komplanar und Kollinear. Wenn nur ein Vektor \\(\\vec v\\) gegeben ist, welcher ungleich \\(\\vec 0\\) ist, ist dieser linear unabh\u00e4ngig. Der \\(\\vec 0\\) ist linear abh\u00e4ngig. Wenn \\(\\vec a\\) und \\(\\vec b\\) linear unabh\u00e4ngig sind, dann ist \\(\\begin{vmatrix}a_x & b_x\\\\ a_y & b_y\\end{vmatrix}\\neq 0\\) . Wenn der Determinant nicht ausgerechnet werden kann, kann man sich \u00fcberlegen, ob zwei Vektoren vielfaches voneinander sind, \u00fcber den Rang oder \u00fcber ein lineares Gleichungssystem. Ein weiterer Tip: in \\(\\R^m\\) k\u00f6nnen maximal \\(m\\) Vektoren linear unabh\u00e4ngig sein. Wenn es mehr Vektoren sind, k\u00f6nnen sie nicht linear unabh\u00e4ngig sein. Eigenschaften: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar Satz 1 Es l\u00e4sst sich der Vektor \\(\\vec c\\) als Linearkombination der Vektoren \\(\\vec a\\) und \\(\\vec b\\) im 2D-Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) komplanar zueinander sind \\(\\vec a\\) und \\(\\vec b\\) nicht kollinear sind Satz 2 Wen drei Vektoren \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) nicht komplanar sind, l\u00e4sst sich jeder Vektor \\(\\vec d\\) in \\(\\R^3\\) als eine Linearkombination von \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) darstellen Kordinaten-System Ein Kordinaten-System im Raum \\(\\R^2=R\\times R\\) hat folgendes: Ein Punkt \\(O\\) als Ursprung Ein Einheitsvektor \\(\\vec e_1\\) Ein zweiten Einheitsvektor \\(\\vec e_2\\) , welcher 90\u00b0 im Gegenurzeigersinn zu \\(\\vec e_1\\) ist Jeder Vektor in diesem Kordinatensystem kann als Linearkombination von \\(\\vec e_1\\) und \\(\\vec e_2\\) gebildet werden. Ein Kordinaten-System im Raum \\(R^3\\) hat folgenedes: Einen Punkt \\(O\\) als Ursprung Einen Einheitsvektor \\(\\vec e_1\\) (typischerweisse kommt dieser aus dem Display) Einen zweiten Einheitsvektor \\(\\vec e_2\\) , welcher druch eine 90\u00b0 Drehung gegen den Urzeigensinn von \\(\\vec e_1\\) Einen dritten Einheitsvektor \\(\\vec e_3\\) , welcher ortogonal (Rechtwinlig) zu \\(\\vec e_1\\) und \\(\\vec e_2\\) ist Ortsvektor Ein Ortsvektor ist ein Vektor, welcher im Ursprung festgeheftet wurde. $$ \\vec r(P)=x\\cdot \\vec e_1+y\\cdot \\vec e_2=\\begin{pmatrix}x\\y\\end{pmatrix} $$ Der Ortsvektor \\(\\vec r(P)\\) ist der Vektor vom Ursprung zum Punkt \\(P\\) . Dies wird zum Teil auch als \\(\\vec{OP}\\) dargestellt Vektor zwischen zwei Punkten \\[ \\vec{PQ}=\\begin{pmatrix}x_Q-x_P\\\\y_Q-y_P\\end{pmatrix}=\\vec r(Q)-\\vec r(P) \\] Skalar Produkt $$ \\vec a \\cdot \\vec b = \\vert \\vec a \\vert \\cdot \\vert \\vec b\\vert \\cdot \\cos(\\varphi)\\ \\vec a \\cdot \\vec b=a_1b_1+a_2b_2+a_3b_3 $$ Ein Speziallfal ist, wenn \\(\\vec a\\) oder \\(\\vec b\\) den Nullvektor \\(\\vec 0\\) ist. In diesem Fall ist das Skalarprodukt \\(0\\) . Da es zwei Definition f\u00fcr das Skalarprodukt gibt, k\u00f6nnen diese gleichgesetzt werden und nach dem Zwischenwinkel afugel\u00f6st werden. $$ \\varphi =cos^{-1}\\left(\\frac{\\vec a \\cdot \\vec b}{|\\vec a|\\cdot |\\vec b|}\\right) $$ Wenn das Skalarprodukt \\(\\vec a \\cdot \\vec b=0\\) ist, dann ist der Winkel zwischen \\(\\vec a\\) und \\(\\vec b\\) \\(90\u00b0=\\frac 2 \\pi\\) Senkrechte Projektion $$ \\vec b_a =\\frac{\\vec a \\cdot \\vec b}{|\\vec a|^2}\\cdot \\vec a\\ |\\vec b_a|=\\frac{|\\vec a \\cdot \\vec b|}{|\\vec a|} $$ Vektorprodukt $$ \\vec a \\times \\vec b \\in \\R^3\\ |\\vec a \\times \\vec b| = |\\vec a|\\cdot |\\vec b|\\cdot \\sin(\\varphi)\\ ... $$ Das Vektorprodukt ist nur f\u00fcr Vektoren im Raum \\(\\R^3\\) definiert. Der resultierende Vektor ist senkrecht zu \\(\\vec a\\) und \\(\\vec b\\) . Der Betrag von \\(|\\vec a \\times \\vec b|\\) ist die Fl\u00e4che eines Paralelogrammes aufgespannt von \\(\\vec a\\) und \\(\\vec b\\) . Gerade als Vektoren Eine Gerade kann folgendermassen dargestellt werden: \\(\\vec r(P)+\\lambda\\cdot \\vec {PQ}\\) , wobei \\(\\vec r(P)\\) , ein Ortsvektor ist, \\(\\lambda\\) ein beliebiger Faktor und \\(\\vec{PQ}\\) ein Richtungsvektor, welcher die Richtung der Gerade anzeigt. Wie stehen zwei Vektoren zu einander Abstand eines Punktes zu einer Gerade Es gibt 3 Varianten den Abstand zwischen einem Punkt und einer Gerade zu bestimmen: In der folgenden Erkl\u00e4rung wird mit der Geraden \\(g: \\pmatrix{1 \\\\ 13 \\\\ -5}+ \\lambda \\cdot \\pmatrix{3 \\\\ 5 \\\\ -4}\\) und dem Punkt \\(A=(3;-1;4)\\) gearbeitet. L\u00f6sungsweg Bestimme den Vektor \\(\\vec r(B)\\) , abh\u00e4ngig von \\(\\lambda\\) \\(\\vec r(B)=\\pmatrix{1+3\\lambda\\\\ 13 + 5\\lambda \\\\ -5 -4\\lambda}\\) Bestimme den Vektor \\(\\vec{BA}=\\vec r(A) - \\vec r(B)=\\pmatrix{2 - 3\\lambda \\\\ -14 -5\\lambda \\\\ 9 + 4\\lambda}\\) \u00dcber das Skalarprodukt \\(\\lambda\\) bestimmen: \\(\\vec {BA}\\orth \\vec a \\Leftrightarrow \\vec {BA} \\cdot \\vec a = 0\\\\\\pmatrix{2 - 3\\lambda \\\\ -14 -5\\lambda \\\\ 9 + 4\\lambda} \\cdot \\pmatrix{3\\\\ -1 \\\\ 4}=-100-50\\lambda=0 \\rightarrow \\lambda = 2\\) Nun kann die L\u00e4nge bestummen werden \\(l=\\vert\\vec{BA}\\vert=9\\) L\u00f6sungsweg \\(\\vec{PA}\\) bestimmen \\(\\vec{PA}=\\pmatrix{3 -1 \\\\ -1 -13 \\\\ 5 - (-5)}=\\pmatrix{2 \\\\ -14\\\\ 9}\\) Fl\u00e4che \\(F\\) des Parallelogrammes bestimmen \\(F=\\vert\\vec{PA}\\times \\vec a \\vert=\\left\\vert \\pmatrix{2 \\\\ -14 \\\\ 9}\\times \\pmatrix{3 \\\\ 5 \\\\ -4} \\right\\vert=\\left\\vert \\pmatrix{11 \\\\ 35\\\\ 52}\\right\\vert=45 \\sqrt 2\\) Die L\u00e4nge \\(l\\) bestimmen \\(F=\\vert\\vec{PA}\\times \\vec a \\vert \\\\F = \\vert \\vec a \\vert \\cdot l \\\\ l=\\frac{\\vert \\vec {PA} \\times \\vec a\\vert}{\\vert \\vec a \\vert}=\\frac{45\\sqrt 2}{5\\sqrt 2}=9\\) L\u00f6sungsweg \\(\\vec{PA}\\) bestimmen \\(\\vec{PA}=\\pmatrix{3 -1 \\\\ -1 -13 \\\\ 5 - (-5)}=\\pmatrix{2 \\\\ -14\\\\ 9}\\) \\(\\vec{PB}\\) mit einer Projektion bestimmen \\(\\vert \\vec{PB}\\vert=\\frac{\\vert \\vec{PA} \\cdot \\vec a \\vert}{\\vert \\vec a \\vert}=2 \\cdot \\sqrt{50}\\) \\(l\\) mit Pytaghoras bestimmen \\(l=\\overline{AB}=\\sqrt{\\vert \\vec{PA}\\vert^2 - \\vert\\vec{PB}\\vert^2}\\) Projektion von einem Vektor auf einen anderen TODO Koordinatendarstellung von Geraden Die Geradendarstellung \\(\\vec r(P)+\\lambda\\cdot \\vec{PQ}\\) kann umgestellt werden in \\(ax+bx+c=0\\) . Dies kann auch gelesen werden als, alle Punkte \\(P(x, y)\\) , welche diese Gleichung erf\u00fcllt, ist auf der Gerade. Eine Gerade kann nur in \\(\\R^2\\) in der Koordinatendarstellung dargestellt werden. Normalvektor Der Normalvektor einer Gerade ist einfach aus der Koordinatendarstellung zu lesen. Die Gerade \\(ax+bx+c=0\\) hat den Normalvektor \\(\\pmatrix{a\\\\b}\\) . Dieser steht orthogonal (rechtwinklig) auf der Geraden Umformen von Parameterdarstellung zu Koordinatendarstellung Um eine Gerade in der Parameterdarstellung in die Koordinatendarstellung um zu wandeln, m\u00fcssen die \\(\\lambda\\) , \\(\\mu\\) und co. eliminiert werden. Daf\u00fcr kann man quasi den \"Gauss\" anwenden. $$ g:\\pmatrix{x\\y}=\\pmatrix{7\\1}+\\lambda\\cdot \\pmatrix{-2\\-4}\\ \\text{Aus dieser Paramterdarstellung kann nun folgendes Gleichungssystem gebaut werden:}\\ \\begin{align} x &=7 -2\\cdot \\lambda \\tag 1\\ y &= 1 -4 \\cdot \\lambda \\tag2 \\ 2\\cdot(1)-(2): 2x-y -13 &= 0 \\end{align} $$ Umformen von Koordinatendarstellung zu Parameterdarstellung Um von der Koordinatnedarstellung in die Parameterdarstellung einer Gerade zu wechseln, m\u00fcssen zwei Punkte auf der Gerade gefunden werden. Von diesen kann die Form \\(g: \\vec r(P)+\\lambda\\cdot \\vec{PQ}\\) gebildet werden. Um zwei Punkte aus der Koordinatendarstellung zu lesen, hilft es, die \\(x\\) oder \\(y\\) auf 0 zu setzen und der andere Parameter zu \u00e4ndern bis 0 erreicht wird. Normalisieren der Parameterdarstellung TODO Darstellung einer Ebenen Parameterdarstellung von Ebenen Eine Ebene kann mit drei Punkten beschrieben werden: \\(E: \\vec r(P)+\\lambda \\cdot \\vec{PR}+\\mu\\cdot \\vec{PQ}\\) , dabei sind \\(\\lambda\\) und \\(\\mu\\) beliebige Zahlen. Der Punkt \\(P\\) heisst Aufpunkt, die Vektoren \\(\\vec{PR}\\) und \\(\\vec{PQ}\\) heissen Richtungsvektoren. Koordinatendarstellung von Ebenen Die Koordinatendarstellung einer Ebenen ist definiert als: \\(E: ax+by+cz+d=0\\) . Die Variablen \\(a\\) , \\(b\\) und \\(c\\) bestimmen die Ausrichtung der Ebene. Die Variable \\(d\\) verschiebt die Ebene parallel. Die Koordinatendarstellung heisst normiert, wenn \\(|\\vec n|=1\\) (der Normalvektor) ist. Normalvektor einer Ebene Aus von einer Ebene kann der Normalvektor berechnet werden. Dieser steht senkrecht auf der Ebene und ist folgendermassen definiert: \\(\\vec n=\\pmatrix{a\\\\b\\\\c}\\) Wenn wir nicht die Koordinatendarstellung haben, sondern die Parameterdarstellung \\(E: \\vec{r}(P)+\\lambda \\cdot \\vec a+\\mu\\cdot\\vec b\\) , dann ist \\(\\vec n = \\vec a \\times \\vec b\\) . Umrechnung von Parameterdarstellung zu Koordinatendarstellung Die Umrechnung der Parameterdarstellung zur Koordinatendarstellung einer Ebene funktioniert gleich, wie bei der Gerade. Der einzige Unterschied ist, dass es drei Gleichungen statt zwei hat. Eine zweite Art, wie dasselbe bewerkstelligt werden kann, ist \u00fcber den Normalvektor. Wenn man den Normalvektor einer Ebene weiss, kann davon sehr einfach die Koordinatendarstellung abgelesen werden. Ebenfalls ist bekannt, dass der Normalvektor senkrecht/orthogonal auf der Eben steht. Mit diesen Informationen kann folgende Gleichung abgeleitet werden: $$ E: \\pmatrix{2\\4\\1}+\\lambda\\cdot\\pmatrix{1\\3\\1}+\\mu \\cdot \\pmatrix{2\\2\\-4}\\ \\vec n=\\pmatrix{1\\3\\1}\\times \\pmatrix{2\\2\\-4}=\\pmatrix{-14\\6\\-4}\\ E: -14x+6y-4z+d=0\\ \\text{Nun muss noch P eingesetzt werden, um d zu bestimmen:}\\ -14\\cdot 2 + 6\\cdot 4 -4\\cdot 1+d=0\\Rightarrow d = 8\\ E: -14x + 6y - 4z + 8 = 0 $$ Umrechnung von Koordinatendarstellung zu Parameterdarstellung Wie bereits bei der Gerade, m\u00fcssen drei Punkte auf der Ebenen gefunden werden. Dies ist am einfachsten, wenn ein Parameter auf 0 gesetzt wird und die anderen entsprechend ver\u00e4ndert werden, dass das Ergebnis 0 ergibt. Liegt ein Punkt auf einer Ebene Wenn \u00fcberpr\u00fcft werden soll, ob ein Punkt auf einer Ebene liegt, kann die Parameterdarstellung einfach dem Punkt gleichgesetzt werden. Wenn es f\u00fcr diese Gleichung einen Wert f\u00fcr \\(\\lambda\\) und \\(\\mu\\) gefunden werden kann, dann ist der Punkt auf der Ebene. Bei der Koordinatendarstellung m\u00fcssen Werte f\u00fcr \\(a\\) , \\(b\\) , \\(c\\) und \\(d\\) gefunden werden, damit die Form \\(ax+by+cz+d=0\\) stimmt. Liegt eine Gerade auf einer Ebene TODO Parameterform gleichsetzten Ebene Koordiatenform, Gerade parameterform. Punkt von Gerade allgemein ausdr\u00fccken und danach in der Koordiatenform der Ebenen einsetzten Wie Ebenen zu einander stehen Ebenen k\u00f6nnen entweder identisch, parallel oder schneidend zu einander stehen. Parallel Wenn \u00fcberpr\u00fcft werden soll, ob zwei Ebenen \\(E\\) und \\(F\\) parallel zu einander sind, muss \u00fcberpr\u00fcft werden, ob die beiden Richtungsvektoren von \\(E\\) komplanar zu den Richtungvektoren von \\(F\\) sind. Wenn die Koordinatenformen der Ebenen gegeben sind, m\u00fcssen entweder ein Faktor \\(p\\) f\u00fcr folgende Gleichungen gefunden werden. Beispiel: $$ E: a_1x+b_1y+c_1z+d_1=0\\ F: a_2x+b_2y+c_2z+d_2=0 $$ In diesem Fall muss es ein Faktor \\(p\\) geben, f\u00fcr welche gilt: $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1\\neq d_2\\cdot p $$ Eine weitere M\u00f6glichkeit ist, dass die Normalvektoren ausgerechnet werden k\u00f6nnen. Diese stehen Senkrecht auf der Ebene \\(E\\) . Der Normalvektor von \\(F\\) koolinear zu dem von \\(E\\) ist, dann sind die Ebenen parallel. Identisch Wenn \u00fcberpr\u00fcft werden soll, ob zwei Ebenen identisch sind und sie in der Koordinatensform gegeben sind, muss folgendes g\u00fcltig sein (die letzte Gleichung ist anderst): $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1=d_2\\cdot p $$ Schneidend Wenn zwei Ebenen schneidend sind und sie gleichgesetzt werden, dann kommt dabei eine Geradegleichung heraus. Bei der Koordinatenform m\u00fcssen die Gleichungen der beiden Ebenen in dasselbe Gleichungssystem eingef\u00fcgt werden, bei der Parameterform m\u00fcssen die Gleichungen gleichgesetzt werden. $$ E: x-2y+2z-1=0\\ F: 2x-3y-z+2=0 $$ Diese zwei Gleichungen k\u00f6nnen in folgendes Gleichungssystem umgewandlet werden: $$ \\begin{align} x-2y+2z&=1\\ 2x-3y-z&=-2 \\end{align} $$ Daraus kann mit dem Gaus nach \\(x\\) , \\(y\\) und \\(z\\) gel\u00f6st werden: $$ \\left( \\begin{array}{ccc|cr} 1 & -2 & 2 & 1\\ 2 & -3 & -1 & -2 \\end{array} \\right) \\Rightarrow \\left( \\begin{array}{ccc|cr} 1 & 0 & -8 & -7\\ 0 & 1 & -5 & -4 \\end{array} \\right)\\ \\ \\begin{align} x&=-7+8\\lambda\\ y&=-4+5\\lambda\\ z&=\\lambda\\ \\end{align} $$ Aus diesen Gleichungen kann die Parameterform abgeleitet werden: \\(\\pmatrix{x\\\\y\\\\z}=\\pmatrix{-7\\\\-4\\\\0}+\\lambda\\cdot\\pmatrix{8\\\\5\\\\1}\\) Abstand von Punkt zu Ebene Um den Abstand \\(l\\) zu berechnen, wird ein beliebiger Punkt \\(P\\) gew\u00e4hlt. Danach wird der Vektor \\(\\vec{PA}\\) auf den Normalvektor \\(\\vec n\\) projiziert. Die L\u00e4nge dieser Projektion ist \\(l\\) . $$ \\text{Wenn die Ebene nicht normiert sind: } l=\\frac{|ax_A+by_A+cz_A+d|}{|\\vec n|}\\ \\text{Wenn die Ebene normiert ist: } l=|ax_A+by_A+cz_A+d| $$ In der Formel obenen kommen \\(x_A\\) , \\(y_A\\) und \\(z_A\\) von den Koordinaten von \\(A\\) und \\(a\\) , \\(b\\) und \\(c\\) von der Koordinatenform der Ebene.","title":"Vektoren"},{"location":"22FS/LA/02_Vektoren.html#vektoren","text":"\\[ \\DeclareMathOperator{\\orth}{\\bot} \\] Vektor Ein Vektor wird durch seine Richtung und Betrag definiert ( Nicht aber der Ort ) Nullvektor Ein Nullvektor \\(\\vec 0\\) hat den Betrag 0 und hat keine Richtung Einheitsvektor/normierter Vektor Ein Vektor \\(\\vec e\\) oder \\(\\vec e_a\\) , welchen der Betrag 1 hat und kann folgendermassen berechnet werden: \\(\\vec e_a=\\frac{\\vec a}{\\vert a \\vert}\\) Gegenvektor Der Gegenvektor zum Vektor \\(\\vec a\\) ist \\(-\\vec a\\) . Es ist also ein Vektor welcher parallel zu \\(\\vec a\\) ist, denselben Betrag hat, aber in die entgegengesetzte Richtung zeigt.","title":"Vektoren"},{"location":"22FS/LA/02_Vektoren.html#addition","text":"Wenn zwei Vektoren addiert werden, werden sie graphisch aneinander geh\u00e4ngt. Diese Operation ist kommutativ und assoziativ:","title":"Addition"},{"location":"22FS/LA/02_Vektoren.html#skalare-multiplikation","text":"Wenn ein Vektor mit einer Zahl multipliziert wird, wird der Vektor gestreckt, bzw. geschrumpft. Oft wird der Faktor als griechischen Buchstaben ausgedr\u00fcckt, um Verwechslung zwischen Vektoren und Faktoren zu vermeiden.","title":"Skalare Multiplikation"},{"location":"22FS/LA/02_Vektoren.html#linearkombination","text":"Eine Linearkombination ist das kombinieren von mehreren skallierten Vektoren: $$ \\lambda_1\\cdot\\vec a_1+\\lambda_2\\cdot\\vec a_2+...+\\lambda_n\\cdot\\vec a_n $$","title":"Linearkombination"},{"location":"22FS/LA/02_Vektoren.html#betrag","text":"Der Betrag eines Vektores ist seine L\u00e4nge. $$ \\begin{align} \\left\\vert\\begin{pmatrix}x\\y\\end{pmatrix}\\right\\vert&=\\sqrt{x^2 + y^2}\\ \\left\\vert\\begin{pmatrix}x\\y\\z\\end{pmatrix}\\right\\vert&=\\sqrt{x^2 + y^2+z^2}\\ \\end{align} $$","title":"Betrag"},{"location":"22FS/LA/02_Vektoren.html#kollinear","text":"Zwei Vektoren sind kollinear, wenn es eine Gerade gibt, zu der beide parallel sind. Mathematisch kann dies als \\(\\vec a = \\lambda\\cdot\\vec b\\) ausgedr\u00fcckt werden","title":"Kollinear"},{"location":"22FS/LA/02_Vektoren.html#komplanar","text":"Drei Vektoren heissen komplanar, wenn es eine Ebene gibt, zu der alle drei parallel sind.","title":"Komplanar"},{"location":"22FS/LA/02_Vektoren.html#linear-unabhangig","text":"Vektoren werden linear unabh\u00e4ngig genannt, wenn es nur eine M\u00f6glichkeit gibt, mit einer Linearkombination den \\(\\vec 0\\) zu bekommen. $$ \\lambda_1 \\cdot \\vec a_1+\\lambda_2\\cdot \\vec a_2 +...+\\lambda_n\\cdot \\vec a_n=\\vec 0 $$ Diese Definition ist kompatible mit Komplanar und Kollinear. Wenn nur ein Vektor \\(\\vec v\\) gegeben ist, welcher ungleich \\(\\vec 0\\) ist, ist dieser linear unabh\u00e4ngig. Der \\(\\vec 0\\) ist linear abh\u00e4ngig. Wenn \\(\\vec a\\) und \\(\\vec b\\) linear unabh\u00e4ngig sind, dann ist \\(\\begin{vmatrix}a_x & b_x\\\\ a_y & b_y\\end{vmatrix}\\neq 0\\) . Wenn der Determinant nicht ausgerechnet werden kann, kann man sich \u00fcberlegen, ob zwei Vektoren vielfaches voneinander sind, \u00fcber den Rang oder \u00fcber ein lineares Gleichungssystem. Ein weiterer Tip: in \\(\\R^m\\) k\u00f6nnen maximal \\(m\\) Vektoren linear unabh\u00e4ngig sein. Wenn es mehr Vektoren sind, k\u00f6nnen sie nicht linear unabh\u00e4ngig sein. Eigenschaften: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar","title":"Linear (Un)abh\u00e4ngig"},{"location":"22FS/LA/02_Vektoren.html#satz-1","text":"Es l\u00e4sst sich der Vektor \\(\\vec c\\) als Linearkombination der Vektoren \\(\\vec a\\) und \\(\\vec b\\) im 2D-Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) komplanar zueinander sind \\(\\vec a\\) und \\(\\vec b\\) nicht kollinear sind","title":"Satz 1"},{"location":"22FS/LA/02_Vektoren.html#satz-2","text":"Wen drei Vektoren \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) nicht komplanar sind, l\u00e4sst sich jeder Vektor \\(\\vec d\\) in \\(\\R^3\\) als eine Linearkombination von \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) darstellen","title":"Satz 2"},{"location":"22FS/LA/02_Vektoren.html#kordinaten-system","text":"Ein Kordinaten-System im Raum \\(\\R^2=R\\times R\\) hat folgendes: Ein Punkt \\(O\\) als Ursprung Ein Einheitsvektor \\(\\vec e_1\\) Ein zweiten Einheitsvektor \\(\\vec e_2\\) , welcher 90\u00b0 im Gegenurzeigersinn zu \\(\\vec e_1\\) ist Jeder Vektor in diesem Kordinatensystem kann als Linearkombination von \\(\\vec e_1\\) und \\(\\vec e_2\\) gebildet werden. Ein Kordinaten-System im Raum \\(R^3\\) hat folgenedes: Einen Punkt \\(O\\) als Ursprung Einen Einheitsvektor \\(\\vec e_1\\) (typischerweisse kommt dieser aus dem Display) Einen zweiten Einheitsvektor \\(\\vec e_2\\) , welcher druch eine 90\u00b0 Drehung gegen den Urzeigensinn von \\(\\vec e_1\\) Einen dritten Einheitsvektor \\(\\vec e_3\\) , welcher ortogonal (Rechtwinlig) zu \\(\\vec e_1\\) und \\(\\vec e_2\\) ist","title":"Kordinaten-System"},{"location":"22FS/LA/02_Vektoren.html#ortsvektor","text":"Ein Ortsvektor ist ein Vektor, welcher im Ursprung festgeheftet wurde. $$ \\vec r(P)=x\\cdot \\vec e_1+y\\cdot \\vec e_2=\\begin{pmatrix}x\\y\\end{pmatrix} $$ Der Ortsvektor \\(\\vec r(P)\\) ist der Vektor vom Ursprung zum Punkt \\(P\\) . Dies wird zum Teil auch als \\(\\vec{OP}\\) dargestellt","title":"Ortsvektor"},{"location":"22FS/LA/02_Vektoren.html#vektor-zwischen-zwei-punkten","text":"\\[ \\vec{PQ}=\\begin{pmatrix}x_Q-x_P\\\\y_Q-y_P\\end{pmatrix}=\\vec r(Q)-\\vec r(P) \\]","title":"Vektor zwischen zwei Punkten"},{"location":"22FS/LA/02_Vektoren.html#skalar-produkt","text":"$$ \\vec a \\cdot \\vec b = \\vert \\vec a \\vert \\cdot \\vert \\vec b\\vert \\cdot \\cos(\\varphi)\\ \\vec a \\cdot \\vec b=a_1b_1+a_2b_2+a_3b_3 $$ Ein Speziallfal ist, wenn \\(\\vec a\\) oder \\(\\vec b\\) den Nullvektor \\(\\vec 0\\) ist. In diesem Fall ist das Skalarprodukt \\(0\\) . Da es zwei Definition f\u00fcr das Skalarprodukt gibt, k\u00f6nnen diese gleichgesetzt werden und nach dem Zwischenwinkel afugel\u00f6st werden. $$ \\varphi =cos^{-1}\\left(\\frac{\\vec a \\cdot \\vec b}{|\\vec a|\\cdot |\\vec b|}\\right) $$ Wenn das Skalarprodukt \\(\\vec a \\cdot \\vec b=0\\) ist, dann ist der Winkel zwischen \\(\\vec a\\) und \\(\\vec b\\) \\(90\u00b0=\\frac 2 \\pi\\)","title":"Skalar Produkt"},{"location":"22FS/LA/02_Vektoren.html#senkrechte-projektion","text":"$$ \\vec b_a =\\frac{\\vec a \\cdot \\vec b}{|\\vec a|^2}\\cdot \\vec a\\ |\\vec b_a|=\\frac{|\\vec a \\cdot \\vec b|}{|\\vec a|} $$","title":"Senkrechte Projektion"},{"location":"22FS/LA/02_Vektoren.html#vektorprodukt","text":"$$ \\vec a \\times \\vec b \\in \\R^3\\ |\\vec a \\times \\vec b| = |\\vec a|\\cdot |\\vec b|\\cdot \\sin(\\varphi)\\ ... $$ Das Vektorprodukt ist nur f\u00fcr Vektoren im Raum \\(\\R^3\\) definiert. Der resultierende Vektor ist senkrecht zu \\(\\vec a\\) und \\(\\vec b\\) . Der Betrag von \\(|\\vec a \\times \\vec b|\\) ist die Fl\u00e4che eines Paralelogrammes aufgespannt von \\(\\vec a\\) und \\(\\vec b\\) .","title":"Vektorprodukt"},{"location":"22FS/LA/02_Vektoren.html#gerade-als-vektoren","text":"Eine Gerade kann folgendermassen dargestellt werden: \\(\\vec r(P)+\\lambda\\cdot \\vec {PQ}\\) , wobei \\(\\vec r(P)\\) , ein Ortsvektor ist, \\(\\lambda\\) ein beliebiger Faktor und \\(\\vec{PQ}\\) ein Richtungsvektor, welcher die Richtung der Gerade anzeigt.","title":"Gerade als Vektoren"},{"location":"22FS/LA/02_Vektoren.html#wie-stehen-zwei-vektoren-zu-einander","text":"","title":"Wie stehen zwei Vektoren zu einander"},{"location":"22FS/LA/02_Vektoren.html#abstand-eines-punktes-zu-einer-gerade","text":"Es gibt 3 Varianten den Abstand zwischen einem Punkt und einer Gerade zu bestimmen: In der folgenden Erkl\u00e4rung wird mit der Geraden \\(g: \\pmatrix{1 \\\\ 13 \\\\ -5}+ \\lambda \\cdot \\pmatrix{3 \\\\ 5 \\\\ -4}\\) und dem Punkt \\(A=(3;-1;4)\\) gearbeitet. L\u00f6sungsweg Bestimme den Vektor \\(\\vec r(B)\\) , abh\u00e4ngig von \\(\\lambda\\) \\(\\vec r(B)=\\pmatrix{1+3\\lambda\\\\ 13 + 5\\lambda \\\\ -5 -4\\lambda}\\) Bestimme den Vektor \\(\\vec{BA}=\\vec r(A) - \\vec r(B)=\\pmatrix{2 - 3\\lambda \\\\ -14 -5\\lambda \\\\ 9 + 4\\lambda}\\) \u00dcber das Skalarprodukt \\(\\lambda\\) bestimmen: \\(\\vec {BA}\\orth \\vec a \\Leftrightarrow \\vec {BA} \\cdot \\vec a = 0\\\\\\pmatrix{2 - 3\\lambda \\\\ -14 -5\\lambda \\\\ 9 + 4\\lambda} \\cdot \\pmatrix{3\\\\ -1 \\\\ 4}=-100-50\\lambda=0 \\rightarrow \\lambda = 2\\) Nun kann die L\u00e4nge bestummen werden \\(l=\\vert\\vec{BA}\\vert=9\\) L\u00f6sungsweg \\(\\vec{PA}\\) bestimmen \\(\\vec{PA}=\\pmatrix{3 -1 \\\\ -1 -13 \\\\ 5 - (-5)}=\\pmatrix{2 \\\\ -14\\\\ 9}\\) Fl\u00e4che \\(F\\) des Parallelogrammes bestimmen \\(F=\\vert\\vec{PA}\\times \\vec a \\vert=\\left\\vert \\pmatrix{2 \\\\ -14 \\\\ 9}\\times \\pmatrix{3 \\\\ 5 \\\\ -4} \\right\\vert=\\left\\vert \\pmatrix{11 \\\\ 35\\\\ 52}\\right\\vert=45 \\sqrt 2\\) Die L\u00e4nge \\(l\\) bestimmen \\(F=\\vert\\vec{PA}\\times \\vec a \\vert \\\\F = \\vert \\vec a \\vert \\cdot l \\\\ l=\\frac{\\vert \\vec {PA} \\times \\vec a\\vert}{\\vert \\vec a \\vert}=\\frac{45\\sqrt 2}{5\\sqrt 2}=9\\) L\u00f6sungsweg \\(\\vec{PA}\\) bestimmen \\(\\vec{PA}=\\pmatrix{3 -1 \\\\ -1 -13 \\\\ 5 - (-5)}=\\pmatrix{2 \\\\ -14\\\\ 9}\\) \\(\\vec{PB}\\) mit einer Projektion bestimmen \\(\\vert \\vec{PB}\\vert=\\frac{\\vert \\vec{PA} \\cdot \\vec a \\vert}{\\vert \\vec a \\vert}=2 \\cdot \\sqrt{50}\\) \\(l\\) mit Pytaghoras bestimmen \\(l=\\overline{AB}=\\sqrt{\\vert \\vec{PA}\\vert^2 - \\vert\\vec{PB}\\vert^2}\\)","title":"Abstand eines Punktes zu einer Gerade"},{"location":"22FS/LA/02_Vektoren.html#projektion-von-einem-vektor-auf-einen-anderen","text":"TODO","title":"Projektion von einem Vektor auf einen anderen"},{"location":"22FS/LA/02_Vektoren.html#koordinatendarstellung-von-geraden","text":"Die Geradendarstellung \\(\\vec r(P)+\\lambda\\cdot \\vec{PQ}\\) kann umgestellt werden in \\(ax+bx+c=0\\) . Dies kann auch gelesen werden als, alle Punkte \\(P(x, y)\\) , welche diese Gleichung erf\u00fcllt, ist auf der Gerade. Eine Gerade kann nur in \\(\\R^2\\) in der Koordinatendarstellung dargestellt werden.","title":"Koordinatendarstellung von Geraden"},{"location":"22FS/LA/02_Vektoren.html#normalvektor","text":"Der Normalvektor einer Gerade ist einfach aus der Koordinatendarstellung zu lesen. Die Gerade \\(ax+bx+c=0\\) hat den Normalvektor \\(\\pmatrix{a\\\\b}\\) . Dieser steht orthogonal (rechtwinklig) auf der Geraden","title":"Normalvektor"},{"location":"22FS/LA/02_Vektoren.html#umformen-von-parameterdarstellung-zu-koordinatendarstellung","text":"Um eine Gerade in der Parameterdarstellung in die Koordinatendarstellung um zu wandeln, m\u00fcssen die \\(\\lambda\\) , \\(\\mu\\) und co. eliminiert werden. Daf\u00fcr kann man quasi den \"Gauss\" anwenden. $$ g:\\pmatrix{x\\y}=\\pmatrix{7\\1}+\\lambda\\cdot \\pmatrix{-2\\-4}\\ \\text{Aus dieser Paramterdarstellung kann nun folgendes Gleichungssystem gebaut werden:}\\ \\begin{align} x &=7 -2\\cdot \\lambda \\tag 1\\ y &= 1 -4 \\cdot \\lambda \\tag2 \\ 2\\cdot(1)-(2): 2x-y -13 &= 0 \\end{align} $$","title":"Umformen von Parameterdarstellung zu Koordinatendarstellung"},{"location":"22FS/LA/02_Vektoren.html#umformen-von-koordinatendarstellung-zu-parameterdarstellung","text":"Um von der Koordinatnedarstellung in die Parameterdarstellung einer Gerade zu wechseln, m\u00fcssen zwei Punkte auf der Gerade gefunden werden. Von diesen kann die Form \\(g: \\vec r(P)+\\lambda\\cdot \\vec{PQ}\\) gebildet werden. Um zwei Punkte aus der Koordinatendarstellung zu lesen, hilft es, die \\(x\\) oder \\(y\\) auf 0 zu setzen und der andere Parameter zu \u00e4ndern bis 0 erreicht wird.","title":"Umformen von Koordinatendarstellung zu Parameterdarstellung"},{"location":"22FS/LA/02_Vektoren.html#normalisieren-der-parameterdarstellung","text":"TODO","title":"Normalisieren der Parameterdarstellung"},{"location":"22FS/LA/02_Vektoren.html#darstellung-einer-ebenen","text":"","title":"Darstellung einer Ebenen"},{"location":"22FS/LA/02_Vektoren.html#parameterdarstellung-von-ebenen","text":"Eine Ebene kann mit drei Punkten beschrieben werden: \\(E: \\vec r(P)+\\lambda \\cdot \\vec{PR}+\\mu\\cdot \\vec{PQ}\\) , dabei sind \\(\\lambda\\) und \\(\\mu\\) beliebige Zahlen. Der Punkt \\(P\\) heisst Aufpunkt, die Vektoren \\(\\vec{PR}\\) und \\(\\vec{PQ}\\) heissen Richtungsvektoren.","title":"Parameterdarstellung von Ebenen"},{"location":"22FS/LA/02_Vektoren.html#koordinatendarstellung-von-ebenen","text":"Die Koordinatendarstellung einer Ebenen ist definiert als: \\(E: ax+by+cz+d=0\\) . Die Variablen \\(a\\) , \\(b\\) und \\(c\\) bestimmen die Ausrichtung der Ebene. Die Variable \\(d\\) verschiebt die Ebene parallel. Die Koordinatendarstellung heisst normiert, wenn \\(|\\vec n|=1\\) (der Normalvektor) ist.","title":"Koordinatendarstellung von Ebenen"},{"location":"22FS/LA/02_Vektoren.html#normalvektor-einer-ebene","text":"Aus von einer Ebene kann der Normalvektor berechnet werden. Dieser steht senkrecht auf der Ebene und ist folgendermassen definiert: \\(\\vec n=\\pmatrix{a\\\\b\\\\c}\\) Wenn wir nicht die Koordinatendarstellung haben, sondern die Parameterdarstellung \\(E: \\vec{r}(P)+\\lambda \\cdot \\vec a+\\mu\\cdot\\vec b\\) , dann ist \\(\\vec n = \\vec a \\times \\vec b\\) .","title":"Normalvektor einer Ebene"},{"location":"22FS/LA/02_Vektoren.html#umrechnung-von-parameterdarstellung-zu-koordinatendarstellung","text":"Die Umrechnung der Parameterdarstellung zur Koordinatendarstellung einer Ebene funktioniert gleich, wie bei der Gerade. Der einzige Unterschied ist, dass es drei Gleichungen statt zwei hat. Eine zweite Art, wie dasselbe bewerkstelligt werden kann, ist \u00fcber den Normalvektor. Wenn man den Normalvektor einer Ebene weiss, kann davon sehr einfach die Koordinatendarstellung abgelesen werden. Ebenfalls ist bekannt, dass der Normalvektor senkrecht/orthogonal auf der Eben steht. Mit diesen Informationen kann folgende Gleichung abgeleitet werden: $$ E: \\pmatrix{2\\4\\1}+\\lambda\\cdot\\pmatrix{1\\3\\1}+\\mu \\cdot \\pmatrix{2\\2\\-4}\\ \\vec n=\\pmatrix{1\\3\\1}\\times \\pmatrix{2\\2\\-4}=\\pmatrix{-14\\6\\-4}\\ E: -14x+6y-4z+d=0\\ \\text{Nun muss noch P eingesetzt werden, um d zu bestimmen:}\\ -14\\cdot 2 + 6\\cdot 4 -4\\cdot 1+d=0\\Rightarrow d = 8\\ E: -14x + 6y - 4z + 8 = 0 $$","title":"Umrechnung von Parameterdarstellung zu Koordinatendarstellung"},{"location":"22FS/LA/02_Vektoren.html#umrechnung-von-koordinatendarstellung-zu-parameterdarstellung","text":"Wie bereits bei der Gerade, m\u00fcssen drei Punkte auf der Ebenen gefunden werden. Dies ist am einfachsten, wenn ein Parameter auf 0 gesetzt wird und die anderen entsprechend ver\u00e4ndert werden, dass das Ergebnis 0 ergibt.","title":"Umrechnung von Koordinatendarstellung zu Parameterdarstellung"},{"location":"22FS/LA/02_Vektoren.html#liegt-ein-punkt-auf-einer-ebene","text":"Wenn \u00fcberpr\u00fcft werden soll, ob ein Punkt auf einer Ebene liegt, kann die Parameterdarstellung einfach dem Punkt gleichgesetzt werden. Wenn es f\u00fcr diese Gleichung einen Wert f\u00fcr \\(\\lambda\\) und \\(\\mu\\) gefunden werden kann, dann ist der Punkt auf der Ebene. Bei der Koordinatendarstellung m\u00fcssen Werte f\u00fcr \\(a\\) , \\(b\\) , \\(c\\) und \\(d\\) gefunden werden, damit die Form \\(ax+by+cz+d=0\\) stimmt.","title":"Liegt ein Punkt auf einer Ebene"},{"location":"22FS/LA/02_Vektoren.html#liegt-eine-gerade-auf-einer-ebene","text":"TODO Parameterform gleichsetzten Ebene Koordiatenform, Gerade parameterform. Punkt von Gerade allgemein ausdr\u00fccken und danach in der Koordiatenform der Ebenen einsetzten","title":"Liegt eine Gerade auf einer Ebene"},{"location":"22FS/LA/02_Vektoren.html#wie-ebenen-zu-einander-stehen","text":"Ebenen k\u00f6nnen entweder identisch, parallel oder schneidend zu einander stehen.","title":"Wie Ebenen zu einander stehen"},{"location":"22FS/LA/02_Vektoren.html#parallel","text":"Wenn \u00fcberpr\u00fcft werden soll, ob zwei Ebenen \\(E\\) und \\(F\\) parallel zu einander sind, muss \u00fcberpr\u00fcft werden, ob die beiden Richtungsvektoren von \\(E\\) komplanar zu den Richtungvektoren von \\(F\\) sind. Wenn die Koordinatenformen der Ebenen gegeben sind, m\u00fcssen entweder ein Faktor \\(p\\) f\u00fcr folgende Gleichungen gefunden werden. Beispiel: $$ E: a_1x+b_1y+c_1z+d_1=0\\ F: a_2x+b_2y+c_2z+d_2=0 $$ In diesem Fall muss es ein Faktor \\(p\\) geben, f\u00fcr welche gilt: $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1\\neq d_2\\cdot p $$ Eine weitere M\u00f6glichkeit ist, dass die Normalvektoren ausgerechnet werden k\u00f6nnen. Diese stehen Senkrecht auf der Ebene \\(E\\) . Der Normalvektor von \\(F\\) koolinear zu dem von \\(E\\) ist, dann sind die Ebenen parallel.","title":"Parallel"},{"location":"22FS/LA/02_Vektoren.html#identisch","text":"Wenn \u00fcberpr\u00fcft werden soll, ob zwei Ebenen identisch sind und sie in der Koordinatensform gegeben sind, muss folgendes g\u00fcltig sein (die letzte Gleichung ist anderst): $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1=d_2\\cdot p $$","title":"Identisch"},{"location":"22FS/LA/02_Vektoren.html#schneidend","text":"Wenn zwei Ebenen schneidend sind und sie gleichgesetzt werden, dann kommt dabei eine Geradegleichung heraus. Bei der Koordinatenform m\u00fcssen die Gleichungen der beiden Ebenen in dasselbe Gleichungssystem eingef\u00fcgt werden, bei der Parameterform m\u00fcssen die Gleichungen gleichgesetzt werden. $$ E: x-2y+2z-1=0\\ F: 2x-3y-z+2=0 $$ Diese zwei Gleichungen k\u00f6nnen in folgendes Gleichungssystem umgewandlet werden: $$ \\begin{align} x-2y+2z&=1\\ 2x-3y-z&=-2 \\end{align} $$ Daraus kann mit dem Gaus nach \\(x\\) , \\(y\\) und \\(z\\) gel\u00f6st werden: $$ \\left( \\begin{array}{ccc|cr} 1 & -2 & 2 & 1\\ 2 & -3 & -1 & -2 \\end{array} \\right) \\Rightarrow \\left( \\begin{array}{ccc|cr} 1 & 0 & -8 & -7\\ 0 & 1 & -5 & -4 \\end{array} \\right)\\ \\ \\begin{align} x&=-7+8\\lambda\\ y&=-4+5\\lambda\\ z&=\\lambda\\ \\end{align} $$ Aus diesen Gleichungen kann die Parameterform abgeleitet werden: \\(\\pmatrix{x\\\\y\\\\z}=\\pmatrix{-7\\\\-4\\\\0}+\\lambda\\cdot\\pmatrix{8\\\\5\\\\1}\\)","title":"Schneidend"},{"location":"22FS/LA/02_Vektoren.html#abstand-von-punkt-zu-ebene","text":"Um den Abstand \\(l\\) zu berechnen, wird ein beliebiger Punkt \\(P\\) gew\u00e4hlt. Danach wird der Vektor \\(\\vec{PA}\\) auf den Normalvektor \\(\\vec n\\) projiziert. Die L\u00e4nge dieser Projektion ist \\(l\\) . $$ \\text{Wenn die Ebene nicht normiert sind: } l=\\frac{|ax_A+by_A+cz_A+d|}{|\\vec n|}\\ \\text{Wenn die Ebene normiert ist: } l=|ax_A+by_A+cz_A+d| $$ In der Formel obenen kommen \\(x_A\\) , \\(y_A\\) und \\(z_A\\) von den Koordinaten von \\(A\\) und \\(a\\) , \\(b\\) und \\(c\\) von der Koordinatenform der Ebene.","title":"Abstand von Punkt zu Ebene"},{"location":"22FS/LA/03_Matrix.html","text":"Matrix \\[ \\DeclareMathOperator{\\rg}{rg} \\] Eine Matrix ist ein rechteckiges Zahlenfeld, wie z.B. diese 3x2 Matrix: \\(\\begin{bmatrix}7 & 6 & 2\\\\2 & 3 & 3\\end{bmatrix}\\) Spezial-Typen Null-Matrix Eine Matrix, bei denen alle Elemente \\(0\\) sind Spaltenmatrix Eine Matrix, welche nur eine Spalte haben und sind dasselbe, wie Vektoren Addition und Subtraktion Matrizen addieren und subtrahieren ist denkbar einfach. Jede Zahl wird mir der Zahl an der gleichen Stelle in der anderen Matrix addiert, bzw. subtrahiert. $$ \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix} - \\begin{bmatrix}y_1 & y_2 & y_3 \\ y_4 & y_5 & y_6\\end{bmatrix} = \\begin{bmatrix}x_1-y_1 & x_2-y_2 & x_3-y_3 \\ x_4-y_4 & x_5-y_5 & x_6-y_6\\end{bmatrix} $$ Dasselbe gilt auch f\u00fcr die Addition. F\u00fcr die Addition und Subtraktion m\u00fcssen beide Matrizden dieselbe Gr\u00f6sse haben, sonst ist das Ergebnis undefiniert. Skalar Multiplikation Wenn eine Matrix mit einem Wert, wie 3 multipliziert wird, entsteht eine neue Matrix, in welcher alle Werte mit diesem Wert multipliziert wurden: $$ c \\cdot \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix}= \\begin{bmatrix}c\\cdot x_1 & c\\cdot x_2 & c\\cdot x_3 \\ c\\cdot x_4 & c\\cdot x_5 & c\\cdot x_6\\end{bmatrix} $$ Matrix Multiplikation Wenn zwei Matrizen multipliziert werden, wie \\(A\\cdot B\\) , dann muss die Breite von \\(A\\) gleich die H\u00f6he von \\(B\\) sein. Das Resultat ist eine Matrix, welche so hoch ist, wie \\(A\\) und so breit ist, wie \\(B\\) . $$ \\begin{bmatrix}x_{11} & x_{21} & x_{31} \\ x_{12} & x_{22} & x_{32}\\end{bmatrix} \\cdot \\begin{bmatrix}y_{11} & y_{21} \\ y_{12} & y_{22} \\ y_{13} & y_{23}\\end{bmatrix} = \\begin{bmatrix} x_{11}\\cdot y_{11} + x_{21}\\cdot y_{12} + x_{31}\\cdot y_{13} & x_{11}\\cdot y_{21} + x_{21}\\cdot y_{22} + x_{21}\\cdot y_{23} \\ x_{12}\\cdot y_{12} + x_{22}\\cdot y_{12} + x_{32}\\cdot y_{13} & x_{12}\\cdot y_{21} + x_{22}\\cdot y_{22} + x_{22}\\cdot y_{23} \\end{bmatrix} $$ Wegen dieser Rechnenart, ist die Multiplikation mit zwei Matrizen nicht kommunikativ. Eine weitere wichtige Eigenschaften von Matrix-Multiplikation ist, dass folgendes nicht gilt: \\(A\\cdot B=C \\text { und } A \\cdot D = C \\not \\Rightarrow B=D\\) , da es m\u00f6glich ist, dass \\(B\\) und \\(D\\) verschiedene Matrix sein k\u00f6nnen, welche beide dasselbe Ergebniss \\(C\\) gibt, wenn mit \\(A\\) multipliziert. Rechnungsregeln Die folgenden Rechenregeln funktioniert f\u00fcr gleichgrosse Matrizen. Kommutativ-Gesetz: \\(A+B=B+A\\) (Geht NICHT bei Multiplikation) Assoziativ-Gesetzt: \\(A+(B+C)=(A+B)+C\\) Distributiv-Gesetzt: \\(\\lambda\\cdot(A+B)=\\lambda\\cdot A + \\lambda \\cdot B\\) Aber Achtung: \\(\\lambda\\cdot A + B\\cdot \\lambda\\) kann nicht ausgeklammert werden (In k\u00f6nnte einfach \\(\\lambda \\cdot A\\) und \\(B\\cdot \\lambda\\) ausgerechnet werden) Distributiv-Gesetzt mit Transportierten Matrizen: \\((A\\cdot B)^T=B^T \\cdot A^T\\) (Beachte die Reihenfolge von A und B) \\((A+B)^T=A^T+B^T=B^T+A^T\\) \\((A-B)^T=A^T-B^T=B^T-A^T\\) Einheitsmatrix Eine Einheitsmatrix, ist eine quadratische Matrix, welche Diagonal \u00fcberall eine 1 hat und sonst 0 : $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ Diese Matrix hat die Eigenschaft, dass wenn eine Matrix \\(A\\) mit einer Identit\u00e4tsmatrix multipliziert wird, dass wieder die Matrix \\(A\\) herauskommt. Inverse Matrix Die Inverse Matrix, ist die Matrix \\(A^{-1}\\) , welche mit der Matrix \\(A\\) , eine Identit\u00e4tsmatrix \\(I\\) ergibt: \\(A\\cdot A^{-1}=I\\) Das Inverse Skalar-Multiplikationen kann folgendermassen gebildet werden: \\((3A)^{-1}=\\frac 1 3 A^{-1}\\) Das Inverse einer Matrix kann gebildet werden, wenn die \\(\\mathrm{det}(A)\\neq 0\\) ist, bzw. die \"Vektoren\" in der Matrix linear unabh\u00e4ngig sind. Inverse Matrix von 2x2-Matrix F\u00fcr 2x2-Matrizen gibt es eine Formel, um das Inverse zu errechnen. Dabei gilt aber: \\(ad\\neq bc\\) $$ \\pmatrix{a & b\\ c & d}^{-1}=\\frac 1 {ad-bc}\\cdot \\pmatrix{d & -b \\ -c & a} $$ Singul\u00e4re und regul\u00e4re Matrizen Eine Matrix wird regul\u00e4r genannt, wenn es ein Inverse von der Matrix gibt. Ansonsten wird sie Singul\u00e4r genannt. Gauss-Jordan Verfahren zur Berechnung der Inverse TODO Transponierte Matrix Eine transponierte Matrix \\(A^T\\) von \\(A\\) ist, wenn die Spalten in \\(A\\) zu Reihen werden und die Reihen in \\(A\\) zu Spalten werden. Man kann es sich auch vorstellen, als ob man die Matrix um 90\u00b0 gegen den Uhrzeigersinn dreht: $$ B= \\begin{bmatrix} 1 & 2 & 3\\ 3 & 4 & 5 \\end{bmatrix}\\ B^T= \\begin{bmatrix} 1 & 3 \\ 2 & 4\\ 3 & 5 \\end{bmatrix} $$ Es gilt folgendes Gesetzt: \\((A\\cdot B)^T=B^T\\cdot A^T\\) Bemerke, dass sich die Reihenfolge von \\(A\\) und \\(B\\) sich \u00e4ndert. Gleichheit Zwei Matrizen sind gleich, wenn alle Elemente der Matritzen gleich sind. Determinanten Wenn die Determinanten einer gr\u00f6sseren Matrix als 3x3 Berechnet werden soll, kann ein Verfahren nach Laplace eingesetzt werden: Es wird eine feste Spalte oder Zeile gew\u00e4hlt Nun wird nach der folgenden Formel entwickelt: $$ \\text{Entwicklung nach i-ten Zeilen: }\\det(A)=\\sum^n_{j=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ \\text{Entwicklung nach j-ten Spalte: }\\det(A)=\\sum^n_{i=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ $$ Dabei ist \\(a_{ij}\\) , das Element an \\(i\\) -ter Zeile und \\(j\\) -ter Spalte und \\(A_{ij}\\) die Matrix, bei welcher die \\(i\\) -te Zeile und \\(j\\) -Spalte weggelassen wurden Eigenschaften Wenn der Determinant \\(\\neq 0\\) ist, dann gilt: \\(\\rg(A)=0\\) Die Matrix ist invertierbar Wenn der Determinant \\(=0\\) ist, dann gilt: \\(\\rg(A) < n\\) (wobei \\(n\\) die Anzahl Spalten der Matrix \\(A\\) ist) Rechenoperation mit Bilder Man kann die einzelnen Elemente einer Matrix als Pixel in einem Bild darstellen. Skalaroperation Mit einer Skalarmultiplikation kann das ganze Bild heller oder dunkler gestalltet werden. Wenn zwei Matrizen addiert werden, \u00fcberlagern sich ihre Pixel. Matrixen Produkt Mit dem Matrizen-Produkt k\u00f6nnen Zeilen vertauscht werden. Transponieren Wenn eine Matrix transponiert wird, wird das Bild entlang der Hauptdiagonalen g","title":"Matrix"},{"location":"22FS/LA/03_Matrix.html#matrix","text":"\\[ \\DeclareMathOperator{\\rg}{rg} \\] Eine Matrix ist ein rechteckiges Zahlenfeld, wie z.B. diese 3x2 Matrix: \\(\\begin{bmatrix}7 & 6 & 2\\\\2 & 3 & 3\\end{bmatrix}\\)","title":"Matrix"},{"location":"22FS/LA/03_Matrix.html#spezial-typen","text":"Null-Matrix Eine Matrix, bei denen alle Elemente \\(0\\) sind Spaltenmatrix Eine Matrix, welche nur eine Spalte haben und sind dasselbe, wie Vektoren","title":"Spezial-Typen"},{"location":"22FS/LA/03_Matrix.html#addition-und-subtraktion","text":"Matrizen addieren und subtrahieren ist denkbar einfach. Jede Zahl wird mir der Zahl an der gleichen Stelle in der anderen Matrix addiert, bzw. subtrahiert. $$ \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix} - \\begin{bmatrix}y_1 & y_2 & y_3 \\ y_4 & y_5 & y_6\\end{bmatrix} = \\begin{bmatrix}x_1-y_1 & x_2-y_2 & x_3-y_3 \\ x_4-y_4 & x_5-y_5 & x_6-y_6\\end{bmatrix} $$ Dasselbe gilt auch f\u00fcr die Addition. F\u00fcr die Addition und Subtraktion m\u00fcssen beide Matrizden dieselbe Gr\u00f6sse haben, sonst ist das Ergebnis undefiniert.","title":"Addition und Subtraktion"},{"location":"22FS/LA/03_Matrix.html#skalar-multiplikation","text":"Wenn eine Matrix mit einem Wert, wie 3 multipliziert wird, entsteht eine neue Matrix, in welcher alle Werte mit diesem Wert multipliziert wurden: $$ c \\cdot \\begin{bmatrix}x_1 & x_2 & x_3 \\ x_4 & x_5 & x_6\\end{bmatrix}= \\begin{bmatrix}c\\cdot x_1 & c\\cdot x_2 & c\\cdot x_3 \\ c\\cdot x_4 & c\\cdot x_5 & c\\cdot x_6\\end{bmatrix} $$","title":"Skalar Multiplikation"},{"location":"22FS/LA/03_Matrix.html#matrix-multiplikation","text":"Wenn zwei Matrizen multipliziert werden, wie \\(A\\cdot B\\) , dann muss die Breite von \\(A\\) gleich die H\u00f6he von \\(B\\) sein. Das Resultat ist eine Matrix, welche so hoch ist, wie \\(A\\) und so breit ist, wie \\(B\\) . $$ \\begin{bmatrix}x_{11} & x_{21} & x_{31} \\ x_{12} & x_{22} & x_{32}\\end{bmatrix} \\cdot \\begin{bmatrix}y_{11} & y_{21} \\ y_{12} & y_{22} \\ y_{13} & y_{23}\\end{bmatrix} = \\begin{bmatrix} x_{11}\\cdot y_{11} + x_{21}\\cdot y_{12} + x_{31}\\cdot y_{13} & x_{11}\\cdot y_{21} + x_{21}\\cdot y_{22} + x_{21}\\cdot y_{23} \\ x_{12}\\cdot y_{12} + x_{22}\\cdot y_{12} + x_{32}\\cdot y_{13} & x_{12}\\cdot y_{21} + x_{22}\\cdot y_{22} + x_{22}\\cdot y_{23} \\end{bmatrix} $$ Wegen dieser Rechnenart, ist die Multiplikation mit zwei Matrizen nicht kommunikativ. Eine weitere wichtige Eigenschaften von Matrix-Multiplikation ist, dass folgendes nicht gilt: \\(A\\cdot B=C \\text { und } A \\cdot D = C \\not \\Rightarrow B=D\\) , da es m\u00f6glich ist, dass \\(B\\) und \\(D\\) verschiedene Matrix sein k\u00f6nnen, welche beide dasselbe Ergebniss \\(C\\) gibt, wenn mit \\(A\\) multipliziert.","title":"Matrix Multiplikation"},{"location":"22FS/LA/03_Matrix.html#rechnungsregeln","text":"Die folgenden Rechenregeln funktioniert f\u00fcr gleichgrosse Matrizen. Kommutativ-Gesetz: \\(A+B=B+A\\) (Geht NICHT bei Multiplikation) Assoziativ-Gesetzt: \\(A+(B+C)=(A+B)+C\\) Distributiv-Gesetzt: \\(\\lambda\\cdot(A+B)=\\lambda\\cdot A + \\lambda \\cdot B\\) Aber Achtung: \\(\\lambda\\cdot A + B\\cdot \\lambda\\) kann nicht ausgeklammert werden (In k\u00f6nnte einfach \\(\\lambda \\cdot A\\) und \\(B\\cdot \\lambda\\) ausgerechnet werden) Distributiv-Gesetzt mit Transportierten Matrizen: \\((A\\cdot B)^T=B^T \\cdot A^T\\) (Beachte die Reihenfolge von A und B) \\((A+B)^T=A^T+B^T=B^T+A^T\\) \\((A-B)^T=A^T-B^T=B^T-A^T\\)","title":"Rechnungsregeln"},{"location":"22FS/LA/03_Matrix.html#einheitsmatrix","text":"Eine Einheitsmatrix, ist eine quadratische Matrix, welche Diagonal \u00fcberall eine 1 hat und sonst 0 : $$ \\begin{bmatrix} 1 & 0 & 0 & 0\\ 0 & 1 & 0 & 0\\ 0 & 0 & 1 & 0\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ Diese Matrix hat die Eigenschaft, dass wenn eine Matrix \\(A\\) mit einer Identit\u00e4tsmatrix multipliziert wird, dass wieder die Matrix \\(A\\) herauskommt.","title":"Einheitsmatrix"},{"location":"22FS/LA/03_Matrix.html#inverse-matrix","text":"Die Inverse Matrix, ist die Matrix \\(A^{-1}\\) , welche mit der Matrix \\(A\\) , eine Identit\u00e4tsmatrix \\(I\\) ergibt: \\(A\\cdot A^{-1}=I\\) Das Inverse Skalar-Multiplikationen kann folgendermassen gebildet werden: \\((3A)^{-1}=\\frac 1 3 A^{-1}\\) Das Inverse einer Matrix kann gebildet werden, wenn die \\(\\mathrm{det}(A)\\neq 0\\) ist, bzw. die \"Vektoren\" in der Matrix linear unabh\u00e4ngig sind.","title":"Inverse Matrix"},{"location":"22FS/LA/03_Matrix.html#inverse-matrix-von-2x2-matrix","text":"F\u00fcr 2x2-Matrizen gibt es eine Formel, um das Inverse zu errechnen. Dabei gilt aber: \\(ad\\neq bc\\) $$ \\pmatrix{a & b\\ c & d}^{-1}=\\frac 1 {ad-bc}\\cdot \\pmatrix{d & -b \\ -c & a} $$","title":"Inverse Matrix von 2x2-Matrix"},{"location":"22FS/LA/03_Matrix.html#singulare-und-regulare-matrizen","text":"Eine Matrix wird regul\u00e4r genannt, wenn es ein Inverse von der Matrix gibt. Ansonsten wird sie Singul\u00e4r genannt.","title":"Singul\u00e4re und regul\u00e4re Matrizen"},{"location":"22FS/LA/03_Matrix.html#gauss-jordan-verfahren-zur-berechnung-der-inverse","text":"TODO","title":"Gauss-Jordan Verfahren zur Berechnung der Inverse"},{"location":"22FS/LA/03_Matrix.html#transponierte-matrix","text":"Eine transponierte Matrix \\(A^T\\) von \\(A\\) ist, wenn die Spalten in \\(A\\) zu Reihen werden und die Reihen in \\(A\\) zu Spalten werden. Man kann es sich auch vorstellen, als ob man die Matrix um 90\u00b0 gegen den Uhrzeigersinn dreht: $$ B= \\begin{bmatrix} 1 & 2 & 3\\ 3 & 4 & 5 \\end{bmatrix}\\ B^T= \\begin{bmatrix} 1 & 3 \\ 2 & 4\\ 3 & 5 \\end{bmatrix} $$ Es gilt folgendes Gesetzt: \\((A\\cdot B)^T=B^T\\cdot A^T\\) Bemerke, dass sich die Reihenfolge von \\(A\\) und \\(B\\) sich \u00e4ndert.","title":"Transponierte Matrix"},{"location":"22FS/LA/03_Matrix.html#gleichheit","text":"Zwei Matrizen sind gleich, wenn alle Elemente der Matritzen gleich sind.","title":"Gleichheit"},{"location":"22FS/LA/03_Matrix.html#determinanten","text":"Wenn die Determinanten einer gr\u00f6sseren Matrix als 3x3 Berechnet werden soll, kann ein Verfahren nach Laplace eingesetzt werden: Es wird eine feste Spalte oder Zeile gew\u00e4hlt Nun wird nach der folgenden Formel entwickelt: $$ \\text{Entwicklung nach i-ten Zeilen: }\\det(A)=\\sum^n_{j=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ \\text{Entwicklung nach j-ten Spalte: }\\det(A)=\\sum^n_{i=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ $$ Dabei ist \\(a_{ij}\\) , das Element an \\(i\\) -ter Zeile und \\(j\\) -ter Spalte und \\(A_{ij}\\) die Matrix, bei welcher die \\(i\\) -te Zeile und \\(j\\) -Spalte weggelassen wurden","title":"Determinanten"},{"location":"22FS/LA/03_Matrix.html#eigenschaften","text":"Wenn der Determinant \\(\\neq 0\\) ist, dann gilt: \\(\\rg(A)=0\\) Die Matrix ist invertierbar Wenn der Determinant \\(=0\\) ist, dann gilt: \\(\\rg(A) < n\\) (wobei \\(n\\) die Anzahl Spalten der Matrix \\(A\\) ist)","title":"Eigenschaften"},{"location":"22FS/LA/03_Matrix.html#rechenoperation-mit-bilder","text":"Man kann die einzelnen Elemente einer Matrix als Pixel in einem Bild darstellen.","title":"Rechenoperation mit Bilder"},{"location":"22FS/LA/03_Matrix.html#skalaroperation","text":"Mit einer Skalarmultiplikation kann das ganze Bild heller oder dunkler gestalltet werden. Wenn zwei Matrizen addiert werden, \u00fcberlagern sich ihre Pixel.","title":"Skalaroperation"},{"location":"22FS/LA/03_Matrix.html#matrixen-produkt","text":"Mit dem Matrizen-Produkt k\u00f6nnen Zeilen vertauscht werden.","title":"Matrixen Produkt"},{"location":"22FS/LA/03_Matrix.html#transponieren","text":"Wenn eine Matrix transponiert wird, wird das Bild entlang der Hauptdiagonalen g","title":"Transponieren"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html","text":"Vektorr\u00e4ume Definition von Vektorr\u00e4umen Ein Vektorraum ist eine Menge \\(V\\) mit den Funktionen Addition und Skalar-Multiplikation: $$ +:V \\times V \\rightarrow V\\ \\cdot : \\R \\times V \\rightarrow V $$ Dabei m\u00fcssen folgende Gesetze existieren: Kommutativgesetz: \\(a + b = b + a\\) Assoziativgesetzt: \\(a + (b + c)=(a + b) + c\\) Es gibt ein neutrales Element \\(\\vec 0\\) , f\u00fcr welches gilt \\(a + 0v = \\vec a\\) und \\(0v \\in V\\) F\u00fcr jedes Element \\(a \\in V\\) muss es ein inverses Element \\(-a \\in V\\) geben, so dass \\(a + (-a) = 0v\\) ergibt. Assoziativgesetzt: \\(\\lambda \\cdot (\\mu \\cdot a) = (\\lambda \\cdot \\mu) \\cdot a\\) Distributivgesetzt: \\(\\lambda \\cdot(a + b) = \\lambda \\cdot a + \\lambda \\cdot b\\) Distirbutgesetzt: \\((\\lambda + \\mu)\\cdot a = \\lambda \\cdot a + \\mu \\cdot a\\) F\u00fcr jedes Element \\(a \\in V\\) gibt es ein neutrales Element \\(1\\cdot a = a\\) , Frage: muss das Skalar \u00fcber \\(\\R\\) erstellt werden oder k\u00f6nnte auch eine andere Menge genommen werden. Reeler Vektoraum \\[ +:V \\times V \\to V: (\\vec a; \\vec b) \\mapsto \\vec a + \\vec b\\\\ \\cdot : \\R \\times V \\to V : (\\lambda; \\vec a) \\mapsto \\lambda \\cdot \\vec a \\] Das neutrale Element bei der Addition ist der Nullvektor \\(\\vec 0\\) und das neutrale Element bei der Skalarmultiplikation ist \\(1\\) . Unterr\u00e4ume Eine Teilmenge \\(U\\) eines Vektorraums \\(V\\) heisst Unterraum von \\(V\\) , wenn \\(U\\) selbst auch ein Vektorraum ist. Daf\u00fcr m\u00fcssen folgende Kriterien erf\u00fcllt sein: F\u00fcr beliebige Element \\(a, b \\in U\\) ist auch \\(a+b\\in U\\) F\u00fcr jeden Skalar \\(\\lambda \\in \\R\\) und jedes Element \\(a\\in U\\) ist auch \\(\\lambda \\cdot a\\in U\\) Die neutralen Elemente der Addition und Skalarmultiplikation m\u00fcssen ebenfalls in \\(U\\) sein. Linearer Spann \\(spann(\\vec a_1, \\vec a_2, ..., \\vec a_n)\\) ist definiert als alle m\u00f6glichen Vektoren von der Linearkombination \\(\\lambda_1\\cdot \\vec a_1 + \\lambda_2\\cdot \\vec a_2 +...+\\lambda_n\\cdot \\vec a_n\\) \u00a7 Die Vektoren \\(\\vec a_1, \\vec a_2, ...\\vec a_n\\) spannen den linearen Spann auf und formen eine geometrische Form. Geometrische Objekte Jenachdem, wie viele Vektoren gegeben sind, wird ein anderes geometrisches Objekt gebildet: Bei 1 Vektor, wird eine Ursprungs-Gerade gebildet Bei 2 Vektoren, wird eine Ursprungs-Ebene Bei 3 Vektoren, wird ein \"Ursprungs-K\u00f6rper\" gebildet Erzeugendensystem Eine Menge von Vektoren \\(\\{\\vec b_1, \\vec b_2, ..., \\vec b_N\\}\\) bildet ein Erzeugendensystem von \\(V\\) , falls \\(V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\) . Dies ist nur der Fall, wenn die Vektoren nicht kollinear, bzw. komplanar sind. Aus dem gehen die folgenden folgende Bedingungen: $$ \\begin{align} & V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\ \\Leftrightarrow \\text{ } & B\\cdot \\vec x = \\vec a \\text { f\u00fcr jedes } \\vec a \\in \\R^m\\ \\Leftrightarrow \\text{ } & rg(B)=m \\end{align} $$ Mit den Vektoren \\(\\vec b_i\\) in einem Erzeugendensystem k\u00f6nnen alle anderen Vektor \\(V\\) (also z.B. \\(\\R^2\\) ) bilden. Basis und Dimensionen Ein Vektor \\(\\vec a = \\pmatrix{a_1 \\\\ a_2}\\) kann auch als \\(\\vec a = a_1\\cdot \\vec e_1 + a_2 \\cdot \\vec e_2\\) geschrieben werden. Anstatt der Vektormenge \\(\\mathcal S=\\{\\vec e_1; \\vec e_2\\}\\) kann auch eine andere Menge \\(\\mathcal B=\\{\\vec b_1; \\vec b_2\\}\\) ben\u00fctzt werden. Der Vektor \\(\\vec a = \\pmatrix{\\alpha_1\\\\ \\alpha_2}_\\mathcal{B}\\) ist nun equivalent zu \\(\\vec a=\\alpha_1 \\cdot \\vec b_1 + \\alpha_2 \\cdot \\vec b_2\\) . In diesem Beispiel sind die Vektoren \\(\\vec a\\) , \\(\\vec c\\) und \\(\\vec d\\) die selben, nur die Vektormenge, durch welche das Koordinatensystem definiert wird, \u00e4ndert sich. Damit dies m\u00f6glich ist, muss die Vektormenge folgende Eigenschaften erf\u00fcllen: \\(\\mathcal B=\\{\\vec b_1, \\vec b_2, ...,\\vec b_n\\}\\) muss ein Erzeugendensystem sein \\(\\vec b_1\\) , \\(\\vec b_2\\) , ..., \\(\\vec b\\) m\u00fcssen linear unabh\u00e4ngig sein Oder in Deutsch: Es darf nur genau eine m\u00f6gliche Linearkombination f\u00fcr jeden Vektor geben Aus diesen zwei Regeln gehen folgende S\u00e4tze hervor: Eine Basis \\(\\R^n\\) besteht genau aus \\(n\\) Vektoren \\(\\rm rg(B)=n\\) (wobei \\(B\\) alle Vektoren in eine Matrix gesteckt werden) \\(\\det(B)\\neq 0\\) \\(B\\) ist invertierbar Das lineare Gleichungssystem \\(B\\cdot \\vec x=\\vec c\\) hat genau eine eindeutige L\u00f6sung Dimensionen Die Dimension \\(\\dim(V)\\) gibt an, wie viel Dimensionen ein Vektorraum oder Basis hat. Bei einer Basis \\(\\mathcal B\\) ist die Basis die Anzahl Vektoren, welche die Basis definiert. Das heisst \\(\\dim(\\R^n)=n\\) und \\(\\mathrm{dim}(\\mathbb P_n[x])=n+1\\) Bei einem Vektorraum ist die Anzahl Dimensionen gleich der Anzahl Vektoren, welche den Spann des Vektorraumes definieren. Bei Vektorr\u00e4ume gilt auch, dass ein Unterraum \\(R\\) von \\(V\\) : \\(\\dim(R) \\le \\dim(V)\\) . Die Dimension des Vektorraums \\(\\{\\vec 0\\}\\) ist gleich \\(\\dim(\\{\\vec 0\\})=0\\) TODO: Matrixen Umwandeln zwischen Komponentendarstellungen Um einen Vektor \\(\\vec v_{\\mathcal B}\\) in den Vektor \\(\\vec v_{\\mathcal{S}}\\) zu umwandeln, kann folgendes getan werden: \\(\\vec v_{\\mathcal B}=v_1\\cdot \\vec b_1+v_2\\cdot \\vec b_2+...+v_n\\cdot \\vec b_n\\) In die umgekehrte Richtung gibt es ein Lineares Gleichungssystem: \\(\\vec v_\\mathcal{S}\\cdot B=\\vec v_\\mathcal{B}\\)","title":"Vektorr\u00e4ume"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#vektorraume","text":"","title":"Vektorr\u00e4ume"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#definition-von-vektorraumen","text":"Ein Vektorraum ist eine Menge \\(V\\) mit den Funktionen Addition und Skalar-Multiplikation: $$ +:V \\times V \\rightarrow V\\ \\cdot : \\R \\times V \\rightarrow V $$ Dabei m\u00fcssen folgende Gesetze existieren: Kommutativgesetz: \\(a + b = b + a\\) Assoziativgesetzt: \\(a + (b + c)=(a + b) + c\\) Es gibt ein neutrales Element \\(\\vec 0\\) , f\u00fcr welches gilt \\(a + 0v = \\vec a\\) und \\(0v \\in V\\) F\u00fcr jedes Element \\(a \\in V\\) muss es ein inverses Element \\(-a \\in V\\) geben, so dass \\(a + (-a) = 0v\\) ergibt. Assoziativgesetzt: \\(\\lambda \\cdot (\\mu \\cdot a) = (\\lambda \\cdot \\mu) \\cdot a\\) Distributivgesetzt: \\(\\lambda \\cdot(a + b) = \\lambda \\cdot a + \\lambda \\cdot b\\) Distirbutgesetzt: \\((\\lambda + \\mu)\\cdot a = \\lambda \\cdot a + \\mu \\cdot a\\) F\u00fcr jedes Element \\(a \\in V\\) gibt es ein neutrales Element \\(1\\cdot a = a\\) , Frage: muss das Skalar \u00fcber \\(\\R\\) erstellt werden oder k\u00f6nnte auch eine andere Menge genommen werden.","title":"Definition von Vektorr\u00e4umen"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#reeler-vektoraum","text":"\\[ +:V \\times V \\to V: (\\vec a; \\vec b) \\mapsto \\vec a + \\vec b\\\\ \\cdot : \\R \\times V \\to V : (\\lambda; \\vec a) \\mapsto \\lambda \\cdot \\vec a \\] Das neutrale Element bei der Addition ist der Nullvektor \\(\\vec 0\\) und das neutrale Element bei der Skalarmultiplikation ist \\(1\\) .","title":"Reeler Vektoraum"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#unterraume","text":"Eine Teilmenge \\(U\\) eines Vektorraums \\(V\\) heisst Unterraum von \\(V\\) , wenn \\(U\\) selbst auch ein Vektorraum ist. Daf\u00fcr m\u00fcssen folgende Kriterien erf\u00fcllt sein: F\u00fcr beliebige Element \\(a, b \\in U\\) ist auch \\(a+b\\in U\\) F\u00fcr jeden Skalar \\(\\lambda \\in \\R\\) und jedes Element \\(a\\in U\\) ist auch \\(\\lambda \\cdot a\\in U\\) Die neutralen Elemente der Addition und Skalarmultiplikation m\u00fcssen ebenfalls in \\(U\\) sein.","title":"Unterr\u00e4ume"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#linearer-spann","text":"\\(spann(\\vec a_1, \\vec a_2, ..., \\vec a_n)\\) ist definiert als alle m\u00f6glichen Vektoren von der Linearkombination \\(\\lambda_1\\cdot \\vec a_1 + \\lambda_2\\cdot \\vec a_2 +...+\\lambda_n\\cdot \\vec a_n\\) \u00a7 Die Vektoren \\(\\vec a_1, \\vec a_2, ...\\vec a_n\\) spannen den linearen Spann auf und formen eine geometrische Form.","title":"Linearer Spann"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#geometrische-objekte","text":"Jenachdem, wie viele Vektoren gegeben sind, wird ein anderes geometrisches Objekt gebildet: Bei 1 Vektor, wird eine Ursprungs-Gerade gebildet Bei 2 Vektoren, wird eine Ursprungs-Ebene Bei 3 Vektoren, wird ein \"Ursprungs-K\u00f6rper\" gebildet","title":"Geometrische Objekte"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#erzeugendensystem","text":"Eine Menge von Vektoren \\(\\{\\vec b_1, \\vec b_2, ..., \\vec b_N\\}\\) bildet ein Erzeugendensystem von \\(V\\) , falls \\(V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\) . Dies ist nur der Fall, wenn die Vektoren nicht kollinear, bzw. komplanar sind. Aus dem gehen die folgenden folgende Bedingungen: $$ \\begin{align} & V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\ \\Leftrightarrow \\text{ } & B\\cdot \\vec x = \\vec a \\text { f\u00fcr jedes } \\vec a \\in \\R^m\\ \\Leftrightarrow \\text{ } & rg(B)=m \\end{align} $$ Mit den Vektoren \\(\\vec b_i\\) in einem Erzeugendensystem k\u00f6nnen alle anderen Vektor \\(V\\) (also z.B. \\(\\R^2\\) ) bilden.","title":"Erzeugendensystem"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#basis-und-dimensionen","text":"Ein Vektor \\(\\vec a = \\pmatrix{a_1 \\\\ a_2}\\) kann auch als \\(\\vec a = a_1\\cdot \\vec e_1 + a_2 \\cdot \\vec e_2\\) geschrieben werden. Anstatt der Vektormenge \\(\\mathcal S=\\{\\vec e_1; \\vec e_2\\}\\) kann auch eine andere Menge \\(\\mathcal B=\\{\\vec b_1; \\vec b_2\\}\\) ben\u00fctzt werden. Der Vektor \\(\\vec a = \\pmatrix{\\alpha_1\\\\ \\alpha_2}_\\mathcal{B}\\) ist nun equivalent zu \\(\\vec a=\\alpha_1 \\cdot \\vec b_1 + \\alpha_2 \\cdot \\vec b_2\\) . In diesem Beispiel sind die Vektoren \\(\\vec a\\) , \\(\\vec c\\) und \\(\\vec d\\) die selben, nur die Vektormenge, durch welche das Koordinatensystem definiert wird, \u00e4ndert sich. Damit dies m\u00f6glich ist, muss die Vektormenge folgende Eigenschaften erf\u00fcllen: \\(\\mathcal B=\\{\\vec b_1, \\vec b_2, ...,\\vec b_n\\}\\) muss ein Erzeugendensystem sein \\(\\vec b_1\\) , \\(\\vec b_2\\) , ..., \\(\\vec b\\) m\u00fcssen linear unabh\u00e4ngig sein Oder in Deutsch: Es darf nur genau eine m\u00f6gliche Linearkombination f\u00fcr jeden Vektor geben Aus diesen zwei Regeln gehen folgende S\u00e4tze hervor: Eine Basis \\(\\R^n\\) besteht genau aus \\(n\\) Vektoren \\(\\rm rg(B)=n\\) (wobei \\(B\\) alle Vektoren in eine Matrix gesteckt werden) \\(\\det(B)\\neq 0\\) \\(B\\) ist invertierbar Das lineare Gleichungssystem \\(B\\cdot \\vec x=\\vec c\\) hat genau eine eindeutige L\u00f6sung","title":"Basis und Dimensionen"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#dimensionen","text":"Die Dimension \\(\\dim(V)\\) gibt an, wie viel Dimensionen ein Vektorraum oder Basis hat. Bei einer Basis \\(\\mathcal B\\) ist die Basis die Anzahl Vektoren, welche die Basis definiert. Das heisst \\(\\dim(\\R^n)=n\\) und \\(\\mathrm{dim}(\\mathbb P_n[x])=n+1\\) Bei einem Vektorraum ist die Anzahl Dimensionen gleich der Anzahl Vektoren, welche den Spann des Vektorraumes definieren. Bei Vektorr\u00e4ume gilt auch, dass ein Unterraum \\(R\\) von \\(V\\) : \\(\\dim(R) \\le \\dim(V)\\) . Die Dimension des Vektorraums \\(\\{\\vec 0\\}\\) ist gleich \\(\\dim(\\{\\vec 0\\})=0\\) TODO: Matrixen","title":"Dimensionen"},{"location":"22FS/LA/05_Vektorr%C3%A4ume.html#umwandeln-zwischen-komponentendarstellungen","text":"Um einen Vektor \\(\\vec v_{\\mathcal B}\\) in den Vektor \\(\\vec v_{\\mathcal{S}}\\) zu umwandeln, kann folgendes getan werden: \\(\\vec v_{\\mathcal B}=v_1\\cdot \\vec b_1+v_2\\cdot \\vec b_2+...+v_n\\cdot \\vec b_n\\) In die umgekehrte Richtung gibt es ein Lineares Gleichungssystem: \\(\\vec v_\\mathcal{S}\\cdot B=\\vec v_\\mathcal{B}\\)","title":"Umwandeln zwischen Komponentendarstellungen"},{"location":"22FS/LA/06_Lineare%20Abbildung.html","text":"Lineare Abbildung $$ \\DeclareMathOperator{\\im}{im} \\DeclareMathOperator{\\span}{span} \\DeclareMathOperator{\\rg}{rg} $$ Eine Lineare Abbildung wird mit Hilfe einer Funktion \\(f: V \\to W\\) , welche ein Parameter vom Typ \\(V\\) nimt und als R\u00fcckgabetyp \\(W\\) zur\u00fcck gibt. Wichtig ist, dass die Funktion folgende zwei Rechungsregeln einh\u00e4lt: \\(f(x+y)=f(x)+f(y)\\) \\(f(\\lambda\\cdot x)=\\lambda\\cdot f(x)\\) Wenn bewiesen werden soll, dass eine Funktion eine Abbildungsfunktion ist, dann m\u00fcssen diese zwei Gesetze allgemein gezeigt werden. Um es zu widerlegen, reicht ein Gegenbeispiel. Lineare Abbildung eines Vektorraumes Wenn die Abbildungsfunktion \\(f\\) komplett definiert ist, f\u00fcr die Einheitsvektoren \\(\\vec e_1\\) , \\(\\vec e_2\\) , ..., \\(\\vec e_n\\) , dann gilt follgendes: $$ \\vec x=x_1 \\cdot \\vec e_1 + x_2 \\cdot \\vec e_2\\ f(\\vec x)=f(x_1 \\cdot \\vec e_1 + x_2 \\cdot \\vec e_2)=f(x_1\\cdot \\vec e_1)+ f(x_2\\cdot \\vec e_2)=x_1\\cdot f(\\vec e_1)+x_2\\cdot f(\\vec e_2)\\ $$ Da das letzte Resultat eine Linearkombination ist, kann diese auch als Matrix geschrieben werden. Um diese Matrix zu finden, gibt es zwei M\u00f6glichkeiten: Die Einheitsvektoren in \\(f(x)\\) ein setzten und aus den Resultaten eine Matrix bauen Zeile f\u00fcr Zeile durchgehen und die Matrixzeilen davon ableiten Zus\u00e4tzlich k\u00f6nnen Matrixen (und auch Abbildngsfunktionen) auch zwischen Basen konvertieren: Bei der Matrix \\(_CA_B\\) und der linearen Abbildung \\(f: V \\to W\\) bezieht sich \\(_B\\) auf \\(V\\) und \\(_C\\) auf \\(W\\) . Abbildungen im Raum In den folgenden Kapiteln werden Beispiele gezeigt, wie eine Abbildung aussehen kann In 2-Dimensionalen Vektorr\u00e4umen Die folgenden Beispielen beziehen sich alle auf einen zweidimensionalen Vektorraum Zweidimensionale Spezialf\u00e4lle Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung Wenn auf eine Gerade projektiert werden soll, welche nicht die x-, y- oder z-Achse ist, muss folgende Formel verwendet werden. Dabei wird erwartet, dass die Gerade in der Kordinatendarstelung ( \\(ax + by = 0\\) ) normiert ist ( \\(a^2 + b^2 = 1\\) ). $$ P= \\begin{pmatrix} 1 - a^2 & -ab\\ -ab & 1-b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$ Spiegelung an einer allgemeinen Gerade durch den Ursprung Wenn alle Vektoren bei einer Gerade, welche durch den Ursprung geht, gespiegelt werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Gerade in der Koordinatendarstellung ( \\(ax + by=0\\) ) normiert ist ( \\(a^2+b^2 = 1\\) ). $$ S= \\begin{pmatrix} 1 - 2a^2 & -2ab\\ -2ab & 1 - 2b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$ In dreidimensionalen Vektorr\u00e4umen Dreidimensionale Spezialf\u00e4lle Orthogonale Projektion auf eine allgemeine Ebene durch den Ursprung Wenn alle Vektoren auf eine Ebene, welche durch den Ursprung geht, projektiert werden sollen, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Koordinatendarstellung der Ebene ( \\(ax + by + cz = 0\\) ) normiert sein ( \\(a^2 + b^2 + c^2=1\\) ). $$ P=\\begin{pmatrix} 1 - a^2 & -ab & -ac\\ -ab & 1 - b^2 & -bc\\ -ac & -bc & 1 - c^2 \\end{pmatrix}=E-\\vec n \\cdot \\vec n^T\\ \\text{Wobei gilt:}\\ ax + by + cz = 0\\ a^2 + b^2 + c^2 = 1 $$ Im folgenden Bild wird noch eine andere Schreibweise gezeigt: Spiegelung an einer allgemeinen Ebene durch den Ursprung Wenn alle Vektoren bei einer Ebene, welche durch den Ursprung geht, gespiegelt werden sollen, kann folgende Formel ben\u00fctzt werden. Dabei m\u00fcssen die Ebene in der Koordinatendarstellung normiert sein: $$ S=\\begin{pmatrix} 1 - 2a^2 & -2ab & -2ac\\ -2ab & 1 - 2b^2 & -2bc\\ -2ac & -2bc & 1 - 2c^2 \\end{pmatrix}=E-\\vec n \\cdot \\vec n^T\\ \\text{Wobei gilt:}\\ ax + by + cz = 0\\ a^2 + b^2 + c^2 = 1 $$ Rotation um eine allgemeine Achse durch den Ursprung Wenn alle Vektoren um eine allgemeine Achse, welche durch den Ursprung geht, gedreht werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss die Koordinatendarstellung der Achse/Gerade normiert sein. Kern und Bild einer Abbildung Wenn wir eine Abbildung \\(f: V \\to W, \\vec x \\mapsto f(\\vec x)=A \\cdot \\vec x\\) haben, dann ist der Kern alle Vektoren \\(\\vec x\\) , welche die Gleichung \\(A \\cdot \\vec x=\\vec 0\\) erf\u00fcllen. Der Nullvektor \\(\\vec 0\\) ist dabei immer in \\(\\ker(A)\\) enthalten. $$ \\ker(A)={\\vec x \\in V \\vert A\\cdot \\vec x = \\vec 0} $$ Das Bild der Abbildung ist der Spalten der Vektoren von \\(A\\) $$ \\im(A)=\\span(\\vec a_1, \\vec a_2, ..., \\vec a_n)={\\lambda_1 \\vec a_1 + \\lambda_2 \\vec a_2 + ... + \\lambda_n\\vec a_n \\vert \\lambda_k \\in \\R} $$ Eine Wichtige Beobachtung ist, dass die Dimension von \\(\\ker(A)\\) und \\(\\im(A)\\) zusammen \\(\\dim(A)\\) ergeben: $$ \\dim(\\ker(A)) + \\dim(\\im(A)) = \\dim(A)\\ \\dim(\\im(A)) = \\rg(A) $$ Um die Dimensionen zu bestimmen gibt es mehrere M\u00f6glichkeiten: Mit der Zeilenstuffenform von \\(A\\) den Rang ablesen. Von diesem kann die Dimension von \\(\\im(A)\\) abgelesen werden und dank des Satzes von oben auch \\(\\dim(\\ker(A))\\) bestimmen Da die Menge, welche von \\(\\ker(A)\\) zur\u00fcck gegeben werden, auch ein Unterraum ist, kann eine Basis mit \\(A\\) erstellt werden. Es m\u00fcssen alle Vektoren \\(a_i\\) gefunden werden, welche linear Unabh\u00e4ngig sind","title":"Lineare Abbildung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#lineare-abbildung","text":"$$ \\DeclareMathOperator{\\im}{im} \\DeclareMathOperator{\\span}{span} \\DeclareMathOperator{\\rg}{rg} $$ Eine Lineare Abbildung wird mit Hilfe einer Funktion \\(f: V \\to W\\) , welche ein Parameter vom Typ \\(V\\) nimt und als R\u00fcckgabetyp \\(W\\) zur\u00fcck gibt. Wichtig ist, dass die Funktion folgende zwei Rechungsregeln einh\u00e4lt: \\(f(x+y)=f(x)+f(y)\\) \\(f(\\lambda\\cdot x)=\\lambda\\cdot f(x)\\) Wenn bewiesen werden soll, dass eine Funktion eine Abbildungsfunktion ist, dann m\u00fcssen diese zwei Gesetze allgemein gezeigt werden. Um es zu widerlegen, reicht ein Gegenbeispiel.","title":"Lineare Abbildung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#lineare-abbildung-eines-vektorraumes","text":"Wenn die Abbildungsfunktion \\(f\\) komplett definiert ist, f\u00fcr die Einheitsvektoren \\(\\vec e_1\\) , \\(\\vec e_2\\) , ..., \\(\\vec e_n\\) , dann gilt follgendes: $$ \\vec x=x_1 \\cdot \\vec e_1 + x_2 \\cdot \\vec e_2\\ f(\\vec x)=f(x_1 \\cdot \\vec e_1 + x_2 \\cdot \\vec e_2)=f(x_1\\cdot \\vec e_1)+ f(x_2\\cdot \\vec e_2)=x_1\\cdot f(\\vec e_1)+x_2\\cdot f(\\vec e_2)\\ $$ Da das letzte Resultat eine Linearkombination ist, kann diese auch als Matrix geschrieben werden. Um diese Matrix zu finden, gibt es zwei M\u00f6glichkeiten: Die Einheitsvektoren in \\(f(x)\\) ein setzten und aus den Resultaten eine Matrix bauen Zeile f\u00fcr Zeile durchgehen und die Matrixzeilen davon ableiten Zus\u00e4tzlich k\u00f6nnen Matrixen (und auch Abbildngsfunktionen) auch zwischen Basen konvertieren: Bei der Matrix \\(_CA_B\\) und der linearen Abbildung \\(f: V \\to W\\) bezieht sich \\(_B\\) auf \\(V\\) und \\(_C\\) auf \\(W\\) .","title":"Lineare Abbildung eines Vektorraumes"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#abbildungen-im-raum","text":"In den folgenden Kapiteln werden Beispiele gezeigt, wie eine Abbildung aussehen kann","title":"Abbildungen im Raum"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#in-2-dimensionalen-vektorraumen","text":"Die folgenden Beispielen beziehen sich alle auf einen zweidimensionalen Vektorraum","title":"In 2-Dimensionalen Vektorr\u00e4umen"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#zweidimensionale-spezialfalle","text":"","title":"Zweidimensionale Spezialf\u00e4lle"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#orthogonale-projektion-auf-eine-allgemeine-gerade-durch-den-ursprung","text":"Wenn auf eine Gerade projektiert werden soll, welche nicht die x-, y- oder z-Achse ist, muss folgende Formel verwendet werden. Dabei wird erwartet, dass die Gerade in der Kordinatendarstelung ( \\(ax + by = 0\\) ) normiert ist ( \\(a^2 + b^2 = 1\\) ). $$ P= \\begin{pmatrix} 1 - a^2 & -ab\\ -ab & 1-b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$","title":"Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#spiegelung-an-einer-allgemeinen-gerade-durch-den-ursprung","text":"Wenn alle Vektoren bei einer Gerade, welche durch den Ursprung geht, gespiegelt werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Gerade in der Koordinatendarstellung ( \\(ax + by=0\\) ) normiert ist ( \\(a^2+b^2 = 1\\) ). $$ S= \\begin{pmatrix} 1 - 2a^2 & -2ab\\ -2ab & 1 - 2b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$","title":"Spiegelung an einer allgemeinen Gerade durch den Ursprung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#in-dreidimensionalen-vektorraumen","text":"","title":"In dreidimensionalen Vektorr\u00e4umen"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#dreidimensionale-spezialfalle","text":"","title":"Dreidimensionale Spezialf\u00e4lle"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#orthogonale-projektion-auf-eine-allgemeine-ebene-durch-den-ursprung","text":"Wenn alle Vektoren auf eine Ebene, welche durch den Ursprung geht, projektiert werden sollen, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Koordinatendarstellung der Ebene ( \\(ax + by + cz = 0\\) ) normiert sein ( \\(a^2 + b^2 + c^2=1\\) ). $$ P=\\begin{pmatrix} 1 - a^2 & -ab & -ac\\ -ab & 1 - b^2 & -bc\\ -ac & -bc & 1 - c^2 \\end{pmatrix}=E-\\vec n \\cdot \\vec n^T\\ \\text{Wobei gilt:}\\ ax + by + cz = 0\\ a^2 + b^2 + c^2 = 1 $$ Im folgenden Bild wird noch eine andere Schreibweise gezeigt:","title":"Orthogonale Projektion auf eine allgemeine Ebene durch den Ursprung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#spiegelung-an-einer-allgemeinen-ebene-durch-den-ursprung","text":"Wenn alle Vektoren bei einer Ebene, welche durch den Ursprung geht, gespiegelt werden sollen, kann folgende Formel ben\u00fctzt werden. Dabei m\u00fcssen die Ebene in der Koordinatendarstellung normiert sein: $$ S=\\begin{pmatrix} 1 - 2a^2 & -2ab & -2ac\\ -2ab & 1 - 2b^2 & -2bc\\ -2ac & -2bc & 1 - 2c^2 \\end{pmatrix}=E-\\vec n \\cdot \\vec n^T\\ \\text{Wobei gilt:}\\ ax + by + cz = 0\\ a^2 + b^2 + c^2 = 1 $$","title":"Spiegelung an einer allgemeinen Ebene durch den Ursprung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#rotation-um-eine-allgemeine-achse-durch-den-ursprung","text":"Wenn alle Vektoren um eine allgemeine Achse, welche durch den Ursprung geht, gedreht werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss die Koordinatendarstellung der Achse/Gerade normiert sein.","title":"Rotation um eine allgemeine Achse durch den Ursprung"},{"location":"22FS/LA/06_Lineare%20Abbildung.html#kern-und-bild-einer-abbildung","text":"Wenn wir eine Abbildung \\(f: V \\to W, \\vec x \\mapsto f(\\vec x)=A \\cdot \\vec x\\) haben, dann ist der Kern alle Vektoren \\(\\vec x\\) , welche die Gleichung \\(A \\cdot \\vec x=\\vec 0\\) erf\u00fcllen. Der Nullvektor \\(\\vec 0\\) ist dabei immer in \\(\\ker(A)\\) enthalten. $$ \\ker(A)={\\vec x \\in V \\vert A\\cdot \\vec x = \\vec 0} $$ Das Bild der Abbildung ist der Spalten der Vektoren von \\(A\\) $$ \\im(A)=\\span(\\vec a_1, \\vec a_2, ..., \\vec a_n)={\\lambda_1 \\vec a_1 + \\lambda_2 \\vec a_2 + ... + \\lambda_n\\vec a_n \\vert \\lambda_k \\in \\R} $$ Eine Wichtige Beobachtung ist, dass die Dimension von \\(\\ker(A)\\) und \\(\\im(A)\\) zusammen \\(\\dim(A)\\) ergeben: $$ \\dim(\\ker(A)) + \\dim(\\im(A)) = \\dim(A)\\ \\dim(\\im(A)) = \\rg(A) $$ Um die Dimensionen zu bestimmen gibt es mehrere M\u00f6glichkeiten: Mit der Zeilenstuffenform von \\(A\\) den Rang ablesen. Von diesem kann die Dimension von \\(\\im(A)\\) abgelesen werden und dank des Satzes von oben auch \\(\\dim(\\ker(A))\\) bestimmen Da die Menge, welche von \\(\\ker(A)\\) zur\u00fcck gegeben werden, auch ein Unterraum ist, kann eine Basis mit \\(A\\) erstellt werden. Es m\u00fcssen alle Vektoren \\(a_i\\) gefunden werden, welche linear Unabh\u00e4ngig sind","title":"Kern und Bild einer Abbildung"},{"location":"22FS/LA/summary.html","tags":["summary","LA"],"text":"LA Summary \\[ \\newcommand{\\len}[1]{\\vert #1 \\vert} \\DeclareMathOperator{\\rg}{rg} \\DeclareMathOperator{\\span}{span} \\DeclareMathOperator{\\dim}{dim} \\DeclareMathOperator{\\im}{im} \\] LA Summary Linearen Gleichungssysteme (LGS) L\u00f6sung aus Zeilenstufenform L\u00f6sung aus reduzierter Zeilenstufenform L\u00f6sbarkeit von LGS Vektoren Linear Unabh\u00e4ngig S\u00e4tze 3D-Koordinatensystem Skalarprodukt Orthogonale Projektion Vektorprodukt Gerade Wie stehen zwei Gerade zueinander Abstand eines Punktes Ebene Wie stehen zwei Ebene zueinander Abstand von einem Punkt zu einer Ebene Matrix Transponierte Matrix Inverse Matrix Determinante Vektorr\u00e4ume Unterr\u00e4ume Linearer Spann Erzeugendensystem Basis Dimension Lineare Abbildung Basis-wechselnde Abbildung Abbildung in der Ebene Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung Spiegelung an einer allgemeinen Gerade durch den Ursprung Abbildung im Raum Kern und Bild Verkn\u00fcpfung von Abbildungen Rest Klassen Prime Restklassen Modulare Arithmethik Linearen Gleichungssysteme (LGS) Zeilenstufenform: Alle nicht- 0 Zeilen, haben eine f\u00fchrende 1 ; Alle 0 -Zeilen stehen zu unterst; Je weiter unten, desto weiter rechts steht eine f\u00fchrende 1 reduzierte Zeilenstufenform: Zus\u00e4tzlich gilt: Eine Spalte mit einer f\u00fchrenden 1 , darf nur noch 0 enthalten L\u00f6sung aus Zeilenstufenform Unterscheiden zwischen Spalten mit f\u00fchrenden 1 und mit freien Unbekannten. F\u00fcr alle freie Unbekannte kann ein Unbekannte gleichgesetzt werden (z.B. \\(\\lambda\\) ) Alle Zeilen mit einer f\u00fchrenden- 1 werden in eine Gleichung umgewandelt werden L\u00f6sung aus reduzierter Zeilenstufenform Das Resultat kann abgeschaut werden. L\u00f6sbarkeit von LGS \\(\\rg(A)=\\text{Anzahl Zeilen}-\\text{Anzahl Nullzeilen}\\) (in der Zeilenstuffen form) \\(n\\) ist die Anzahl Spalten von \\(A\\) Eigenschaften, wenn \\(rg(A)=n\\) gilt: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar Vektoren Ortsvektor Ein Vektor \\(\\vec r(P)\\) , welcher am Ursprung festgehaftet ist Nullvektor \\(\\vec 0\\) Ein Vektor mit dem Betrag 0 und keiner Richtung Gegenvektor : \\(\\vec a\\rightarrow -\\vec a\\) Kollinear : Wenn zwei Vektoren parallel sind oder \\(\\vec a = \\lambda \\cdot \\vec b\\) Komplanar Drei Vektoren heissen komplanar, wenn es eine Ebene gibt, zu der alle drei parallel sind. Vektor zwischen zwei Punkten \\(\\vec{PQ}=\\begin{pmatrix}x_Q-x_P\\\\y_Q-y_P\\end{pmatrix}=\\vec r(Q)-\\vec r(P)\\) Linear Unabh\u00e4ngig Vektoren sind linear Unabh\u00e4ngig, wenn es nur eine M\u00f6glichkeit gibt mit einer Linearkombination \\(\\vec 0\\) zu erreichen: \\(\\lambda_1\\cdot \\vec a_1 + \\lambda_2 \\cdot \\vec a_2 + ... + \\lambda_n \\cdot \\vec a_n=\\vec 0\\) Eigenschaften die daraus folgen: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) die Inversematrix kann gebildet werden \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n=\\text{Anzahl Spalten}\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar S\u00e4tze Satz 1 : Es l\u00e4sst sich der Vektor \\(\\vec c\\) als Linearkombination der Vektorn \\(\\vec a\\) und \\(\\vec b\\) im 2D -Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) komplanar sind \\(\\vec a\\) und \\(\\vec b\\) nicht kollinear sind Satz 2 : Es l\u00e4sst sich den Vektor \\(\\vec d\\) als Linearkombinatino der Vektoren \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) im 3D -Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) nicht komplanar sind 3D-Koordinatensystem Skalarprodukt $$ \\vec a \\cdot \\vec b = \\vert \\vec a \\vert \\cdot \\vert \\vec b\\vert \\cdot \\cos(\\varphi)\\ \\vec a \\cdot \\vec b=a_1b_1+a_2b_2+a_3b_3\\ \\varphi =cos^{-1}\\left(\\frac{\\vec a \\cdot \\vec b}{|\\vec a|\\cdot |\\vec b|}\\right)\\ \\vec a \\cdot \\vec b = 0\\Rightarrow \\varphi=90\u00b0=\\frac 2 \\pi $$ Folgende Gesetzte gelten: Kommuntativ-Gesetzt: \\(\\vec a \\cdot \\vec b=\\vec b \\cdot \\vec a\\) Distributive-Gesetzt: \\(\\vec a \\cdot (\\vec b + \\vec c)=\\vec a \\cdot \\vec b + \\vec a \\cdot \\vec c\\) Gemischtes Assoziativ-Gesetzt: \\(\\lambda\\cdot (\\vec a \\cdot \\vec b)=(\\lambda \\cdot \\vec a)\\cdot \\vec b=\\vec a \\cdot (\\lambda \\cdot \\vec b)\\) \\(\\vec a \\cdot \\vec a=\\vert \\vec a \\vert ^2\\) Orthogonale Projektion $$ \\vec b_a =\\frac{\\vec a \\cdot \\vec b}{|\\vec a|^2}\\cdot \\vec a\\ |\\vec b_a|=\\frac{|\\vec a \\cdot \\vec b|}{|\\vec a|} $$ Vektorprodukt Folgende Gesetze gelten: \\(\\len {\\vec a \\times \\vec b}=\\len {\\vec a}\\cdot \\len {\\vec b}\\cdot \\sin(\\varphi)\\) \\(\\vec a \\times \\vec b\\) ist orthogonal zu \\(\\vec a\\) und \\(\\vec b\\) \\(\\vec a\\) und \\(\\vec b\\) sind kollinear, wenn \\(\\vec a \\times \\vec b=\\vec 0\\) gilt \\(\\vec a \\times \\vec a = \\vec 0\\) Antikommutativ-Gesetz: \\(\\vec a \\times \\vec b = -(\\vec b \\times \\vec a)\\) Distributiv-Gesetzt: \\(\\vec a \\times (\\vec b + \\vec c)=\\vec a \\times \\vec b + \\vec a \\times \\vec c\\) und \\((\\vec a + \\vec c)\\times \\vec c = \\vec a \\times \\vec c + \\vec b \\times \\vec c\\) Gemischtes Assoziativ-Gesetz: \\(\\lambda \\cdot (\\vec a \\times \\vec b)=(\\lambda \\cdot \\vec a)\\times \\vec b=\\vec a \\times (\\lambda \\cdot \\vec b)\\) Das Assoziative-Gesetzt gilt nicht : \\(\\vec a \\times (\\vec b \\times \\vec c)\\neq (\\vec a \\times \\vec b)\\times\\vec c\\) \\(\\vec a \\times \\vec b\\) ist die Fl\u00e4che eines Parallelogrammes aufgespannt durch \\(\\vec a\\) und \\(\\vec b\\) Gerade Parameterdarstellung \\(g: \\vec r(P)+ \\lambda \\cdot \\vec{PQ}\\) Zu Kordinatendarstellung umrechnen Als LGS schreiben und \\(\\lambda\\) eliminieren Kordinatendarstellung (nur in 2D) \\(g: ax+by+c=0\\) Normalvektor \\(n=\\pmatrix{a \\\\ b}\\) Normalvektor steht senkrecht auf der gerade Zu Paramterdarstellung umrechnen: Zwei Punkte auf \\(g\\) finden und damit \\(\\vec{PQ}\\) berechnen Normierte Kordinatendarstellung (Nur in 2D) Die L\u00e4nge des Normalvektors is \\(0\\) . Um dies zu berechnen, den Normalvektor normieren (also durch die L\u00e4nge des Normalvektors teilen) Wie stehen zwei Gerade zueinander Abstand eines Punktes TODO Ebene Parameterdarstellung \\(E: \\vec r(P)+\\lambda \\cdot \\vec{PR}+\\mu\\cdot \\vec{PQ}\\) Normalvektor \\(\\vec n = \\vec{PR}\\times \\vec{PQ}\\) Zu Koordinatendarstelung umwandeln Variante 1 Normalvektor \\(\\vec n\\) ausrechnen und in Koordinatenform einsetzen. Daraus ergibt sich eine Gleichung mit einer Unbekannte \\(d\\) . Diese L\u00f6sen Variante 2 Die drei Gleichungen in einem LGS schreiben und \\(\\lambda\\) und \\(\\mu\\) eliminieren Koordinatendarstellung \\(E: ax+by+cz+d=0\\) Normalvektor: \\(\\vec n=\\pmatrix{a\\\\b\\\\ c}\\) Normalvektor steht orthogonal auf der Ebene Zu Parameterdarstellung umwandeln Drei Punkte auf der Ebene finden und daraus die Parameterdarstellung bilden Normierte Koordinatendarstellung Der Normalvektor \\(\\vec n\\) ist normiert (durch \\(\\vert \\vec n \\vert\\) geteilt) ( \\(d\\) muss auch durch \\(|\\vec n |\\) geteilt werden) Wie stehen zwei Ebene zueinander Parallel : Parameterdarstellung \u00dcberpr\u00fcfen, ob die Richtungsvektoren komplanar zu einander sind Koordinatendarstellung Es muss ein Faktor \\(p\\) in folgendem System geben $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1\\neq d_2\\cdot p $$ Alternativ: Die Normalvektoren beider Ebenen m\u00fcssen koolinear sein Identisch Parameterdarstellung Wenn die zwei Ebenen gleichgesetzt werden, m\u00fcssen unendlich viele L\u00f6sungen, mit zwei nicht gefixte Grade, heraus kommen Koordinatendarstellung: F\u00fcr die Koordinatendarstellung muss folgendes g\u00fcltig sein (die letzte Gleichung ist anderst) $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1=d_2\\cdot p $$ Schneident Parameterdarstellung Wenn die zwei Ebenen gleichgesetzt werden, m\u00fcssen unendlich viele L\u00f6sungen, mit einer nicht gefixte Grade, heraus kommen. Das Resultat ist eine Gerade in der Parameterdarstellung Koordinatendarstellung Die beiden Ebenen in dasselbe Gleichungssystem tun und zu einem Gauss umwandeln ( \\(d\\) auf die andere Seite nehmen). Wenn dies aufgel\u00f6st wird, m\u00fcsste eine Geradegleichung dabei herauskommen Abstand von einem Punkt zu einer Ebene \\[ \\text{Wenn die Ebene nicht normiert sind: } l=\\frac{|ax_A+by_A+cz_A+d|}{|\\vec n|}\\\\ \\text{Wenn die Ebene normiert ist: } l=|ax_A+by_A+cz_A+d| \\] Matrix Null-Matrix : Eine Matrix mit nur Nullen Spalten-Matrix : Eine Matrix mit nur einer Spalte. Verh\u00e4lt sich gleich, wie ein Vektor Die folgenden Rechenregeln funktioniert f\u00fcr gleichgrosse Matrizen. Kommutativ-Gesetz: \\(A+B=B+A\\) (Geht NICHT bei Multiplikation) Assoziativ-Gesetzt: \\(A+(B+C)=(A+B)+C\\) Distributiv-Gesetzt: \\(\\lambda\\cdot(A+B)=\\lambda\\cdot A + \\lambda \\cdot B\\) Aber Achtung: \\(\\lambda\\cdot A + B\\cdot \\lambda\\) kann nicht ausgeklammert werden (In k\u00f6nnte einfach \\(\\lambda \\cdot A\\) und \\(B\\cdot \\lambda\\) ausgerechnet werden) Distributiv-Gesetzt mit Transportierten Matrizen: \\((A\\cdot B)^T=B^T \\cdot A^T\\) (Beachte die Reihenfolge von A und B) \\((A+B)^T=A^T+B^T=B^T+A^T\\) \\((A-B)^T=A^T-B^T=B^T-A^T\\) Transponierte Matrix \\[ B= \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 4 & 5 \\end{bmatrix}\\\\ B^T= \\begin{bmatrix} 1 & 3 \\\\ 2 & 4\\\\ 3 & 5 \\end{bmatrix} \\] Es gilt folgendes Gesetzt: \\((A\\cdot B)^T=B^T\\cdot A^T\\) (Bemerke, dass sich die Reihenfolge von \\(A\\) und \\(B\\) sich \u00e4ndert) Inverse Matrix Die inverse Matrix kann von einer Quadratischen-Matrix gebildet werden, bei welcher \\(\\det(A)\\neq 0\\) gilt $$ \\pmatrix{a & b\\ c & d}^{-1}=\\frac 1 {ad-bc}\\cdot \\pmatrix{d & -b \\ -c & a} $$ F\u00fcr gr\u00f6ssere Matrizen folgendes Gleichungssystem muss aufgel\u00f6st werden: $$ \\pmatrix{ a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} }^{-1} \\Rightarrow \\left(\\begin{array}{ccc|cr} a_{11} & a_{12} & a_{13} & 1 & 0 & 0\\ a_{21} & a_{22} & a_{23} & 0 & 1 & 0\\ a_{31} & a_{32} & a_{33} & 0 & 0 & 1 \\end{array}\\right ) $$ Determinante Wenn die Determinanten einer gr\u00f6sseren Matrix als 3x3 Berechnet werden soll, kann ein Verfahren nach Laplace eingesetzt werden: Es wird eine feste Spalte oder Zeile gew\u00e4hlt Nun wird nach der folgenden Formel entwickelt: $$ \\text{Entwicklung nach i-ten Zeilen: }\\det(A)=\\sum^n_{j=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ \\text{Entwicklung nach j-ten Spalte: }\\det(A)=\\sum^n_{i=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ $$ Dabei ist \\(a_{ij}\\) , das Element an \\(i\\) -ter Zeile und \\(j\\) -ter Spalte und \\(A_{ij}\\) die Matrix, bei welcher die \\(i\\) -te Zeile und \\(j\\) -Spalte weggelassen wurden Der Determinante einer 2x2-Matrix, ist der Fl\u00e4cheninhalt des Parallelogrammes, wenn die Spalten als Vektoren aufgefasst werden. Der Determinante einer 3x3-Matrix ist der Volumeninhalt des Spates, von den Spalten der Matrix aufgespannt wird. Eigenschaften: Einheitsmatrix haben den Determinanten \\(1\\) F\u00fcr nxn Matrix gilt: \\(\\det(A\\cdot B)=\\det(A)\\cdot \\det(B)\\) F\u00fcr invertierbare Matrix gilt: \\(\\det(A^{-1})=\\frac 1 {\\det(A)}\\) F\u00fcr \\(A^T\\) gilt: \\(\\det(A^T)=\\det(A)\\) Wenn: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Die Spalten und Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow \\rg(A)=n=m\\) \\(\\Leftrightarrow A\\) ist invertierbar \\(\\Leftrightarrow\\) Das LGS \\(A\\cdot \\vec x = \\vec c\\) hat eine eindeutige L\u00f6sung $\\Leftrightarrow $ Die Vektoren in \\(A\\) sind eine Basis Vektorr\u00e4ume \\[ +:V \\times V \\rightarrow V\\\\ \\cdot : \\R \\times V \\rightarrow V \\] Dabei m\u00fcssen folgende Gesetze existieren: Kommutativgesetz: \\(a + b = b + a\\) Assoziativgesetzt: \\(a + (b + c)=(a + b) + c\\) Es gibt ein neutrales Element \\(\\vec 0\\) , f\u00fcr welches gilt \\(a + 0v = \\vec a\\) und \\(0v \\in V\\) F\u00fcr jedes Element \\(a \\in V\\) muss es ein inverses Element \\(-a \\in V\\) geben, so dass \\(a + (-a) = 0v\\) ergibt. Assoziativgesetzt: \\(\\lambda \\cdot (\\mu \\cdot a) = (\\lambda \\cdot \\mu) \\cdot a\\) Distributivgesetzt: \\(\\lambda \\cdot(a + b) = \\lambda \\cdot a + \\lambda \\cdot b\\) Distirbutgesetzt: \\((\\lambda + \\mu)\\cdot a = \\lambda \\cdot a + \\mu \\cdot a\\) F\u00fcr jedes Element \\(a \\in V\\) gibt es ein neutrales Element \\(1\\cdot a = a\\) , Allgemein bekannte Vektorr\u00e4ume: \\(\\R^n\\) - Vektorraum von allen Vekotren mit \\(n\\) reellen Komponente $ \\R^{m\\times n}$ - Vektorraum von allen reelen \\(m\\times n\\) -Matrizen \\(\\mathbb P_n[x]\\) - Vektorraum der Polynome von Grad \\(\\le n\\) Unterr\u00e4ume F\u00fcr beliebige Element \\(a, b \\in U\\) ist auch \\(a+b\\in U\\) F\u00fcr jeden Skalar \\(\\lambda \\in \\R\\) und jedes Element \\(a\\in U\\) ist auch \\(\\lambda \\cdot a\\in U\\) (Die neutralen Elemente der Addition und Skalarmultiplikation m\u00fcssen ebenfalls in \\(U\\) sein.) Linearer Spann \\[ \\span(\\vec a_1, \\vec a_2 , ..., \\vec a_n)=\\lambda_1\\cdot \\vec a_n1 + \\lambda_2\\cdot \\vec a_2 + ... + \\lambda_n \\cdot \\vec a_n \\] Jenachdem, wie viele linear unabh\u00e4ngige Vektoren gegeben sind, wird ein anderes geometrisches Objekt gebildet: Bei 1 Vektor, wird eine Ursprungs-Gerade gebildet Bei 2 Vektoren, wird eine Ursprungs-Ebene Bei 3 Vektoren, wird ein \"Ursprungs-K\u00f6rper\" gebildet Erzeugendensystem Eine Menge von Vektoren \\(\\{\\vec b_1, \\vec b_2, ..., \\vec b_N\\}\\) , falls die Vektoren nicht komplanar und kolinear zueinander sind, bilden ein Erzeugendensystem von \\(V\\) : \\(V=\\span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\) Ein Erzeugendensystem hat folgende eigenschaften: $$ \\begin{align} & V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\ \\Leftrightarrow \\text{ } & B\\cdot \\vec x = \\vec a \\text { f\u00fcr jedes } \\vec a \\in \\R^m\\ \\Leftrightarrow \\text{ } & rg(B)=m = \\text{Anzahl Zeilen} \\end{align} $$ Basis Eine Basis ist eine Menge von Vektoren, welche ein Erzeugendensystem sind linear unabh\u00e4ngig sind (Auf Deutsch: Es darf nur eine M\u00f6glichkeit geben, jeden Vektor zu Bilden) Es kann auch \u00fcberpr\u00fcft werden, ob \\(\\det(A)\\neq 0\\) ist (siehe Determinante) Wichtige Basen: F\u00fcr \\(\\R^n\\) : \\(\\mathcal S=\\{\\vec e_1, \\vec e_2, ..., \\vec e_n\\}\\) - Standardbasis F\u00fcr \\(\\mathbb P_n[x]\\) \\(\\mathcal M=\\{1, x, x^2, ..., x^n\\}\\) - Monombasis Dimension Die Anzahl Vektoren in der Basis eines Vektorraumes: \\(\\dim(V)\\) Die Dimension von \\(\\{\\vec 0\\}\\) ist \\(0\\) Lineare Abbildung Eine Lineare Abbildung ist eine Funktion \\(f: V \\to W\\) , welche folgende zwei Regeln einh\u00e4lt: $$ f(x+y)=f(x)+f(y)\\ f(\\lambda \\cdot x)=\\lambda \\cdot f(x) $$ Eine lineare Abbildung kann auch als Matrix geschrieben werden. Um dies zu erreichen, gibt es zwei m\u00f6glichkeiten: Die Einheitsvektoren in \\(f(x)\\) einsetzen und aus den Resultaten eine Matrix bauen Zeile f\u00fcr Zeile durchgehen und die Matrixzeilen davon ableiten $$ A\\cdot\\pmatrix{x \\ y \\ z} = \\pmatrix{x\\ z - y \\ y - x \\ 2x - y} \\Rightarrow A = \\pmatrix{1 & 0 & 0 \\ 0 & -1 & 1 \\ -1 & 1 & 0 \\ 2 & -1 & 0} $$ Basis-wechselnde Abbildung \\(_CA_B\\) beschreibt die Lineare Abbildung \\(f: V_B \\to W_C\\) (Achtung Reihenfolge) und wird wie folgt gebraucht: \\(_CA_B\\cdot \\vec x_B=f(\\vec x)\\) . Es kann wie folgt gebildet werden: Die Matrix \\((_CA_B)^{-1}={}_BA_C\\) Abbildung in der Ebene Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung Wenn auf eine Gerade projektiert werden soll, welche nicht die x-, y- oder z-Achse ist, muss folgende Formel verwendet werden. Dabei wird erwartet, dass die Gerade in der Kordinatendarstelung ( \\(ax + by = 0\\) ) normiert ist ( \\(a^2 + b^2 = 1\\) ). $$ P= \\begin{pmatrix} 1 - a^2 & -ab\\ -ab & 1-b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$ Spiegelung an einer allgemeinen Gerade durch den Ursprung Wenn alle Vektoren bei einer Gerade, welche durch den Ursprung geht, gespiegelt werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Gerade in der Koordinatendarstellung ( \\(ax + by=0\\) ) normiert ist ( \\(a^2+b^2 = 1\\) ). $$ S= \\begin{pmatrix} 1 - 2a^2 & -2ab\\ -2ab & 1 - 2b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$ Abbildung im Raum Kern und Bild \\[ \\ker(A)=\\{\\vec x \\in V \\vert A\\cdot \\vec x = \\vec 0\\}\\\\ \\im(A)=\\span(\\vec a_1, \\vec a_2, ..., \\vec a_n)=\\{\\lambda_1 \\vec a_1 + \\lambda_2 \\vec a_2 + ... + \\lambda_n\\vec a_n \\vert \\lambda_k \\in \\R\\} \\] Der Kern \\(\\ker(A)\\) besteht aus alle Vektoren \\(\\vec x\\) , welche die Gleichung \\(A\\cdot \\vec x=\\vec 0\\) erf\u00fcllen Das Bild \\(\\im(A)\\) ist der Spalten der Vektoren von \\(A\\) Zus\u00e4tzlich gilt f\u00fcr \\(\\im(A)\\) und \\(\\ker(A)\\) : $$ \\dim(\\ker(A)) + \\dim(\\im(A)) = \\dim(A)\\ \\dim(\\im(A)) = \\rg(A) $$ Um die Dimensionen zu bestimmen gibt es mehrere M\u00f6glichkeiten: Mit der Zeilenstuffenform von \\(A\\) den Rang ablesen. Von diesem kann die Dimension von \\(\\im(A)\\) abgelesen werden und dank des Satzes von oben auch \\(\\dim(\\ker(A))\\) bestimmen Da die Menge, welche von \\(\\ker(A)\\) zur\u00fcck gegeben werden, auch ein Unterraum ist, kann eine Basis mit \\(A\\) erstellt werden. Es m\u00fcssen alle Vektoren \\(a_i\\) gefunden werden, welche linear Unabh\u00e4ngig sind Verkn\u00fcpfung von Abbildungen \\[ g: V \\to W \\mapsto g(\\vec x)=A \\cdot \\vec x\\\\ f: U \\to W \\mapsto f(\\vec x)=B \\cdot \\vec x \\\\ g(f(\\vec x)) = (g \\circ f)(\\vec x)=B \\cdot A \\cdot \\vec x \\] Rest Klassen In der Restklasse \\([x]_n\\) sind alle Zahlen \\(a\\) , welche durch \\(n\\) geteilt den Rest \\(x\\) ergeben Formel Erkl\u00e4rung \\(\\Z/n=\\{[z]_n\\|z\\in \\Z\\}\\) Die Menge aller Restklasse \\(\\Z^*_{/n}\\) Das Primes Restklassenssytem, welches nur die Restklassen enth\u00e4lt, welche zu n teilerfremd sind. Alle Restklassen in diesem System k\u00f6nnen multipliziert werden (Siehe Prime Restklassen ) \\([z]_n=\\overline{z}\\) Die Restklasse, bzw. \u00c4quivalenzklasse mit dem Teiler n und dem Vertreter \\(z\\) Prime Restklassen Prime Restklassen sind die Restklassen, welche ein Inverseselement f\u00fcr die Multiplikation besitzen. Dies wird mit einem Stern geschrieben, wie hier zu sehen: \\(\\Z_{/7}^{*}\\) . Beispiel: \\(\\Z^*_{/7}=\\{[1], [2], [3], [4], [5], [6]\\}\\) \\(\\Z^*_{/6}=\\{[1], [5]\\}\\) Modulare Arithmethik f\u00fcr Multiplikation: neutrales Element: \\([1]_n\\) inverses Element: Nur Zahlen, welche teilefrmed sind ( \\(ggT(Zahl, N)=1\\) ) Eine Zahl multipliziert mt ihrem inversen Element gibt \\(1\\) Kann mit dem Erweiterten Euklidischen Algorithmus berechnet werden: \\(Zahlenbereich \\cdot x + Zahl \\cdot y=1\\) \\(\\Rightarrow y\\) ist das multiplikative Inverse. (Zahl muss kleiner sein als Zahlenbereich, sonst muss gewechselt werden)","title":"LA Summary"},{"location":"22FS/LA/summary.html#la-summary","text":"\\[ \\newcommand{\\len}[1]{\\vert #1 \\vert} \\DeclareMathOperator{\\rg}{rg} \\DeclareMathOperator{\\span}{span} \\DeclareMathOperator{\\dim}{dim} \\DeclareMathOperator{\\im}{im} \\] LA Summary Linearen Gleichungssysteme (LGS) L\u00f6sung aus Zeilenstufenform L\u00f6sung aus reduzierter Zeilenstufenform L\u00f6sbarkeit von LGS Vektoren Linear Unabh\u00e4ngig S\u00e4tze 3D-Koordinatensystem Skalarprodukt Orthogonale Projektion Vektorprodukt Gerade Wie stehen zwei Gerade zueinander Abstand eines Punktes Ebene Wie stehen zwei Ebene zueinander Abstand von einem Punkt zu einer Ebene Matrix Transponierte Matrix Inverse Matrix Determinante Vektorr\u00e4ume Unterr\u00e4ume Linearer Spann Erzeugendensystem Basis Dimension Lineare Abbildung Basis-wechselnde Abbildung Abbildung in der Ebene Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung Spiegelung an einer allgemeinen Gerade durch den Ursprung Abbildung im Raum Kern und Bild Verkn\u00fcpfung von Abbildungen Rest Klassen Prime Restklassen Modulare Arithmethik","title":"LA Summary"},{"location":"22FS/LA/summary.html#linearen-gleichungssysteme-lgs","text":"Zeilenstufenform: Alle nicht- 0 Zeilen, haben eine f\u00fchrende 1 ; Alle 0 -Zeilen stehen zu unterst; Je weiter unten, desto weiter rechts steht eine f\u00fchrende 1 reduzierte Zeilenstufenform: Zus\u00e4tzlich gilt: Eine Spalte mit einer f\u00fchrenden 1 , darf nur noch 0 enthalten","title":"Linearen Gleichungssysteme (LGS)"},{"location":"22FS/LA/summary.html#losung-aus-zeilenstufenform","text":"Unterscheiden zwischen Spalten mit f\u00fchrenden 1 und mit freien Unbekannten. F\u00fcr alle freie Unbekannte kann ein Unbekannte gleichgesetzt werden (z.B. \\(\\lambda\\) ) Alle Zeilen mit einer f\u00fchrenden- 1 werden in eine Gleichung umgewandelt werden","title":"L\u00f6sung aus Zeilenstufenform"},{"location":"22FS/LA/summary.html#losung-aus-reduzierter-zeilenstufenform","text":"Das Resultat kann abgeschaut werden.","title":"L\u00f6sung aus reduzierter Zeilenstufenform"},{"location":"22FS/LA/summary.html#losbarkeit-von-lgs","text":"\\(\\rg(A)=\\text{Anzahl Zeilen}-\\text{Anzahl Nullzeilen}\\) (in der Zeilenstuffen form) \\(n\\) ist die Anzahl Spalten von \\(A\\) Eigenschaften, wenn \\(rg(A)=n\\) gilt: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar","title":"L\u00f6sbarkeit von LGS"},{"location":"22FS/LA/summary.html#vektoren","text":"Ortsvektor Ein Vektor \\(\\vec r(P)\\) , welcher am Ursprung festgehaftet ist Nullvektor \\(\\vec 0\\) Ein Vektor mit dem Betrag 0 und keiner Richtung Gegenvektor : \\(\\vec a\\rightarrow -\\vec a\\) Kollinear : Wenn zwei Vektoren parallel sind oder \\(\\vec a = \\lambda \\cdot \\vec b\\) Komplanar Drei Vektoren heissen komplanar, wenn es eine Ebene gibt, zu der alle drei parallel sind. Vektor zwischen zwei Punkten \\(\\vec{PQ}=\\begin{pmatrix}x_Q-x_P\\\\y_Q-y_P\\end{pmatrix}=\\vec r(Q)-\\vec r(P)\\)","title":"Vektoren"},{"location":"22FS/LA/summary.html#linear-unabhangig","text":"Vektoren sind linear Unabh\u00e4ngig, wenn es nur eine M\u00f6glichkeit gibt mit einer Linearkombination \\(\\vec 0\\) zu erreichen: \\(\\lambda_1\\cdot \\vec a_1 + \\lambda_2 \\cdot \\vec a_2 + ... + \\lambda_n \\cdot \\vec a_n=\\vec 0\\) Eigenschaften die daraus folgen: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) die Inversematrix kann gebildet werden \\(\\Leftrightarrow\\) Spalten sind linear unabh\u00e4ngig \\(\\Leftrightarrow\\) Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow rg(A)=n=\\text{Anzahl Spalten}\\) \\(\\Leftrightarrow\\) A ist regul\u00e4r, bzw. invertierbar \\(\\Leftrightarrow A\\cdot \\vec x=\\vec 0\\) ist eindeutig l\u00f6sbar","title":"Linear Unabh\u00e4ngig"},{"location":"22FS/LA/summary.html#satze","text":"Satz 1 : Es l\u00e4sst sich der Vektor \\(\\vec c\\) als Linearkombination der Vektorn \\(\\vec a\\) und \\(\\vec b\\) im 2D -Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) komplanar sind \\(\\vec a\\) und \\(\\vec b\\) nicht kollinear sind Satz 2 : Es l\u00e4sst sich den Vektor \\(\\vec d\\) als Linearkombinatino der Vektoren \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) im 3D -Raum darstellen, wenn \\(\\vec a\\) , \\(\\vec b\\) und \\(\\vec c\\) nicht komplanar sind","title":"S\u00e4tze"},{"location":"22FS/LA/summary.html#3d-koordinatensystem","text":"","title":"3D-Koordinatensystem"},{"location":"22FS/LA/summary.html#skalarprodukt","text":"$$ \\vec a \\cdot \\vec b = \\vert \\vec a \\vert \\cdot \\vert \\vec b\\vert \\cdot \\cos(\\varphi)\\ \\vec a \\cdot \\vec b=a_1b_1+a_2b_2+a_3b_3\\ \\varphi =cos^{-1}\\left(\\frac{\\vec a \\cdot \\vec b}{|\\vec a|\\cdot |\\vec b|}\\right)\\ \\vec a \\cdot \\vec b = 0\\Rightarrow \\varphi=90\u00b0=\\frac 2 \\pi $$ Folgende Gesetzte gelten: Kommuntativ-Gesetzt: \\(\\vec a \\cdot \\vec b=\\vec b \\cdot \\vec a\\) Distributive-Gesetzt: \\(\\vec a \\cdot (\\vec b + \\vec c)=\\vec a \\cdot \\vec b + \\vec a \\cdot \\vec c\\) Gemischtes Assoziativ-Gesetzt: \\(\\lambda\\cdot (\\vec a \\cdot \\vec b)=(\\lambda \\cdot \\vec a)\\cdot \\vec b=\\vec a \\cdot (\\lambda \\cdot \\vec b)\\) \\(\\vec a \\cdot \\vec a=\\vert \\vec a \\vert ^2\\)","title":"Skalarprodukt"},{"location":"22FS/LA/summary.html#orthogonale-projektion","text":"$$ \\vec b_a =\\frac{\\vec a \\cdot \\vec b}{|\\vec a|^2}\\cdot \\vec a\\ |\\vec b_a|=\\frac{|\\vec a \\cdot \\vec b|}{|\\vec a|} $$","title":"Orthogonale Projektion"},{"location":"22FS/LA/summary.html#vektorprodukt","text":"Folgende Gesetze gelten: \\(\\len {\\vec a \\times \\vec b}=\\len {\\vec a}\\cdot \\len {\\vec b}\\cdot \\sin(\\varphi)\\) \\(\\vec a \\times \\vec b\\) ist orthogonal zu \\(\\vec a\\) und \\(\\vec b\\) \\(\\vec a\\) und \\(\\vec b\\) sind kollinear, wenn \\(\\vec a \\times \\vec b=\\vec 0\\) gilt \\(\\vec a \\times \\vec a = \\vec 0\\) Antikommutativ-Gesetz: \\(\\vec a \\times \\vec b = -(\\vec b \\times \\vec a)\\) Distributiv-Gesetzt: \\(\\vec a \\times (\\vec b + \\vec c)=\\vec a \\times \\vec b + \\vec a \\times \\vec c\\) und \\((\\vec a + \\vec c)\\times \\vec c = \\vec a \\times \\vec c + \\vec b \\times \\vec c\\) Gemischtes Assoziativ-Gesetz: \\(\\lambda \\cdot (\\vec a \\times \\vec b)=(\\lambda \\cdot \\vec a)\\times \\vec b=\\vec a \\times (\\lambda \\cdot \\vec b)\\) Das Assoziative-Gesetzt gilt nicht : \\(\\vec a \\times (\\vec b \\times \\vec c)\\neq (\\vec a \\times \\vec b)\\times\\vec c\\) \\(\\vec a \\times \\vec b\\) ist die Fl\u00e4che eines Parallelogrammes aufgespannt durch \\(\\vec a\\) und \\(\\vec b\\)","title":"Vektorprodukt"},{"location":"22FS/LA/summary.html#gerade","text":"Parameterdarstellung \\(g: \\vec r(P)+ \\lambda \\cdot \\vec{PQ}\\) Zu Kordinatendarstellung umrechnen Als LGS schreiben und \\(\\lambda\\) eliminieren Kordinatendarstellung (nur in 2D) \\(g: ax+by+c=0\\) Normalvektor \\(n=\\pmatrix{a \\\\ b}\\) Normalvektor steht senkrecht auf der gerade Zu Paramterdarstellung umrechnen: Zwei Punkte auf \\(g\\) finden und damit \\(\\vec{PQ}\\) berechnen Normierte Kordinatendarstellung (Nur in 2D) Die L\u00e4nge des Normalvektors is \\(0\\) . Um dies zu berechnen, den Normalvektor normieren (also durch die L\u00e4nge des Normalvektors teilen)","title":"Gerade"},{"location":"22FS/LA/summary.html#wie-stehen-zwei-gerade-zueinander","text":"","title":"Wie stehen zwei Gerade zueinander"},{"location":"22FS/LA/summary.html#abstand-eines-punktes","text":"TODO","title":"Abstand eines Punktes"},{"location":"22FS/LA/summary.html#ebene","text":"Parameterdarstellung \\(E: \\vec r(P)+\\lambda \\cdot \\vec{PR}+\\mu\\cdot \\vec{PQ}\\) Normalvektor \\(\\vec n = \\vec{PR}\\times \\vec{PQ}\\) Zu Koordinatendarstelung umwandeln Variante 1 Normalvektor \\(\\vec n\\) ausrechnen und in Koordinatenform einsetzen. Daraus ergibt sich eine Gleichung mit einer Unbekannte \\(d\\) . Diese L\u00f6sen Variante 2 Die drei Gleichungen in einem LGS schreiben und \\(\\lambda\\) und \\(\\mu\\) eliminieren Koordinatendarstellung \\(E: ax+by+cz+d=0\\) Normalvektor: \\(\\vec n=\\pmatrix{a\\\\b\\\\ c}\\) Normalvektor steht orthogonal auf der Ebene Zu Parameterdarstellung umwandeln Drei Punkte auf der Ebene finden und daraus die Parameterdarstellung bilden Normierte Koordinatendarstellung Der Normalvektor \\(\\vec n\\) ist normiert (durch \\(\\vert \\vec n \\vert\\) geteilt) ( \\(d\\) muss auch durch \\(|\\vec n |\\) geteilt werden)","title":"Ebene"},{"location":"22FS/LA/summary.html#wie-stehen-zwei-ebene-zueinander","text":"Parallel : Parameterdarstellung \u00dcberpr\u00fcfen, ob die Richtungsvektoren komplanar zu einander sind Koordinatendarstellung Es muss ein Faktor \\(p\\) in folgendem System geben $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1\\neq d_2\\cdot p $$ Alternativ: Die Normalvektoren beider Ebenen m\u00fcssen koolinear sein Identisch Parameterdarstellung Wenn die zwei Ebenen gleichgesetzt werden, m\u00fcssen unendlich viele L\u00f6sungen, mit zwei nicht gefixte Grade, heraus kommen Koordinatendarstellung: F\u00fcr die Koordinatendarstellung muss folgendes g\u00fcltig sein (die letzte Gleichung ist anderst) $$ a_1=a_2\\cdot p\\ b_1=b_2\\cdot p\\ c_1=c_2\\cdot p\\ d_1=d_2\\cdot p $$ Schneident Parameterdarstellung Wenn die zwei Ebenen gleichgesetzt werden, m\u00fcssen unendlich viele L\u00f6sungen, mit einer nicht gefixte Grade, heraus kommen. Das Resultat ist eine Gerade in der Parameterdarstellung Koordinatendarstellung Die beiden Ebenen in dasselbe Gleichungssystem tun und zu einem Gauss umwandeln ( \\(d\\) auf die andere Seite nehmen). Wenn dies aufgel\u00f6st wird, m\u00fcsste eine Geradegleichung dabei herauskommen","title":"Wie stehen zwei Ebene zueinander"},{"location":"22FS/LA/summary.html#abstand-von-einem-punkt-zu-einer-ebene","text":"\\[ \\text{Wenn die Ebene nicht normiert sind: } l=\\frac{|ax_A+by_A+cz_A+d|}{|\\vec n|}\\\\ \\text{Wenn die Ebene normiert ist: } l=|ax_A+by_A+cz_A+d| \\]","title":"Abstand von einem Punkt zu einer Ebene"},{"location":"22FS/LA/summary.html#matrix","text":"Null-Matrix : Eine Matrix mit nur Nullen Spalten-Matrix : Eine Matrix mit nur einer Spalte. Verh\u00e4lt sich gleich, wie ein Vektor Die folgenden Rechenregeln funktioniert f\u00fcr gleichgrosse Matrizen. Kommutativ-Gesetz: \\(A+B=B+A\\) (Geht NICHT bei Multiplikation) Assoziativ-Gesetzt: \\(A+(B+C)=(A+B)+C\\) Distributiv-Gesetzt: \\(\\lambda\\cdot(A+B)=\\lambda\\cdot A + \\lambda \\cdot B\\) Aber Achtung: \\(\\lambda\\cdot A + B\\cdot \\lambda\\) kann nicht ausgeklammert werden (In k\u00f6nnte einfach \\(\\lambda \\cdot A\\) und \\(B\\cdot \\lambda\\) ausgerechnet werden) Distributiv-Gesetzt mit Transportierten Matrizen: \\((A\\cdot B)^T=B^T \\cdot A^T\\) (Beachte die Reihenfolge von A und B) \\((A+B)^T=A^T+B^T=B^T+A^T\\) \\((A-B)^T=A^T-B^T=B^T-A^T\\)","title":"Matrix"},{"location":"22FS/LA/summary.html#transponierte-matrix","text":"\\[ B= \\begin{bmatrix} 1 & 2 & 3\\\\ 3 & 4 & 5 \\end{bmatrix}\\\\ B^T= \\begin{bmatrix} 1 & 3 \\\\ 2 & 4\\\\ 3 & 5 \\end{bmatrix} \\] Es gilt folgendes Gesetzt: \\((A\\cdot B)^T=B^T\\cdot A^T\\) (Bemerke, dass sich die Reihenfolge von \\(A\\) und \\(B\\) sich \u00e4ndert)","title":"Transponierte Matrix"},{"location":"22FS/LA/summary.html#inverse-matrix","text":"Die inverse Matrix kann von einer Quadratischen-Matrix gebildet werden, bei welcher \\(\\det(A)\\neq 0\\) gilt $$ \\pmatrix{a & b\\ c & d}^{-1}=\\frac 1 {ad-bc}\\cdot \\pmatrix{d & -b \\ -c & a} $$ F\u00fcr gr\u00f6ssere Matrizen folgendes Gleichungssystem muss aufgel\u00f6st werden: $$ \\pmatrix{ a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} }^{-1} \\Rightarrow \\left(\\begin{array}{ccc|cr} a_{11} & a_{12} & a_{13} & 1 & 0 & 0\\ a_{21} & a_{22} & a_{23} & 0 & 1 & 0\\ a_{31} & a_{32} & a_{33} & 0 & 0 & 1 \\end{array}\\right ) $$","title":"Inverse Matrix"},{"location":"22FS/LA/summary.html#determinante","text":"Wenn die Determinanten einer gr\u00f6sseren Matrix als 3x3 Berechnet werden soll, kann ein Verfahren nach Laplace eingesetzt werden: Es wird eine feste Spalte oder Zeile gew\u00e4hlt Nun wird nach der folgenden Formel entwickelt: $$ \\text{Entwicklung nach i-ten Zeilen: }\\det(A)=\\sum^n_{j=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ \\text{Entwicklung nach j-ten Spalte: }\\det(A)=\\sum^n_{i=1} (-1)^{i+j}\\cdot a_{ij}\\cdot\\det(A_{ij})\\ $$ Dabei ist \\(a_{ij}\\) , das Element an \\(i\\) -ter Zeile und \\(j\\) -ter Spalte und \\(A_{ij}\\) die Matrix, bei welcher die \\(i\\) -te Zeile und \\(j\\) -Spalte weggelassen wurden Der Determinante einer 2x2-Matrix, ist der Fl\u00e4cheninhalt des Parallelogrammes, wenn die Spalten als Vektoren aufgefasst werden. Der Determinante einer 3x3-Matrix ist der Volumeninhalt des Spates, von den Spalten der Matrix aufgespannt wird. Eigenschaften: Einheitsmatrix haben den Determinanten \\(1\\) F\u00fcr nxn Matrix gilt: \\(\\det(A\\cdot B)=\\det(A)\\cdot \\det(B)\\) F\u00fcr invertierbare Matrix gilt: \\(\\det(A^{-1})=\\frac 1 {\\det(A)}\\) F\u00fcr \\(A^T\\) gilt: \\(\\det(A^T)=\\det(A)\\) Wenn: \\(\\det(A)\\neq 0\\) \\(\\Leftrightarrow\\) Die Spalten und Zeilen sind linear unabh\u00e4ngig \\(\\Leftrightarrow \\rg(A)=n=m\\) \\(\\Leftrightarrow A\\) ist invertierbar \\(\\Leftrightarrow\\) Das LGS \\(A\\cdot \\vec x = \\vec c\\) hat eine eindeutige L\u00f6sung $\\Leftrightarrow $ Die Vektoren in \\(A\\) sind eine Basis","title":"Determinante"},{"location":"22FS/LA/summary.html#vektorraume","text":"\\[ +:V \\times V \\rightarrow V\\\\ \\cdot : \\R \\times V \\rightarrow V \\] Dabei m\u00fcssen folgende Gesetze existieren: Kommutativgesetz: \\(a + b = b + a\\) Assoziativgesetzt: \\(a + (b + c)=(a + b) + c\\) Es gibt ein neutrales Element \\(\\vec 0\\) , f\u00fcr welches gilt \\(a + 0v = \\vec a\\) und \\(0v \\in V\\) F\u00fcr jedes Element \\(a \\in V\\) muss es ein inverses Element \\(-a \\in V\\) geben, so dass \\(a + (-a) = 0v\\) ergibt. Assoziativgesetzt: \\(\\lambda \\cdot (\\mu \\cdot a) = (\\lambda \\cdot \\mu) \\cdot a\\) Distributivgesetzt: \\(\\lambda \\cdot(a + b) = \\lambda \\cdot a + \\lambda \\cdot b\\) Distirbutgesetzt: \\((\\lambda + \\mu)\\cdot a = \\lambda \\cdot a + \\mu \\cdot a\\) F\u00fcr jedes Element \\(a \\in V\\) gibt es ein neutrales Element \\(1\\cdot a = a\\) , Allgemein bekannte Vektorr\u00e4ume: \\(\\R^n\\) - Vektorraum von allen Vekotren mit \\(n\\) reellen Komponente $ \\R^{m\\times n}$ - Vektorraum von allen reelen \\(m\\times n\\) -Matrizen \\(\\mathbb P_n[x]\\) - Vektorraum der Polynome von Grad \\(\\le n\\)","title":"Vektorr\u00e4ume"},{"location":"22FS/LA/summary.html#unterraume","text":"F\u00fcr beliebige Element \\(a, b \\in U\\) ist auch \\(a+b\\in U\\) F\u00fcr jeden Skalar \\(\\lambda \\in \\R\\) und jedes Element \\(a\\in U\\) ist auch \\(\\lambda \\cdot a\\in U\\) (Die neutralen Elemente der Addition und Skalarmultiplikation m\u00fcssen ebenfalls in \\(U\\) sein.)","title":"Unterr\u00e4ume"},{"location":"22FS/LA/summary.html#linearer-spann","text":"\\[ \\span(\\vec a_1, \\vec a_2 , ..., \\vec a_n)=\\lambda_1\\cdot \\vec a_n1 + \\lambda_2\\cdot \\vec a_2 + ... + \\lambda_n \\cdot \\vec a_n \\] Jenachdem, wie viele linear unabh\u00e4ngige Vektoren gegeben sind, wird ein anderes geometrisches Objekt gebildet: Bei 1 Vektor, wird eine Ursprungs-Gerade gebildet Bei 2 Vektoren, wird eine Ursprungs-Ebene Bei 3 Vektoren, wird ein \"Ursprungs-K\u00f6rper\" gebildet","title":"Linearer Spann"},{"location":"22FS/LA/summary.html#erzeugendensystem","text":"Eine Menge von Vektoren \\(\\{\\vec b_1, \\vec b_2, ..., \\vec b_N\\}\\) , falls die Vektoren nicht komplanar und kolinear zueinander sind, bilden ein Erzeugendensystem von \\(V\\) : \\(V=\\span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\) Ein Erzeugendensystem hat folgende eigenschaften: $$ \\begin{align} & V=span(\\vec b_1, \\vec b_2, ..., \\vec b_n)\\ \\Leftrightarrow \\text{ } & B\\cdot \\vec x = \\vec a \\text { f\u00fcr jedes } \\vec a \\in \\R^m\\ \\Leftrightarrow \\text{ } & rg(B)=m = \\text{Anzahl Zeilen} \\end{align} $$","title":"Erzeugendensystem"},{"location":"22FS/LA/summary.html#basis","text":"Eine Basis ist eine Menge von Vektoren, welche ein Erzeugendensystem sind linear unabh\u00e4ngig sind (Auf Deutsch: Es darf nur eine M\u00f6glichkeit geben, jeden Vektor zu Bilden) Es kann auch \u00fcberpr\u00fcft werden, ob \\(\\det(A)\\neq 0\\) ist (siehe Determinante) Wichtige Basen: F\u00fcr \\(\\R^n\\) : \\(\\mathcal S=\\{\\vec e_1, \\vec e_2, ..., \\vec e_n\\}\\) - Standardbasis F\u00fcr \\(\\mathbb P_n[x]\\) \\(\\mathcal M=\\{1, x, x^2, ..., x^n\\}\\) - Monombasis","title":"Basis"},{"location":"22FS/LA/summary.html#dimension","text":"Die Anzahl Vektoren in der Basis eines Vektorraumes: \\(\\dim(V)\\) Die Dimension von \\(\\{\\vec 0\\}\\) ist \\(0\\)","title":"Dimension"},{"location":"22FS/LA/summary.html#lineare-abbildung","text":"Eine Lineare Abbildung ist eine Funktion \\(f: V \\to W\\) , welche folgende zwei Regeln einh\u00e4lt: $$ f(x+y)=f(x)+f(y)\\ f(\\lambda \\cdot x)=\\lambda \\cdot f(x) $$ Eine lineare Abbildung kann auch als Matrix geschrieben werden. Um dies zu erreichen, gibt es zwei m\u00f6glichkeiten: Die Einheitsvektoren in \\(f(x)\\) einsetzen und aus den Resultaten eine Matrix bauen Zeile f\u00fcr Zeile durchgehen und die Matrixzeilen davon ableiten $$ A\\cdot\\pmatrix{x \\ y \\ z} = \\pmatrix{x\\ z - y \\ y - x \\ 2x - y} \\Rightarrow A = \\pmatrix{1 & 0 & 0 \\ 0 & -1 & 1 \\ -1 & 1 & 0 \\ 2 & -1 & 0} $$","title":"Lineare Abbildung"},{"location":"22FS/LA/summary.html#basis-wechselnde-abbildung","text":"\\(_CA_B\\) beschreibt die Lineare Abbildung \\(f: V_B \\to W_C\\) (Achtung Reihenfolge) und wird wie folgt gebraucht: \\(_CA_B\\cdot \\vec x_B=f(\\vec x)\\) . Es kann wie folgt gebildet werden: Die Matrix \\((_CA_B)^{-1}={}_BA_C\\)","title":"Basis-wechselnde Abbildung"},{"location":"22FS/LA/summary.html#abbildung-in-der-ebene","text":"","title":"Abbildung in der Ebene"},{"location":"22FS/LA/summary.html#orthogonale-projektion-auf-eine-allgemeine-gerade-durch-den-ursprung","text":"Wenn auf eine Gerade projektiert werden soll, welche nicht die x-, y- oder z-Achse ist, muss folgende Formel verwendet werden. Dabei wird erwartet, dass die Gerade in der Kordinatendarstelung ( \\(ax + by = 0\\) ) normiert ist ( \\(a^2 + b^2 = 1\\) ). $$ P= \\begin{pmatrix} 1 - a^2 & -ab\\ -ab & 1-b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$","title":"Orthogonale Projektion auf eine allgemeine Gerade durch den Ursprung"},{"location":"22FS/LA/summary.html#spiegelung-an-einer-allgemeinen-gerade-durch-den-ursprung","text":"Wenn alle Vektoren bei einer Gerade, welche durch den Ursprung geht, gespiegelt werden soll, kann folgende Formel ben\u00fctzt werden. Dabei muss aber die Gerade in der Koordinatendarstellung ( \\(ax + by=0\\) ) normiert ist ( \\(a^2+b^2 = 1\\) ). $$ S= \\begin{pmatrix} 1 - 2a^2 & -2ab\\ -2ab & 1 - 2b^2 \\end{pmatrix}\\ \\text{Wobei gilt: }\\ ax + by = 0\\ a^2+ b^2 = 1 $$","title":"Spiegelung an einer allgemeinen Gerade durch den Ursprung"},{"location":"22FS/LA/summary.html#abbildung-im-raum","text":"","title":"Abbildung im Raum"},{"location":"22FS/LA/summary.html#kern-und-bild","text":"\\[ \\ker(A)=\\{\\vec x \\in V \\vert A\\cdot \\vec x = \\vec 0\\}\\\\ \\im(A)=\\span(\\vec a_1, \\vec a_2, ..., \\vec a_n)=\\{\\lambda_1 \\vec a_1 + \\lambda_2 \\vec a_2 + ... + \\lambda_n\\vec a_n \\vert \\lambda_k \\in \\R\\} \\] Der Kern \\(\\ker(A)\\) besteht aus alle Vektoren \\(\\vec x\\) , welche die Gleichung \\(A\\cdot \\vec x=\\vec 0\\) erf\u00fcllen Das Bild \\(\\im(A)\\) ist der Spalten der Vektoren von \\(A\\) Zus\u00e4tzlich gilt f\u00fcr \\(\\im(A)\\) und \\(\\ker(A)\\) : $$ \\dim(\\ker(A)) + \\dim(\\im(A)) = \\dim(A)\\ \\dim(\\im(A)) = \\rg(A) $$ Um die Dimensionen zu bestimmen gibt es mehrere M\u00f6glichkeiten: Mit der Zeilenstuffenform von \\(A\\) den Rang ablesen. Von diesem kann die Dimension von \\(\\im(A)\\) abgelesen werden und dank des Satzes von oben auch \\(\\dim(\\ker(A))\\) bestimmen Da die Menge, welche von \\(\\ker(A)\\) zur\u00fcck gegeben werden, auch ein Unterraum ist, kann eine Basis mit \\(A\\) erstellt werden. Es m\u00fcssen alle Vektoren \\(a_i\\) gefunden werden, welche linear Unabh\u00e4ngig sind","title":"Kern und Bild"},{"location":"22FS/LA/summary.html#verknupfung-von-abbildungen","text":"\\[ g: V \\to W \\mapsto g(\\vec x)=A \\cdot \\vec x\\\\ f: U \\to W \\mapsto f(\\vec x)=B \\cdot \\vec x \\\\ g(f(\\vec x)) = (g \\circ f)(\\vec x)=B \\cdot A \\cdot \\vec x \\]","title":"Verkn\u00fcpfung von Abbildungen"},{"location":"22FS/LA/summary.html#rest-klassen","text":"In der Restklasse \\([x]_n\\) sind alle Zahlen \\(a\\) , welche durch \\(n\\) geteilt den Rest \\(x\\) ergeben Formel Erkl\u00e4rung \\(\\Z/n=\\{[z]_n\\|z\\in \\Z\\}\\) Die Menge aller Restklasse \\(\\Z^*_{/n}\\) Das Primes Restklassenssytem, welches nur die Restklassen enth\u00e4lt, welche zu n teilerfremd sind. Alle Restklassen in diesem System k\u00f6nnen multipliziert werden (Siehe Prime Restklassen ) \\([z]_n=\\overline{z}\\) Die Restklasse, bzw. \u00c4quivalenzklasse mit dem Teiler n und dem Vertreter \\(z\\)","title":"Rest Klassen"},{"location":"22FS/LA/summary.html#prime-restklassen","text":"Prime Restklassen sind die Restklassen, welche ein Inverseselement f\u00fcr die Multiplikation besitzen. Dies wird mit einem Stern geschrieben, wie hier zu sehen: \\(\\Z_{/7}^{*}\\) . Beispiel: \\(\\Z^*_{/7}=\\{[1], [2], [3], [4], [5], [6]\\}\\) \\(\\Z^*_{/6}=\\{[1], [5]\\}\\)","title":"Prime Restklassen"},{"location":"22FS/LA/summary.html#modulare-arithmethik","text":"f\u00fcr Multiplikation: neutrales Element: \\([1]_n\\) inverses Element: Nur Zahlen, welche teilefrmed sind ( \\(ggT(Zahl, N)=1\\) ) Eine Zahl multipliziert mt ihrem inversen Element gibt \\(1\\) Kann mit dem Erweiterten Euklidischen Algorithmus berechnet werden: \\(Zahlenbereich \\cdot x + Zahl \\cdot y=1\\) \\(\\Rightarrow y\\) ist das multiplikative Inverse. (Zahl muss kleiner sein als Zahlenbereich, sonst muss gewechselt werden)","title":"Modulare Arithmethik"},{"location":"22FS/PM2/Massnahmen.html","text":"Massnahmen Zu begin haben Manuel und ich vermehrt unser Fachwissen eingebracht Dies hat sich \u00fcber PM1 ge\u00e4ndert. Tanija und Jonas konnten sich immer mehr einbringen Wir haten keinen Team-Leader Jemand, welcher den Progress des Projekts \u00fcberwacht, w\u00e4re sinvoll Wissensl\u00fccken haben versucht bei Design-Meetings zu stopfen Designs-Meetings beibehalten W\u00f6chtentliche Stand-Ups, um so den Fortschritt zu beobachten. Jemand soll \"T\u00e4tsch-Meister\" sein Tickets mit Abh\u00e4ngikeites versehen; ev. sogar Gantt Diagram erstellen Projekt-Idee: Markdown-Editor mit Share-Features","title":"Massnahmen"},{"location":"22FS/PM2/Massnahmen.html#massnahmen","text":"Zu begin haben Manuel und ich vermehrt unser Fachwissen eingebracht Dies hat sich \u00fcber PM1 ge\u00e4ndert. Tanija und Jonas konnten sich immer mehr einbringen Wir haten keinen Team-Leader Jemand, welcher den Progress des Projekts \u00fcberwacht, w\u00e4re sinvoll Wissensl\u00fccken haben versucht bei Design-Meetings zu stopfen Designs-Meetings beibehalten W\u00f6chtentliche Stand-Ups, um so den Fortschritt zu beobachten. Jemand soll \"T\u00e4tsch-Meister\" sein Tickets mit Abh\u00e4ngikeites versehen; ev. sogar Gantt Diagram erstellen Projekt-Idee: Markdown-Editor mit Share-Features","title":"Massnahmen"},{"location":"22FS/PM2/Pitch.html","text":"Pitch Hallo, Wir sind CodeBrewery. Ich darf vorstellen: Michael Ziegler, unser Wirtschaftsinformatiker. Er bringt Know-How \u00fcber die Budgetierung und das Finanzwesen. Ebenfalls Jonas Costa, welcher dank seiner Mediamatiker ausbildung Grafiken und Designs anfertigen kann. Manuel Thalman und Ich, Sebastian Zumbrunn haben beide einen Informatiker Hintergrund und bringen Technisches Know-How zu unserem Team. Zu viert hatten wir die Idee, ein virtuelles Haustier zu entwickeln. Dies wird Sie Tags \u00fcbers Bespassen und kann, dank einer App, Ihnen sogar auf einen Sparziergang Gesellschaft leisten. Daf\u00fcr brauchen wir aber Ihre Unterst\u00fctzung, um dies zu verwirklichen. Manuel Thalman wird Ihnen nun mehr \u00fcber unsere Idee erz\u00e4hlen. Bitte Manuel... Unser n\u00e4chstes Ziel ist ein ersten Prototyp zu entwickeln. ~~Dieser soll unsere Vision greifbarer machen.~~ Es wird bereits m\u00f6glich sein, ein Tomodachi auf seinen Desktop zu zaubern und damit zu interagieren. Ebenfalls wird es ab und zu von selbst Aktionen ausf\u00fchren, ~~wie z.B. ein Power-Nap einzulegen, um danach mit voller Energie Sie zu belustigen.~~ Um Ihnen dabei nicht in den Weg zu kommen, wird es m\u00f6glich sein, das Tomodachi mit dem Mauszeiger per Drag'n'drop zu verschieben. Auch werden wir ein Zuhause f\u00fcr das Tomodachi entwickeln, in welches es sich zur\u00fcck ziehen kann. Falls Sie Interesse an Ikitomo haben, w\u00e4ren wir froh, um Ihre Expertise, finanzielle Unterst\u00fcrzung und Ihr Netzwerk. Danke f\u00fcr Ihre Aufmerksamkeit... Unser n\u00e4chstes Ziel ist es ein ersten Prototyp zu entwickeln. In diesem soll Tomodachi auf dem Desktop herum laufen und es soll m\u00f6glich sein, damit zu interagieren. Per Drag'n'Drop muss es verschiebbar sein und von selbst, soll es ab und zu selbst Aktionen ausf\u00fchren. Auch soll es ein ein Zuhause f\u00fcr das Tomodachi geben, in welches es sich zur\u00fcck ziehen kann. Things to look out for handover sign posting (einerseit - anderseit. 1. 2. 3. ,...) handover expliziter gestalten (was das n\u00e4chste thema ist) F\u00fcr mich, zu Beginn das Thema bereits sagen Wir sind, die, welche programmieren Konkurenz erw\u00e4hnen","title":"Pitch"},{"location":"22FS/PM2/Pitch.html#pitch","text":"Hallo, Wir sind CodeBrewery. Ich darf vorstellen: Michael Ziegler, unser Wirtschaftsinformatiker. Er bringt Know-How \u00fcber die Budgetierung und das Finanzwesen. Ebenfalls Jonas Costa, welcher dank seiner Mediamatiker ausbildung Grafiken und Designs anfertigen kann. Manuel Thalman und Ich, Sebastian Zumbrunn haben beide einen Informatiker Hintergrund und bringen Technisches Know-How zu unserem Team. Zu viert hatten wir die Idee, ein virtuelles Haustier zu entwickeln. Dies wird Sie Tags \u00fcbers Bespassen und kann, dank einer App, Ihnen sogar auf einen Sparziergang Gesellschaft leisten. Daf\u00fcr brauchen wir aber Ihre Unterst\u00fctzung, um dies zu verwirklichen. Manuel Thalman wird Ihnen nun mehr \u00fcber unsere Idee erz\u00e4hlen. Bitte Manuel... Unser n\u00e4chstes Ziel ist ein ersten Prototyp zu entwickeln. ~~Dieser soll unsere Vision greifbarer machen.~~ Es wird bereits m\u00f6glich sein, ein Tomodachi auf seinen Desktop zu zaubern und damit zu interagieren. Ebenfalls wird es ab und zu von selbst Aktionen ausf\u00fchren, ~~wie z.B. ein Power-Nap einzulegen, um danach mit voller Energie Sie zu belustigen.~~ Um Ihnen dabei nicht in den Weg zu kommen, wird es m\u00f6glich sein, das Tomodachi mit dem Mauszeiger per Drag'n'drop zu verschieben. Auch werden wir ein Zuhause f\u00fcr das Tomodachi entwickeln, in welches es sich zur\u00fcck ziehen kann. Falls Sie Interesse an Ikitomo haben, w\u00e4ren wir froh, um Ihre Expertise, finanzielle Unterst\u00fcrzung und Ihr Netzwerk. Danke f\u00fcr Ihre Aufmerksamkeit... Unser n\u00e4chstes Ziel ist es ein ersten Prototyp zu entwickeln. In diesem soll Tomodachi auf dem Desktop herum laufen und es soll m\u00f6glich sein, damit zu interagieren. Per Drag'n'Drop muss es verschiebbar sein und von selbst, soll es ab und zu selbst Aktionen ausf\u00fchren. Auch soll es ein ein Zuhause f\u00fcr das Tomodachi geben, in welches es sich zur\u00fcck ziehen kann.","title":"Pitch"},{"location":"22FS/PM2/Pitch.html#things-to-look-out-for","text":"handover sign posting (einerseit - anderseit. 1. 2. 3. ,...) handover expliziter gestalten (was das n\u00e4chste thema ist) F\u00fcr mich, zu Beginn das Thema bereits sagen Wir sind, die, welche programmieren Konkurenz erw\u00e4hnen","title":"Things to look out for"},{"location":"22FS/PM2/Projektskizze.html","text":"Projektskizze Ideen UML Modelierungs app (zu gross) latex text editor (zu gross) markdown editor Care Taker App / Eat.ch f\u00fcr Lebensmittel? Gantt Vorratsschrank Verwaltung Buchhaltsungs App Hex-Editor (mit Pattern Matching) Sound Board Funny Voice Filter Program Desktop Pet","title":"Projektskizze"},{"location":"22FS/PM2/Projektskizze.html#projektskizze","text":"","title":"Projektskizze"},{"location":"22FS/PM2/Projektskizze.html#ideen","text":"UML Modelierungs app (zu gross) latex text editor (zu gross) markdown editor Care Taker App / Eat.ch f\u00fcr Lebensmittel? Gantt Vorratsschrank Verwaltung Buchhaltsungs App Hex-Editor (mit Pattern Matching) Sound Board Funny Voice Filter Program Desktop Pet","title":"Ideen"},{"location":"22FS/PROG2/-1_Stuff.html","text":"Stuff Javadoc (L1) Beschreiben Sie in Javadoc den Zweck der von Ihnen erstellten Klassen und Interfaces. Dokumentieren Sie ausserdem Methoden in Interfaces, abstrakte Methoden sowie \u00f6ffentliche Methoden von Klassen, die die Rolle von internen Schnittstellen einnehmen wie zum Beispiel Data Access Objects. F\u00fcr Methoden ist es wichtig, dass der Javadoc-Kommentar den Vertrag zwischen Methode und anwendendem Code beschreibt: Es ist erkl\u00e4rt, was die Methode macht. Es sind s\u00e4mtliche Vorbedingungen aufgelistet (z.B., dass Argument nicht null sein darf). Es sind s\u00e4mtliche Nachbedingungen aufgelistet (z.B., dass retournierte Collection nie null sein kann). Es ist jede Exception aufgelistet, die auftreten kann und in welcher Situation das passiert. Jeder Parameter ist beschrieben. Sofern sinnvoll ist der R\u00fcckgabewert beschrieben. F\u00fcr abstrakte Methoden ist ausserdem wichtig, dass Sie beschreiben, welche Erwartungen an eine Implementierung gestellt werden. Gute Commits (L2) Tim Pope hat 2008 auf seinem Blog beschrieben, was eine gute Commit-Nachricht f\u00fcr Git ausmacht. Und hat dazu diese Modell-Nachricht verfasst: Capitalized, short (50 chars or less) summary More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of an email and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); tools like rebase can get confused if you run the two together. Write your commit message in the imperative: \"Fix bug\" and not \"Fixed bug\" or \"Fixes bug.\" This convention matches up with commit messages generated by commands like git merge and git revert. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, followed by a single space, with blank lines in between, but conventions vary here - Use a hanging indent \u2014 Tim Pope A Note About Git Commit Messages Folgen Sie seinem Rat, und Ihre History wird gleichzeitig informativ und einfach zu verfolgen sein:","title":"Stuff"},{"location":"22FS/PROG2/-1_Stuff.html#stuff","text":"","title":"Stuff"},{"location":"22FS/PROG2/-1_Stuff.html#javadoc-l1","text":"Beschreiben Sie in Javadoc den Zweck der von Ihnen erstellten Klassen und Interfaces. Dokumentieren Sie ausserdem Methoden in Interfaces, abstrakte Methoden sowie \u00f6ffentliche Methoden von Klassen, die die Rolle von internen Schnittstellen einnehmen wie zum Beispiel Data Access Objects. F\u00fcr Methoden ist es wichtig, dass der Javadoc-Kommentar den Vertrag zwischen Methode und anwendendem Code beschreibt: Es ist erkl\u00e4rt, was die Methode macht. Es sind s\u00e4mtliche Vorbedingungen aufgelistet (z.B., dass Argument nicht null sein darf). Es sind s\u00e4mtliche Nachbedingungen aufgelistet (z.B., dass retournierte Collection nie null sein kann). Es ist jede Exception aufgelistet, die auftreten kann und in welcher Situation das passiert. Jeder Parameter ist beschrieben. Sofern sinnvoll ist der R\u00fcckgabewert beschrieben. F\u00fcr abstrakte Methoden ist ausserdem wichtig, dass Sie beschreiben, welche Erwartungen an eine Implementierung gestellt werden.","title":"Javadoc (L1)"},{"location":"22FS/PROG2/-1_Stuff.html#gute-commits-l2","text":"Tim Pope hat 2008 auf seinem Blog beschrieben, was eine gute Commit-Nachricht f\u00fcr Git ausmacht. Und hat dazu diese Modell-Nachricht verfasst: Capitalized, short (50 chars or less) summary More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of an email and the rest of the text as the body. The blank line separating the summary from the body is critical (unless you omit the body entirely); tools like rebase can get confused if you run the two together. Write your commit message in the imperative: \"Fix bug\" and not \"Fixed bug\" or \"Fixes bug.\" This convention matches up with commit messages generated by commands like git merge and git revert. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, followed by a single space, with blank lines in between, but conventions vary here - Use a hanging indent \u2014 Tim Pope A Note About Git Commit Messages Folgen Sie seinem Rat, und Ihre History wird gleichzeitig informativ und einfach zu verfolgen sein:","title":"Gute Commits (L2)"},{"location":"22FS/PROG2/00_Gradle.html","text":"Gradle Dependencies Command Explanation implementation 'group:artifactId:version' Dependenciy is needed to compile and run the project testImplementation 'group:artifactId:version' Dependency is only needed to compile and run tests testRuntimeOnly 'group:artifactId:version' Dependency is only needed durring the runtime of tests","title":"Gradle"},{"location":"22FS/PROG2/00_Gradle.html#gradle","text":"","title":"Gradle"},{"location":"22FS/PROG2/00_Gradle.html#dependencies","text":"Command Explanation implementation 'group:artifactId:version' Dependenciy is needed to compile and run the project testImplementation 'group:artifactId:version' Dependency is only needed to compile and run tests testRuntimeOnly 'group:artifactId:version' Dependency is only needed durring the runtime of tests","title":"Dependencies"},{"location":"22FS/PROG2/01_Concurrency.html","text":"Concurrency Types of Concurrencies There are multiple types of concurrencies: True concurrency On a computer with more multiple cores, each core can run a flow independently Interleaving concurrency Each flow gets a slice of time. After that time the flow will be paused and the core will work on another flow. The scheduler controls which core works on which flow Strategies for Interlaving Concurrency Non-Preemptive (cooperative) The process releases the core voluntarily Tyes: FCFS(First comes, first served), SNP(shortest process next). This was how it was in the olden days Preemtive A scheduler can interrupt a process Program vs Process vs Thread A program is a sequence of instructions and can consists of multiple processes. A process executes a program or part of it and can consists of multiple threads. Each process has its own memory, uses IPC (Inter-Process-Communication) to communicate to other processes and switching between processes is expensive. A thread is part of a process and runs one flow. It shares its memory with the other threads in the same process and switching between thread is cheap. Java-Concurrency Thread Thread.sleep() doesn't gurantee that sleep doesn't wake up early or late Object.yield() will advice the scheduler to release the thread, but there is guarantee that the thread will be suspened With Thread.currentThread one can get the thread which runs the current thread Thread.stop() , Thread.suspend() and Thread.resume() are depricated and potentialy unsafe Lifecycle of a Thread A Thread is considered \"alive\" and Thread.isAlive() will return true, when the Thread is either ready, running oder suspended (the blocks with the dotted outline). This means that run needs to start running before the Thread is alive. Executor Framework verify(behaviorModel, never()).setPosition(any());Executor Service An Executor just promises to execute a given task. An ExecutorService extends Executor to allow to shutdown the Executor and to track the progress and the state of a task. The shutdownNow() method uses Thread.interrupt() under the hood and is thus not deprecated. The ScheduledExecutorService extends the ExecutorService to allow a task to be scheduled. The method signitures of the new methods are: schedule(Runnable task, long delay, TimeUnit unit) , scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit) scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit) Thread Pools A thread pool uses multiple threads which are reused for multiple tasks. Thread pools usually use a queue to hold the tasks to be executed. A special kind of thread pool is a Blocking Queue , which when it's full, will reject newly submitted tasks. Most Executor Services use thread pools underneath. Different Executors Executor Name Description Executors.newSingleThreadExecutor() Creates an Executor which only uses one thread Executors.newFixedThreadPool(int numOfThreads) Creates an Executor which has the given number of threads. Those thread will be reused Executors.newCachedThreadPool() Creates new threads as needed. It will retain Threads for an amount of time (approx. up to 60s) and will stop it after. Executors.newScheduledThreadPoool(int numOfThreads) Creates a new scheduled thread pool with the given number of threads. Executors.newSingleThreadExecutor() Creates a new scheduled executor with a single thread","title":"Concurrency"},{"location":"22FS/PROG2/01_Concurrency.html#concurrency","text":"","title":"Concurrency"},{"location":"22FS/PROG2/01_Concurrency.html#types-of-concurrencies","text":"There are multiple types of concurrencies: True concurrency On a computer with more multiple cores, each core can run a flow independently Interleaving concurrency Each flow gets a slice of time. After that time the flow will be paused and the core will work on another flow. The scheduler controls which core works on which flow","title":"Types of Concurrencies"},{"location":"22FS/PROG2/01_Concurrency.html#strategies-for-interlaving-concurrency","text":"Non-Preemptive (cooperative) The process releases the core voluntarily Tyes: FCFS(First comes, first served), SNP(shortest process next). This was how it was in the olden days Preemtive A scheduler can interrupt a process","title":"Strategies for Interlaving Concurrency"},{"location":"22FS/PROG2/01_Concurrency.html#program-vs-process-vs-thread","text":"A program is a sequence of instructions and can consists of multiple processes. A process executes a program or part of it and can consists of multiple threads. Each process has its own memory, uses IPC (Inter-Process-Communication) to communicate to other processes and switching between processes is expensive. A thread is part of a process and runs one flow. It shares its memory with the other threads in the same process and switching between thread is cheap.","title":"Program vs Process vs Thread"},{"location":"22FS/PROG2/01_Concurrency.html#java-concurrency","text":"","title":"Java-Concurrency"},{"location":"22FS/PROG2/01_Concurrency.html#thread","text":"Thread.sleep() doesn't gurantee that sleep doesn't wake up early or late Object.yield() will advice the scheduler to release the thread, but there is guarantee that the thread will be suspened With Thread.currentThread one can get the thread which runs the current thread Thread.stop() , Thread.suspend() and Thread.resume() are depricated and potentialy unsafe","title":"Thread"},{"location":"22FS/PROG2/01_Concurrency.html#lifecycle-of-a-thread","text":"A Thread is considered \"alive\" and Thread.isAlive() will return true, when the Thread is either ready, running oder suspended (the blocks with the dotted outline). This means that run needs to start running before the Thread is alive.","title":"Lifecycle of a Thread"},{"location":"22FS/PROG2/01_Concurrency.html#executor-framework","text":"","title":"Executor Framework"},{"location":"22FS/PROG2/01_Concurrency.html#verifybehaviormodel-neversetpositionanyexecutor-service","text":"An Executor just promises to execute a given task. An ExecutorService extends Executor to allow to shutdown the Executor and to track the progress and the state of a task. The shutdownNow() method uses Thread.interrupt() under the hood and is thus not deprecated. The ScheduledExecutorService extends the ExecutorService to allow a task to be scheduled. The method signitures of the new methods are: schedule(Runnable task, long delay, TimeUnit unit) , scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit) scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)","title":"verify(behaviorModel, never()).setPosition(any());Executor Service"},{"location":"22FS/PROG2/01_Concurrency.html#thread-pools","text":"A thread pool uses multiple threads which are reused for multiple tasks. Thread pools usually use a queue to hold the tasks to be executed. A special kind of thread pool is a Blocking Queue , which when it's full, will reject newly submitted tasks. Most Executor Services use thread pools underneath.","title":"Thread Pools"},{"location":"22FS/PROG2/01_Concurrency.html#different-executors","text":"Executor Name Description Executors.newSingleThreadExecutor() Creates an Executor which only uses one thread Executors.newFixedThreadPool(int numOfThreads) Creates an Executor which has the given number of threads. Those thread will be reused Executors.newCachedThreadPool() Creates new threads as needed. It will retain Threads for an amount of time (approx. up to 60s) and will stop it after. Executors.newScheduledThreadPoool(int numOfThreads) Creates a new scheduled thread pool with the given number of threads. Executors.newSingleThreadExecutor() Creates a new scheduled executor with a single thread","title":"Different Executors"},{"location":"22FS/PROG2/summary.html","tags":["summary","PROG2"],"text":"PROG2 Summary Gradle Concurrency Types of Concurrencies There are multiple types of concurrencies: True concurrency On a computer with more multiple cores, each core can run a flow independently Interleaving concurrency Each flow gets a slice of time. After that time the flow will be paused and the core will work on another flow. The scheduler controls which core works on which flow Strategies for Interlaving Concurrency Non-Preemptive (cooperative) The process releases the core voluntarily Tyes: FCFS(First comes, first served), SNP(shortest process next). This was how it was in the olden days Preemtive A scheduler can interrupt a process Program vs Process vs Thread A program is a sequence of instructions and can consists of multiple processes. A process executes a program or part of it and can consists of multiple threads. Each process has its own memory, uses IPC (Inter-Process-Communication) to communicate to other processes and switching between processes is expensive. A thread is part of a process and runs one flow. It shares its memory with the other threads in the same process and switching between thread is cheap. Java-Concurrency Thread Thread.sleep() doesn't gurantee that sleep doesn't wake up early or late Object.yield() will advice the scheduler to release the thread, but there is guarantee that the thread will be suspened With Thread.currentThread() one can get the thread which runs the current thread Thread.stop() , Thread.suspend() and Thread.resume() are depricated and potentialy unsafe public static void main ( String [] args ) { System . out . println ( \"START: main\" ); Thread java = new JoinThread ( \"Java\" ); Thread fiji = new JoinThread ( \"Fiji\" ); java . start (); fiji . start (); System . out . println ( \"Wait for theads..\" ); try { java . join (); // blocks until java ends fiji . join (); // blocks until fiji ends } catch ( InterruptedException e ) { System . out . println ( \"Interrupted\" ); } System . out . println ( \"DONE main\" ); } Lifecycle of a Thread A Thread is considered \"alive\" and Thread.isAlive() will return true, when the Thread is either ready, running oder suspended (the blocks with the dotted outline). This means that run needs to start running before the Thread is alive. Executor Framework // Example of a Sheduled Executor public static void main ( String [] args ) { ScheduledExecutorService scheduledExecutor = Executors . newScheduledThreadPool ( 2 ); scheduledExecutor . execute ( new ScheduledTask ( 0 , System . currentTimeMillis ())); Future <?> future = scheduledExecutor . submit ( new ScheduledTask ( 0 , System . currentTimeMillis ())); scheduledExecutor . schedule ( new ScheduledTask ( 1 , System . currentTimeMillis ()), 4 , TimeUnit . SECONDS ); scheduledExecutor . scheduleAtFixedRate ( new ScheduledTask ( 2 , System . currentTimeMillis ()), 4 , 3 , TimeUnit . SECONDS ); scheduledExecutor . scheduleWithFixedDelay ( new ScheduledTask ( 3 , System . currentTimeMillis ()), 2 , 3 , TimeUnit . SECONDS ); try { TimeUnit . SECONDS . sleep ( 20 ); // waiting for 20s } catch ( InterruptedException e ) { } scheduledExecutor . shutdown (); } private static record ScheduledTask ( int id , long starttime ) implements Runnable { @Override public void run () { System . out . println ( \"Executing Task \" + id + \" at \" + ( System . currentTimeMillis () - starttime ) + \" ms after start \" + \" in Thread : \" + Thread . currentThread (). getName ()); } } Executor Service An Executor just promises to execute a given task. An ExecutorService extends Executor to allow to shutdown the Executor and to track the progress and the state of a task. The shutdownNow() method uses Thread.interrupt() under the hood and is thus not deprecated. The ScheduledExecutorService extends the ExecutorService to allow a task to be scheduled. The method signitures of the new methods are: schedule(Runnable task, long delay, TimeUnit unit) , scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit) scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit) Thread Pools A thread pool uses multiple threads which are reused for multiple tasks. Thread pools usually use a queue to hold the tasks to be executed. A special kind of thread pool is a Blocking Queue , which when it's full, will reject newly submitted tasks. Most Executor Services use thread pools underneath. Different Executors Executor Name Description Executors.newSingleThreadExecutor() Creates an Executor which only uses one thread Executors.newFixedThreadPool(int numOfThreads) Creates an Executor which has the given number of threads. Those thread will be reused Executors.newCachedThreadPool() Creates new threads as needed. It will retain Threads for an amount of time (approx. up to 60s) and will stop it after. Executors.newScheduledThreadPoool(int numOfThreads) Creates a new scheduled thread pool with the given number of threads. Executors.newSingleThreadExecutor() Creates a new scheduled executor with a single thread Callable and Futures public interface Callable < V > { V call () throws Exception ; } A Callable will return a result or an exception and can also be submitted to an ExecutorService and a Future<V> will be returned. public static void main ( String [] args ) throws InterruptedException , ExecutionException , TimeoutException { ExecutorService service = Executors . newSingleThreadExecutor (); Future < String > future = service . submit (() -> \"Hello world\" ); String result = future . get (); // waits until the future completes result = future . get ( 1 , TimeUnit . SECONDS ); // will throw TimeoutException after 1 second future . cancel ( < mayInterruptIfRunning > ); // will cancel the future future . isDone (); // returs if the future is done future . isCancelled (); // returns if the future was cancelled } Patterns Wait for all Tasks to finish List < Future <?>> futureList = executorService . invokeAll ( taskList ); for ( Future <?> future : futureList ) { future . get (); // wait for each future } Wait for the fastest task to finish String result = executorService . invokeAny ( taskList ); /* The result of the task which completed first, is returned */ Share Data between Multiple Threads Atomic Use the atomic data types, like AtomicBoolean , AtomicInteger , AtomicLong , AtomicReference , AtomicIntegerArray , AtomicLongArray or AtomicReferenceArray . private static class Account { private final int id ; private AtomicInteger balance ; public Account ( int id , int initialAmount ) { this . id = id ; this . balance = new AtomicInteger ( initialAmount ); } public int getId () { return id ; } public int getBalance () { return balance . get (); } public void setBalance ( int amount ) { this . balance . set ( amount ); } public void transferAmount ( int amount ) { this . balance . addAndGet ( amount ); } } Synchronized class Account { private int balance ; public synchronized void transferAmount1 ( int amount ) { this . balance += amaount ; } public void transferAmount2 ( int amount ) { synchronized ( this ) { this . balance += amaount ; } } public synchronized static staticLock1 () { //do stuff } public static staticLock1 () { synchronized ( Amount . class ) { // do stuff } } } Never call an other synchronized method which uses a different object. This can cause a dead lock. Monitor A Java object can be used as a locked. class FooBar { private Object monitor ; public void test () { synchronized ( monitor ) { // waits for the monitor to be called with monitor.notify() or monitor.notifyAll() monitor . wait (); } } } Object.wait() blocks until Object.notify() or Object.notifyAll() is invoked on the same monitor object. notify() only wakes up one waiting Thread while notifyAll() will wake up all waiting threads. wait() releases the monitor object . Types of Synchronization Mutual Exclusion Mutual Exclusion means that only only thread can access a shared resource at a time. This usually means, that a section of code needs to be locked (eg. with synchronize) until the thread is done with that code. Conditional Synchronization Conditional synchronization is needed when one thread waits for an event to happen in another thread. This is basicly the Producer-Consumer \"Pattern\". The order of events or operations is critical. Producer-Consumer The producer produces some data which can be consumed by the consumer. The consumer tries to access the resource. If it is already ready, then it can just continue. If not it will wait() for the producer to notify() its monitor after which it can access the resource. The producer thread might needs to throttle itself to avoid loosing results when no consumer can consume them. Here is an example for a consumer-producer example: The while loop is necessary because when the thread calls wait() it releases the monitor the synchronize block and an other thread can enter the synchronize block and call wait() . Synchronized Queue With a queue the problem of the consumer and producer can be abstracted into a separate class to make it less brittle. Implementing the following becomes trivial: The producer fills the queue with data The consumer retrieves the data from the queue if available The consumer waits only if the queue is empty The producer waits when the queue is full Locks and Conditions A Lock is like a monitor object but instead of using synchronize the methods lock() and unlock() are used (in a try-finally-block). Additionally Conditions can be created with Lock.newCondition() . A condition is connected to its lock and can only be interacted with when its lock is locked. A Condition has await() , signal() and signallAll() , which behaviour like Object.wait() , Object.notify() and Object.notifyAll() . The advantage of Conditions is, that each lock can have multiple conditions. With ReentrantLock.hasWaiters(Condition) can be checked, if a thread currently waits for a condition. public class ConditionalSyncQueue < E > { private Lock mutex = new ReentrantLock (); private Condition notEmpty = mutex . newCondition (); private Condition notFull = mutex . newCondition (); private LinkedList < E > queue = new LinkedList < E > (); private int capacity = 5 ; public void add ( E item ) throws InterruptedException { mutex . lock (); // enter critical section try { // condition 1: queue not full while ( queue . size () >= capacity ) { notFull . await (); } queue . addLast ( item ); notEmpty . signal (); } finally { mutex . unlock (); // exit critical section } } public E remove () throws InterruptedException { E item = null ; mutex . lock (); // enter critical section try { // condition 2: queue not empty while ( queue . empty ()) { notEmpty . await (); } item = queue . removeFirst (); notFull . signal (); } finally { mutex . unlock (); // exit critical section } return item ; } } ReadWriteLocks A ReadWriteLock is like a Lock but it provides 2 Lock instances: A write lock: When locked, neither locks are lockable anymore A read lock: When locked, the write lock won't be lockable The ReentrantReadWriteLock has the methods readLock() and writeLock() which return the respective lock instance. This helps reduce the performance impact of synchronizing. Problems of lack of Synchronization Lost Update A lost update happens when an write/update was overridden by another thread. Deadlocks A deadlock occurs when two threads wait for a resource, which is locked by the other thread. It can only occur when all of the following conditions are meth: Mutual Exclusion : Each resource is available only once Hold and Wait Condition : A thread which already blocks a resource, claims additional resources No Preemption : A blocked resource cannot be taken away by the OS Cyclic waiting Conditions : A chain of processes exists which are waiting for a resource, which is blocked by a successor in the chain How to avoid Dead Locks Generally avoiding shared resources will avoid dead locks as well. This however isn't always possible. In those cases, insure that a resource is always locked in the same order, public static void transfer ( Account from , Account to , int amount ) { boolean isLower = from . getId () < to . getId (); Account lowerAccount = isLower ? from : to ; Account higherAccount = ! isLower ? from : to ; synchronized ( lowerAccount ) { synchronized ( higherAccount ) { from . transferAmount ( - amount ); to . transferAmount ( amount ); } } } Another solution is to program a special case for one of the resource which will access the resources in the reverse direction (see Dining Philosophers) Dining Philosophers There are 5 Philosophers. Each philosophers can either eat or think. For eating a philosopher needs two forks, but there are only 5 forks in total, so not everybody can eat at the same time. A naive solution would first let the philosophers take the right and then the left fork. This would result in everybody holding a fork in the right hand and waiting for a fork to be available resulting in a dead lock . To prevent this cyclic waiting condition the abstract can be change to always take and release two forks as one atomic action. The situation above should never happen. A second solution is to change the behavior of one philosopher to first take the left and then the right fork. GUI Scene Graph A scene Graph is a cycle free graph of nodes. It contains one root node. Panes Group All children keep their size and it is just large enough to contain all children Region Is the base class of all panes and controlls and defines minimum, maximum and desired size Pane The size of the pane and the layout of its children can be manually set; clipping is possible HBox/VBox Aligns the children horizontally or vertically BorderPane Defines 5 regions. Nodes are added by setCenter(Node) , setLeft(Node) , ... GridPane The children are aranged in a table. Nodes are added with add(Node, column, row) FlowPane Automaticly aranges nodes in a new row/column, when the size of the pane is filled. AnchorPane Nodes can be anchored to multiple edges. This allows for a flexible layout. A node is added with getChildren().add(Node) and can be attached to an edge with setTopAnchor(Node, distance) , setLeftAnchor(Node, distance) , setBottomAnchor(Node, distance) and setRightAnchor(Node, distance) . TilePane Every Node gets the same amount of space in a grid. Like in a FlowPane , nodes are wrapped to the next line if the size of the pane is filled. Either a max tile size is set or the biggest child is used as a reference. Nodes are added with getChildren().add(Node) . Menus The root is MenuBar which contains Menu s (contain other Menus oder MenuItems) or MenuItem s (contains text and/or graphics), like CheckMenuItem or RadioMenuItem MenuBar menuBar = new MenuBar (); Menu fileMenu = new Menu ( \"File\" ); menuBar . getMenus (). add ( fileMenu ); MenuItem quitMenuItem = new MenuItem ( \"Quit\" ); fileMenu . getItems (). add ( quitMenuItem ); Image quitImage = new Image ( getClass (). getClassLoader (). getResourceAsStream ( \"quit-icon.png\" )); quitMenuItem . setGraphic ( new ImageView ( quitImage )); quitMenuItem . setAccelerator ( KeyCombination . keyCombination ( \"ESC\" )); quitItem . setOnAction ( new EventHandler < ActionEvent > () { public void handle ( ActionEvent e ) { Platform . exit (); } }); // or as lambda expression quitMenuItem . setOnAction ( e -> Platform . exit ()); CheckMenuItem bookMenu = new CheckMenuItem ( \"Book\" ); bookMenu . setSelected ( true ); fileMenu . getItems (). add ( bookMenu ); Events An event has two phases: Event Capturing Phase : The event is passed up from the origin node to the stage. On each node, its EventFilter is invoked Event Bubbling Phase The event is passed back up from the stage to the origin node. On each node, its EventHandler is called. An event handler can be added to a node via their respective methods: Button button = new Button ( \"test\" ); button . setOnAction (( ActionEvent event ) -> {}); button . setOnAction ( new EventHandler < ActionEvent > { @Override public void handle ( ActionEvent event ) {} }); button . setOnMouseClicked (( MouseEvent event ) -> {}); All event handlers are EventHandler<? extends Event> Demo App public class App extends Application { @Override public void start ( Stage primaryStage ) throws Exception { FXMLLoader loader = new FXMLLoader ( getClass (). getResource ( \"test.fxml\" )); Parent parent = loader . load (); Scene scene = new Scene ( parent ); stage . setTitle ( \"Test\" ); stage . setScene ( scene ); stage . setMinWidth ( 400 ); stage . setMinHeight ( 600 ); // if this is a new stage stage . initOwner ( parentStage ); // disables events for owner windows only stage . initModality ( Modality . WINDOW_MODAL ); // disables events for all app windows stage . initModality ( Modality . WINDOW_MODAL ); stage . show (); // or stage.showAndWait(); to block until modal window is closed // create new Stage (primaryStage= new Stage()) to open a new window } } public class Controller { @FXML private BorderPane rootPane ; @FXML public void initialize () { rootPane . setStyle ( \"-fx-bakground-color: red;\" ); rootPane . setLayoutX ( 0 ); rootPane . setLayoutY ( 0 ); } } MVC Model : Contains the data with the domain logic, but it has to be independent from the View-Classes. View: The UI components which render the data. The view doesn't call the model directly (usually), but it knows about the types of the model (for example via generics). Controller: The glue between the model and the UI. It listens to events from the UI and calls the model accordingly The benefits of this pattern are: Independent development and testing of model and UI Its possible to have multiple views and controllers for one model Changes to the UI or model are far easier FXML Properties and Bindings IntegerProperty prop = new SimpleIntegerProperty ( 3 ); prop . addListener ( new ChangeListener < Number > () { public void changed ( ObservableValue <? extends Integer > o , Number oldVal , Number newVal ) {} }); prop . getValue (); // returns the value prop . setValue ( 4 ); // sets the value prop . bind ( otherProp ); // binds the prop to the otherProp prop . bindBidirectional ( otherProp ); // binds the two properties bidirectionally Initialize The method initialize() can be annotated with @FXML and will be called when the controller is initialized. Testing Testing is the process of executing a programm with the intent of finding errors. Principles of Testing Specification of Input and Output For each test case the input and the expected output should be specified. Separation of Creation and Testing The developer of the code shouldn't write the test for their code. Completeness of Tests Code should always be tested for valid inputs and invalid tests. The natural tendency is to test only the valid inputs. Testing is an investement Test cases are reused Error Cluster If an error is found in a section of code, the probability of more errors increases. Error-prone Sections should be well tested. Mock Testing Mock testing is used when a class with dependencies should be tested. The dependencies can be mocked that it implements the minimal of behaviour to function. This allows to only test the class under testing and not its dependencies. Different Mocking Types There are different type of mock classes. Dummy Dummies are objects which are never used. They fill parameter lists of methods, if those methods would throw NullPointerExceptions otherwise. Stubs A stub is the minimal implementation of an interface. Void method usually don't do anything and methods with a return value will usually return a hard coded value. Here is an example. public class EmailStub implements EmailServer { public void sendMail ( String mailTextt ) { // do nothing } public String receiveMail () { return \"Mail received\" ; // a hard coded value } } An EmailDummy would return null in receiveMail() because it is just a dummy. Spies Spies are similar to stubs, but record which members were invoked. This information can be checked in unit tests. Fakes A fake will implement a class similar to the production class but with shortcuts (e.g. an in-memory database) Mock A test double which implements the functions in away which we expect for the test. Depending on how they are implemented, they can function as a dummy, stub, spy or a fake. Mock testing is usually split in multiple phases: Create: The mock object is created Specify: The expected behaviour is specified Use: The mock object is used in a normal unit test Verify behaviour: The mock object is verified public class OrderInteractionTester extends MockObjectTestCase { private static String TALISKER = \"Talisker\" ; public void testFillingRemovesInventoryIfInStock () { // configuration Order order = new Order ( TALISKER , 50 ); Mock warehouseMock = new Mock ( Warehouse . class ); // expectations warehouseMock . expects ( once ()) . method ( \"hasInventory\" ) . with ( eq ( TALISKER ), eq ( 50 )) . will ( returnValue ( true )); warehouseMock . expects ( once ()) . method ( \"remove\" ) . with ( eq ( TALISKER ), eq ( 50 )) . after ( \"hasInventory\" ); //exercise order . fill (( Warehouse ) warehouseMock . proxy ()); //verify warehouseMock . verify (); //verify expected behavior assertTrue ( order . isFilled ()); //verify state } } Blacking-Box vs White-Box Testing In black-box testing (or state testing), only the public interface is known. No assumptions is done about the internal implementaiton. Usually stubbing can be used. In white-box testing (or behaviour testing) the inner working of the class is known and tested. Here, usually mocking can be used. Mockito Create a Mock Either the method mock(Class<?> clazz) is used or the annotation @Mock for which MockitoAnnotations.openMocks() needs to be called in the setup method. void testHalf ( @Mock Half mockedHalf2 ) { Half mockedHalf = mock ( Half . class ); } Mock Behaviour To mock the return value of methods, the when(<method>).thenReturn(<value1>).thenReturn(<value2>) pattern can be used. When the returned value should have a bit more logic than a constant value, the thenAnswer(Answer<T>) method can be used (see example below). To mock an exception throwing method, the doThrow(<exception>).when(<mockObj>).<method>(<args>) pattern needs to be used. The method must support throwing the exception in case of an checked-exception. There are multiple matchers available, which can match an argument of a mocked method: Any-matchers : anyInt() , anyString() , any(Class<?> clazz) , ... String-matchers : startsWith(String) , endsWith(String) , contains(String) , ... Object-matchers : isNull() , isNotNull() , ... Compare-matchvers : eq(T obj) , ... Custom-matchers : argThat()... , intThat(...) , ... Person mock = mock ( Person . class ); // mock return values when ( mock . getName ()). thenReturn ( \"Hans\" ). thenReturn ( \"Max\" ); doReturn ( 10 ). doReturn ( 20 ). when ( mock ). getAge (); when ( mock . getMessage ( anyString ())). thenAnswer (( InvocationOnMock invocation ) -> \"hello world\" ); // mock exception throwing doThrow ( new IllegalArgumentException ()). when ( mock ). setAge ( - 1 ); When an method isn't mocked, then a value is still returned based on the return value: The return value is an primitive : The \"zero\"-primitive is returned The return value is a primitive wrapper class : Then the \"zero\"-primitive of the wrapper class is returned The return value is a collection : The return value is an empty collection For the toString() method an description of the mock is returned For Comparable#compareTo(T other) returns zero if the references are equal, else a non-zero value Else : null is returned. Verify Behaviour Mockito can verify that a method was invoked. For this, the pattern verify(<mock>).<method>(<args>) can be used. With an additional argument of verify, further conditions can be specified. With verify(<mock>, never()).<method>(<args>) can be checked that the method was never invoked. Other condition includes never() , times(int) , atLeastOnce() , atLeast(int) , atMost(int) , timeout(int milliseconds) (that the method is invoked in the given timeout). These conditions can be combined like timeout(10).times(2) Mockito can also verify the order in which methods were called. For this a InOrder object can be created with inOrder(<mockObj>) . On the InOrder object, the verify(...) method can be used. verify ( mockedHalf ). contractAtrium (); verify ( mockedHalf , times ( 2 )). isAtrioventricularValveOpen (); verify ( mockedList , never ()). add ( \"ZHAW\" ); InOrder inOrder = inOrder ( singleMock ); // Verify the order inOrder . verify ( singleMock ). add ( \"second\" ); inOrder . verify ( singleMock ). add ( \"first\" ); Spies A spy object is created based on a \"real\" object. All methods are delegated to this object, but the behaviour of methods can be selectively changed (similar with mocks) and it can verify than methods were called. It can be created with spy(Object obj) and can be used like a mock. Similar to @Mock the @Spy annotation can be used instead of spy(...) ( MockitoAnnotations.openMocks() needs to be called in the setup method). List list = new LinkedList (); // create a spy on the real object instance List spy = spy ( list ); // stub the size() method when ( spy . size ()). thenReturn ( 100 ); // add() is not stubbed. So it will use the real method spy . add ( \"one\" ); spy . add ( \"two\" ); assertEquals ( \"one\" , spy . get ( 0 )); assertEquals ( 100 , spy . size ()); IO Serializing In order for an object to be serializable in needs to implement the marker interface Serializable . Fields can be marked with transient ( private transient Date someDate; ) if they shouldn't be serialized. This can be usefull for serializing classes which contain unserializable classes (like dates, file descriptor, network sockets or db connections). Employee harry = new Employee ( \"Dirty Harry\" , 50000 , LocalDate . of ( 1967 , 3 , 11 )); Manager boss = new Manager ( \"Walter Smith\" , 80000 , LocalDate . of ( 1950 , 12 , 4 )); // Manager is extending Employee boss . setAssistant ( harry ); // Save (serialize) two objects to the file empolyee.dat try ( ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( \"employee.dat\" ))) { // objects are written in the given order to the file out . writeObject ( harry ); // write object Dirty Harry out . writeObject ( boss ); // write object Walter Smith out . writeInt ( 12 ); // write value of primitive type int } // Load (deserialize) two objects from the file employee.dat try ( ObjectInputStream in = new ObjectInputStream ( new FileInputStream ( \"employee.dat\" ))) { // number and order of reading the objects must match, also the type must be compatible (match or super class) Employee e1 = ( Employee ) in . readObject (); // object for Dirty Harry Employee e2 = ( Employee ) in . readObject (); // object for Walter Smith // e2.getClass().getName() would return type Manager int count = in . readInt (); // read primitive type int } IO Streams A byte stream can be converted to a char stream with InputStreamReader and OutputStreamWriter respectively. InputStream and Readers usually allow to skip a number of bytes/chars with skip(long n) . However, OutputStream s and Writer s don't allow removing or inserting into a file, only appending ( FileOutputStream(File file, boolean append) ) or replacing is supported. RandomAccessFile Allows reading from anywhere in the file, not just skipping bytes like an InputStream . This can be done with the seek(long pos) or the skipBytes(long n) methods. // create file and write some data into it File f = new File ( \"randomaccessfile.txt\" ); try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( f , true ))) { for ( int i = 2 ; i <= 10 ; i ++ ) { if ( i % 2 == 0 ) { bw . write ( Integer . toString ( i )); bw . newLine (); } } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"rw\" )) { // read-write mode for ( int i = 1 ; i <= 5 ; i ++ ){ randomFile . seek ( randomFile . length ()); // set file pointer to end of file (EOF) randomFile . writeBytes ( Integer . toString ( i )); // append \"1\",\"2\",\"3\",\"4\",\"5\" at EOF } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"r\" )) { // read-only mode int i = ( int ) randomFile . length (); // get length of file in bytes System . out . println ( \"Length: \" + i ); randomFile . seek ( i - 3 ); // set file pointer to EOF-3 bytes for ( int ct = 0 ; ct < 3 ; ct ++ ){ byte b = randomFile . readByte (); // read byte(s) System . out . println (( char ) b ); } } Charset An instance of Charset can be either obtained by Charset.forName(<name>) , Charset.getDefaultCharset() or Charset.getAvailableCharsets() . Alternatively StandardCharsets.UTF_8 can be used. Logger Each Logger instance has a list of Handlers . A Handler can be used by multiple Loggers and handles the storing of the logging messages (like writing it to a file, or displaying in the console). Both the Logger and the Handler have a Level. And each will only forward messages which have a level higher than their configured level. The possible levels are: SEVERE(1000) , WARNING(900) , INFO(800) , CONFIG(700) , FINE(500) , FINER(400) , FINEST(300) . The following properties file is an example logging configuration. ## configure handlers java.util.logging.ConsoleHandler.level = ALL ## File handler configuration ## see https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/FileHandler.html java.util.logging.FileHandler.level = ALL # %g = generation number, %u = unique number to resolve conflicts java.util.logging.FileHandler.pattern = log-%g-%u.log # use SimpleFormatter instead of default XMLFormatter java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.FileHandler.encoding = UTF-8 # max log file size in byte before switching to next generation (=1kB); 0 = unlimited java.util.logging.FileHandler.limit = 1024 # max number of generations (%g) before overwriting (5 -> 0..4) java.util.logging.FileHandler.count = 5 java.util.logging.FileHandler.append = true ## configure Formatter (see SimpleFormatter documentation) java.util.logging.SimpleFormatter.format = [%1$tc] %4$s: %5$s {%2$s}%6$s%n ## configure default log level (for all loggers, if not overwritten below) .level = INFO ## configure root logger \"\" handlers = java.util.logging.ConsoleHandler level = INFO ## Application specific logger configuration # loggers starting with \"ch.zhaw.prog2.io\" -> write to console and file and do not forward to parent handlers ch.zhaw.prog2.io.level = FINE ch.zhaw.prog2.io.handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler ch.zhaw.prog2.io.useParentHandlers = false # logger for class ch.zhaw.prog2.io.LogConfiguration ch.zhaw.prog2.io.LogConfiguration.level = FINEST A log configuration can be loaded anytime and all already existing loggers will be updated. InputStream logConfig = this . getClass (). getClassLoader (). getResourceAsStream ( \"log.properties\" ); LogManager . getLogManager (). readConfiguration ( logConfig );","title":"PROG2 Summary"},{"location":"22FS/PROG2/summary.html#prog2-summary","text":"","title":"PROG2 Summary"},{"location":"22FS/PROG2/summary.html#gradle","text":"","title":"Gradle"},{"location":"22FS/PROG2/summary.html#concurrency","text":"","title":"Concurrency"},{"location":"22FS/PROG2/summary.html#types-of-concurrencies","text":"There are multiple types of concurrencies: True concurrency On a computer with more multiple cores, each core can run a flow independently Interleaving concurrency Each flow gets a slice of time. After that time the flow will be paused and the core will work on another flow. The scheduler controls which core works on which flow","title":"Types of Concurrencies"},{"location":"22FS/PROG2/summary.html#strategies-for-interlaving-concurrency","text":"Non-Preemptive (cooperative) The process releases the core voluntarily Tyes: FCFS(First comes, first served), SNP(shortest process next). This was how it was in the olden days Preemtive A scheduler can interrupt a process","title":"Strategies for Interlaving Concurrency"},{"location":"22FS/PROG2/summary.html#program-vs-process-vs-thread","text":"A program is a sequence of instructions and can consists of multiple processes. A process executes a program or part of it and can consists of multiple threads. Each process has its own memory, uses IPC (Inter-Process-Communication) to communicate to other processes and switching between processes is expensive. A thread is part of a process and runs one flow. It shares its memory with the other threads in the same process and switching between thread is cheap.","title":"Program vs Process vs Thread"},{"location":"22FS/PROG2/summary.html#java-concurrency","text":"","title":"Java-Concurrency"},{"location":"22FS/PROG2/summary.html#thread","text":"Thread.sleep() doesn't gurantee that sleep doesn't wake up early or late Object.yield() will advice the scheduler to release the thread, but there is guarantee that the thread will be suspened With Thread.currentThread() one can get the thread which runs the current thread Thread.stop() , Thread.suspend() and Thread.resume() are depricated and potentialy unsafe public static void main ( String [] args ) { System . out . println ( \"START: main\" ); Thread java = new JoinThread ( \"Java\" ); Thread fiji = new JoinThread ( \"Fiji\" ); java . start (); fiji . start (); System . out . println ( \"Wait for theads..\" ); try { java . join (); // blocks until java ends fiji . join (); // blocks until fiji ends } catch ( InterruptedException e ) { System . out . println ( \"Interrupted\" ); } System . out . println ( \"DONE main\" ); }","title":"Thread"},{"location":"22FS/PROG2/summary.html#lifecycle-of-a-thread","text":"A Thread is considered \"alive\" and Thread.isAlive() will return true, when the Thread is either ready, running oder suspended (the blocks with the dotted outline). This means that run needs to start running before the Thread is alive.","title":"Lifecycle of a Thread"},{"location":"22FS/PROG2/summary.html#executor-framework","text":"// Example of a Sheduled Executor public static void main ( String [] args ) { ScheduledExecutorService scheduledExecutor = Executors . newScheduledThreadPool ( 2 ); scheduledExecutor . execute ( new ScheduledTask ( 0 , System . currentTimeMillis ())); Future <?> future = scheduledExecutor . submit ( new ScheduledTask ( 0 , System . currentTimeMillis ())); scheduledExecutor . schedule ( new ScheduledTask ( 1 , System . currentTimeMillis ()), 4 , TimeUnit . SECONDS ); scheduledExecutor . scheduleAtFixedRate ( new ScheduledTask ( 2 , System . currentTimeMillis ()), 4 , 3 , TimeUnit . SECONDS ); scheduledExecutor . scheduleWithFixedDelay ( new ScheduledTask ( 3 , System . currentTimeMillis ()), 2 , 3 , TimeUnit . SECONDS ); try { TimeUnit . SECONDS . sleep ( 20 ); // waiting for 20s } catch ( InterruptedException e ) { } scheduledExecutor . shutdown (); } private static record ScheduledTask ( int id , long starttime ) implements Runnable { @Override public void run () { System . out . println ( \"Executing Task \" + id + \" at \" + ( System . currentTimeMillis () - starttime ) + \" ms after start \" + \" in Thread : \" + Thread . currentThread (). getName ()); } }","title":"Executor Framework"},{"location":"22FS/PROG2/summary.html#executor-service","text":"An Executor just promises to execute a given task. An ExecutorService extends Executor to allow to shutdown the Executor and to track the progress and the state of a task. The shutdownNow() method uses Thread.interrupt() under the hood and is thus not deprecated. The ScheduledExecutorService extends the ExecutorService to allow a task to be scheduled. The method signitures of the new methods are: schedule(Runnable task, long delay, TimeUnit unit) , scheduleAtFixedRate(Runnable task, long initialDelay, long period, TimeUnit unit) scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)","title":"Executor Service"},{"location":"22FS/PROG2/summary.html#thread-pools","text":"A thread pool uses multiple threads which are reused for multiple tasks. Thread pools usually use a queue to hold the tasks to be executed. A special kind of thread pool is a Blocking Queue , which when it's full, will reject newly submitted tasks. Most Executor Services use thread pools underneath.","title":"Thread Pools"},{"location":"22FS/PROG2/summary.html#different-executors","text":"Executor Name Description Executors.newSingleThreadExecutor() Creates an Executor which only uses one thread Executors.newFixedThreadPool(int numOfThreads) Creates an Executor which has the given number of threads. Those thread will be reused Executors.newCachedThreadPool() Creates new threads as needed. It will retain Threads for an amount of time (approx. up to 60s) and will stop it after. Executors.newScheduledThreadPoool(int numOfThreads) Creates a new scheduled thread pool with the given number of threads. Executors.newSingleThreadExecutor() Creates a new scheduled executor with a single thread","title":"Different Executors"},{"location":"22FS/PROG2/summary.html#callable-and-futures","text":"public interface Callable < V > { V call () throws Exception ; } A Callable will return a result or an exception and can also be submitted to an ExecutorService and a Future<V> will be returned. public static void main ( String [] args ) throws InterruptedException , ExecutionException , TimeoutException { ExecutorService service = Executors . newSingleThreadExecutor (); Future < String > future = service . submit (() -> \"Hello world\" ); String result = future . get (); // waits until the future completes result = future . get ( 1 , TimeUnit . SECONDS ); // will throw TimeoutException after 1 second future . cancel ( < mayInterruptIfRunning > ); // will cancel the future future . isDone (); // returs if the future is done future . isCancelled (); // returns if the future was cancelled }","title":"Callable and Futures"},{"location":"22FS/PROG2/summary.html#patterns","text":"","title":"Patterns"},{"location":"22FS/PROG2/summary.html#wait-for-all-tasks-to-finish","text":"List < Future <?>> futureList = executorService . invokeAll ( taskList ); for ( Future <?> future : futureList ) { future . get (); // wait for each future }","title":"Wait for all Tasks to finish"},{"location":"22FS/PROG2/summary.html#wait-for-the-fastest-task-to-finish","text":"String result = executorService . invokeAny ( taskList ); /* The result of the task which completed first, is returned */","title":"Wait for the fastest task to finish"},{"location":"22FS/PROG2/summary.html#share-data-between-multiple-threads","text":"","title":"Share Data between Multiple Threads"},{"location":"22FS/PROG2/summary.html#atomic","text":"Use the atomic data types, like AtomicBoolean , AtomicInteger , AtomicLong , AtomicReference , AtomicIntegerArray , AtomicLongArray or AtomicReferenceArray . private static class Account { private final int id ; private AtomicInteger balance ; public Account ( int id , int initialAmount ) { this . id = id ; this . balance = new AtomicInteger ( initialAmount ); } public int getId () { return id ; } public int getBalance () { return balance . get (); } public void setBalance ( int amount ) { this . balance . set ( amount ); } public void transferAmount ( int amount ) { this . balance . addAndGet ( amount ); } }","title":"Atomic"},{"location":"22FS/PROG2/summary.html#synchronized","text":"class Account { private int balance ; public synchronized void transferAmount1 ( int amount ) { this . balance += amaount ; } public void transferAmount2 ( int amount ) { synchronized ( this ) { this . balance += amaount ; } } public synchronized static staticLock1 () { //do stuff } public static staticLock1 () { synchronized ( Amount . class ) { // do stuff } } } Never call an other synchronized method which uses a different object. This can cause a dead lock.","title":"Synchronized"},{"location":"22FS/PROG2/summary.html#monitor","text":"A Java object can be used as a locked. class FooBar { private Object monitor ; public void test () { synchronized ( monitor ) { // waits for the monitor to be called with monitor.notify() or monitor.notifyAll() monitor . wait (); } } } Object.wait() blocks until Object.notify() or Object.notifyAll() is invoked on the same monitor object. notify() only wakes up one waiting Thread while notifyAll() will wake up all waiting threads. wait() releases the monitor object .","title":"Monitor"},{"location":"22FS/PROG2/summary.html#types-of-synchronization","text":"","title":"Types of Synchronization"},{"location":"22FS/PROG2/summary.html#mutual-exclusion","text":"Mutual Exclusion means that only only thread can access a shared resource at a time. This usually means, that a section of code needs to be locked (eg. with synchronize) until the thread is done with that code.","title":"Mutual Exclusion"},{"location":"22FS/PROG2/summary.html#conditional-synchronization","text":"Conditional synchronization is needed when one thread waits for an event to happen in another thread. This is basicly the Producer-Consumer \"Pattern\". The order of events or operations is critical.","title":"Conditional Synchronization"},{"location":"22FS/PROG2/summary.html#producer-consumer","text":"The producer produces some data which can be consumed by the consumer. The consumer tries to access the resource. If it is already ready, then it can just continue. If not it will wait() for the producer to notify() its monitor after which it can access the resource. The producer thread might needs to throttle itself to avoid loosing results when no consumer can consume them. Here is an example for a consumer-producer example: The while loop is necessary because when the thread calls wait() it releases the monitor the synchronize block and an other thread can enter the synchronize block and call wait() .","title":"Producer-Consumer"},{"location":"22FS/PROG2/summary.html#synchronized-queue","text":"With a queue the problem of the consumer and producer can be abstracted into a separate class to make it less brittle. Implementing the following becomes trivial: The producer fills the queue with data The consumer retrieves the data from the queue if available The consumer waits only if the queue is empty The producer waits when the queue is full","title":"Synchronized Queue"},{"location":"22FS/PROG2/summary.html#locks-and-conditions","text":"A Lock is like a monitor object but instead of using synchronize the methods lock() and unlock() are used (in a try-finally-block). Additionally Conditions can be created with Lock.newCondition() . A condition is connected to its lock and can only be interacted with when its lock is locked. A Condition has await() , signal() and signallAll() , which behaviour like Object.wait() , Object.notify() and Object.notifyAll() . The advantage of Conditions is, that each lock can have multiple conditions. With ReentrantLock.hasWaiters(Condition) can be checked, if a thread currently waits for a condition. public class ConditionalSyncQueue < E > { private Lock mutex = new ReentrantLock (); private Condition notEmpty = mutex . newCondition (); private Condition notFull = mutex . newCondition (); private LinkedList < E > queue = new LinkedList < E > (); private int capacity = 5 ; public void add ( E item ) throws InterruptedException { mutex . lock (); // enter critical section try { // condition 1: queue not full while ( queue . size () >= capacity ) { notFull . await (); } queue . addLast ( item ); notEmpty . signal (); } finally { mutex . unlock (); // exit critical section } } public E remove () throws InterruptedException { E item = null ; mutex . lock (); // enter critical section try { // condition 2: queue not empty while ( queue . empty ()) { notEmpty . await (); } item = queue . removeFirst (); notFull . signal (); } finally { mutex . unlock (); // exit critical section } return item ; } }","title":"Locks and Conditions"},{"location":"22FS/PROG2/summary.html#readwritelocks","text":"A ReadWriteLock is like a Lock but it provides 2 Lock instances: A write lock: When locked, neither locks are lockable anymore A read lock: When locked, the write lock won't be lockable The ReentrantReadWriteLock has the methods readLock() and writeLock() which return the respective lock instance. This helps reduce the performance impact of synchronizing.","title":"ReadWriteLocks"},{"location":"22FS/PROG2/summary.html#problems-of-lack-of-synchronization","text":"","title":"Problems of lack of Synchronization"},{"location":"22FS/PROG2/summary.html#lost-update","text":"A lost update happens when an write/update was overridden by another thread.","title":"Lost Update"},{"location":"22FS/PROG2/summary.html#deadlocks","text":"A deadlock occurs when two threads wait for a resource, which is locked by the other thread. It can only occur when all of the following conditions are meth: Mutual Exclusion : Each resource is available only once Hold and Wait Condition : A thread which already blocks a resource, claims additional resources No Preemption : A blocked resource cannot be taken away by the OS Cyclic waiting Conditions : A chain of processes exists which are waiting for a resource, which is blocked by a successor in the chain","title":"Deadlocks"},{"location":"22FS/PROG2/summary.html#how-to-avoid-dead-locks","text":"Generally avoiding shared resources will avoid dead locks as well. This however isn't always possible. In those cases, insure that a resource is always locked in the same order, public static void transfer ( Account from , Account to , int amount ) { boolean isLower = from . getId () < to . getId (); Account lowerAccount = isLower ? from : to ; Account higherAccount = ! isLower ? from : to ; synchronized ( lowerAccount ) { synchronized ( higherAccount ) { from . transferAmount ( - amount ); to . transferAmount ( amount ); } } } Another solution is to program a special case for one of the resource which will access the resources in the reverse direction (see Dining Philosophers)","title":"How to avoid Dead Locks"},{"location":"22FS/PROG2/summary.html#dining-philosophers","text":"There are 5 Philosophers. Each philosophers can either eat or think. For eating a philosopher needs two forks, but there are only 5 forks in total, so not everybody can eat at the same time. A naive solution would first let the philosophers take the right and then the left fork. This would result in everybody holding a fork in the right hand and waiting for a fork to be available resulting in a dead lock . To prevent this cyclic waiting condition the abstract can be change to always take and release two forks as one atomic action. The situation above should never happen. A second solution is to change the behavior of one philosopher to first take the left and then the right fork.","title":"Dining Philosophers"},{"location":"22FS/PROG2/summary.html#gui","text":"","title":"GUI"},{"location":"22FS/PROG2/summary.html#scene-graph","text":"A scene Graph is a cycle free graph of nodes. It contains one root node.","title":"Scene Graph"},{"location":"22FS/PROG2/summary.html#panes","text":"Group All children keep their size and it is just large enough to contain all children Region Is the base class of all panes and controlls and defines minimum, maximum and desired size Pane The size of the pane and the layout of its children can be manually set; clipping is possible HBox/VBox Aligns the children horizontally or vertically BorderPane Defines 5 regions. Nodes are added by setCenter(Node) , setLeft(Node) , ... GridPane The children are aranged in a table. Nodes are added with add(Node, column, row) FlowPane Automaticly aranges nodes in a new row/column, when the size of the pane is filled. AnchorPane Nodes can be anchored to multiple edges. This allows for a flexible layout. A node is added with getChildren().add(Node) and can be attached to an edge with setTopAnchor(Node, distance) , setLeftAnchor(Node, distance) , setBottomAnchor(Node, distance) and setRightAnchor(Node, distance) . TilePane Every Node gets the same amount of space in a grid. Like in a FlowPane , nodes are wrapped to the next line if the size of the pane is filled. Either a max tile size is set or the biggest child is used as a reference. Nodes are added with getChildren().add(Node) .","title":"Panes"},{"location":"22FS/PROG2/summary.html#menus","text":"The root is MenuBar which contains Menu s (contain other Menus oder MenuItems) or MenuItem s (contains text and/or graphics), like CheckMenuItem or RadioMenuItem MenuBar menuBar = new MenuBar (); Menu fileMenu = new Menu ( \"File\" ); menuBar . getMenus (). add ( fileMenu ); MenuItem quitMenuItem = new MenuItem ( \"Quit\" ); fileMenu . getItems (). add ( quitMenuItem ); Image quitImage = new Image ( getClass (). getClassLoader (). getResourceAsStream ( \"quit-icon.png\" )); quitMenuItem . setGraphic ( new ImageView ( quitImage )); quitMenuItem . setAccelerator ( KeyCombination . keyCombination ( \"ESC\" )); quitItem . setOnAction ( new EventHandler < ActionEvent > () { public void handle ( ActionEvent e ) { Platform . exit (); } }); // or as lambda expression quitMenuItem . setOnAction ( e -> Platform . exit ()); CheckMenuItem bookMenu = new CheckMenuItem ( \"Book\" ); bookMenu . setSelected ( true ); fileMenu . getItems (). add ( bookMenu );","title":"Menus"},{"location":"22FS/PROG2/summary.html#events","text":"An event has two phases: Event Capturing Phase : The event is passed up from the origin node to the stage. On each node, its EventFilter is invoked Event Bubbling Phase The event is passed back up from the stage to the origin node. On each node, its EventHandler is called. An event handler can be added to a node via their respective methods: Button button = new Button ( \"test\" ); button . setOnAction (( ActionEvent event ) -> {}); button . setOnAction ( new EventHandler < ActionEvent > { @Override public void handle ( ActionEvent event ) {} }); button . setOnMouseClicked (( MouseEvent event ) -> {}); All event handlers are EventHandler<? extends Event>","title":"Events"},{"location":"22FS/PROG2/summary.html#demo-app","text":"public class App extends Application { @Override public void start ( Stage primaryStage ) throws Exception { FXMLLoader loader = new FXMLLoader ( getClass (). getResource ( \"test.fxml\" )); Parent parent = loader . load (); Scene scene = new Scene ( parent ); stage . setTitle ( \"Test\" ); stage . setScene ( scene ); stage . setMinWidth ( 400 ); stage . setMinHeight ( 600 ); // if this is a new stage stage . initOwner ( parentStage ); // disables events for owner windows only stage . initModality ( Modality . WINDOW_MODAL ); // disables events for all app windows stage . initModality ( Modality . WINDOW_MODAL ); stage . show (); // or stage.showAndWait(); to block until modal window is closed // create new Stage (primaryStage= new Stage()) to open a new window } } public class Controller { @FXML private BorderPane rootPane ; @FXML public void initialize () { rootPane . setStyle ( \"-fx-bakground-color: red;\" ); rootPane . setLayoutX ( 0 ); rootPane . setLayoutY ( 0 ); } }","title":"Demo App"},{"location":"22FS/PROG2/summary.html#mvc","text":"Model : Contains the data with the domain logic, but it has to be independent from the View-Classes. View: The UI components which render the data. The view doesn't call the model directly (usually), but it knows about the types of the model (for example via generics). Controller: The glue between the model and the UI. It listens to events from the UI and calls the model accordingly The benefits of this pattern are: Independent development and testing of model and UI Its possible to have multiple views and controllers for one model Changes to the UI or model are far easier","title":"MVC"},{"location":"22FS/PROG2/summary.html#fxml","text":"","title":"FXML"},{"location":"22FS/PROG2/summary.html#properties-and-bindings","text":"IntegerProperty prop = new SimpleIntegerProperty ( 3 ); prop . addListener ( new ChangeListener < Number > () { public void changed ( ObservableValue <? extends Integer > o , Number oldVal , Number newVal ) {} }); prop . getValue (); // returns the value prop . setValue ( 4 ); // sets the value prop . bind ( otherProp ); // binds the prop to the otherProp prop . bindBidirectional ( otherProp ); // binds the two properties bidirectionally","title":"Properties and Bindings"},{"location":"22FS/PROG2/summary.html#initialize","text":"The method initialize() can be annotated with @FXML and will be called when the controller is initialized.","title":"Initialize"},{"location":"22FS/PROG2/summary.html#testing","text":"Testing is the process of executing a programm with the intent of finding errors.","title":"Testing"},{"location":"22FS/PROG2/summary.html#principles-of-testing","text":"Specification of Input and Output For each test case the input and the expected output should be specified. Separation of Creation and Testing The developer of the code shouldn't write the test for their code. Completeness of Tests Code should always be tested for valid inputs and invalid tests. The natural tendency is to test only the valid inputs. Testing is an investement Test cases are reused Error Cluster If an error is found in a section of code, the probability of more errors increases. Error-prone Sections should be well tested.","title":"Principles of Testing"},{"location":"22FS/PROG2/summary.html#mock-testing","text":"Mock testing is used when a class with dependencies should be tested. The dependencies can be mocked that it implements the minimal of behaviour to function. This allows to only test the class under testing and not its dependencies.","title":"Mock Testing"},{"location":"22FS/PROG2/summary.html#different-mocking-types","text":"There are different type of mock classes.","title":"Different Mocking Types"},{"location":"22FS/PROG2/summary.html#dummy","text":"Dummies are objects which are never used. They fill parameter lists of methods, if those methods would throw NullPointerExceptions otherwise.","title":"Dummy"},{"location":"22FS/PROG2/summary.html#stubs","text":"A stub is the minimal implementation of an interface. Void method usually don't do anything and methods with a return value will usually return a hard coded value. Here is an example. public class EmailStub implements EmailServer { public void sendMail ( String mailTextt ) { // do nothing } public String receiveMail () { return \"Mail received\" ; // a hard coded value } } An EmailDummy would return null in receiveMail() because it is just a dummy.","title":"Stubs"},{"location":"22FS/PROG2/summary.html#spies","text":"Spies are similar to stubs, but record which members were invoked. This information can be checked in unit tests.","title":"Spies"},{"location":"22FS/PROG2/summary.html#fakes","text":"A fake will implement a class similar to the production class but with shortcuts (e.g. an in-memory database)","title":"Fakes"},{"location":"22FS/PROG2/summary.html#mock","text":"A test double which implements the functions in away which we expect for the test. Depending on how they are implemented, they can function as a dummy, stub, spy or a fake. Mock testing is usually split in multiple phases: Create: The mock object is created Specify: The expected behaviour is specified Use: The mock object is used in a normal unit test Verify behaviour: The mock object is verified public class OrderInteractionTester extends MockObjectTestCase { private static String TALISKER = \"Talisker\" ; public void testFillingRemovesInventoryIfInStock () { // configuration Order order = new Order ( TALISKER , 50 ); Mock warehouseMock = new Mock ( Warehouse . class ); // expectations warehouseMock . expects ( once ()) . method ( \"hasInventory\" ) . with ( eq ( TALISKER ), eq ( 50 )) . will ( returnValue ( true )); warehouseMock . expects ( once ()) . method ( \"remove\" ) . with ( eq ( TALISKER ), eq ( 50 )) . after ( \"hasInventory\" ); //exercise order . fill (( Warehouse ) warehouseMock . proxy ()); //verify warehouseMock . verify (); //verify expected behavior assertTrue ( order . isFilled ()); //verify state } }","title":"Mock"},{"location":"22FS/PROG2/summary.html#blacking-box-vs-white-box-testing","text":"In black-box testing (or state testing), only the public interface is known. No assumptions is done about the internal implementaiton. Usually stubbing can be used. In white-box testing (or behaviour testing) the inner working of the class is known and tested. Here, usually mocking can be used.","title":"Blacking-Box vs White-Box Testing"},{"location":"22FS/PROG2/summary.html#mockito","text":"","title":"Mockito"},{"location":"22FS/PROG2/summary.html#create-a-mock","text":"Either the method mock(Class<?> clazz) is used or the annotation @Mock for which MockitoAnnotations.openMocks() needs to be called in the setup method. void testHalf ( @Mock Half mockedHalf2 ) { Half mockedHalf = mock ( Half . class ); }","title":"Create a Mock"},{"location":"22FS/PROG2/summary.html#mock-behaviour","text":"To mock the return value of methods, the when(<method>).thenReturn(<value1>).thenReturn(<value2>) pattern can be used. When the returned value should have a bit more logic than a constant value, the thenAnswer(Answer<T>) method can be used (see example below). To mock an exception throwing method, the doThrow(<exception>).when(<mockObj>).<method>(<args>) pattern needs to be used. The method must support throwing the exception in case of an checked-exception. There are multiple matchers available, which can match an argument of a mocked method: Any-matchers : anyInt() , anyString() , any(Class<?> clazz) , ... String-matchers : startsWith(String) , endsWith(String) , contains(String) , ... Object-matchers : isNull() , isNotNull() , ... Compare-matchvers : eq(T obj) , ... Custom-matchers : argThat()... , intThat(...) , ... Person mock = mock ( Person . class ); // mock return values when ( mock . getName ()). thenReturn ( \"Hans\" ). thenReturn ( \"Max\" ); doReturn ( 10 ). doReturn ( 20 ). when ( mock ). getAge (); when ( mock . getMessage ( anyString ())). thenAnswer (( InvocationOnMock invocation ) -> \"hello world\" ); // mock exception throwing doThrow ( new IllegalArgumentException ()). when ( mock ). setAge ( - 1 ); When an method isn't mocked, then a value is still returned based on the return value: The return value is an primitive : The \"zero\"-primitive is returned The return value is a primitive wrapper class : Then the \"zero\"-primitive of the wrapper class is returned The return value is a collection : The return value is an empty collection For the toString() method an description of the mock is returned For Comparable#compareTo(T other) returns zero if the references are equal, else a non-zero value Else : null is returned.","title":"Mock Behaviour"},{"location":"22FS/PROG2/summary.html#verify-behaviour","text":"Mockito can verify that a method was invoked. For this, the pattern verify(<mock>).<method>(<args>) can be used. With an additional argument of verify, further conditions can be specified. With verify(<mock>, never()).<method>(<args>) can be checked that the method was never invoked. Other condition includes never() , times(int) , atLeastOnce() , atLeast(int) , atMost(int) , timeout(int milliseconds) (that the method is invoked in the given timeout). These conditions can be combined like timeout(10).times(2) Mockito can also verify the order in which methods were called. For this a InOrder object can be created with inOrder(<mockObj>) . On the InOrder object, the verify(...) method can be used. verify ( mockedHalf ). contractAtrium (); verify ( mockedHalf , times ( 2 )). isAtrioventricularValveOpen (); verify ( mockedList , never ()). add ( \"ZHAW\" ); InOrder inOrder = inOrder ( singleMock ); // Verify the order inOrder . verify ( singleMock ). add ( \"second\" ); inOrder . verify ( singleMock ). add ( \"first\" );","title":"Verify Behaviour"},{"location":"22FS/PROG2/summary.html#spies_1","text":"A spy object is created based on a \"real\" object. All methods are delegated to this object, but the behaviour of methods can be selectively changed (similar with mocks) and it can verify than methods were called. It can be created with spy(Object obj) and can be used like a mock. Similar to @Mock the @Spy annotation can be used instead of spy(...) ( MockitoAnnotations.openMocks() needs to be called in the setup method). List list = new LinkedList (); // create a spy on the real object instance List spy = spy ( list ); // stub the size() method when ( spy . size ()). thenReturn ( 100 ); // add() is not stubbed. So it will use the real method spy . add ( \"one\" ); spy . add ( \"two\" ); assertEquals ( \"one\" , spy . get ( 0 )); assertEquals ( 100 , spy . size ());","title":"Spies"},{"location":"22FS/PROG2/summary.html#io","text":"","title":"IO"},{"location":"22FS/PROG2/summary.html#serializing","text":"In order for an object to be serializable in needs to implement the marker interface Serializable . Fields can be marked with transient ( private transient Date someDate; ) if they shouldn't be serialized. This can be usefull for serializing classes which contain unserializable classes (like dates, file descriptor, network sockets or db connections). Employee harry = new Employee ( \"Dirty Harry\" , 50000 , LocalDate . of ( 1967 , 3 , 11 )); Manager boss = new Manager ( \"Walter Smith\" , 80000 , LocalDate . of ( 1950 , 12 , 4 )); // Manager is extending Employee boss . setAssistant ( harry ); // Save (serialize) two objects to the file empolyee.dat try ( ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( \"employee.dat\" ))) { // objects are written in the given order to the file out . writeObject ( harry ); // write object Dirty Harry out . writeObject ( boss ); // write object Walter Smith out . writeInt ( 12 ); // write value of primitive type int } // Load (deserialize) two objects from the file employee.dat try ( ObjectInputStream in = new ObjectInputStream ( new FileInputStream ( \"employee.dat\" ))) { // number and order of reading the objects must match, also the type must be compatible (match or super class) Employee e1 = ( Employee ) in . readObject (); // object for Dirty Harry Employee e2 = ( Employee ) in . readObject (); // object for Walter Smith // e2.getClass().getName() would return type Manager int count = in . readInt (); // read primitive type int }","title":"Serializing"},{"location":"22FS/PROG2/summary.html#io-streams","text":"A byte stream can be converted to a char stream with InputStreamReader and OutputStreamWriter respectively. InputStream and Readers usually allow to skip a number of bytes/chars with skip(long n) . However, OutputStream s and Writer s don't allow removing or inserting into a file, only appending ( FileOutputStream(File file, boolean append) ) or replacing is supported.","title":"IO Streams"},{"location":"22FS/PROG2/summary.html#randomaccessfile","text":"Allows reading from anywhere in the file, not just skipping bytes like an InputStream . This can be done with the seek(long pos) or the skipBytes(long n) methods. // create file and write some data into it File f = new File ( \"randomaccessfile.txt\" ); try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( f , true ))) { for ( int i = 2 ; i <= 10 ; i ++ ) { if ( i % 2 == 0 ) { bw . write ( Integer . toString ( i )); bw . newLine (); } } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"rw\" )) { // read-write mode for ( int i = 1 ; i <= 5 ; i ++ ){ randomFile . seek ( randomFile . length ()); // set file pointer to end of file (EOF) randomFile . writeBytes ( Integer . toString ( i )); // append \"1\",\"2\",\"3\",\"4\",\"5\" at EOF } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"r\" )) { // read-only mode int i = ( int ) randomFile . length (); // get length of file in bytes System . out . println ( \"Length: \" + i ); randomFile . seek ( i - 3 ); // set file pointer to EOF-3 bytes for ( int ct = 0 ; ct < 3 ; ct ++ ){ byte b = randomFile . readByte (); // read byte(s) System . out . println (( char ) b ); } }","title":"RandomAccessFile"},{"location":"22FS/PROG2/summary.html#charset","text":"An instance of Charset can be either obtained by Charset.forName(<name>) , Charset.getDefaultCharset() or Charset.getAvailableCharsets() . Alternatively StandardCharsets.UTF_8 can be used.","title":"Charset"},{"location":"22FS/PROG2/summary.html#logger","text":"Each Logger instance has a list of Handlers . A Handler can be used by multiple Loggers and handles the storing of the logging messages (like writing it to a file, or displaying in the console). Both the Logger and the Handler have a Level. And each will only forward messages which have a level higher than their configured level. The possible levels are: SEVERE(1000) , WARNING(900) , INFO(800) , CONFIG(700) , FINE(500) , FINER(400) , FINEST(300) . The following properties file is an example logging configuration. ## configure handlers java.util.logging.ConsoleHandler.level = ALL ## File handler configuration ## see https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/FileHandler.html java.util.logging.FileHandler.level = ALL # %g = generation number, %u = unique number to resolve conflicts java.util.logging.FileHandler.pattern = log-%g-%u.log # use SimpleFormatter instead of default XMLFormatter java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.FileHandler.encoding = UTF-8 # max log file size in byte before switching to next generation (=1kB); 0 = unlimited java.util.logging.FileHandler.limit = 1024 # max number of generations (%g) before overwriting (5 -> 0..4) java.util.logging.FileHandler.count = 5 java.util.logging.FileHandler.append = true ## configure Formatter (see SimpleFormatter documentation) java.util.logging.SimpleFormatter.format = [%1$tc] %4$s: %5$s {%2$s}%6$s%n ## configure default log level (for all loggers, if not overwritten below) .level = INFO ## configure root logger \"\" handlers = java.util.logging.ConsoleHandler level = INFO ## Application specific logger configuration # loggers starting with \"ch.zhaw.prog2.io\" -> write to console and file and do not forward to parent handlers ch.zhaw.prog2.io.level = FINE ch.zhaw.prog2.io.handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler ch.zhaw.prog2.io.useParentHandlers = false # logger for class ch.zhaw.prog2.io.LogConfiguration ch.zhaw.prog2.io.LogConfiguration.level = FINEST A log configuration can be loaded anytime and all already existing loggers will be updated. InputStream logConfig = this . getClass (). getClassLoader (). getResourceAsStream ( \"log.properties\" ); LogManager . getLogManager (). readConfiguration ( logConfig );","title":"Logger"},{"location":"22FS/SNP/01_C.html","text":"C-Sprache Typen Typ Bytes char 1 Byte int 4 Bytes float 4 Bytes double 8 Bytes Typ Std-Typ Bytes Wertebereich char int8_t 1-Byte/8-Bits -128 bis 127 unsigned char uint8_t 1-Byte/8-Bits 0 bis 255 short int16_t 2-Bytes/16-Bits -32'768 bis 32'767 unsigned short uint16_t 2-Bytes/16-Bits 0 bis 65'535 int int32_t 4-Bytes/32-Bits \\(-2^{31}\\) bis \\(2^{31}-1\\) unsigned int uint32_t 4-Bytes/32-Bits \\(0\\) bis \\(2^{32}-1\\) long int64_t 8-Bytes/64-Bits \\(-2^{63}\\) bis \\(2^{63}-1\\) unsigned long uint64_t 8-Bytes/64-Bits \\(0\\) bis \\(2^{64}-1\\) long double 10-Bytes/80-Bits \\(-1.2\\cdot 10^{4932}\\) bis \\(1.2\\cdot 10^{4932}\\) Eine Dezimalzahl im Code wird als signed int interpretiert eine oktal und hexadezimal Zahl werden als unsigned int interpretiert Wenn eine Zahl zu gross f\u00fcr einen int ist, wird sie als long abgespeichert mit L oder l nach einer Zahl als long interpretiert mit LL oder ll wird eine Zahl als long long interpretiert wird U oder u wird eine Zahl als unsigned int interpretiert Preprocessor #define Mit #define wird eine Variable definiert, welche w\u00e4hrend der Kompilierzeit ersetzt werden. Der Syntax ist der folgende: #define NAME <value> Ein Macro darf zus\u00e4tzlich auch Parameter enthalten. Diese Parameter haben keinen Typ, wie z.B. #define circleArea(R) (3.1415*(R)*(R)) Main Die Main-Methode in C hat eine der folgenden formen: void main ( void ); int main ( void ); void main ( int argc , char ** argv ); int main ( int argc , char ** argv ) Definitionen static-Variable Eine static variable ist nur Sichtbar im definierten C File. Zus\u00e4tzlich dazu wird die Variable im Daten-Header in der Memory gespeichert. Wenn eine statische Variable in einer Methode definiert wird, behaltet sie \u00fcber mehrere Aufrufe ihren Wert. int max ( int a ) { static int maxValue = 0 ; if ( a > maxValue ) { maxValue = a } return maxValue ; } In diesem Beispiel behaltet maxValue den Wert, auch wenn max mehrmals aufgerufen wird. Der Initialwert wird nur einmal gesetzt. Register-Variabeln Der Compiler versucht die Variable in einem Register zu speichert. Dies wird heute nicht mehr verwendet, da der Compiler dies selbst sehr gut optimieren kann. Extern-Variabeln Der Compiler geht davon aus, dass die Variable in einem anderen File definiert ist. Auto-Variabeln Die Variable wird auf dem Stack gespeichert. Dies wird heute nicht mehr verwendet, da der Compiler dies selbst optimieren kann. Konstante // ein konstanter Pointer zu einer int-Variable int * const i1 ; // ein Pointer zu einer konstanter int-Variable const int * i2 ; // ein konstanter Pointer zu einer konstanter int-Variable const int * const i3 ; // Ausnahme bei typedef Pointers typdef int * int_pntr ; // ein konstanter Pointer zu einer variablen int-Variable const int_pntr i4 ; // das selbe, wie oben int_pntr const i5 ; Typ-Alias Enum Mit enum week {Monday, Tuesday, Wendsday}; kann ein neues Enum erstellt werden. Wenn das Enum ohne Typedef erstellt wurde, kann es mit enum week verwendet werden ( enum week weekday_name; ). Wenn man daf\u00fcr zu schreibfaul ist, kann mit typeder enum week {Monday, Tuesday, Wendsday} week_t; ein Typalias week_t erstellt werden, welcher anstatt enum week verwendet werden kann. Funktionen als Variable Die Funktion void logger(char * msg) kann in der Variable mit der Definition void (*out)(char *) . Sobald zwei Klammern in der Definition einer Variablen stehen, geht es meistens um eine Funktion. Die Zuweissung kann mit out = &logger oder auch out = logger zu gewiessen weden. Dabei machen die beiden Zuweissungen dasselbe. Der Compiler ist beim zweiten schlau genug, die Adresse der Funktion zu speichern. (*out)(\"Hello\") oder out(\"Hello\") machen beide dasselbe: Sie rufen die Funktion in out aus. Der Compiler automatisch dereferenziert das zweite Beispiel.` Mit typedef void (*logger_fp_t)(char*) kann ein Typalias f\u00fcr eine Funktion erstellt werden. Danach kann logger_fp_t als Typ verwendet werden ( logger_fp_t logger_fun = logger ). Arrays Ein Array ist ein Datenblock im Speicher, welcher kontinuierlich ist. Der Variabelnnamen eines Arrays (ohne Klammern), ist ein Pointer und kann zu einem Pointer zu gewissen werden: int arr[4]; int* arrPointer = arr; Ein Array kann folgendermassen erstellt werden; int data[100] - das Array wird alloziert, aber nicht initialisiert int data[100] = {1} - das Array wird alloziert, das erste Element wird 1 und der Rest auf 0 (nur int data[] = {} ist ein Compilerfehler) int data[] = {1, 2} - Ein neues Array mit der L\u00e4nge 2 und den Elementen 1 und 2 Mit data[7] kann auf den 7. Wert zu gegriffen werden. Es gibt C typischerweisse kein Check, ob das Array gen\u00fcgend gross ist. Ein Konstantes Array ( const int data[100] ) kann nicht modifiziert wird. Dies wird vom Compiler \u00fcberpr\u00fcft. Wenn ein Array als Parameter \u00fcbergeben wird, wird der Pointer zum Startwert \u00fcbergeben. Auf der Funktionsseite w\u00fcrde man es folgendermassen schreiben: void arrayParamter ( int [] data ) { // do stuff with data } In der Funktion weiss man nicht, wie lange das Array ist ( sizeof(data) gibt die Gr\u00f6sse des Pointers des Arrays, wenn es als Parameter \u00fcbergeben wird). L\u00e4nge Tricks bei Arrays Wenn das Array im selben Block alloziert wurde, kann sizeof(data)/sizeof(data[0]) die Gr\u00f6sse errechnet werden Die L\u00e4nge wird als Parameter ebenfalls mitgegeben void arrayParameter ( int [] data , size_t size ); int a [ 100 ]; size_t n = sizeof ( a ) / sizeof ( a [ 0 ]); arrayParameter ( a , n ); Es gibt ein Sentry Wert (wie \\0 bei Strings/char Arrays) Arrays vergleichen Mit a == b , wenn a und b ein Arrays ist, vergleicht die Start-Adressen des Arrays, nicht die Elemente selbst. F\u00fcr \"normale\" Arrays gibt es keine standardt Methode, welche der Inhalt von Arrays vergleicht. F\u00fcr String gibt es int strcomp(char *s1, char *s2) , welche 0 zur\u00fcck gibt, wenn die Strings gleich sind, -1 , wenn s1 kleiner ist als s2 und 1 , wenn s1 gr\u00f6sser als s2 ist. Mehrdimensionale Arrays int data [ 2 ][ 3 ] = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; data [ 1 ][ 2 ] // gibt 5 zur\u00fcck In C k\u00f6nnen Mehrdimensionale Arrays erstellt. Diese k\u00f6nnen \"normal\" darauf zugegrifen werden. Strings Strings in C sind Char-Arrays, welche am Ende ein \\0 haben. Dabei k\u00f6nnen ASCI-Zeichen (nicht UTF-8) in einem String stehen. char hello1 [] = \"hello, world\" ; // Array mit 13 Zeichen char hello2 [ 13 ] = \"hello, world\" ; // Array mit 13 Zeichen char hello3 [ 14 ] = \"hello, world\" ; // Array mit 14 Zeichen. Am ende hat es zwei \\0 char hello4 [ 12 ] = \"hello, world\" ; // Array mit 12 Zeichen, aber das \\0 fehlt am ende char hello5 [ 13 ]; // Array mit 13 Zeichen. Wird nicht initialisiert Wenn das \\0 am ende eines Strings fehlt, werden die String-Funktionen einfach weiter lesen, bis ein \\0 im Speicher gefunden wird. Meistens f\u00fchrt dies zu einem Crash. mit strncpy() und strncat() k\u00f6nnen mit String String-Literale wird in Read-Only Teil des Programmes gespeichert und kann daher nicht modifiziert werden. Ein String-Literal kann dazu ben\u00fctzt werden, ein char-Array zu erstellen, welches ge\u00e4ndert werden kann. char * str_literal = \"test\" ; str_literal [ 0 ] = 'H' ; // undefined behaviour. str_literal points to read-only memory char [] str_arr = \"test\" ; // copies the string_literal to the array str_arr [ 0 ] = 'H' ; // works Gross-/Kleinbuchstaben 'a' & '_' == 'A' ; // 0b0110 0001 & 0b0101 1111 = 0b0100 0001 'A' & '_' == 'A' ; 'A' | ' ' == 'a' ; // 0b0100 0001 | 0b0010 0000 = 0b0110 0001 'a' | ' ' == 'a' ; Pointers int data [ 4 ]; int * pointer = data ; // da data[] bereits ein Pointer ist, kann er direkt zugewissen werden pointer ++ ; // geht zur n\u00e4chsten Addresse 4 Bytes weiter, da ein int 4 bytes lang ist int value = * pointer ; // mit *<pointerVar> wird der Pointer dereferenziert int intVar = 1 ; pointer = & intVar ; // setzt die Adresse von intVar zu dem Pointer * pointer = intVar ; // setzt die Adresse von intVar zu dem Pointer double ** pointerZuPointer ; // ein Meehrdimensionalen Pointer double * pointer , notPointer ; // erstellt ein Double-Pointer und ein Double-Variable int i2 = dataPointer -> nr ; // dereferenziert den Pointer zu einem Struct und gibt nr zur\u00fcck Ein Pointer kann mit int* data erstellt werden. Ein Pointer ist eine Adresse, mit welcher gerechnet werden kann. Um den Wert eines Pointers zu bekommen, muss er dereferenziert werden. Dies kann mit *data bewerkstelligt werden. Wenn man die Adresse einer Variable bekommen m\u00f6chte, kann man diese mit &variable bekommen und z.B. einem Pointer zu weisen. Ein Pointer kann man eine Adresse zu weissen ( pointer = &variable ), ebenfalls kann ein dereferenzierten Pointer zu gewissen werden ( *pointer = variable ). Beides funktioniert und bewerkstelligt dasselbe. double *d1[20] ist ein Array von 20 Double-Pointers, hingegen double (*d2)[20] ist ein Pointer auf ein Array von Double-Elementen. Presedenz von * double * d1 [ 20 ]; // ein Array von 20 Pointern auf Doubles double ( * d2 )[ 20 ]; // ein Pointer auf ein Array von 20 Double Elemente struct data { int nr ;} struct data * dataPointer , dataObj ; * dataPointer = dataObj ; int i1 = ( * dataPointer ). nr ; // *dataPointer.nr w\u00fcrde dataPointer.nr dereferenzieren int i2 = dataPointer -> nr ; // macht dasselbe, wie oben Void-Pointers Pointers haben immer einen Daten-Typ. Die einzige Ausnahme ist der void-pointer NULL-Pointer Der Pointer NULL (von stdio.h ) ist ein Alias f\u00fcr die Adresse f\u00fcr 0 und heisst, dass der Pointer auf nichts zeigt. Er soll zur Dokumentation Speicher allozieren Wenn ein neues Objekt erzeugt wird (z.B. ein int , aber auch ein struct oder ein array ), dann wird dies auf dem Stack gespeichert. Mit Methoden, wie malloc(size_t) k\u00f6nnen aber auch Daten auf dem Heap gespeichert werden. Methode Erkl\u00e4rung void* malloc(size_t size) Alloziert speicher auf dem Heap void* calloc(size_t nsize, size_t size) void* realloc(void *ptr, size_t size) Setzt die Gr\u00f6sse des gegebenen Pointers auf die gegebene Gr\u00f6sse void free(void *ptr) Gibt allozierten Speicher an der gegebenen Adresse wieder frei Methoden Funktions-Parameter Standardm\u00e4ssig werden alle Parameter by value \u00fcbergeben. Falls dies nicht gewollt ist, m\u00fcssen Pointers verwendet werden. const-Parameter void write_int(const int a) bewirkt, dass a nicht in der Methode ver\u00e4ndert werden kann. Es ist nat\u00fcrlich erlaubt einen konstanten Pointer zu definieren ( void write_char(const char *s) ). Dabei kann der Pointer selbst ( a = NULL ), wie auch der Wert des Pointers ( *a=5 ) nicht mehr ge\u00e4ndert werden. Die konstante Variable darf nicht im linken Teil einer Zuweisung stehen. Array Parameter void write_array(int* a) ist dasselbe, wie void write_array(int a[]) . In beiden F\u00e4llen weiss die aufgerufene Methode nicht, wie gross das Array a ist. Auch bei Arrays k\u00f6nnen mit const ausgestatet werden ( void array_method(const int a[]) ) Bei Mehrdimensionalen Arrays m\u00fcssen alle Dimensionen, ausser die erste, angegeben werden: void print_matrx(double matrix[][3]) oder print_matrix(double (*matrix)[3]) . Variable Anzahl Parameter #include <stdarg.h> int average ( unsigned int anzahl , ...) { va_list args ; int summe = 0 ; va_start ( args , anzahl ); // beginnt bei 1, da das 0. Argument `anzahl` ist for ( int i = 1 ; i <= anzahl ; i ++ ) { summe += va_arg ( args , int ); } va_end ( args ); return summe / anzahl ; } Damit eine Funktion eine Variable Anzahl von Parameter ben\u00fctzten kann, muss stdarg.h inkludiert sein. Auf die Argumente kann mit der Struktur va_list zugegriffen werden. Diese Struktur muss mit va_start(va_list args, int numberOfArgs) initialisiert werden und mit va_end(va_list args) gel\u00f6scht werden. Der eigentliche Wert kann mit va_arg(va_list args, type) zugegriffen werden. R\u00fcckgabe Wenn ein Pointer zur\u00fcck gegeben wird, muss die Variable auf dem Heap gespeichert sein. Folgendes Beispiel w\u00fcrde nicht funktionieren int * create_array () { int arr [ 10 ]; return arr ; } Fehler Stack-Overflow: Auf dem Stack hat es nicht mehr gen\u00fcgend platz Buffer-Overflow: Wenn ein Buffer (z.B. ein Array) \u00fcber die Grenze \u00fcberschrieben werden Sichererers Programmieren fgets() anstatt gets() strncpy() und strncat() anstatt strcpy() und strcat() Bei malloc() immer \u00fcberpr\u00fcfen, ob der Speicher wirklich alloziert wurde Header Files In einem Header File stehen Funktions-Deklarationen (ohne Code), Structs, Enums, #define und weitere Definitionen. Diese k\u00f6nnen in einem *.c File includiert werden und der Compiler weiss, dass es diese Funktionen und Daten-Typen gibt. Ein Headerfile sollte noch folgendes Boiler-Template haben: #ifndef DEF_H #define DEF_H int add ( int , int ); int sub ( int , int ); #endif Dies verhindert, dass das Headerfile zwei mal etwas definiert. Bin\u00e4r Operatoren Op Erkl\u00e4rung Beispiel & und 0101 & 0100 = 0100 | oder 0101 & 0010 = 0111 ^ xor 0101 ^ 0100 = 0001 ~ invert ~0101 = 1010 >> right shift 0100 >> 2 = 0001 << left shift 0001 << 2 = 0100 Tipps Variablen tauschen Um zwei Variablen zu tauschen, kann drei mal geXORed werden: int a = 2 ; //0010 int b = 4 ; //0100 a = a ^ b ; //0110 b = a ^ b ; //0010 a = a ^ b ; //0100","title":"C-Sprache"},{"location":"22FS/SNP/01_C.html#c-sprache","text":"","title":"C-Sprache"},{"location":"22FS/SNP/01_C.html#typen","text":"Typ Bytes char 1 Byte int 4 Bytes float 4 Bytes double 8 Bytes Typ Std-Typ Bytes Wertebereich char int8_t 1-Byte/8-Bits -128 bis 127 unsigned char uint8_t 1-Byte/8-Bits 0 bis 255 short int16_t 2-Bytes/16-Bits -32'768 bis 32'767 unsigned short uint16_t 2-Bytes/16-Bits 0 bis 65'535 int int32_t 4-Bytes/32-Bits \\(-2^{31}\\) bis \\(2^{31}-1\\) unsigned int uint32_t 4-Bytes/32-Bits \\(0\\) bis \\(2^{32}-1\\) long int64_t 8-Bytes/64-Bits \\(-2^{63}\\) bis \\(2^{63}-1\\) unsigned long uint64_t 8-Bytes/64-Bits \\(0\\) bis \\(2^{64}-1\\) long double 10-Bytes/80-Bits \\(-1.2\\cdot 10^{4932}\\) bis \\(1.2\\cdot 10^{4932}\\) Eine Dezimalzahl im Code wird als signed int interpretiert eine oktal und hexadezimal Zahl werden als unsigned int interpretiert Wenn eine Zahl zu gross f\u00fcr einen int ist, wird sie als long abgespeichert mit L oder l nach einer Zahl als long interpretiert mit LL oder ll wird eine Zahl als long long interpretiert wird U oder u wird eine Zahl als unsigned int interpretiert","title":"Typen"},{"location":"22FS/SNP/01_C.html#preprocessor","text":"","title":"Preprocessor"},{"location":"22FS/SNP/01_C.html#define","text":"Mit #define wird eine Variable definiert, welche w\u00e4hrend der Kompilierzeit ersetzt werden. Der Syntax ist der folgende: #define NAME <value> Ein Macro darf zus\u00e4tzlich auch Parameter enthalten. Diese Parameter haben keinen Typ, wie z.B. #define circleArea(R) (3.1415*(R)*(R))","title":"#define"},{"location":"22FS/SNP/01_C.html#main","text":"Die Main-Methode in C hat eine der folgenden formen: void main ( void ); int main ( void ); void main ( int argc , char ** argv ); int main ( int argc , char ** argv )","title":"Main"},{"location":"22FS/SNP/01_C.html#definitionen","text":"","title":"Definitionen"},{"location":"22FS/SNP/01_C.html#static-variable","text":"Eine static variable ist nur Sichtbar im definierten C File. Zus\u00e4tzlich dazu wird die Variable im Daten-Header in der Memory gespeichert. Wenn eine statische Variable in einer Methode definiert wird, behaltet sie \u00fcber mehrere Aufrufe ihren Wert. int max ( int a ) { static int maxValue = 0 ; if ( a > maxValue ) { maxValue = a } return maxValue ; } In diesem Beispiel behaltet maxValue den Wert, auch wenn max mehrmals aufgerufen wird. Der Initialwert wird nur einmal gesetzt.","title":"static-Variable"},{"location":"22FS/SNP/01_C.html#register-variabeln","text":"Der Compiler versucht die Variable in einem Register zu speichert. Dies wird heute nicht mehr verwendet, da der Compiler dies selbst sehr gut optimieren kann.","title":"Register-Variabeln"},{"location":"22FS/SNP/01_C.html#extern-variabeln","text":"Der Compiler geht davon aus, dass die Variable in einem anderen File definiert ist.","title":"Extern-Variabeln"},{"location":"22FS/SNP/01_C.html#auto-variabeln","text":"Die Variable wird auf dem Stack gespeichert. Dies wird heute nicht mehr verwendet, da der Compiler dies selbst optimieren kann.","title":"Auto-Variabeln"},{"location":"22FS/SNP/01_C.html#konstante","text":"// ein konstanter Pointer zu einer int-Variable int * const i1 ; // ein Pointer zu einer konstanter int-Variable const int * i2 ; // ein konstanter Pointer zu einer konstanter int-Variable const int * const i3 ; // Ausnahme bei typedef Pointers typdef int * int_pntr ; // ein konstanter Pointer zu einer variablen int-Variable const int_pntr i4 ; // das selbe, wie oben int_pntr const i5 ;","title":"Konstante"},{"location":"22FS/SNP/01_C.html#typ-alias","text":"","title":"Typ-Alias"},{"location":"22FS/SNP/01_C.html#enum","text":"Mit enum week {Monday, Tuesday, Wendsday}; kann ein neues Enum erstellt werden. Wenn das Enum ohne Typedef erstellt wurde, kann es mit enum week verwendet werden ( enum week weekday_name; ). Wenn man daf\u00fcr zu schreibfaul ist, kann mit typeder enum week {Monday, Tuesday, Wendsday} week_t; ein Typalias week_t erstellt werden, welcher anstatt enum week verwendet werden kann.","title":"Enum"},{"location":"22FS/SNP/01_C.html#funktionen-als-variable","text":"Die Funktion void logger(char * msg) kann in der Variable mit der Definition void (*out)(char *) . Sobald zwei Klammern in der Definition einer Variablen stehen, geht es meistens um eine Funktion. Die Zuweissung kann mit out = &logger oder auch out = logger zu gewiessen weden. Dabei machen die beiden Zuweissungen dasselbe. Der Compiler ist beim zweiten schlau genug, die Adresse der Funktion zu speichern. (*out)(\"Hello\") oder out(\"Hello\") machen beide dasselbe: Sie rufen die Funktion in out aus. Der Compiler automatisch dereferenziert das zweite Beispiel.` Mit typedef void (*logger_fp_t)(char*) kann ein Typalias f\u00fcr eine Funktion erstellt werden. Danach kann logger_fp_t als Typ verwendet werden ( logger_fp_t logger_fun = logger ).","title":"Funktionen als Variable"},{"location":"22FS/SNP/01_C.html#arrays","text":"Ein Array ist ein Datenblock im Speicher, welcher kontinuierlich ist. Der Variabelnnamen eines Arrays (ohne Klammern), ist ein Pointer und kann zu einem Pointer zu gewissen werden: int arr[4]; int* arrPointer = arr; Ein Array kann folgendermassen erstellt werden; int data[100] - das Array wird alloziert, aber nicht initialisiert int data[100] = {1} - das Array wird alloziert, das erste Element wird 1 und der Rest auf 0 (nur int data[] = {} ist ein Compilerfehler) int data[] = {1, 2} - Ein neues Array mit der L\u00e4nge 2 und den Elementen 1 und 2 Mit data[7] kann auf den 7. Wert zu gegriffen werden. Es gibt C typischerweisse kein Check, ob das Array gen\u00fcgend gross ist. Ein Konstantes Array ( const int data[100] ) kann nicht modifiziert wird. Dies wird vom Compiler \u00fcberpr\u00fcft. Wenn ein Array als Parameter \u00fcbergeben wird, wird der Pointer zum Startwert \u00fcbergeben. Auf der Funktionsseite w\u00fcrde man es folgendermassen schreiben: void arrayParamter ( int [] data ) { // do stuff with data } In der Funktion weiss man nicht, wie lange das Array ist ( sizeof(data) gibt die Gr\u00f6sse des Pointers des Arrays, wenn es als Parameter \u00fcbergeben wird).","title":"Arrays"},{"location":"22FS/SNP/01_C.html#lange-tricks-bei-arrays","text":"Wenn das Array im selben Block alloziert wurde, kann sizeof(data)/sizeof(data[0]) die Gr\u00f6sse errechnet werden Die L\u00e4nge wird als Parameter ebenfalls mitgegeben void arrayParameter ( int [] data , size_t size ); int a [ 100 ]; size_t n = sizeof ( a ) / sizeof ( a [ 0 ]); arrayParameter ( a , n ); Es gibt ein Sentry Wert (wie \\0 bei Strings/char Arrays)","title":"L\u00e4nge Tricks bei Arrays"},{"location":"22FS/SNP/01_C.html#arrays-vergleichen","text":"Mit a == b , wenn a und b ein Arrays ist, vergleicht die Start-Adressen des Arrays, nicht die Elemente selbst. F\u00fcr \"normale\" Arrays gibt es keine standardt Methode, welche der Inhalt von Arrays vergleicht. F\u00fcr String gibt es int strcomp(char *s1, char *s2) , welche 0 zur\u00fcck gibt, wenn die Strings gleich sind, -1 , wenn s1 kleiner ist als s2 und 1 , wenn s1 gr\u00f6sser als s2 ist.","title":"Arrays vergleichen"},{"location":"22FS/SNP/01_C.html#mehrdimensionale-arrays","text":"int data [ 2 ][ 3 ] = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; data [ 1 ][ 2 ] // gibt 5 zur\u00fcck In C k\u00f6nnen Mehrdimensionale Arrays erstellt. Diese k\u00f6nnen \"normal\" darauf zugegrifen werden.","title":"Mehrdimensionale Arrays"},{"location":"22FS/SNP/01_C.html#strings","text":"Strings in C sind Char-Arrays, welche am Ende ein \\0 haben. Dabei k\u00f6nnen ASCI-Zeichen (nicht UTF-8) in einem String stehen. char hello1 [] = \"hello, world\" ; // Array mit 13 Zeichen char hello2 [ 13 ] = \"hello, world\" ; // Array mit 13 Zeichen char hello3 [ 14 ] = \"hello, world\" ; // Array mit 14 Zeichen. Am ende hat es zwei \\0 char hello4 [ 12 ] = \"hello, world\" ; // Array mit 12 Zeichen, aber das \\0 fehlt am ende char hello5 [ 13 ]; // Array mit 13 Zeichen. Wird nicht initialisiert Wenn das \\0 am ende eines Strings fehlt, werden die String-Funktionen einfach weiter lesen, bis ein \\0 im Speicher gefunden wird. Meistens f\u00fchrt dies zu einem Crash. mit strncpy() und strncat() k\u00f6nnen mit String String-Literale wird in Read-Only Teil des Programmes gespeichert und kann daher nicht modifiziert werden. Ein String-Literal kann dazu ben\u00fctzt werden, ein char-Array zu erstellen, welches ge\u00e4ndert werden kann. char * str_literal = \"test\" ; str_literal [ 0 ] = 'H' ; // undefined behaviour. str_literal points to read-only memory char [] str_arr = \"test\" ; // copies the string_literal to the array str_arr [ 0 ] = 'H' ; // works","title":"Strings"},{"location":"22FS/SNP/01_C.html#gross-kleinbuchstaben","text":"'a' & '_' == 'A' ; // 0b0110 0001 & 0b0101 1111 = 0b0100 0001 'A' & '_' == 'A' ; 'A' | ' ' == 'a' ; // 0b0100 0001 | 0b0010 0000 = 0b0110 0001 'a' | ' ' == 'a' ;","title":"Gross-/Kleinbuchstaben"},{"location":"22FS/SNP/01_C.html#pointers","text":"int data [ 4 ]; int * pointer = data ; // da data[] bereits ein Pointer ist, kann er direkt zugewissen werden pointer ++ ; // geht zur n\u00e4chsten Addresse 4 Bytes weiter, da ein int 4 bytes lang ist int value = * pointer ; // mit *<pointerVar> wird der Pointer dereferenziert int intVar = 1 ; pointer = & intVar ; // setzt die Adresse von intVar zu dem Pointer * pointer = intVar ; // setzt die Adresse von intVar zu dem Pointer double ** pointerZuPointer ; // ein Meehrdimensionalen Pointer double * pointer , notPointer ; // erstellt ein Double-Pointer und ein Double-Variable int i2 = dataPointer -> nr ; // dereferenziert den Pointer zu einem Struct und gibt nr zur\u00fcck Ein Pointer kann mit int* data erstellt werden. Ein Pointer ist eine Adresse, mit welcher gerechnet werden kann. Um den Wert eines Pointers zu bekommen, muss er dereferenziert werden. Dies kann mit *data bewerkstelligt werden. Wenn man die Adresse einer Variable bekommen m\u00f6chte, kann man diese mit &variable bekommen und z.B. einem Pointer zu weisen. Ein Pointer kann man eine Adresse zu weissen ( pointer = &variable ), ebenfalls kann ein dereferenzierten Pointer zu gewissen werden ( *pointer = variable ). Beides funktioniert und bewerkstelligt dasselbe. double *d1[20] ist ein Array von 20 Double-Pointers, hingegen double (*d2)[20] ist ein Pointer auf ein Array von Double-Elementen.","title":"Pointers"},{"location":"22FS/SNP/01_C.html#presedenz-von","text":"double * d1 [ 20 ]; // ein Array von 20 Pointern auf Doubles double ( * d2 )[ 20 ]; // ein Pointer auf ein Array von 20 Double Elemente struct data { int nr ;} struct data * dataPointer , dataObj ; * dataPointer = dataObj ; int i1 = ( * dataPointer ). nr ; // *dataPointer.nr w\u00fcrde dataPointer.nr dereferenzieren int i2 = dataPointer -> nr ; // macht dasselbe, wie oben","title":"Presedenz von *"},{"location":"22FS/SNP/01_C.html#void-pointers","text":"Pointers haben immer einen Daten-Typ. Die einzige Ausnahme ist der void-pointer","title":"Void-Pointers"},{"location":"22FS/SNP/01_C.html#null-pointer","text":"Der Pointer NULL (von stdio.h ) ist ein Alias f\u00fcr die Adresse f\u00fcr 0 und heisst, dass der Pointer auf nichts zeigt. Er soll zur Dokumentation","title":"NULL-Pointer"},{"location":"22FS/SNP/01_C.html#speicher-allozieren","text":"Wenn ein neues Objekt erzeugt wird (z.B. ein int , aber auch ein struct oder ein array ), dann wird dies auf dem Stack gespeichert. Mit Methoden, wie malloc(size_t) k\u00f6nnen aber auch Daten auf dem Heap gespeichert werden. Methode Erkl\u00e4rung void* malloc(size_t size) Alloziert speicher auf dem Heap void* calloc(size_t nsize, size_t size) void* realloc(void *ptr, size_t size) Setzt die Gr\u00f6sse des gegebenen Pointers auf die gegebene Gr\u00f6sse void free(void *ptr) Gibt allozierten Speicher an der gegebenen Adresse wieder frei","title":"Speicher allozieren"},{"location":"22FS/SNP/01_C.html#methoden","text":"","title":"Methoden"},{"location":"22FS/SNP/01_C.html#funktions-parameter","text":"Standardm\u00e4ssig werden alle Parameter by value \u00fcbergeben. Falls dies nicht gewollt ist, m\u00fcssen Pointers verwendet werden.","title":"Funktions-Parameter"},{"location":"22FS/SNP/01_C.html#const-parameter","text":"void write_int(const int a) bewirkt, dass a nicht in der Methode ver\u00e4ndert werden kann. Es ist nat\u00fcrlich erlaubt einen konstanten Pointer zu definieren ( void write_char(const char *s) ). Dabei kann der Pointer selbst ( a = NULL ), wie auch der Wert des Pointers ( *a=5 ) nicht mehr ge\u00e4ndert werden. Die konstante Variable darf nicht im linken Teil einer Zuweisung stehen.","title":"const-Parameter"},{"location":"22FS/SNP/01_C.html#array-parameter","text":"void write_array(int* a) ist dasselbe, wie void write_array(int a[]) . In beiden F\u00e4llen weiss die aufgerufene Methode nicht, wie gross das Array a ist. Auch bei Arrays k\u00f6nnen mit const ausgestatet werden ( void array_method(const int a[]) ) Bei Mehrdimensionalen Arrays m\u00fcssen alle Dimensionen, ausser die erste, angegeben werden: void print_matrx(double matrix[][3]) oder print_matrix(double (*matrix)[3]) .","title":"Array Parameter"},{"location":"22FS/SNP/01_C.html#variable-anzahl-parameter","text":"#include <stdarg.h> int average ( unsigned int anzahl , ...) { va_list args ; int summe = 0 ; va_start ( args , anzahl ); // beginnt bei 1, da das 0. Argument `anzahl` ist for ( int i = 1 ; i <= anzahl ; i ++ ) { summe += va_arg ( args , int ); } va_end ( args ); return summe / anzahl ; } Damit eine Funktion eine Variable Anzahl von Parameter ben\u00fctzten kann, muss stdarg.h inkludiert sein. Auf die Argumente kann mit der Struktur va_list zugegriffen werden. Diese Struktur muss mit va_start(va_list args, int numberOfArgs) initialisiert werden und mit va_end(va_list args) gel\u00f6scht werden. Der eigentliche Wert kann mit va_arg(va_list args, type) zugegriffen werden.","title":"Variable Anzahl Parameter"},{"location":"22FS/SNP/01_C.html#ruckgabe","text":"Wenn ein Pointer zur\u00fcck gegeben wird, muss die Variable auf dem Heap gespeichert sein. Folgendes Beispiel w\u00fcrde nicht funktionieren int * create_array () { int arr [ 10 ]; return arr ; }","title":"R\u00fcckgabe"},{"location":"22FS/SNP/01_C.html#fehler","text":"Stack-Overflow: Auf dem Stack hat es nicht mehr gen\u00fcgend platz Buffer-Overflow: Wenn ein Buffer (z.B. ein Array) \u00fcber die Grenze \u00fcberschrieben werden","title":"Fehler"},{"location":"22FS/SNP/01_C.html#sichererers-programmieren","text":"fgets() anstatt gets() strncpy() und strncat() anstatt strcpy() und strcat() Bei malloc() immer \u00fcberpr\u00fcfen, ob der Speicher wirklich alloziert wurde","title":"Sichererers Programmieren"},{"location":"22FS/SNP/01_C.html#header-files","text":"In einem Header File stehen Funktions-Deklarationen (ohne Code), Structs, Enums, #define und weitere Definitionen. Diese k\u00f6nnen in einem *.c File includiert werden und der Compiler weiss, dass es diese Funktionen und Daten-Typen gibt. Ein Headerfile sollte noch folgendes Boiler-Template haben: #ifndef DEF_H #define DEF_H int add ( int , int ); int sub ( int , int ); #endif Dies verhindert, dass das Headerfile zwei mal etwas definiert.","title":"Header Files"},{"location":"22FS/SNP/01_C.html#binar-operatoren","text":"Op Erkl\u00e4rung Beispiel & und 0101 & 0100 = 0100 | oder 0101 & 0010 = 0111 ^ xor 0101 ^ 0100 = 0001 ~ invert ~0101 = 1010 >> right shift 0100 >> 2 = 0001 << left shift 0001 << 2 = 0100","title":"Bin\u00e4r Operatoren"},{"location":"22FS/SNP/01_C.html#tipps","text":"","title":"Tipps"},{"location":"22FS/SNP/01_C.html#variablen-tauschen","text":"Um zwei Variablen zu tauschen, kann drei mal geXORed werden: int a = 2 ; //0010 int b = 4 ; //0100 a = a ^ b ; //0110 b = a ^ b ; //0010 a = a ^ b ; //0100","title":"Variablen tauschen"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html","text":"Preprocessor und Compiler Preprocessor Der Preprocessor ist eine Textmaschine, welche Text ersetzten, einf\u00fcgen und l\u00f6schen kann. Wenn man den Output nach den Preprocesser sehen m\u00f6chte, kann man dies mit: gcc -E <path> #define und #undef Mit #define VARNAME <value> kann eine Konstante definiert werden, welche vom Preprocessor ersetzt wird. Mit #undef VARNAME kann eine Konstante wieder gel\u00f6scht werden Mit gcc -DVARNAME kann eine Konstante definiert werden. Dies kann hilfreich f\u00fcr die #ifdef Anweisungen sein. #include #include <header.h> importiert ein Headerfile, welches mit dem Compiler mit kommt, bzw. beim OS installiert sind #include \"header.h\" importiert ein Headerfile, welches im selbe Verzeichnis, wie das File, in welchem die Anweisung steht. #if , #elif , #else , endif , #ifdef und #ifndef Mit diesen Anweissungen kann gewissen Code beim Kompilieren ignoriert werden. Beim folgenden Beispiel wird der Debugging Output nur ausgegeben, wenn DEBUG definiert ist. Die selbe Anweissung k\u00f6nne man auch mit #ifdef DEBUG schreiben. #if defined DEBUG printf ( \"Program Version 1 (Debugging) \\n \" ); #else printf ( \"Programm Version 1 (Production) \\n \" ); #endif Mit gcc -DVARNAME kann eine Konstante definiert werden. Compiler Es kann nur den Compiler (und Preprocessor) mit gcc -c <path_to_file> aufgerufen werden. Dies produziert ein *.o File. In diesem gibt es noch Referenzen zu anderen Modulen und Files. Linker Der Linker kombiniert alle *.o Files in eine ausf\u00fchrbare Datei und l\u00f6st die Referenzen im *.o File aufzul\u00f6sen. Wenn gcc mit *.o Files aufgerufen wird, wird der Linker ben\u00fctzt (Befehl gcc *.o ).","title":"Preprocessor und Compiler"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#preprocessor-und-compiler","text":"","title":"Preprocessor und Compiler"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#preprocessor","text":"Der Preprocessor ist eine Textmaschine, welche Text ersetzten, einf\u00fcgen und l\u00f6schen kann. Wenn man den Output nach den Preprocesser sehen m\u00f6chte, kann man dies mit: gcc -E <path>","title":"Preprocessor"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#define-und-undef","text":"Mit #define VARNAME <value> kann eine Konstante definiert werden, welche vom Preprocessor ersetzt wird. Mit #undef VARNAME kann eine Konstante wieder gel\u00f6scht werden Mit gcc -DVARNAME kann eine Konstante definiert werden. Dies kann hilfreich f\u00fcr die #ifdef Anweisungen sein.","title":"#define und #undef"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#include","text":"#include <header.h> importiert ein Headerfile, welches mit dem Compiler mit kommt, bzw. beim OS installiert sind #include \"header.h\" importiert ein Headerfile, welches im selbe Verzeichnis, wie das File, in welchem die Anweisung steht.","title":"#include"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#if-elif-else-endif-ifdef-und-ifndef","text":"Mit diesen Anweissungen kann gewissen Code beim Kompilieren ignoriert werden. Beim folgenden Beispiel wird der Debugging Output nur ausgegeben, wenn DEBUG definiert ist. Die selbe Anweissung k\u00f6nne man auch mit #ifdef DEBUG schreiben. #if defined DEBUG printf ( \"Program Version 1 (Debugging) \\n \" ); #else printf ( \"Programm Version 1 (Production) \\n \" ); #endif Mit gcc -DVARNAME kann eine Konstante definiert werden.","title":"#if, #elif, #else, endif, #ifdef und #ifndef"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#compiler","text":"Es kann nur den Compiler (und Preprocessor) mit gcc -c <path_to_file> aufgerufen werden. Dies produziert ein *.o File. In diesem gibt es noch Referenzen zu anderen Modulen und Files.","title":"Compiler"},{"location":"22FS/SNP/02_Preprocessor%20und%20Compiler.html#linker","text":"Der Linker kombiniert alle *.o Files in eine ausf\u00fchrbare Datei und l\u00f6st die Referenzen im *.o File aufzul\u00f6sen. Wenn gcc mit *.o Files aufgerufen wird, wird der Linker ben\u00fctzt (Befehl gcc *.o ).","title":"Linker"},{"location":"22FS/SNP/03_Make.html","text":"Make Makefile Grunds\u00e4tzlichen Syntax: .PHONE : < targets , welche keine File sind > target : dependency 1 dependency 2 cmd target ist ein Befehl und den Output des Befehles. Dieser kann mit make target aufgerufen wird. dependencies ist eine Liste von Abh\u00e4ngikeiten. Diese m\u00fcssen vorhanden sein f\u00fcr das target . cmd wird ausgef\u00fchrt, um das target zu erstellen, nach dem die dependencies erstellt und ausgef\u00fchrt wurden. Variablen Name Erkl\u00e4rung $@ Dem Target der aktuellen Regel $^ Alle Abh\u00e4ngigkeiten $< Die erste Abh\u00e4ngigkeit Beispiel TARGET_EXEC := producer BUILD_DIR := ./build SRC_DIR := ./ SRCS := producer_consumer.c list.c OBJS := $( SRCS:%.c = $( BUILD_DIR ) /%.o ) #producer.c will be turned into producer.o .DEFAULT_GOAL := $( BUILD_DIR ) / $( TARGET_EXEC ) $(BUILD_DIR)/$(TARGET_EXEC) : $( OBJS ) $( CC ) $( OBJS ) -o $( BUILD_DIR ) / $( TARGET_EXEC ) $(BUILD_DIR)/%.o : %. c #builds .o files from .c files mkdir -p $( dir $@ ) # $< is the first dependency, $@ is the target $( CC ) $( CFLAGS ) -c $< -o $@ .PHONY : clean all clean : rm -r $( BUILD_DIR ) all : @make clean @make","title":"Make"},{"location":"22FS/SNP/03_Make.html#make","text":"","title":"Make"},{"location":"22FS/SNP/03_Make.html#makefile","text":"Grunds\u00e4tzlichen Syntax: .PHONE : < targets , welche keine File sind > target : dependency 1 dependency 2 cmd target ist ein Befehl und den Output des Befehles. Dieser kann mit make target aufgerufen wird. dependencies ist eine Liste von Abh\u00e4ngikeiten. Diese m\u00fcssen vorhanden sein f\u00fcr das target . cmd wird ausgef\u00fchrt, um das target zu erstellen, nach dem die dependencies erstellt und ausgef\u00fchrt wurden.","title":"Makefile"},{"location":"22FS/SNP/03_Make.html#variablen","text":"Name Erkl\u00e4rung $@ Dem Target der aktuellen Regel $^ Alle Abh\u00e4ngigkeiten $< Die erste Abh\u00e4ngigkeit","title":"Variablen"},{"location":"22FS/SNP/03_Make.html#beispiel","text":"TARGET_EXEC := producer BUILD_DIR := ./build SRC_DIR := ./ SRCS := producer_consumer.c list.c OBJS := $( SRCS:%.c = $( BUILD_DIR ) /%.o ) #producer.c will be turned into producer.o .DEFAULT_GOAL := $( BUILD_DIR ) / $( TARGET_EXEC ) $(BUILD_DIR)/$(TARGET_EXEC) : $( OBJS ) $( CC ) $( OBJS ) -o $( BUILD_DIR ) / $( TARGET_EXEC ) $(BUILD_DIR)/%.o : %. c #builds .o files from .c files mkdir -p $( dir $@ ) # $< is the first dependency, $@ is the target $( CC ) $( CFLAGS ) -c $< -o $@ .PHONY : clean all clean : rm -r $( BUILD_DIR ) all : @make clean @make","title":"Beispiel"},{"location":"22FS/SNP/04_Unit%20Tests.html","text":"Unit Tests CU_ASSERT_EQUAL(actual, expected) CU_ASSERT_NOT_EQUAL(actual, expected) CU_ASSERT_STRING_EQUAL(actual, expected) CU_ASSERT_TRUE(value) Siehe man CUnit f\u00fcr mehr Details.","title":"Unit Tests"},{"location":"22FS/SNP/04_Unit%20Tests.html#unit-tests","text":"CU_ASSERT_EQUAL(actual, expected) CU_ASSERT_NOT_EQUAL(actual, expected) CU_ASSERT_STRING_EQUAL(actual, expected) CU_ASSERT_TRUE(value) Siehe man CUnit f\u00fcr mehr Details.","title":"Unit Tests"},{"location":"22FS/SNP/05_OS.html","text":"OS Hardware CPU Die CPU f\u00fchrt die Befehle aus und ist Chef des System-Bus. \u00dcber den Bus kann die CPU auf den Speicher oder IO zugreifen. Im PC Register (Program Counter) steht, wo in Memory die n\u00e4chste Maschineninstruktion steht. In IR -Register ( Instruction Register) steht die aktuell ausgef\u00fchrte Instruktion. ALU steht f\u00fcr Arithmentic-Logic-Unit, welches mit Integers rechnet. Memory Die Memory wird \u00fcber den System-Bus angesprochen. CPU-Entlastung Ablaufbeschleunigung in der CPU Cache:beschleunigter Zugriff auf zwischengespeicherte Daten Pipeline:beschleunigte Ausf\u00fchrung durch gestaffelte Verarbeitung Arbeitsentlastung der CPU IC: Interrupt Controller vermitteln von Interrupts DMA: Direct Memory AccessDaten kopieren ohne CPU Interaktion FPU: Floating-Point UnitRecheneinheit f\u00fcr Gleitkommazahlen DSP: Digital Signal Processorspezielle Daten-Recheneinheit GPU: Graphics Processing Unit spezielle Graphik-Recheneinheit MPU: Memory Protection Unit \u00dcberwachung von Adresszugriffen Modi Im Supervisor/Kernel-Mode l\u00e4uft der Kernel. So bald ein Program auf Funktionalit\u00e4t des Kernels zu greifen m\u00f6chte, muss ein Sys-Call aufgerufen werden, welcher der Modi wechselt. Schichten Linux Startup Prozess Der Header unistd.h muss inkludiert werden. Prozess erstellen ( fork() ) Mit pid_t fork() kann ein neuen Prozess erstellt werden, welche eine Kopie des aktuellen Prozess ist. Von diesem Punkt ab laufen zwei Threads den gleichen Code. Im aktuellen Prozess gibt fork() die PID des neuen Prozess zur\u00fcck, im neuen Prozess wird 0 zur\u00fcck gegeben. Falls der Return Value kleiner als 0 ist, trat ein Fehler auf. Es werden alle File Deskriptoren, Semaphoren, Signal Actions vererbt. exec() in neuen Prozessen execX() Funktionen ersetzt den Code in einem Thread. Dies kann zusammen mit fork() ben\u00fctzt werden, um ein Programm in einem neuen Thread zu starten. int execv(char *pathname, char *argv[]) F\u00fchrt das Programm bei pathname mit den angegebenen Argumenten aus. Der aktuelle Code wird ersetzt int system( char *command) Ist eine Helper-Method, welche mit fork() und execv() ein neues Programm ausf\u00fchrt und wartet bis das Programm fertig ist. Der Return Value des Programmes wird zur\u00fcckgegeben. Der angegebene Befehl wird mit /bin/sh ausgef\u00fchrt. FILE *popen(char *command, char *type) und int pclose(FILE *stream ) Funktioniert wie system() . Es wird der Befehl command in /bin/sh ausgef\u00fchrt und ein File-Stream zur\u00fcck gegeben, von welchem mit fgets(char *s, int size, FILE *stream) zugegriffen werden kann. Der type muss r f\u00fcr zum Lesen und w f\u00fcr zum Schreiben enthalten #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <sys/wait.h> int main ( void ) { pid_t pid = fork (); if ( pid > 0 ) { wait ( NULL ); } else { // using system(...) int exit_code = system ( \"ls -la\" ); printf ( \"child exited with %d \\n\\n \" , WEXITSTATUS ( exit_code )); // using popen(...) FILE * stream = popen ( \"ls -la\" , \"r\" ); char buffer [ 256 ]; while ( fgets ( buffer , 256 , stream ) != NULL ) printf ( buffer ); exit_code = pclose ( stream ); printf ( \"child exited with %d \\n\\n \" , WEXITSTATUS ( exit_code )); // using execv(...) char * argv [] = { \"ls\" , \"-la\" , NULL }; if ( execv ( \"/usr/bin/ls\" , argv ) == -1 ) ERROR ( \"execv\" ); printf ( \"This will never be executed \\n \" ); } } wait() / waitpid() (sys/wait.h) Nach dem ein Prozess beendet wurde, gibt es ihn noch als Zombie-Prozess bis der Parent-Prozess pid_t wait(int *wstatus) oder pid_t waitpid(pid_t pid, int *wstatus, int options) aufgerufen hat und den Status so abgeholt hat. pid_t pid = fork (); if ( pid == 0 ) { int wstatus ; pid_t wpid = waitpid ( pid , & wstatus , 0 ); if ( wpid != null ) { perror ( \"waitpid\" ); exit ( 1 ); } printf ( \"process %d exited with status %d (%d) \\n \" , pid , WEXITSTATUS ( wstatus ), wstatus ); wait ( & wstatus ); // will do the same as waitpid() but with a random child-process } Threading Begriffe Race Condition : Dead Lock : Zwei Threads warten auf eine Resource, welche vom anderen Thread \"gelockt\" wurde Live Lock : Zwei Threads haben eine Resource frei gegeben und warten darauf, dass sie der andere Thread lockt Critical Section : Ein St\u00fcck code, in welchem nur ein Thread gleichzeitig l\u00e4uft Starvation : ein blockierter Task kommt nie an die Reihe, da andere Tasks sich vordr\u00e4ngen. Dies sollte vom OS behoben werden. volatile Das Volatile-Keyword zwingt dem Compiler nicht zu optimieren. Somit wird wirklich ausgef\u00fchrt, was in C geschrieben wurde. Ansonsten kann der Compiler Schreib-Aufrufe verschieben oder Resultate cachen. Dies ist n\u00fctzlich bei Multi-Threading, da eine Variable von mehreren Threads ge\u00e4ndert werden kann und das Cachen problematisch sein k\u00f6nnte. volatile int value = 0 ; // erstellt ein neuen volatile int pthread_create(...) Mit int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) kann einen neuen Thread gestartet werden. Wenn ein neuen Thread erstellt wird, muss entweder pthread_detach() oder pthread_join() void * worker ( void * arg ) { printf ( \"worker: hi \\n \" ); return \"Hello\" ; } void main () { pthread_t thread ; pthread_create ( & thread , NULL , worker , NULL ); void * msg ; pthread_join ( & thread , & msg ); // pthread_join(...) wants void** as the msg printf ( \"Thread sent %s \\n \" , ( char * ) status ) } pthread_detach(...) int pthread_detach(pthread_t thread) markiert ein Thread als detached und wenn ein solchen Thread sich beendet, werden die System-Resourcen automatisch freigegeben. pthread_exit(...) void pthread_exit(void *retval) beendet den akutellen Thread mit dem mit gegebenen Wert. Dieser kann mit int pthread_join(...) abgerufen werden. Processor-Shared-Resources, wie File-Deskriptoren, werden nicht freigegeben. pthread_join(...) int pthread_join(pthread_t thread, void** retval) wartet bis der angegebene Thread sich beendet. Der \"Exit-Status\" wird in den retval Pointer gespeichert. Die System-Resourcen des Threads werden nach dem int pthread_join(...) zur\u00fcckkehrt, frei gegeben. IO INode Die Repr\u00e4sentation von einem File. Es werden Daten, wie der letzte Zugriffzeitpunkt, Besitzer, L\u00e4nge, physikalischer Ort auf dem Datentr\u00e4ger gespeichert. Aber nicht der Name der Datei. Folder Ein einem Ordner hats Name-INode Paare. Diese geben den INodes einen Name. Hardlinks vs Softlink Ein Softlink funktioniert auf dem Filesystem und sagt dem Kernel, das dieses File bei diesem Pfad gefunden wird. Ein Hardlink ist ein \"Link\" auf ein INode. Es kann mehrere Namen f\u00fcr ein INode geben. Der INode ist erst gel\u00f6scht, wenn es keinen Namen daf\u00fcr mehr gibt. Spezielle Files Character Devices Block Devices Named Pipes Sockets FILE* Ein File Deskriptor, welcher auf ein File zeigt. Folgende Funktionen sind relevant zu FILE* . F\u00fcr viele Funktionen muss der Header unistd.h inkludiert werden. Die folgenden Operationen sind die wichtigsten: FILE* fopen(char *pathname, char* mode) \u00d6ffnet ein File zum schrieben. Falls das File nicht ge\u00f6ffnet werden konnte, wird NULL zur\u00fcck gegeben. Wenn f\u00fcr mode folgendes angegeben wird: `r : File nur zum lesen ge\u00f6ffnet r+ : File wird zum lesen und schreiben ge\u00f6ffnet w : File wird zum lesen ge\u00f6ffnet. Das File wird erstellt oder \u00fcberschrieben w+ : Wie r+ , aber das File wird erstellt oder \u00fcberschrieben a : File wird zum schreiben am Ende der Datei ge\u00f6ffnet. Das File wird erstellt, falls es nicht existiert a+ : File wird zum lesen und schreiben vom Ende der Datei ge\u00f6ffnet. Falls das Datei nicht existiert, wird es erstellt int fclose(FILE *stream) Flushed und schliesst den angegeben File-Handler. Wenn erfolgreich, 0 wird zur\u00fcck geben int fprintf(FILE *stream, char* format, ...) Wie fprint(...) aber schreibt auf den angegeben File-Handler. Die Funktion gibt die Anzahl gedruckte Zeichen aus oder einen negative Zahl, wenn ein Fehler aufgetreten ist int fgetc(FILE *stream) Liest von stream ein char und gibt in zur\u00fcck. EOF wird beim File-Ende zur\u00fcck gebenen. Bei einem Fehler wird einen negativen Wert zur\u00fcck gegeben char* fgets(char *s, int size, FILE *stream) Liest eine Zeile oder bis zum Ende des Streams und schreibt diesen in s . Es wird maximal size-1 -Anzahl chars gelesen ( -1 wegen \\0 ) int sscanf(FILE *stream, char *format, ...) Wie scanf(...) , aber liest von einem angegeben stream int fputc(int c, FILE *stream) Cast c zu einem unsigned char und schreibt diesen in den Stream. Als R\u00fcckgabe-Wert wird c zur\u00fcck gegeben, oder EOF im Fehlerfall. int fputs(char *s, FILE *stream) Schreibt ein String (ohne \\0 ) in den Stream. Wenn ein Error aufgetreten ist, wird EOF zur\u00fcck geben, sonst eine positive Zahl. Nach jedem IO Aufruf sollte \u00fcberpr\u00fcft werden, ob die Operation erfolgreich war: Buffereing in Streams unbuffered : Die daten werden sofort weiter geleitet. fully-buffered : Wenn der Buffer voll ist, wird der Buffer geleert line-buffered : Wenn das Ende der Zeile erreicht wird oder der Buffer voll ist, wird der Buffer geleert stdin und stdout sind normallerweisse fully-buffered, wenn sie nicht mit einem interaktiven Device verbunden sind . stderr ist unbuffere File IO Beispiel #include <stdio.h> int main ( void ) { FILE * test_file = fopen ( \"./test\" , \"w\" ); char buffer [ 200 ]; int buffer_size = sizeof ( buffer ) / sizeof ( char ); char * buffer_pntr = buffer ; for ( int input = getchar (); input >= 0 && input != 'q' && buffer_pntr < buffer + buffer_size ; input = getchar ()) { * ( buffer_pntr ++ ) = ( char ) input ; } buffer [ buffer_size - 1 ] = '\\0' ; fprintf ( test_file , \"%s\" , buffer ); fclose ( test_file ); test_file = fopen ( \"./test\" , \"r\" ); while ( fgets ( buffer , buffer_size , test_file ) != NULL ) { printf ( \"buffer: %s\" , buffer ); } fclose ( test_file ); return 0 ; } Mutex (pthread.h) In einer Critical Section ist nur ein Thread gleichzeitig am laufen Mit int pthread_mutex_init(pthread_mutex *mutex, NULL) kann ein p_thread_mutex Objekt initialisiert werden. Mit int pthread_mutex_lock(pthread_mutex *mutex) kann der Mutex gelockt werden und mit int pthread_mutex_unlock(pthread_mutex *mutex) Um Attribute f\u00fcr einen Mutex zu \u00e4ndern, wird der Typ pthread_mutexattr_t genuzt, welcher mit int pthread_mutexattr_init(pthread_mutexattr_t *mutexattr) initialisiert und mit int pthread_mutexattr_settype(pthread_mutex *mutex, int flag) . Ein m\u00f6gliches Flag ist PTHREAD_MUTEX_RECURSIVE , welches bewirkt, dass wenn ein Mutex bereits im Thread a gelockt wurde und Thread a nochmals versucht zu locken, wird nichts getan (sonst g\u00e4be es ein Deadlock). Beispiel Mutex #include <pthread.h> #include <stdbool.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #define ERROR(M) ... static pthread_mutex_t mutex ; static volatile bool running = true ; static volatile int value = 0 ; void * worker ( void * arg ) { while ( running ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock worker\" ); printf ( \"current value: %d \\n \" , value ); if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock worker\" ); } } void * printer ( void * arg ) { FILE * random = fopen ( \"/dev/urandom\" , \"rb\" ); if ( random == NULL ) ERROR ( \"fopen\" ); while ( running ) { int input = -1 ; if ( fread ( & input , sizeof ( input ), 1 , random ) != 1 ) ERROR ( \"read\" ); if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); value = input ; if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } fclose ( random ); } int main ( void ) { pthread_mutex_init ( & mutex , NULL ); pthread_t worker_thread , printer_thread ; if ( pthread_create ( & worker_thread , NULL , worker , NULL ) == -1 ) ERROR ( \"worker thread\" ); if ( pthread_create ( & printer_thread , NULL , printer , NULL ) == -1 ) ERROR ( \"printer thread\" ); while ( getchar () != 'q' ) {} running = false ; if ( pthread_join ( worker_thread , NULL ) == -1 ) ERROR ( \"join\" ); if ( pthread_join ( printer_thread , NULL ) == -1 ) ERROR ( \"join\" ); } Beispiel Rekursiver Mutex #include <stdlib.h> #include <stdio.h> #include <pthread.h> #define ERROR(M) .. #define N 1000 pthread_mutex_t mutex ; int value = 0 ; void calc ( int step ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); value += step ; if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } void * count ( void * p ) { for ( int i = 0 ; i < N ; i ++ ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); calc ( * ( int * ) p ); if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } } int main ( void ) { pthread_mutexattr_t mutex_attr ; if ( pthread_mutexattr_init ( & mutex_attr ) != 0 ) ERROR ( \"init mutexattr\" ); if ( pthread_mutexattr_settype ( & mutex_attr , PTHREAD_MUTEX_RECURSIVE ) != 0 ) ERROR ( \"set recursive type\" ); if ( pthread_mutex_init ( & mutex , & mutex_attr ) != 0 ) ERROR ( \"init mutex\" ); pthread_t th_inc , th_dec ; int inc = 1 ; int dec = -1 ; if ( pthread_create ( & th_inc , NULL , count , & inc ) != 0 ) ERROR ( \"create inc thread\" ); if ( pthread_create ( & th_dec , NULL , count , & dec ) != 0 ) ERROR ( \"create dec thread\" ); if ( pthread_join ( th_inc , NULL ) != 0 ) ERROR ( \"inc thread join\" ); if ( pthread_join ( th_dec , NULL ) != 0 ) ERROR ( \"dec thread join\" ); printf ( \"value: %d \\n \" , value ); } Sempaphors Es wird den Include #include <semaphor.h> (und #include <fcntl.h> f\u00fcr O_CREAT) ben\u00f6tigt. Semaphors k\u00f6nnen f\u00fcr Prozesse, wie auch f\u00fcr Threads verwendet werden. Eine Semaphor ben\u00fctzt ein Counter. Wenn der Counter 0 ist, warten Prozesse, welche int sem_wait(...) aufrufen. Wenn der Counter h\u00f6her ist, wird der Counter um 1 dekrementiert und den Prozess durchgelassen. int sem_post(...) erh\u00f6ht den Counter um 1 , was bedeutet, dass ein Prozess mehr durch kann. Semaphors ben\u00fctzen die Struktur sem_t . F\u00fcr eine In-Memory Sempahor kann int sem_init(sem_t *sem, int pshared, unsigned int value) ben\u00fctzt weden. Bei einer Named-Semaphor muss sem_t *sem_open(char *name, int oflags, mode_t mode, unsigned int value) aufgerufen werden, welches eine neue Semaphor zur\u00fcck gibt. Als oflag kann O_CREAT (ohne E am ende) (in fcntl.h definiert) ben\u00fctzt werden und bewirkt, dass die Sempahore erstellt wird, wenn sie noch nicht existiert. mode_t ist ein Otal-File Mode (wie 0700 ). int sem_wait(sem_t *sem) wartet darauf, dass der Counter h\u00f6her ist als 0 . Wenn ja, wird er um eins dekrementiert und durchgelassen, sonst wird blockiert. int sem_post(sem_t *sem) erh\u00f6ht den Counter um eins. Falls ein Prozess bereits int sem_wait(...) aufgerufen hat, wird dieser druchgelassen, bzw. der n\u00e4chste Prozess wird direkt durchgelassen. In-Memory Semaphors werden mit int sem_destroy(sem_t *sem) geschlossen. Named Semaphors werden mit int sem_close(sem_t *sem) geschlossen. Mit int sem_unlink(sem_t *sem) wird die Semaphor gel\u00f6scht, sobald alle Prozesse sem_close(...) darauf aufgerufen haben. Beispiel #include <semaphore.h> #include <sys/stat.h> #include <fcntl.h> #include <stdbool.h> #include <stdlib.h> int main ( void ) { // creates a unnamed in memory semaphore sem_t unamed_sem ; //false means that the semaphore should be used for thread-communication // 0 is the initial value if ( sem_init ( & unamed_sem , false , 0 ) != 0 ) perror ( \"Couldn't init unnamed semaphore\" ); // creates a named semaphore which can be opend by multiple processes sem_unlink ( \"/name\" ); // 0 is the initial value sem_t * named_sem = sem_open ( \"/name\" , O_CREAT , 0700 , 0 ); if ( named_sem == NULL ) perror ( \"Couldn't init named semaphore\" ); sem_unlink ( \"/name\" ); } Im folgenden Beispiel wurde Sudo-Code geschrieben. Barriere Eine Barriere blockiert mehrere Tasks. Eine Barriere l\u00e4sst bloss alle Tasks durch, wenn gen\u00fcgend Tasks da sind. Im Vergleich zu dem Sempaphors: Semaphoren: der Busfahrer l\u00e4sst solange Passagiere in den Bus, bis er voll ist Barriere: der Busfahrer wartet bis die gesamte Klasse da ist und l\u00e4sst sie erst dann in den Bus einsteigen Signale Ein Prozess kann einem anderen Prozess Signale mithilfe von kill(pid, signal_code) . Der empfangende Prozess kann entweder sich beenden, das Signal ignorieren oder ein Handler ausf\u00fchren, wenn dieser Code empfangen wird. Das Verhalten von SIGKILL und SIGSTOP kann nicht ver\u00e4ndert werden und beendet immer den Prozess. Ein Prozess kann mit pause() warten, bis ein Signal empfangen wurde. Mit sigaction(int sig, struct sigaction *act, struct sigaction *oact) kann das Verhalten beim Empfangen eines Signal ge\u00e4ndert werden. Der int sig ist die Nummer des Signales, act ist die neue Action und in oact kann ein sigaction Variable angegeben werden, in welche die alte Action geschrieben wird. Die sigaction kann folgendermassen ben\u00fctzt werden: Der Typ von sigaction.sa_handler hat den Typ void(*) (int) , was ein Pointer auf eine Funktion, wie void test(int a) ist. Diese kann entweder eine eigene Funktion sein, oder SIG_DFL f\u00fcr den Default und SIG_IGN zum ignorieren, angegeben werden. raise(int sig) sendet das Signal zum eigenen Prozess. Signal Erkl\u00e4rung Default Aktion SININT Interrupt-Signal von der Tastatur (CTRL-C) Term SIGQUIT Quit-Signal von der Tastatur (CTRL-) Core SIGABRT Abort-Signal via abort() oder assert() Core SIGKILL Kill-Signal (unver\u00e4nderbar) Term SIGSEGV Unzul\u00e4ssiger Speicherzugriff Core SIGALRM Timer-Signal durch alarm() ausgel\u00f6st Term SIGTERM Terminierungs-Signal Term SIGSTOP Stoppt den Prozess (oder ignoriert falls gestoppt) (unver\u00e4nderbar) Stop SIGCONT Reaktiviert den Prozess (oder ignoriert falls am Laufen) Cont Dabei steht: Ter f\u00fcr das terminieren der Prozesse Core f\u00fcr das terminieren der Prozesse und ein Code-Dump zu produzieren Ignored f\u00fcr das ignorieren des Signales Stop/Cont f\u00fcr das stoppen und reaktivieren des Prozesses (oder ignorieren, falls nicht anwendbar) Beispiel SA_SIGINFO #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <sys/wait.h> #include <fcntl.h> void handler ( int sig , siginfo_t * info , void * context ) { printf ( \"caught (%d): source=%d, this=%d \\n \" , sig , info -> si_pid , getpid ()); raise ( SIGTERM ); // = kill(getpid(), SIGTERM) } int main ( void ) { pid_t pid = fork (); if ( pid == 0 ) { struct sigaction sa = { 0 }; sa . sa_flags = SA_SIGINFO ; // use extended handler sa . sa_sigaction = handler ; // set handler // sigfillset specifies that all signals should be ignored while the handler(...) is running if ( sigfillset ( & sa . sa_mask ) == -1 ) ERROR ( \"sigfillset\" ); if ( sigaction ( SIGUSR1 , & sa , NULL ) == -1 ) ERROR ( \"sigaction\" ); if ( pause () == -1 ) ERROR ( \"pause()\" ); // pause process } else { sleep ( 1 ); if ( kill ( pid , SIGUSR1 ) == -1 ) ERROR ( \"kill\" ); } } Pipes int pipe(int filedes[2]) erstellt eine unbenannte Pipe mit zwei Filedeskriptoren, welche in das angegebene Array geschrieben wird. Auf diese k\u00f6nnen mit write() und read() geschrieben und gelesen weden. pipe(...) gibt 0 zur\u00fcck, wenn kein Fehler aufgetreten ist. Eine Pipe geht nur in eine Richtung und daher muss eine der beiden Deskriptoren von je einem Prozess kreuzweise mit close(int filedesriptor) geschlossen werden, dass die Pipe nutzbar ist. Mit write(int filedes, void *buffer, size_t size) Eine Pipe kann auch Non-Blocking genutzt werden. Dies kann folgendermassen gesetzt werden: Nun kann folgendermassen davon gelesen werden: Mit int mkfifo(char* pathname, mode_t mode) wird eine Named-Pipe erstellt. Die Funktion gibt 0 zur\u00fcck, wenn kein Fehler aufgetreten ist. Die beiden Prozesse k\u00f6nnen vom File bei pathname lesen oder schrieben. Message Queue Ist eine Queue, welche Strings zwischen Prozessen austauschen kann. Das Programm muss mit dem -lrt Flag kompiliert werden. Mit mqd_t mq_open(char* qname, int flag, int mode, struct mq_attribute *attr) kann eine neue Queue ge\u00f6ffnet werden. Der QName muss mit einem Slash beginnen und existieren in einem Virtuellen Filesystem /dev/mqueue . Queues k\u00f6nnen auch Non-Blocking ge\u00f6ffnet werden. Mit int mq_close(mqd_t queue) teilt dem Kernel mit, dass der Zugriff auf die Queue abgeschlossen ist. Mit int mq_unlink(char* name) kann die Queue gel\u00f6scht werden. Sie kann danach nicht mehr ge\u00f6ffnet werden und wird gel\u00f6scht, wenn jeder Prozess, welcher ein File-Deskriptor offen hat, diesen mit mq_close(...) geschlossen hat. Sockets","title":"OS"},{"location":"22FS/SNP/05_OS.html#os","text":"","title":"OS"},{"location":"22FS/SNP/05_OS.html#hardware","text":"","title":"Hardware"},{"location":"22FS/SNP/05_OS.html#cpu","text":"Die CPU f\u00fchrt die Befehle aus und ist Chef des System-Bus. \u00dcber den Bus kann die CPU auf den Speicher oder IO zugreifen. Im PC Register (Program Counter) steht, wo in Memory die n\u00e4chste Maschineninstruktion steht. In IR -Register ( Instruction Register) steht die aktuell ausgef\u00fchrte Instruktion. ALU steht f\u00fcr Arithmentic-Logic-Unit, welches mit Integers rechnet.","title":"CPU"},{"location":"22FS/SNP/05_OS.html#memory","text":"Die Memory wird \u00fcber den System-Bus angesprochen.","title":"Memory"},{"location":"22FS/SNP/05_OS.html#cpu-entlastung","text":"Ablaufbeschleunigung in der CPU Cache:beschleunigter Zugriff auf zwischengespeicherte Daten Pipeline:beschleunigte Ausf\u00fchrung durch gestaffelte Verarbeitung Arbeitsentlastung der CPU IC: Interrupt Controller vermitteln von Interrupts DMA: Direct Memory AccessDaten kopieren ohne CPU Interaktion FPU: Floating-Point UnitRecheneinheit f\u00fcr Gleitkommazahlen DSP: Digital Signal Processorspezielle Daten-Recheneinheit GPU: Graphics Processing Unit spezielle Graphik-Recheneinheit MPU: Memory Protection Unit \u00dcberwachung von Adresszugriffen","title":"CPU-Entlastung"},{"location":"22FS/SNP/05_OS.html#modi","text":"Im Supervisor/Kernel-Mode l\u00e4uft der Kernel. So bald ein Program auf Funktionalit\u00e4t des Kernels zu greifen m\u00f6chte, muss ein Sys-Call aufgerufen werden, welcher der Modi wechselt.","title":"Modi"},{"location":"22FS/SNP/05_OS.html#schichten","text":"","title":"Schichten"},{"location":"22FS/SNP/05_OS.html#linux-startup","text":"","title":"Linux Startup"},{"location":"22FS/SNP/05_OS.html#prozess","text":"Der Header unistd.h muss inkludiert werden.","title":"Prozess"},{"location":"22FS/SNP/05_OS.html#prozess-erstellen-fork","text":"Mit pid_t fork() kann ein neuen Prozess erstellt werden, welche eine Kopie des aktuellen Prozess ist. Von diesem Punkt ab laufen zwei Threads den gleichen Code. Im aktuellen Prozess gibt fork() die PID des neuen Prozess zur\u00fcck, im neuen Prozess wird 0 zur\u00fcck gegeben. Falls der Return Value kleiner als 0 ist, trat ein Fehler auf. Es werden alle File Deskriptoren, Semaphoren, Signal Actions vererbt.","title":"Prozess erstellen (fork())"},{"location":"22FS/SNP/05_OS.html#exec-in-neuen-prozessen","text":"execX() Funktionen ersetzt den Code in einem Thread. Dies kann zusammen mit fork() ben\u00fctzt werden, um ein Programm in einem neuen Thread zu starten. int execv(char *pathname, char *argv[]) F\u00fchrt das Programm bei pathname mit den angegebenen Argumenten aus. Der aktuelle Code wird ersetzt int system( char *command) Ist eine Helper-Method, welche mit fork() und execv() ein neues Programm ausf\u00fchrt und wartet bis das Programm fertig ist. Der Return Value des Programmes wird zur\u00fcckgegeben. Der angegebene Befehl wird mit /bin/sh ausgef\u00fchrt. FILE *popen(char *command, char *type) und int pclose(FILE *stream ) Funktioniert wie system() . Es wird der Befehl command in /bin/sh ausgef\u00fchrt und ein File-Stream zur\u00fcck gegeben, von welchem mit fgets(char *s, int size, FILE *stream) zugegriffen werden kann. Der type muss r f\u00fcr zum Lesen und w f\u00fcr zum Schreiben enthalten #include <stdlib.h> #include <stdio.h> #include <unistd.h> #include <sys/wait.h> int main ( void ) { pid_t pid = fork (); if ( pid > 0 ) { wait ( NULL ); } else { // using system(...) int exit_code = system ( \"ls -la\" ); printf ( \"child exited with %d \\n\\n \" , WEXITSTATUS ( exit_code )); // using popen(...) FILE * stream = popen ( \"ls -la\" , \"r\" ); char buffer [ 256 ]; while ( fgets ( buffer , 256 , stream ) != NULL ) printf ( buffer ); exit_code = pclose ( stream ); printf ( \"child exited with %d \\n\\n \" , WEXITSTATUS ( exit_code )); // using execv(...) char * argv [] = { \"ls\" , \"-la\" , NULL }; if ( execv ( \"/usr/bin/ls\" , argv ) == -1 ) ERROR ( \"execv\" ); printf ( \"This will never be executed \\n \" ); } }","title":"exec() in neuen Prozessen"},{"location":"22FS/SNP/05_OS.html#wait-waitpid-syswaith","text":"Nach dem ein Prozess beendet wurde, gibt es ihn noch als Zombie-Prozess bis der Parent-Prozess pid_t wait(int *wstatus) oder pid_t waitpid(pid_t pid, int *wstatus, int options) aufgerufen hat und den Status so abgeholt hat. pid_t pid = fork (); if ( pid == 0 ) { int wstatus ; pid_t wpid = waitpid ( pid , & wstatus , 0 ); if ( wpid != null ) { perror ( \"waitpid\" ); exit ( 1 ); } printf ( \"process %d exited with status %d (%d) \\n \" , pid , WEXITSTATUS ( wstatus ), wstatus ); wait ( & wstatus ); // will do the same as waitpid() but with a random child-process }","title":"wait() /waitpid() (sys/wait.h)"},{"location":"22FS/SNP/05_OS.html#threading","text":"","title":"Threading"},{"location":"22FS/SNP/05_OS.html#begriffe","text":"Race Condition : Dead Lock : Zwei Threads warten auf eine Resource, welche vom anderen Thread \"gelockt\" wurde Live Lock : Zwei Threads haben eine Resource frei gegeben und warten darauf, dass sie der andere Thread lockt Critical Section : Ein St\u00fcck code, in welchem nur ein Thread gleichzeitig l\u00e4uft Starvation : ein blockierter Task kommt nie an die Reihe, da andere Tasks sich vordr\u00e4ngen. Dies sollte vom OS behoben werden.","title":"Begriffe"},{"location":"22FS/SNP/05_OS.html#volatile","text":"Das Volatile-Keyword zwingt dem Compiler nicht zu optimieren. Somit wird wirklich ausgef\u00fchrt, was in C geschrieben wurde. Ansonsten kann der Compiler Schreib-Aufrufe verschieben oder Resultate cachen. Dies ist n\u00fctzlich bei Multi-Threading, da eine Variable von mehreren Threads ge\u00e4ndert werden kann und das Cachen problematisch sein k\u00f6nnte. volatile int value = 0 ; // erstellt ein neuen volatile int","title":"volatile"},{"location":"22FS/SNP/05_OS.html#pthread_create","text":"Mit int pthread_create(pthread_t *thread, pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) kann einen neuen Thread gestartet werden. Wenn ein neuen Thread erstellt wird, muss entweder pthread_detach() oder pthread_join() void * worker ( void * arg ) { printf ( \"worker: hi \\n \" ); return \"Hello\" ; } void main () { pthread_t thread ; pthread_create ( & thread , NULL , worker , NULL ); void * msg ; pthread_join ( & thread , & msg ); // pthread_join(...) wants void** as the msg printf ( \"Thread sent %s \\n \" , ( char * ) status ) }","title":"pthread_create(...)"},{"location":"22FS/SNP/05_OS.html#pthread_detach","text":"int pthread_detach(pthread_t thread) markiert ein Thread als detached und wenn ein solchen Thread sich beendet, werden die System-Resourcen automatisch freigegeben.","title":"pthread_detach(...)"},{"location":"22FS/SNP/05_OS.html#pthread_exit","text":"void pthread_exit(void *retval) beendet den akutellen Thread mit dem mit gegebenen Wert. Dieser kann mit int pthread_join(...) abgerufen werden. Processor-Shared-Resources, wie File-Deskriptoren, werden nicht freigegeben.","title":"pthread_exit(...)"},{"location":"22FS/SNP/05_OS.html#pthread_join","text":"int pthread_join(pthread_t thread, void** retval) wartet bis der angegebene Thread sich beendet. Der \"Exit-Status\" wird in den retval Pointer gespeichert. Die System-Resourcen des Threads werden nach dem int pthread_join(...) zur\u00fcckkehrt, frei gegeben.","title":"pthread_join(...)"},{"location":"22FS/SNP/05_OS.html#io","text":"","title":"IO"},{"location":"22FS/SNP/05_OS.html#inode","text":"Die Repr\u00e4sentation von einem File. Es werden Daten, wie der letzte Zugriffzeitpunkt, Besitzer, L\u00e4nge, physikalischer Ort auf dem Datentr\u00e4ger gespeichert. Aber nicht der Name der Datei.","title":"INode"},{"location":"22FS/SNP/05_OS.html#folder","text":"Ein einem Ordner hats Name-INode Paare. Diese geben den INodes einen Name.","title":"Folder"},{"location":"22FS/SNP/05_OS.html#hardlinks-vs-softlink","text":"Ein Softlink funktioniert auf dem Filesystem und sagt dem Kernel, das dieses File bei diesem Pfad gefunden wird. Ein Hardlink ist ein \"Link\" auf ein INode. Es kann mehrere Namen f\u00fcr ein INode geben. Der INode ist erst gel\u00f6scht, wenn es keinen Namen daf\u00fcr mehr gibt.","title":"Hardlinks vs Softlink"},{"location":"22FS/SNP/05_OS.html#spezielle-files","text":"Character Devices Block Devices Named Pipes Sockets","title":"Spezielle Files"},{"location":"22FS/SNP/05_OS.html#file","text":"Ein File Deskriptor, welcher auf ein File zeigt. Folgende Funktionen sind relevant zu FILE* . F\u00fcr viele Funktionen muss der Header unistd.h inkludiert werden. Die folgenden Operationen sind die wichtigsten: FILE* fopen(char *pathname, char* mode) \u00d6ffnet ein File zum schrieben. Falls das File nicht ge\u00f6ffnet werden konnte, wird NULL zur\u00fcck gegeben. Wenn f\u00fcr mode folgendes angegeben wird: `r : File nur zum lesen ge\u00f6ffnet r+ : File wird zum lesen und schreiben ge\u00f6ffnet w : File wird zum lesen ge\u00f6ffnet. Das File wird erstellt oder \u00fcberschrieben w+ : Wie r+ , aber das File wird erstellt oder \u00fcberschrieben a : File wird zum schreiben am Ende der Datei ge\u00f6ffnet. Das File wird erstellt, falls es nicht existiert a+ : File wird zum lesen und schreiben vom Ende der Datei ge\u00f6ffnet. Falls das Datei nicht existiert, wird es erstellt int fclose(FILE *stream) Flushed und schliesst den angegeben File-Handler. Wenn erfolgreich, 0 wird zur\u00fcck geben int fprintf(FILE *stream, char* format, ...) Wie fprint(...) aber schreibt auf den angegeben File-Handler. Die Funktion gibt die Anzahl gedruckte Zeichen aus oder einen negative Zahl, wenn ein Fehler aufgetreten ist int fgetc(FILE *stream) Liest von stream ein char und gibt in zur\u00fcck. EOF wird beim File-Ende zur\u00fcck gebenen. Bei einem Fehler wird einen negativen Wert zur\u00fcck gegeben char* fgets(char *s, int size, FILE *stream) Liest eine Zeile oder bis zum Ende des Streams und schreibt diesen in s . Es wird maximal size-1 -Anzahl chars gelesen ( -1 wegen \\0 ) int sscanf(FILE *stream, char *format, ...) Wie scanf(...) , aber liest von einem angegeben stream int fputc(int c, FILE *stream) Cast c zu einem unsigned char und schreibt diesen in den Stream. Als R\u00fcckgabe-Wert wird c zur\u00fcck gegeben, oder EOF im Fehlerfall. int fputs(char *s, FILE *stream) Schreibt ein String (ohne \\0 ) in den Stream. Wenn ein Error aufgetreten ist, wird EOF zur\u00fcck geben, sonst eine positive Zahl. Nach jedem IO Aufruf sollte \u00fcberpr\u00fcft werden, ob die Operation erfolgreich war:","title":"FILE*"},{"location":"22FS/SNP/05_OS.html#buffereing-in-streams","text":"unbuffered : Die daten werden sofort weiter geleitet. fully-buffered : Wenn der Buffer voll ist, wird der Buffer geleert line-buffered : Wenn das Ende der Zeile erreicht wird oder der Buffer voll ist, wird der Buffer geleert stdin und stdout sind normallerweisse fully-buffered, wenn sie nicht mit einem interaktiven Device verbunden sind . stderr ist unbuffere","title":"Buffereing in Streams"},{"location":"22FS/SNP/05_OS.html#file-io-beispiel","text":"#include <stdio.h> int main ( void ) { FILE * test_file = fopen ( \"./test\" , \"w\" ); char buffer [ 200 ]; int buffer_size = sizeof ( buffer ) / sizeof ( char ); char * buffer_pntr = buffer ; for ( int input = getchar (); input >= 0 && input != 'q' && buffer_pntr < buffer + buffer_size ; input = getchar ()) { * ( buffer_pntr ++ ) = ( char ) input ; } buffer [ buffer_size - 1 ] = '\\0' ; fprintf ( test_file , \"%s\" , buffer ); fclose ( test_file ); test_file = fopen ( \"./test\" , \"r\" ); while ( fgets ( buffer , buffer_size , test_file ) != NULL ) { printf ( \"buffer: %s\" , buffer ); } fclose ( test_file ); return 0 ; }","title":"File IO Beispiel"},{"location":"22FS/SNP/05_OS.html#mutex-pthreadh","text":"In einer Critical Section ist nur ein Thread gleichzeitig am laufen Mit int pthread_mutex_init(pthread_mutex *mutex, NULL) kann ein p_thread_mutex Objekt initialisiert werden. Mit int pthread_mutex_lock(pthread_mutex *mutex) kann der Mutex gelockt werden und mit int pthread_mutex_unlock(pthread_mutex *mutex) Um Attribute f\u00fcr einen Mutex zu \u00e4ndern, wird der Typ pthread_mutexattr_t genuzt, welcher mit int pthread_mutexattr_init(pthread_mutexattr_t *mutexattr) initialisiert und mit int pthread_mutexattr_settype(pthread_mutex *mutex, int flag) . Ein m\u00f6gliches Flag ist PTHREAD_MUTEX_RECURSIVE , welches bewirkt, dass wenn ein Mutex bereits im Thread a gelockt wurde und Thread a nochmals versucht zu locken, wird nichts getan (sonst g\u00e4be es ein Deadlock).","title":"Mutex (pthread.h)"},{"location":"22FS/SNP/05_OS.html#beispiel-mutex","text":"#include <pthread.h> #include <stdbool.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #define ERROR(M) ... static pthread_mutex_t mutex ; static volatile bool running = true ; static volatile int value = 0 ; void * worker ( void * arg ) { while ( running ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock worker\" ); printf ( \"current value: %d \\n \" , value ); if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock worker\" ); } } void * printer ( void * arg ) { FILE * random = fopen ( \"/dev/urandom\" , \"rb\" ); if ( random == NULL ) ERROR ( \"fopen\" ); while ( running ) { int input = -1 ; if ( fread ( & input , sizeof ( input ), 1 , random ) != 1 ) ERROR ( \"read\" ); if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); value = input ; if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } fclose ( random ); } int main ( void ) { pthread_mutex_init ( & mutex , NULL ); pthread_t worker_thread , printer_thread ; if ( pthread_create ( & worker_thread , NULL , worker , NULL ) == -1 ) ERROR ( \"worker thread\" ); if ( pthread_create ( & printer_thread , NULL , printer , NULL ) == -1 ) ERROR ( \"printer thread\" ); while ( getchar () != 'q' ) {} running = false ; if ( pthread_join ( worker_thread , NULL ) == -1 ) ERROR ( \"join\" ); if ( pthread_join ( printer_thread , NULL ) == -1 ) ERROR ( \"join\" ); }","title":"Beispiel Mutex"},{"location":"22FS/SNP/05_OS.html#beispiel-rekursiver-mutex","text":"#include <stdlib.h> #include <stdio.h> #include <pthread.h> #define ERROR(M) .. #define N 1000 pthread_mutex_t mutex ; int value = 0 ; void calc ( int step ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); value += step ; if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } void * count ( void * p ) { for ( int i = 0 ; i < N ; i ++ ) { if ( pthread_mutex_lock ( & mutex ) == -1 ) ERROR ( \"lock\" ); calc ( * ( int * ) p ); if ( pthread_mutex_unlock ( & mutex ) == -1 ) ERROR ( \"unlock\" ); } } int main ( void ) { pthread_mutexattr_t mutex_attr ; if ( pthread_mutexattr_init ( & mutex_attr ) != 0 ) ERROR ( \"init mutexattr\" ); if ( pthread_mutexattr_settype ( & mutex_attr , PTHREAD_MUTEX_RECURSIVE ) != 0 ) ERROR ( \"set recursive type\" ); if ( pthread_mutex_init ( & mutex , & mutex_attr ) != 0 ) ERROR ( \"init mutex\" ); pthread_t th_inc , th_dec ; int inc = 1 ; int dec = -1 ; if ( pthread_create ( & th_inc , NULL , count , & inc ) != 0 ) ERROR ( \"create inc thread\" ); if ( pthread_create ( & th_dec , NULL , count , & dec ) != 0 ) ERROR ( \"create dec thread\" ); if ( pthread_join ( th_inc , NULL ) != 0 ) ERROR ( \"inc thread join\" ); if ( pthread_join ( th_dec , NULL ) != 0 ) ERROR ( \"dec thread join\" ); printf ( \"value: %d \\n \" , value ); }","title":"Beispiel Rekursiver Mutex"},{"location":"22FS/SNP/05_OS.html#sempaphors","text":"Es wird den Include #include <semaphor.h> (und #include <fcntl.h> f\u00fcr O_CREAT) ben\u00f6tigt. Semaphors k\u00f6nnen f\u00fcr Prozesse, wie auch f\u00fcr Threads verwendet werden. Eine Semaphor ben\u00fctzt ein Counter. Wenn der Counter 0 ist, warten Prozesse, welche int sem_wait(...) aufrufen. Wenn der Counter h\u00f6her ist, wird der Counter um 1 dekrementiert und den Prozess durchgelassen. int sem_post(...) erh\u00f6ht den Counter um 1 , was bedeutet, dass ein Prozess mehr durch kann. Semaphors ben\u00fctzen die Struktur sem_t . F\u00fcr eine In-Memory Sempahor kann int sem_init(sem_t *sem, int pshared, unsigned int value) ben\u00fctzt weden. Bei einer Named-Semaphor muss sem_t *sem_open(char *name, int oflags, mode_t mode, unsigned int value) aufgerufen werden, welches eine neue Semaphor zur\u00fcck gibt. Als oflag kann O_CREAT (ohne E am ende) (in fcntl.h definiert) ben\u00fctzt werden und bewirkt, dass die Sempahore erstellt wird, wenn sie noch nicht existiert. mode_t ist ein Otal-File Mode (wie 0700 ). int sem_wait(sem_t *sem) wartet darauf, dass der Counter h\u00f6her ist als 0 . Wenn ja, wird er um eins dekrementiert und durchgelassen, sonst wird blockiert. int sem_post(sem_t *sem) erh\u00f6ht den Counter um eins. Falls ein Prozess bereits int sem_wait(...) aufgerufen hat, wird dieser druchgelassen, bzw. der n\u00e4chste Prozess wird direkt durchgelassen. In-Memory Semaphors werden mit int sem_destroy(sem_t *sem) geschlossen. Named Semaphors werden mit int sem_close(sem_t *sem) geschlossen. Mit int sem_unlink(sem_t *sem) wird die Semaphor gel\u00f6scht, sobald alle Prozesse sem_close(...) darauf aufgerufen haben.","title":"Sempaphors"},{"location":"22FS/SNP/05_OS.html#beispiel","text":"#include <semaphore.h> #include <sys/stat.h> #include <fcntl.h> #include <stdbool.h> #include <stdlib.h> int main ( void ) { // creates a unnamed in memory semaphore sem_t unamed_sem ; //false means that the semaphore should be used for thread-communication // 0 is the initial value if ( sem_init ( & unamed_sem , false , 0 ) != 0 ) perror ( \"Couldn't init unnamed semaphore\" ); // creates a named semaphore which can be opend by multiple processes sem_unlink ( \"/name\" ); // 0 is the initial value sem_t * named_sem = sem_open ( \"/name\" , O_CREAT , 0700 , 0 ); if ( named_sem == NULL ) perror ( \"Couldn't init named semaphore\" ); sem_unlink ( \"/name\" ); } Im folgenden Beispiel wurde Sudo-Code geschrieben.","title":"Beispiel"},{"location":"22FS/SNP/05_OS.html#barriere","text":"Eine Barriere blockiert mehrere Tasks. Eine Barriere l\u00e4sst bloss alle Tasks durch, wenn gen\u00fcgend Tasks da sind. Im Vergleich zu dem Sempaphors: Semaphoren: der Busfahrer l\u00e4sst solange Passagiere in den Bus, bis er voll ist Barriere: der Busfahrer wartet bis die gesamte Klasse da ist und l\u00e4sst sie erst dann in den Bus einsteigen","title":"Barriere"},{"location":"22FS/SNP/05_OS.html#signale","text":"Ein Prozess kann einem anderen Prozess Signale mithilfe von kill(pid, signal_code) . Der empfangende Prozess kann entweder sich beenden, das Signal ignorieren oder ein Handler ausf\u00fchren, wenn dieser Code empfangen wird. Das Verhalten von SIGKILL und SIGSTOP kann nicht ver\u00e4ndert werden und beendet immer den Prozess. Ein Prozess kann mit pause() warten, bis ein Signal empfangen wurde. Mit sigaction(int sig, struct sigaction *act, struct sigaction *oact) kann das Verhalten beim Empfangen eines Signal ge\u00e4ndert werden. Der int sig ist die Nummer des Signales, act ist die neue Action und in oact kann ein sigaction Variable angegeben werden, in welche die alte Action geschrieben wird. Die sigaction kann folgendermassen ben\u00fctzt werden: Der Typ von sigaction.sa_handler hat den Typ void(*) (int) , was ein Pointer auf eine Funktion, wie void test(int a) ist. Diese kann entweder eine eigene Funktion sein, oder SIG_DFL f\u00fcr den Default und SIG_IGN zum ignorieren, angegeben werden. raise(int sig) sendet das Signal zum eigenen Prozess. Signal Erkl\u00e4rung Default Aktion SININT Interrupt-Signal von der Tastatur (CTRL-C) Term SIGQUIT Quit-Signal von der Tastatur (CTRL-) Core SIGABRT Abort-Signal via abort() oder assert() Core SIGKILL Kill-Signal (unver\u00e4nderbar) Term SIGSEGV Unzul\u00e4ssiger Speicherzugriff Core SIGALRM Timer-Signal durch alarm() ausgel\u00f6st Term SIGTERM Terminierungs-Signal Term SIGSTOP Stoppt den Prozess (oder ignoriert falls gestoppt) (unver\u00e4nderbar) Stop SIGCONT Reaktiviert den Prozess (oder ignoriert falls am Laufen) Cont Dabei steht: Ter f\u00fcr das terminieren der Prozesse Core f\u00fcr das terminieren der Prozesse und ein Code-Dump zu produzieren Ignored f\u00fcr das ignorieren des Signales Stop/Cont f\u00fcr das stoppen und reaktivieren des Prozesses (oder ignorieren, falls nicht anwendbar)","title":"Signale"},{"location":"22FS/SNP/05_OS.html#beispiel-sa_siginfo","text":"#include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <signal.h> #include <sys/wait.h> #include <fcntl.h> void handler ( int sig , siginfo_t * info , void * context ) { printf ( \"caught (%d): source=%d, this=%d \\n \" , sig , info -> si_pid , getpid ()); raise ( SIGTERM ); // = kill(getpid(), SIGTERM) } int main ( void ) { pid_t pid = fork (); if ( pid == 0 ) { struct sigaction sa = { 0 }; sa . sa_flags = SA_SIGINFO ; // use extended handler sa . sa_sigaction = handler ; // set handler // sigfillset specifies that all signals should be ignored while the handler(...) is running if ( sigfillset ( & sa . sa_mask ) == -1 ) ERROR ( \"sigfillset\" ); if ( sigaction ( SIGUSR1 , & sa , NULL ) == -1 ) ERROR ( \"sigaction\" ); if ( pause () == -1 ) ERROR ( \"pause()\" ); // pause process } else { sleep ( 1 ); if ( kill ( pid , SIGUSR1 ) == -1 ) ERROR ( \"kill\" ); } }","title":"Beispiel SA_SIGINFO"},{"location":"22FS/SNP/05_OS.html#pipes","text":"int pipe(int filedes[2]) erstellt eine unbenannte Pipe mit zwei Filedeskriptoren, welche in das angegebene Array geschrieben wird. Auf diese k\u00f6nnen mit write() und read() geschrieben und gelesen weden. pipe(...) gibt 0 zur\u00fcck, wenn kein Fehler aufgetreten ist. Eine Pipe geht nur in eine Richtung und daher muss eine der beiden Deskriptoren von je einem Prozess kreuzweise mit close(int filedesriptor) geschlossen werden, dass die Pipe nutzbar ist. Mit write(int filedes, void *buffer, size_t size) Eine Pipe kann auch Non-Blocking genutzt werden. Dies kann folgendermassen gesetzt werden: Nun kann folgendermassen davon gelesen werden: Mit int mkfifo(char* pathname, mode_t mode) wird eine Named-Pipe erstellt. Die Funktion gibt 0 zur\u00fcck, wenn kein Fehler aufgetreten ist. Die beiden Prozesse k\u00f6nnen vom File bei pathname lesen oder schrieben.","title":"Pipes"},{"location":"22FS/SNP/05_OS.html#message-queue","text":"Ist eine Queue, welche Strings zwischen Prozessen austauschen kann. Das Programm muss mit dem -lrt Flag kompiliert werden. Mit mqd_t mq_open(char* qname, int flag, int mode, struct mq_attribute *attr) kann eine neue Queue ge\u00f6ffnet werden. Der QName muss mit einem Slash beginnen und existieren in einem Virtuellen Filesystem /dev/mqueue . Queues k\u00f6nnen auch Non-Blocking ge\u00f6ffnet werden. Mit int mq_close(mqd_t queue) teilt dem Kernel mit, dass der Zugriff auf die Queue abgeschlossen ist. Mit int mq_unlink(char* name) kann die Queue gel\u00f6scht werden. Sie kann danach nicht mehr ge\u00f6ffnet werden und wird gel\u00f6scht, wenn jeder Prozess, welcher ein File-Deskriptor offen hat, diesen mit mq_close(...) geschlossen hat.","title":"Message Queue"},{"location":"22FS/SNP/05_OS.html#sockets","text":"","title":"Sockets"},{"location":"22FS/SNP/06_Standard%20Library.html","text":"Standard Library stdio.h perror void perror(char *s) druckt den letzten Fehler mit der angegebenen Nachricht aus. printf / sprintf (man 3 printf) printf(char *format, args...) formatiert die args anhand von dem format . Es gibt 3 relevante Methoden: printf(char *format, args...) druckt den formatierten String in die Konsole sprintf(charr *str, char *format, args...) schreibt den formatierten String in die Variable str . fprintf(FILE *stream, char *format, args...) schreibt den formatierten String in das File stream Jeder Platzhalter folgt dem Muster %[flags][width][.precision]conversion Die width gibt an, wie viel Platz vor der Variable soll sein. Wenn die Zahl mit einem 0 prefixt ist (z.B. 022 ), wird die Zahl 0-padded. Dies wird allerdings nur von Zahlen, wie Integers oder Doubles unterst\u00fctzt. Die .precision gibt an, wie viele Stellen nach dem Komma gedruckt werden sollen und wird nur f\u00fcr Kommazahlen unterst\u00fctzt. Anstatt eine Zahl f\u00fcr width und .precision kann auch ein * verwendet werden. Dabei wird der Wert als Input genommen. Beispiel: printf(\"%0*.*f\", 7, 2, 2.456666) w\u00fcrde 0002.46 ausgeben. Das flag kann - sein, was bewirkt, dass das Feld left-adjusted wird. Folgende Conversions sind g\u00e4ngig: Typ C Erkl\u00e4rung Beispiel int d, i gibt ein int aus. Precission ist nicht unterst\u00fctzt %02i (druckt 03 ) unsinged int u, x/X u gibt die Zahl in dezimal aus, x in Hex als kleine Buchstaben (ff) und X mit grossen Buchstaben (FF) %04u (druckt 0022 ), %X (druckt AF2 ) double f gibt double aus %.3f = \"2.340\" char c gibt ein char aus. Precission und 0-padding sind nicht unterst\u00fctzt %2c = \" d\" char* s gibt ein string aus %s = \"Hello world\" scanf scanf(char *format, ...) liest ein Format vom stdin. Es gibt auch fscanf(FILE *stream, char *format, ...) , was von einem File scannt und sscanf(char *str, char *format, ...) , was von einem String scannet. Als R\u00fcckgabe Wert wird die Anzahl von gefunden Inputs zur\u00fcck gegeben. Das Format ist wie bei printf mit einigen \u00c4nderungen. f ist nur f\u00fcr floats lf muss f\u00fcr doubles genutzt werden scanf(\"hello %d\", i) w\u00e4re nicht valide, da keine fixe Strings im scanf -Format stehen darf int getchar() Blockiert, bis der Nutzer eine Zeile in die Konsole eingegeben hat. Danach wird jeweils ein Zeichen von diesem Buffer gelesen und zur\u00fcck gegeben. Wenn stdin geschlossen wird, wird EOF zur\u00fcck gegeben. String-Library int strlen(char *str) Die L\u00e4nge des Strings (ohne \\0 ) int strcmp(char *s1, char *s2) char* strcpy(char *dest, char *src) Achtung: dest muss genug gross f\u00fcr src sein car *strcat(char *s1, char *s2) Achtung: s1 muss genug gross, f\u00fcr s1 + s2 sein char *strdup(char *s) Dupliziert s in einer neuen char* , welcher mit free(...) freigegeben werden muss char* strsep(char **stringp, char* dellim) Findet den ersten Token und gibt ein Pointer auf diesem Zur\u00fcck. In *stringp wird der delim mit \\0 \u00fcberschrieben und **stringp wird geupdated, dass es auf den delim zeigt. #include <string.h> #include <stdio.h> #include <stdlib.h> int main ( void ) { char * s1 = strdup ( \"1, 2, 3, hi\" ); char * token ; while (( token = strsep ( & src , \",\" )) != NULL ) { printf ( \"token: %s \\n \" , token ); } free ( s1 ); } char *strtok(char *s, char *delim) Es wird nach delim in s gesucht. Wenn gefunden, wird delim durch \\0 ersetzt und es wird ein Pointer auf den gefundenen Token zur\u00fcck gegeben. Es wird ein interner statischer Buffer verwendet. Daher wird bei folge Aufrufe NULL als s verwendet. #include <string.h> #include <stdio.h> #include <stdlib.h> int main ( void ) { char * s1 = strdup ( \"1, 2, 3, hi\" ); for ( char * token = strtok ( s1 , \",\" ); token != NULL ; token = strtok ( NULL , \",\" )) { printf ( \"token: %s \\n \" , token ); } free ( s1 ); }","title":"Standard Library"},{"location":"22FS/SNP/06_Standard%20Library.html#standard-library","text":"","title":"Standard Library"},{"location":"22FS/SNP/06_Standard%20Library.html#stdioh","text":"","title":"stdio.h"},{"location":"22FS/SNP/06_Standard%20Library.html#perror","text":"void perror(char *s) druckt den letzten Fehler mit der angegebenen Nachricht aus.","title":"perror"},{"location":"22FS/SNP/06_Standard%20Library.html#printfsprintf-man-3-printf","text":"printf(char *format, args...) formatiert die args anhand von dem format . Es gibt 3 relevante Methoden: printf(char *format, args...) druckt den formatierten String in die Konsole sprintf(charr *str, char *format, args...) schreibt den formatierten String in die Variable str . fprintf(FILE *stream, char *format, args...) schreibt den formatierten String in das File stream Jeder Platzhalter folgt dem Muster %[flags][width][.precision]conversion Die width gibt an, wie viel Platz vor der Variable soll sein. Wenn die Zahl mit einem 0 prefixt ist (z.B. 022 ), wird die Zahl 0-padded. Dies wird allerdings nur von Zahlen, wie Integers oder Doubles unterst\u00fctzt. Die .precision gibt an, wie viele Stellen nach dem Komma gedruckt werden sollen und wird nur f\u00fcr Kommazahlen unterst\u00fctzt. Anstatt eine Zahl f\u00fcr width und .precision kann auch ein * verwendet werden. Dabei wird der Wert als Input genommen. Beispiel: printf(\"%0*.*f\", 7, 2, 2.456666) w\u00fcrde 0002.46 ausgeben. Das flag kann - sein, was bewirkt, dass das Feld left-adjusted wird. Folgende Conversions sind g\u00e4ngig: Typ C Erkl\u00e4rung Beispiel int d, i gibt ein int aus. Precission ist nicht unterst\u00fctzt %02i (druckt 03 ) unsinged int u, x/X u gibt die Zahl in dezimal aus, x in Hex als kleine Buchstaben (ff) und X mit grossen Buchstaben (FF) %04u (druckt 0022 ), %X (druckt AF2 ) double f gibt double aus %.3f = \"2.340\" char c gibt ein char aus. Precission und 0-padding sind nicht unterst\u00fctzt %2c = \" d\" char* s gibt ein string aus %s = \"Hello world\"","title":"printf/sprintf (man 3 printf)"},{"location":"22FS/SNP/06_Standard%20Library.html#scanf","text":"scanf(char *format, ...) liest ein Format vom stdin. Es gibt auch fscanf(FILE *stream, char *format, ...) , was von einem File scannt und sscanf(char *str, char *format, ...) , was von einem String scannet. Als R\u00fcckgabe Wert wird die Anzahl von gefunden Inputs zur\u00fcck gegeben. Das Format ist wie bei printf mit einigen \u00c4nderungen. f ist nur f\u00fcr floats lf muss f\u00fcr doubles genutzt werden scanf(\"hello %d\", i) w\u00e4re nicht valide, da keine fixe Strings im scanf -Format stehen darf","title":"scanf"},{"location":"22FS/SNP/06_Standard%20Library.html#int-getchar","text":"Blockiert, bis der Nutzer eine Zeile in die Konsole eingegeben hat. Danach wird jeweils ein Zeichen von diesem Buffer gelesen und zur\u00fcck gegeben. Wenn stdin geschlossen wird, wird EOF zur\u00fcck gegeben.","title":"int getchar()"},{"location":"22FS/SNP/06_Standard%20Library.html#string-library","text":"int strlen(char *str) Die L\u00e4nge des Strings (ohne \\0 ) int strcmp(char *s1, char *s2) char* strcpy(char *dest, char *src) Achtung: dest muss genug gross f\u00fcr src sein car *strcat(char *s1, char *s2) Achtung: s1 muss genug gross, f\u00fcr s1 + s2 sein char *strdup(char *s) Dupliziert s in einer neuen char* , welcher mit free(...) freigegeben werden muss char* strsep(char **stringp, char* dellim) Findet den ersten Token und gibt ein Pointer auf diesem Zur\u00fcck. In *stringp wird der delim mit \\0 \u00fcberschrieben und **stringp wird geupdated, dass es auf den delim zeigt. #include <string.h> #include <stdio.h> #include <stdlib.h> int main ( void ) { char * s1 = strdup ( \"1, 2, 3, hi\" ); char * token ; while (( token = strsep ( & src , \",\" )) != NULL ) { printf ( \"token: %s \\n \" , token ); } free ( s1 ); } char *strtok(char *s, char *delim) Es wird nach delim in s gesucht. Wenn gefunden, wird delim durch \\0 ersetzt und es wird ein Pointer auf den gefundenen Token zur\u00fcck gegeben. Es wird ein interner statischer Buffer verwendet. Daher wird bei folge Aufrufe NULL als s verwendet. #include <string.h> #include <stdio.h> #include <stdlib.h> int main ( void ) { char * s1 = strdup ( \"1, 2, 3, hi\" ); for ( char * token = strtok ( s1 , \",\" ); token != NULL ; token = strtok ( NULL , \",\" )) { printf ( \"token: %s \\n \" , token ); } free ( s1 ); }","title":"String-Library"},{"location":"22FS/THIN/00_Fragen.html","text":"Fragen Satz von Rice Das heisst doch, dass eine Menge von entscheidbaren Funktionen unentscheidbar ist? F\u00fcr was werden Loop/While/... Programme ben\u00f6tigt? Und wieso sind sie so restriktiv (z.B. \\(x_0=x_1+x_2\\) ist nicht erlaubt, obwohl es mit einem Loop-Programm selbst machbar ist)? Eine Frage wegen der Entscheidbarkeit vom Halteproblem: Wie passen die folgende zwei Folien zusammen: und und Laut den Folien ist das Spezielle Halteproblem, das Halteproblem und das leere Halteproblem semi-entscheidbar, weill H0 semi entscheidbar ist und nicht entscheidbar weil Hs nicht entscheidbar ist. Nicht-Entscheidbar = Es ist nicht entscheidbar, k\u00f6nnte aber semi-entscheidbar sein Unentscheidbar = Es h\u00e4lt nie an In der Folien werden die Begriffe als Synonyme verwendet \"So kann auch komplement von M nicht nach (1) semi-entscheidbar sein\"? Wenn NP=P ist, dann k\u00f6nnten alle NP-Probeleme deterministisch in Polynomzeit gel\u00f6st werden.","title":"Fragen"},{"location":"22FS/THIN/00_Fragen.html#fragen","text":"Satz von Rice Das heisst doch, dass eine Menge von entscheidbaren Funktionen unentscheidbar ist? F\u00fcr was werden Loop/While/... Programme ben\u00f6tigt? Und wieso sind sie so restriktiv (z.B. \\(x_0=x_1+x_2\\) ist nicht erlaubt, obwohl es mit einem Loop-Programm selbst machbar ist)? Eine Frage wegen der Entscheidbarkeit vom Halteproblem: Wie passen die folgende zwei Folien zusammen: und und Laut den Folien ist das Spezielle Halteproblem, das Halteproblem und das leere Halteproblem semi-entscheidbar, weill H0 semi entscheidbar ist und nicht entscheidbar weil Hs nicht entscheidbar ist. Nicht-Entscheidbar = Es ist nicht entscheidbar, k\u00f6nnte aber semi-entscheidbar sein Unentscheidbar = Es h\u00e4lt nie an In der Folien werden die Begriffe als Synonyme verwendet \"So kann auch komplement von M nicht nach (1) semi-entscheidbar sein\"? Wenn NP=P ist, dann k\u00f6nnten alle NP-Probeleme deterministisch in Polynomzeit gel\u00f6st werden.","title":"Fragen"},{"location":"22FS/THIN/01_Definitionen.html","text":"Definitionen Alphabet Ein Alphabet ist ein endliche, nichtleere Menge von Symbolen. Als Beispiel: \\(\\Sigma=\\{a, b, c\\}\\) \\(\\N\\) w\u00e4re kein Alphabet, das es nicht endlich ist! W\u00f6rter Ein Wort ist eine endliche Folge von Symbolen eines bestimmten Alphabets. Das leere Wort \\(\\varepsilon\\) ist ein Wort, welches keine Symbole enthaltet. Dieses Wort gibt es \u00fcber jedem Alphabet. Als Beispiel: \\(abc\\) ist ein Wort \u00fcber dem Alphabet \\(\\Sigma_{lat}\\) . W\u00f6rter k\u00f6nnen auch als Mengenschreibweisse dargestellt werden. L\u00e4nge eines Wortes Der Betrag eines Wortes ist die L\u00e4nge des Wortes. Beispiel: \\(|abc|=3\\) \\(|\\varepsilon|=0\\) Absolute H\u00e4ufigkeit \\(|w|_x bezeichnet die absolute H\\) uffigkeit eines Symboles \\(x\\) in einem Wort \\(w\\) Beispiel: \\(|abc|_a=1\\) \\(|100111|_1=4\\) \\(|\\varepsilon|_{\\varepsilon}=1\\) Spiegelwort Mit \\(w^R\\) wird das Spiegelwort zu \\(w\\) bezeichnet. $$ W^R=(x_1, x_2...x_n)^R=(x_n...x_2,x_1) $$ Dabei gilt, dass \\(|w|=|w^R|\\) und \\(|w|_x=|w^R|_x\\) Wenn \\(w=w^R\\) gilt, dann wird \\(w\\) als Palindrom bezeichnet Beispiel: \\((abc)^R=cba\\) Teile von W\u00f6rter Der start eines Wortes \\(w\\) wird Pr\u00e4fix genannt. Symbole in der Mitte werden Infixe oder auch Teilw\u00f6rter. Das Ende eines Wortes \\(w\\) wird Suffix genannt. Ein Pr\u00e4fix, Infix oder Suffix ist echt, wenn sie nicht gleich das Wort \\(w\\) ist Menge aller W\u00f6rter mit einer L\u00e4nge Die Menge aller W\u00f6rter der L\u00e4nge \\(k\\) \u00fcber einem Alphabet \\(\\Sigma\\) wird mit \\(\\Sigma^k\\) bezeichnet. \\(\\Sigma^0=\\{\\varepsilon\\}\\) Dies ist per Definition f\u00fcr alle Alphabete gegeben. Beispiel: \\(\\{0, 1\\}^2=\\{00, 01, 10, 11\\}\\) Kleenesche H\u00fclle Die Menge aller W\u00f6rter \\(\\Sigma^*\\) in einem Alphabet wird Kleenesche H\u00fclle genannt und ist abz\u00e4hlbar Unendlich \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) und ist die Menge aller W\u00f6rter \u00fcber \\(\\Sigma\\) ohne das leere Wort Konkatination \\(x\\circ y=xy\\) heisst, dass die W\u00f6rter \\(x\\) und \\(y\\) zusammen verkettet werden. Die W\u00f6rter m\u00fcssen nicht aus demselben Alphabet kommen. Es gilt zudem: \\(|x|+|y|=|xy|=|x\\circ y|\\) Beispiel: \\(x=22\\) und \\(y=100\\) , dann gilt: \\(xy=x\\circ y=22100\\) Wortpotenzen Die Wortpotenz ist definiert mit der folgenden Defintion $$ x^0=\\varepsilon\\ x^{n+1}=x^n\\circ x $$ Beispiel: \\(a^3=a^2a=a^1aa=a^0aaa=aaa\\) \\(bbababababaaa=b^2(ab)^4a^3\\) (Dies ist nicht die einzige L\u00f6sung) Sprachen Eine Teilmenge von W\u00f6rtern nennt man eine Sprache (Dies kann auch als \\(L\\subseteq \\Sigma^*\\) geschrieben werden) \\(\\Sigma*\\) ist auch eine Sprache \u00fcber dem Alphabet \\(\\Sigma\\) Wenn \\(\\Sigma_1 \\subseteq \\Sigma_2\\) und \\(L\\) eine Sprache \u00fcber \\(\\Sigma_1\\) ist, dann ist \\(L\\) auch eine Sprache \u00fcber \\(\\Sigma_2\\) \\(\\emptyset\\) ist eine leere Sprache; Also eine Sprache ohne W\u00f6rter und gilt f\u00fcr jedes Alphabet ( \\(\\empty\\neq \\{\\varepsilon\\}\\) ) Sprache k\u00f6nnen aus unendlich vielen W\u00f6rtern bestehen. Die W\u00f6rter m\u00fcssen aus einem endlichen Alphabet gebildet werden und m\u00fcssen endlich lang sein. Darstellungsm\u00f6glichkeiten: \\(L=\\{\\varepsilon, 10, 1100, 111000, ...\\}\\) in Prosa \\(L=\\{1^n0^n|n\\in \\N\\}\\) Sprachen-Konkatenation \\(A\\subset \\Sigma^*\\) und \\(B\\subset \\Gamma^*\\) sind zwei Sprachen, dann ist \\(AB=\\{uv|u\\in A \\text{ und } v \\in B\\}\\) Zudem gilt: Ist \\(A\\) eine Sprache \u00fcber \\(\\Sigma\\) und \\(B\\) eine Sprache \u00fcber \\(\\Gamma\\) , dann ist \\(AB\\) eine Sprache \u00fcber dem Alphabet \\(\\Sigma \\cup\\Gamma\\) Kleenesche H\u00fclle einer Sprache Die Kleenesche H\u00fclle \\(A*\\) einer Sprache \\(A\\) ist durch \\({\\varepsilon}\\cup A \\cup AA \\cup AAA \\cup ...\\) Die Kleenische H\u00e8lle einer Sprache ist selbst eine Liste von W\u00f6rter, da die Liste aber unendlich ist, ist sie selbst keine Sprache ( stimmt das? ) Komplement einer Sprache Das Komplement einer Sprache sind alle W\u00f6rter, welche nicht in der Sprache sind \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\) Entscheidungsproblem Sei eine Sprache \\(L\\) \u00fcber einem Alphabet \\(\\Sigma\\) gegeben. Das Entscheidungsproblem \\((\\Sigma, L)\\) ist die folgende: Input: Eine Sprache \\(L\\) und ein Wort \\(x\\in\\Sigma^*\\) Output: JA, falls \\(x\\in L\\) ist und NEIN, falls \\(x\\not \\in L\\) ist In Deutsch: \"Geh\u00f6rt ein Wort eines Alphabetes zu einer Sprache?\" Chomsky-Hirarchie Fragen Ist die Kleenische H\u00fclle einer Sprache wieder eine Sprache? - Ja","title":"Definitionen"},{"location":"22FS/THIN/01_Definitionen.html#definitionen","text":"","title":"Definitionen"},{"location":"22FS/THIN/01_Definitionen.html#alphabet","text":"Ein Alphabet ist ein endliche, nichtleere Menge von Symbolen. Als Beispiel: \\(\\Sigma=\\{a, b, c\\}\\) \\(\\N\\) w\u00e4re kein Alphabet, das es nicht endlich ist!","title":"Alphabet"},{"location":"22FS/THIN/01_Definitionen.html#worter","text":"Ein Wort ist eine endliche Folge von Symbolen eines bestimmten Alphabets. Das leere Wort \\(\\varepsilon\\) ist ein Wort, welches keine Symbole enthaltet. Dieses Wort gibt es \u00fcber jedem Alphabet. Als Beispiel: \\(abc\\) ist ein Wort \u00fcber dem Alphabet \\(\\Sigma_{lat}\\) . W\u00f6rter k\u00f6nnen auch als Mengenschreibweisse dargestellt werden.","title":"W\u00f6rter"},{"location":"22FS/THIN/01_Definitionen.html#lange-eines-wortes","text":"Der Betrag eines Wortes ist die L\u00e4nge des Wortes. Beispiel: \\(|abc|=3\\) \\(|\\varepsilon|=0\\)","title":"L\u00e4nge eines Wortes"},{"location":"22FS/THIN/01_Definitionen.html#absolute-haufigkeit","text":"\\(|w|_x bezeichnet die absolute H\\) uffigkeit eines Symboles \\(x\\) in einem Wort \\(w\\) Beispiel: \\(|abc|_a=1\\) \\(|100111|_1=4\\) \\(|\\varepsilon|_{\\varepsilon}=1\\)","title":"Absolute H\u00e4ufigkeit"},{"location":"22FS/THIN/01_Definitionen.html#spiegelwort","text":"Mit \\(w^R\\) wird das Spiegelwort zu \\(w\\) bezeichnet. $$ W^R=(x_1, x_2...x_n)^R=(x_n...x_2,x_1) $$ Dabei gilt, dass \\(|w|=|w^R|\\) und \\(|w|_x=|w^R|_x\\) Wenn \\(w=w^R\\) gilt, dann wird \\(w\\) als Palindrom bezeichnet Beispiel: \\((abc)^R=cba\\)","title":"Spiegelwort"},{"location":"22FS/THIN/01_Definitionen.html#teile-von-worter","text":"Der start eines Wortes \\(w\\) wird Pr\u00e4fix genannt. Symbole in der Mitte werden Infixe oder auch Teilw\u00f6rter. Das Ende eines Wortes \\(w\\) wird Suffix genannt. Ein Pr\u00e4fix, Infix oder Suffix ist echt, wenn sie nicht gleich das Wort \\(w\\) ist","title":"Teile von W\u00f6rter"},{"location":"22FS/THIN/01_Definitionen.html#menge-aller-worter-mit-einer-lange","text":"Die Menge aller W\u00f6rter der L\u00e4nge \\(k\\) \u00fcber einem Alphabet \\(\\Sigma\\) wird mit \\(\\Sigma^k\\) bezeichnet. \\(\\Sigma^0=\\{\\varepsilon\\}\\) Dies ist per Definition f\u00fcr alle Alphabete gegeben. Beispiel: \\(\\{0, 1\\}^2=\\{00, 01, 10, 11\\}\\)","title":"Menge aller W\u00f6rter mit einer L\u00e4nge"},{"location":"22FS/THIN/01_Definitionen.html#kleenesche-hulle","text":"Die Menge aller W\u00f6rter \\(\\Sigma^*\\) in einem Alphabet wird Kleenesche H\u00fclle genannt und ist abz\u00e4hlbar Unendlich \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) und ist die Menge aller W\u00f6rter \u00fcber \\(\\Sigma\\) ohne das leere Wort","title":"Kleenesche H\u00fclle"},{"location":"22FS/THIN/01_Definitionen.html#konkatination","text":"\\(x\\circ y=xy\\) heisst, dass die W\u00f6rter \\(x\\) und \\(y\\) zusammen verkettet werden. Die W\u00f6rter m\u00fcssen nicht aus demselben Alphabet kommen. Es gilt zudem: \\(|x|+|y|=|xy|=|x\\circ y|\\) Beispiel: \\(x=22\\) und \\(y=100\\) , dann gilt: \\(xy=x\\circ y=22100\\)","title":"Konkatination"},{"location":"22FS/THIN/01_Definitionen.html#wortpotenzen","text":"Die Wortpotenz ist definiert mit der folgenden Defintion $$ x^0=\\varepsilon\\ x^{n+1}=x^n\\circ x $$ Beispiel: \\(a^3=a^2a=a^1aa=a^0aaa=aaa\\) \\(bbababababaaa=b^2(ab)^4a^3\\) (Dies ist nicht die einzige L\u00f6sung)","title":"Wortpotenzen"},{"location":"22FS/THIN/01_Definitionen.html#sprachen","text":"Eine Teilmenge von W\u00f6rtern nennt man eine Sprache (Dies kann auch als \\(L\\subseteq \\Sigma^*\\) geschrieben werden) \\(\\Sigma*\\) ist auch eine Sprache \u00fcber dem Alphabet \\(\\Sigma\\) Wenn \\(\\Sigma_1 \\subseteq \\Sigma_2\\) und \\(L\\) eine Sprache \u00fcber \\(\\Sigma_1\\) ist, dann ist \\(L\\) auch eine Sprache \u00fcber \\(\\Sigma_2\\) \\(\\emptyset\\) ist eine leere Sprache; Also eine Sprache ohne W\u00f6rter und gilt f\u00fcr jedes Alphabet ( \\(\\empty\\neq \\{\\varepsilon\\}\\) ) Sprache k\u00f6nnen aus unendlich vielen W\u00f6rtern bestehen. Die W\u00f6rter m\u00fcssen aus einem endlichen Alphabet gebildet werden und m\u00fcssen endlich lang sein. Darstellungsm\u00f6glichkeiten: \\(L=\\{\\varepsilon, 10, 1100, 111000, ...\\}\\) in Prosa \\(L=\\{1^n0^n|n\\in \\N\\}\\)","title":"Sprachen"},{"location":"22FS/THIN/01_Definitionen.html#sprachen-konkatenation","text":"\\(A\\subset \\Sigma^*\\) und \\(B\\subset \\Gamma^*\\) sind zwei Sprachen, dann ist \\(AB=\\{uv|u\\in A \\text{ und } v \\in B\\}\\) Zudem gilt: Ist \\(A\\) eine Sprache \u00fcber \\(\\Sigma\\) und \\(B\\) eine Sprache \u00fcber \\(\\Gamma\\) , dann ist \\(AB\\) eine Sprache \u00fcber dem Alphabet \\(\\Sigma \\cup\\Gamma\\)","title":"Sprachen-Konkatenation"},{"location":"22FS/THIN/01_Definitionen.html#kleenesche-hulle-einer-sprache","text":"Die Kleenesche H\u00fclle \\(A*\\) einer Sprache \\(A\\) ist durch \\({\\varepsilon}\\cup A \\cup AA \\cup AAA \\cup ...\\) Die Kleenische H\u00e8lle einer Sprache ist selbst eine Liste von W\u00f6rter, da die Liste aber unendlich ist, ist sie selbst keine Sprache ( stimmt das? )","title":"Kleenesche H\u00fclle einer Sprache"},{"location":"22FS/THIN/01_Definitionen.html#komplement-einer-sprache","text":"Das Komplement einer Sprache sind alle W\u00f6rter, welche nicht in der Sprache sind \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\)","title":"Komplement einer Sprache"},{"location":"22FS/THIN/01_Definitionen.html#entscheidungsproblem","text":"Sei eine Sprache \\(L\\) \u00fcber einem Alphabet \\(\\Sigma\\) gegeben. Das Entscheidungsproblem \\((\\Sigma, L)\\) ist die folgende: Input: Eine Sprache \\(L\\) und ein Wort \\(x\\in\\Sigma^*\\) Output: JA, falls \\(x\\in L\\) ist und NEIN, falls \\(x\\not \\in L\\) ist In Deutsch: \"Geh\u00f6rt ein Wort eines Alphabetes zu einer Sprache?\"","title":"Entscheidungsproblem"},{"location":"22FS/THIN/01_Definitionen.html#chomsky-hirarchie","text":"","title":"Chomsky-Hirarchie"},{"location":"22FS/THIN/01_Definitionen.html#fragen","text":"Ist die Kleenische H\u00fclle einer Sprache wieder eine Sprache? - Ja","title":"Fragen"},{"location":"22FS/THIN/02_RegEx.html","text":"RegEx Syntax vs Semantik Der Syntax sagt aus, wie die Symbole des Alphabetes zu W\u00f6rter angeordnet werden. Die Semantik sagt aus, was die Symbole bedeuten (z.B. dass die Zahl 101 im Zehnersystem die Zahl 5 ist.) Syntax \\((0|1)\\) - entweder 0 oder 1 (Manchmal wird dies auch als \\((0+1)\\) geschrieben) \\(x^*\\) - beliebig oft \\(x\\) , auch null mal \\(x^+=xx^*\\) - mindestens 1-mal \\(x\\) \\(x?=(x|\\epsilon)\\) - \\(x\\) ist optional \\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache Regular-Expression-Sprache Die Sprache \\(RA_\\Sigma\\) i Eine Menge von Regexe f\u00fcr das Alphabet \\(\\Sigma\\) ist eine Sprache \u00fcber dem Alphabet \\(\\{\\O, \\epsilon, ^*, (, ), \\vert\\} \\cup \\Sigma\\) \"Punkt vor Strich\"-Regeln f\u00fcr Regex: \\(^*\\) vor Konkatenation Konkatenanation vor \\(\\vert\\) Definitionen \\(L(\\emptyset)=\\emptyset\\) \\(L(\\epsilon)=\\{\\varepsilon\\}\\) \\(L(a)=\\{a\\}\\) \\(L(R^*)=L(R)^*\\) \\(L(R|S)=L(R) \\cup L(S)\\) \\(L(RS)=L(R)L(S)\\) Wann ist Sprachen regul\u00e4r Eine Sprache nennt sich regul\u00e4r, wenn sie mit einem Regul\u00e4ren Ausdruck gebildet werden kann. Daf\u00fcr gibt es eine Regeln: Die Sprache \\(L_1\\) und \\(L_2\\) sind jeweils regul\u00e4r: \\(L_1L_2\\) ist regul\u00e4r \\(L_1\\cup L_2\\) (Vereinigung) ist regul\u00e4r \\(L_1\\cap L_1\\) (Schnittmenge) ist regul\u00e4r \\(L_1\\setminus L_2\\) (Differenz) ist regul\u00e4r \\(L_1^*\\) ist regul\u00e4r \\(\\overline {L_1}\\) ist regul\u00e4r Kurz gesagt: Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r Fragen Kommt es nicht auf den Regex darauf an, ob das Alphabet eine Teilmenge der Sprache ist? Wenn \\(R\\) ein Wort ist, w\u00e4re die Kleenische H\u00fclle nicht eine Sprache? Wenn ja, wieso ist eine Sprache ein Element einer anderen Sprache? Was bedeutet \\(\\O\\) ? Was ist die Kleenische H\u00fclle eines Regex? (Folie 7)","title":"RegEx"},{"location":"22FS/THIN/02_RegEx.html#regex","text":"","title":"RegEx"},{"location":"22FS/THIN/02_RegEx.html#syntax-vs-semantik","text":"Der Syntax sagt aus, wie die Symbole des Alphabetes zu W\u00f6rter angeordnet werden. Die Semantik sagt aus, was die Symbole bedeuten (z.B. dass die Zahl 101 im Zehnersystem die Zahl 5 ist.)","title":"Syntax vs Semantik"},{"location":"22FS/THIN/02_RegEx.html#syntax","text":"\\((0|1)\\) - entweder 0 oder 1 (Manchmal wird dies auch als \\((0+1)\\) geschrieben) \\(x^*\\) - beliebig oft \\(x\\) , auch null mal \\(x^+=xx^*\\) - mindestens 1-mal \\(x\\) \\(x?=(x|\\epsilon)\\) - \\(x\\) ist optional \\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache","title":"Syntax"},{"location":"22FS/THIN/02_RegEx.html#regular-expression-sprache","text":"Die Sprache \\(RA_\\Sigma\\) i Eine Menge von Regexe f\u00fcr das Alphabet \\(\\Sigma\\) ist eine Sprache \u00fcber dem Alphabet \\(\\{\\O, \\epsilon, ^*, (, ), \\vert\\} \\cup \\Sigma\\) \"Punkt vor Strich\"-Regeln f\u00fcr Regex: \\(^*\\) vor Konkatenation Konkatenanation vor \\(\\vert\\)","title":"Regular-Expression-Sprache"},{"location":"22FS/THIN/02_RegEx.html#definitionen","text":"\\(L(\\emptyset)=\\emptyset\\) \\(L(\\epsilon)=\\{\\varepsilon\\}\\) \\(L(a)=\\{a\\}\\) \\(L(R^*)=L(R)^*\\) \\(L(R|S)=L(R) \\cup L(S)\\) \\(L(RS)=L(R)L(S)\\)","title":"Definitionen"},{"location":"22FS/THIN/02_RegEx.html#wann-ist-sprachen-regular","text":"Eine Sprache nennt sich regul\u00e4r, wenn sie mit einem Regul\u00e4ren Ausdruck gebildet werden kann. Daf\u00fcr gibt es eine Regeln: Die Sprache \\(L_1\\) und \\(L_2\\) sind jeweils regul\u00e4r: \\(L_1L_2\\) ist regul\u00e4r \\(L_1\\cup L_2\\) (Vereinigung) ist regul\u00e4r \\(L_1\\cap L_1\\) (Schnittmenge) ist regul\u00e4r \\(L_1\\setminus L_2\\) (Differenz) ist regul\u00e4r \\(L_1^*\\) ist regul\u00e4r \\(\\overline {L_1}\\) ist regul\u00e4r Kurz gesagt: Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r","title":"Wann ist Sprachen regul\u00e4r"},{"location":"22FS/THIN/02_RegEx.html#fragen","text":"Kommt es nicht auf den Regex darauf an, ob das Alphabet eine Teilmenge der Sprache ist? Wenn \\(R\\) ein Wort ist, w\u00e4re die Kleenische H\u00fclle nicht eine Sprache? Wenn ja, wieso ist eine Sprache ein Element einer anderen Sprache? Was bedeutet \\(\\O\\) ? Was ist die Kleenische H\u00fclle eines Regex? (Folie 7)","title":"Fragen"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html","text":"Endliche Automaten Endliche Automaten haben keine Variabeln oder Speicher; Das einzige gespeicherte, ist der aktuelle Zustand Endliche Automaten arbeiten in Echtzeit Das \"Resultat\" ist der Endzustand und ob der Endzustand akkzeptiert/valid ist Definition eines Endlichen Autommaten Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein Konfiguration Eine Konfiguration ist: \\((q, w) \\in Q\\times\\Sigma^*\\) oder in Worten ist eine Konfiguration ein Zustand mit zus\u00e4tzlich das noch zu verarbeitende Wort Eine Startkonfiguration ist ein Element aus \\(\\{q_0\\}\\times \\Sigma^*\\) . Als Beispiel: \\((q_0, w_1)\\) Eine Endkonfiguration ist: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) . Als Beispiel: \\((q2, \\epsilon)\\) Das Wort \\(w\\) in einer Konfiguration \\((q, w)\\) ist der noch zu verarbeitende Teil des Inputwortes. Es ist daher ein Sufix des Inputwortes. Berechnungsschritte Der Berechnungsschritt \\(\\vdash_M\\) der Endlichen Maschine \\(M\\) ist definiert als \\((q, w)\\vdash_M(p,x)\\) , wenn \\(w=ax, a\\in\\Sigma\\) und \\(\\delta(q, a)=p\\) ergibt. Oder in Deutsch \\(\\vdash_M\\) der Endlichen Maschine M ist der Berechnungschritt zwischen einem und dem n\u00e4chsten Zustand. Beispiel Bei dieser Maschine w\u00fcrde folgendes Beispiel g\u00fcltig sein: \\((q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)\\) Berechnungen Eine endliche Folge von Berechnungsschritten, nennt man Berechnung . Es wird die folgende Notation ben\u00fctzt: \\((q_a, w_1,w_2...w_n)\\vdash_M(q_b, w_2...w_n)\\vdash_M...\\vdash_M(q_e,w_j...w_n)\\vdash_M=(q_a, w_1,w_2...w_n)\\vdash^*_M(q_e, w_j...w_n)\\) Der \\(\\vdash^*\\) Operator stellt alle Berechnungschritten zwischen den zwei angegebenen Schritten dar. Ausf\u00fchrung von Automaten (akzeptieren, verwerfen, stranden, Abfallzustand) Eine Berechnung wird akzeptiert , wenn der Endzustand \\(q_e\\in F\\) ist, also ein Endzustand ist. Falls dies nicht der Fall ist, wird die Berechnung verworfen . Die Maschine wird dann auch gestrantet genannt. Wenn ein Eingabewort nicht verarbeitet werden kann, weil es f\u00fcr ein Input-Symbol keinen \u00dcbergang gibt, geht die Maschine zum Abfallzustand . Das Eingabewort wird verworfen. Sprache eins endlichen Automaten Die Sprache eines endlichen Automaten \\(M\\) besteht aus allen W\u00f6rtern, welche bei \\(M\\) auf einem akzeptierenden Zustand fallen. \\(L(M)=\\{w\\in\\Sigma^*|\\text{Berechnung von } M \\text{ auf } w \\text{ ist akzeptiert}\\}\\) Jeder endlichen Automat kann als Regex geschrieben werden und umgekehrt. Elemente Was Beschreibung Der Startzustand Normaler Zustand Akzeptierter Endzustand \u00dcbergangsfunktionen: Vom Zustand \"0.50\" kann zu \"1.50\" gelaufen werden Zus\u00e4tzlich wird das Eingabealphabet definiert. Dies sind die Symbole, welche dem Automaten als Input gegeben weden kann. Moore Automaten vs Mealy Automaten Bei einem Mealy Automaten h\u00e4ngt der n\u00e4chste Zustand vom aktuellen Zustand und dem Input ab. Beim Moore Automaten hingegen h\u00e4ngt der n\u00e4chste Zustand nur vom aktuellen Zustand ab. F\u00fcr jeder Mealy Automat gibt es einen Moore Automat und umgekehrt. Berechnungsmodell Das Berechnungsmodel beschriebt, wie ein Automat berechnet wird. Definiere die Struktur des Automaten. F\u00fcr einen endlichen Automaten ist es: \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Beschreibung der Bedeutung (Semantik) der Struktur Konfiguration : Die vollst\u00e4ndige Beschreibung eines Zustandes des Automats Berechnungsschritt : Der \u00dcbergang von einer Konfiguration zur n\u00e4chsten Berechnung: Die Berechnungsschritte werden gefolgt Jedem Zustand des Automaten k\u00f6nnen eine Bedeutung zu gewissen werden. (Nicht-)Deterministische endlichen Automaten Bei einem determinisctischen endlichen Automaten ist jede Konfiguration einzigartig. Also bei einem Zustand gibt es f\u00fcr jedes Inputwort ein m\u00f6glichen n\u00e4chsten Zustand. Bei einem nicht-deterministischen endlichen Automaten (NEA) ist dies nicht gegeben. Bei der folgenden NEA kann man von \\(q_0\\) mit \\(0\\) zu \\(q_1\\) oder bei \\(q_0\\) bleiben. Daher ist die Berechnungsfunktion \\(\\delta\\) anderst definiert: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) . Als \\(\\delta\\) gibt eine Menge von Zust\u00e4nde zur\u00fcck ( \\(\\mathcal P(Q)\\) ist die Potenzmenge von \\(Q\\) , also alle M\u00f6glichen Teilmengen von \\(Q\\) ) Bei solchen Automaten wird jede M\u00f6glichkeit ausprobiert. Gewisse M\u00f6glichkeiten werden in Sackgassen geraten und gewisse auf einem nicht akzeptierten Feld. Damit eine NEA ein Wort akzeptiert reicht wenn eine M\u00f6glichkeit gefunden wird, bei welchem den Endzustand akzeptiert wird. DEA und NEA sind gleichwertig. Eine Sprache kann in beiden Automaten abgebildet werden. NEA mit \\(\\epsilon\\) -\u00dcberg\u00e4nge Eine Zus\u00e4tzliche Eigenheit von NEAs sind die die \\(\\epsilon\\) -\u00dcberg\u00e4nge. Mit diesen kann die NEA den Zustand wechseln, ohne ein Inputwort zu konsumieren. Die \u00dcbergangsfunktion muss mit \\(\\epsilon\\) -\u00dcberg\u00e4nge noch mals modifiziert werden, da nun das leere Symbol noch hinzugef\u00fcgt werden muss: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) Unten folgt noch ein Beispiel mit \\(\\epsilon\\) -\u00dcberg\u00e4nge: DEAs sind ebenfalls equivalent zu \\(\\epsilon\\) -NEAs und umgekehrt. Also jede DEA kann in eine \\(\\epsilon\\) -NEA umgewandelt werden und umgekehrt. Um von einer \\(\\epsilon\\) -NEA zu einer DEA umwandeln, m\u00fcssen zuerst die \\(\\epsilon\\) -\u00dcberg\u00e4nge aufgel\u00f6st werden. Daf\u00fcr kann man sich \u00fcberlegen, was f\u00fcr Zeichen konsumiert werden k\u00f6nnten, wenn man den \\(\\epsilon\\) -\u00dcbergang nimmt. Diese \u00dcbergange in den urspr\u00fcnglichen Zustand aufnehmen. Es kann helfen, dies grafisch zu erledigen. Nach dem aufl\u00f6sen der \\(\\epsilon\\) -\u00dcberg\u00e4nge wird eine Teilmengenkonstruktion durchgef\u00fchrt. Teilmengenkonstruktion Mit einer Teilmengenkonstruktion kann aus einer NEA eine DEA erstellt werden. Die DEA \\(D=(Q_D, \\Sigma, \\delta_D, q_0, F_D)\\) wird aus der NEA \\(N=(Q_N, \\Sigma, \\delta_N, q_0, F_N)\\) \\(Q_d=\\mathcal P(Q_N)\\) : Alle Teilmengen von \\(Q_N\\) sind Zust\u00e4nde im DEA \\(F_D=\\{S\\in Q_D \\vert S \\cap F_N\\neq \\O\\}\\) : Alle Zust\u00e4nd-Teilmengen, welche ein Element mit den akzeptierten Zust\u00e4nden \\(F_N\\) teilen \\(\\delta_D(S, a)=\\cup_{p \\in S}\\delta_N(p, a)\\) : Alle Zust\u00e4nde, welche von einem Zustand in der Menge \\(S \\in Q_D\\) , erreichbar sind Oder in Worten ausgedr\u00fcckt: Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) Die potentielle Startzustand Kandidaten sind alle diese Teilmengen von \\(Q_N\\) , welche \\(q_0\\) enthalten Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Also nie bei einer Eingabe-Spalte auftauchen. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. Wenn \\(\\{q_1\\}\\) in einer Eingabe-Spalte steht, heisst das nur, dass \\(\\{q_1\\}\\) vorhanden ist. \\(\\{q_1, q_2\\}\\) muss immer noch gestrichen werden, wenn es nicht selbst vorkommt Wenn eine Verbindung das leeres Wort nimmt, werden die Zust\u00e4nde, welche man vom leeren Wort Zustand erreichen kann, auch vom urspr\u00fcnglichen Wort als erreichbar angesehen. Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z) Das resultiertende DEA aus dem NEA oben ist: \u00c4quivalenz von Automaten eine DEA ist \u00e4quivalent zu einem Regularen Ausdruck und umgekehrt Dabei ist eine Regularen Ausdruck ein beschreibenden Mechanismus und die DEAs, NEAs und \\(\\epsilon\\) -EAS akzeptierende Mechanismen. Automaten in einen RegEx umwandeln F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen Beispiel F\u00fcr jeden Zustand einen Ausdruck aufschreiben: $$ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0L_{q_1}\\Rightarrow(0|1)^ 0L_{q_1}\\Rightarrow(0|1) 01\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\ L_{q_2}&=\\varepsilon\\ \\end{align} $$ Arden'sches Lemma \\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruch Zustandsklassen \\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand) Folgende Regeln gelten f\u00fcr die Zustandsklassen: Jedes Wort landet in einem Zustand (wenn ein Automat strandet oder ein Input nicht verwendet werden kann, wird der zuletzt erreichten Zustand genommen) Kein Wort landet in einer DEA in zwei Zust\u00e4nde (gilt nicht f\u00fcr NEAs) Untere Schranke f\u00fcr endliche Automaten Die grunds\u00e4tzliche Idee ist, dass wenn die Worte \\(x\\) und \\(y\\) in derselben Zustandsklasse ist, dann ist \\(zx=zy\\) , wobei \\(z\\) irgend ein Wort ist. Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort, ein Wort ergibt, welches in der Sprache ist und mit dem anderen Wort ein, ein Wort welches nicht in der Sprache ist Wenn dies f\u00fcr jedes Wort von Schritt 2. getan werden kann, dann werden mindestens so viel Zust\u00e4nde ben\u00f6tigt. Da wenn zwei W\u00f6rter mit demselben Wort verbunden wird und diese in unterschiedlichen Sprache sind, die zwei W\u00f6rter in unterschiedlichen Zust\u00e4nde endet. Beispiel:","title":"Endliche Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#endliche-automaten","text":"Endliche Automaten haben keine Variabeln oder Speicher; Das einzige gespeicherte, ist der aktuelle Zustand Endliche Automaten arbeiten in Echtzeit Das \"Resultat\" ist der Endzustand und ob der Endzustand akkzeptiert/valid ist","title":"Endliche Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#definition-eines-endlichen-autommaten","text":"Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein","title":"Definition eines Endlichen Autommaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#konfiguration","text":"Eine Konfiguration ist: \\((q, w) \\in Q\\times\\Sigma^*\\) oder in Worten ist eine Konfiguration ein Zustand mit zus\u00e4tzlich das noch zu verarbeitende Wort Eine Startkonfiguration ist ein Element aus \\(\\{q_0\\}\\times \\Sigma^*\\) . Als Beispiel: \\((q_0, w_1)\\) Eine Endkonfiguration ist: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) . Als Beispiel: \\((q2, \\epsilon)\\) Das Wort \\(w\\) in einer Konfiguration \\((q, w)\\) ist der noch zu verarbeitende Teil des Inputwortes. Es ist daher ein Sufix des Inputwortes.","title":"Konfiguration"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#berechnungsschritte","text":"Der Berechnungsschritt \\(\\vdash_M\\) der Endlichen Maschine \\(M\\) ist definiert als \\((q, w)\\vdash_M(p,x)\\) , wenn \\(w=ax, a\\in\\Sigma\\) und \\(\\delta(q, a)=p\\) ergibt. Oder in Deutsch \\(\\vdash_M\\) der Endlichen Maschine M ist der Berechnungschritt zwischen einem und dem n\u00e4chsten Zustand.","title":"Berechnungsschritte"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#beispiel","text":"Bei dieser Maschine w\u00fcrde folgendes Beispiel g\u00fcltig sein: \\((q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)\\)","title":"Beispiel"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#berechnungen","text":"Eine endliche Folge von Berechnungsschritten, nennt man Berechnung . Es wird die folgende Notation ben\u00fctzt: \\((q_a, w_1,w_2...w_n)\\vdash_M(q_b, w_2...w_n)\\vdash_M...\\vdash_M(q_e,w_j...w_n)\\vdash_M=(q_a, w_1,w_2...w_n)\\vdash^*_M(q_e, w_j...w_n)\\) Der \\(\\vdash^*\\) Operator stellt alle Berechnungschritten zwischen den zwei angegebenen Schritten dar.","title":"Berechnungen"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#ausfuhrung-von-automaten-akzeptieren-verwerfen-stranden-abfallzustand","text":"Eine Berechnung wird akzeptiert , wenn der Endzustand \\(q_e\\in F\\) ist, also ein Endzustand ist. Falls dies nicht der Fall ist, wird die Berechnung verworfen . Die Maschine wird dann auch gestrantet genannt. Wenn ein Eingabewort nicht verarbeitet werden kann, weil es f\u00fcr ein Input-Symbol keinen \u00dcbergang gibt, geht die Maschine zum Abfallzustand . Das Eingabewort wird verworfen.","title":"Ausf\u00fchrung von Automaten (akzeptieren, verwerfen, stranden, Abfallzustand)"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#sprache-eins-endlichen-automaten","text":"Die Sprache eines endlichen Automaten \\(M\\) besteht aus allen W\u00f6rtern, welche bei \\(M\\) auf einem akzeptierenden Zustand fallen. \\(L(M)=\\{w\\in\\Sigma^*|\\text{Berechnung von } M \\text{ auf } w \\text{ ist akzeptiert}\\}\\) Jeder endlichen Automat kann als Regex geschrieben werden und umgekehrt.","title":"Sprache eins endlichen Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#elemente","text":"Was Beschreibung Der Startzustand Normaler Zustand Akzeptierter Endzustand \u00dcbergangsfunktionen: Vom Zustand \"0.50\" kann zu \"1.50\" gelaufen werden Zus\u00e4tzlich wird das Eingabealphabet definiert. Dies sind die Symbole, welche dem Automaten als Input gegeben weden kann.","title":"Elemente"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#moore-automaten-vs-mealy-automaten","text":"Bei einem Mealy Automaten h\u00e4ngt der n\u00e4chste Zustand vom aktuellen Zustand und dem Input ab. Beim Moore Automaten hingegen h\u00e4ngt der n\u00e4chste Zustand nur vom aktuellen Zustand ab. F\u00fcr jeder Mealy Automat gibt es einen Moore Automat und umgekehrt.","title":"Moore Automaten vs Mealy Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#berechnungsmodell","text":"Das Berechnungsmodel beschriebt, wie ein Automat berechnet wird. Definiere die Struktur des Automaten. F\u00fcr einen endlichen Automaten ist es: \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Beschreibung der Bedeutung (Semantik) der Struktur Konfiguration : Die vollst\u00e4ndige Beschreibung eines Zustandes des Automats Berechnungsschritt : Der \u00dcbergang von einer Konfiguration zur n\u00e4chsten Berechnung: Die Berechnungsschritte werden gefolgt Jedem Zustand des Automaten k\u00f6nnen eine Bedeutung zu gewissen werden.","title":"Berechnungsmodell"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#nicht-deterministische-endlichen-automaten","text":"Bei einem determinisctischen endlichen Automaten ist jede Konfiguration einzigartig. Also bei einem Zustand gibt es f\u00fcr jedes Inputwort ein m\u00f6glichen n\u00e4chsten Zustand. Bei einem nicht-deterministischen endlichen Automaten (NEA) ist dies nicht gegeben. Bei der folgenden NEA kann man von \\(q_0\\) mit \\(0\\) zu \\(q_1\\) oder bei \\(q_0\\) bleiben. Daher ist die Berechnungsfunktion \\(\\delta\\) anderst definiert: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) . Als \\(\\delta\\) gibt eine Menge von Zust\u00e4nde zur\u00fcck ( \\(\\mathcal P(Q)\\) ist die Potenzmenge von \\(Q\\) , also alle M\u00f6glichen Teilmengen von \\(Q\\) ) Bei solchen Automaten wird jede M\u00f6glichkeit ausprobiert. Gewisse M\u00f6glichkeiten werden in Sackgassen geraten und gewisse auf einem nicht akzeptierten Feld. Damit eine NEA ein Wort akzeptiert reicht wenn eine M\u00f6glichkeit gefunden wird, bei welchem den Endzustand akzeptiert wird. DEA und NEA sind gleichwertig. Eine Sprache kann in beiden Automaten abgebildet werden.","title":"(Nicht-)Deterministische endlichen Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#nea-mit-epsilon-ubergange","text":"Eine Zus\u00e4tzliche Eigenheit von NEAs sind die die \\(\\epsilon\\) -\u00dcberg\u00e4nge. Mit diesen kann die NEA den Zustand wechseln, ohne ein Inputwort zu konsumieren. Die \u00dcbergangsfunktion muss mit \\(\\epsilon\\) -\u00dcberg\u00e4nge noch mals modifiziert werden, da nun das leere Symbol noch hinzugef\u00fcgt werden muss: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) Unten folgt noch ein Beispiel mit \\(\\epsilon\\) -\u00dcberg\u00e4nge: DEAs sind ebenfalls equivalent zu \\(\\epsilon\\) -NEAs und umgekehrt. Also jede DEA kann in eine \\(\\epsilon\\) -NEA umgewandelt werden und umgekehrt. Um von einer \\(\\epsilon\\) -NEA zu einer DEA umwandeln, m\u00fcssen zuerst die \\(\\epsilon\\) -\u00dcberg\u00e4nge aufgel\u00f6st werden. Daf\u00fcr kann man sich \u00fcberlegen, was f\u00fcr Zeichen konsumiert werden k\u00f6nnten, wenn man den \\(\\epsilon\\) -\u00dcbergang nimmt. Diese \u00dcbergange in den urspr\u00fcnglichen Zustand aufnehmen. Es kann helfen, dies grafisch zu erledigen. Nach dem aufl\u00f6sen der \\(\\epsilon\\) -\u00dcberg\u00e4nge wird eine Teilmengenkonstruktion durchgef\u00fchrt.","title":"NEA mit \\(\\epsilon\\)-\u00dcberg\u00e4nge"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#teilmengenkonstruktion","text":"Mit einer Teilmengenkonstruktion kann aus einer NEA eine DEA erstellt werden. Die DEA \\(D=(Q_D, \\Sigma, \\delta_D, q_0, F_D)\\) wird aus der NEA \\(N=(Q_N, \\Sigma, \\delta_N, q_0, F_N)\\) \\(Q_d=\\mathcal P(Q_N)\\) : Alle Teilmengen von \\(Q_N\\) sind Zust\u00e4nde im DEA \\(F_D=\\{S\\in Q_D \\vert S \\cap F_N\\neq \\O\\}\\) : Alle Zust\u00e4nd-Teilmengen, welche ein Element mit den akzeptierten Zust\u00e4nden \\(F_N\\) teilen \\(\\delta_D(S, a)=\\cup_{p \\in S}\\delta_N(p, a)\\) : Alle Zust\u00e4nde, welche von einem Zustand in der Menge \\(S \\in Q_D\\) , erreichbar sind Oder in Worten ausgedr\u00fcckt: Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) Die potentielle Startzustand Kandidaten sind alle diese Teilmengen von \\(Q_N\\) , welche \\(q_0\\) enthalten Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Also nie bei einer Eingabe-Spalte auftauchen. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. Wenn \\(\\{q_1\\}\\) in einer Eingabe-Spalte steht, heisst das nur, dass \\(\\{q_1\\}\\) vorhanden ist. \\(\\{q_1, q_2\\}\\) muss immer noch gestrichen werden, wenn es nicht selbst vorkommt Wenn eine Verbindung das leeres Wort nimmt, werden die Zust\u00e4nde, welche man vom leeren Wort Zustand erreichen kann, auch vom urspr\u00fcnglichen Wort als erreichbar angesehen. Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z) Das resultiertende DEA aus dem NEA oben ist:","title":"Teilmengenkonstruktion"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#aquivalenz-von-automaten","text":"eine DEA ist \u00e4quivalent zu einem Regularen Ausdruck und umgekehrt Dabei ist eine Regularen Ausdruck ein beschreibenden Mechanismus und die DEAs, NEAs und \\(\\epsilon\\) -EAS akzeptierende Mechanismen.","title":"\u00c4quivalenz von Automaten"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#automaten-in-einen-regex-umwandeln","text":"F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen","title":"Automaten in einen RegEx umwandeln"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#beispiel_1","text":"F\u00fcr jeden Zustand einen Ausdruck aufschreiben: $$ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0L_{q_1}\\Rightarrow(0|1)^ 0L_{q_1}\\Rightarrow(0|1) 01\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\ L_{q_2}&=\\varepsilon\\ \\end{align} $$","title":"Beispiel"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#ardensches-lemma","text":"\\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruch","title":"Arden'sches Lemma"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#zustandsklassen","text":"\\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand) Folgende Regeln gelten f\u00fcr die Zustandsklassen: Jedes Wort landet in einem Zustand (wenn ein Automat strandet oder ein Input nicht verwendet werden kann, wird der zuletzt erreichten Zustand genommen) Kein Wort landet in einer DEA in zwei Zust\u00e4nde (gilt nicht f\u00fcr NEAs)","title":"Zustandsklassen"},{"location":"22FS/THIN/03_Endliche%20%20Automaten.html#untere-schranke-fur-endliche-automaten","text":"Die grunds\u00e4tzliche Idee ist, dass wenn die Worte \\(x\\) und \\(y\\) in derselben Zustandsklasse ist, dann ist \\(zx=zy\\) , wobei \\(z\\) irgend ein Wort ist. Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort, ein Wort ergibt, welches in der Sprache ist und mit dem anderen Wort ein, ein Wort welches nicht in der Sprache ist Wenn dies f\u00fcr jedes Wort von Schritt 2. getan werden kann, dann werden mindestens so viel Zust\u00e4nde ben\u00f6tigt. Da wenn zwei W\u00f6rter mit demselben Wort verbunden wird und diese in unterschiedlichen Sprache sind, die zwei W\u00f6rter in unterschiedlichen Zust\u00e4nde endet. Beispiel:","title":"Untere Schranke f\u00fcr endliche Automaten"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html","text":"Kontextfreie Grammatik Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale (Variabeln)ist , welche mit Produktionen in \\(P\\) aufgel\u00f6st werden k\u00f6nnen \\(\\Sigma\\) das Alphabet der Terminale ist \\(P\\) eine endliche Menge von Produktionen in der Form \\(X \\rightarrow \\beta\\) ist. Dabei ist der Kopf \\(X\\in N\\) und der Rumpf \\(\\beta \\in (N\\cup\\Sigma)^*\\) ) \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) Geschrieben kann es folgendermassen: $$ G_1=({A}, {0, 1}, P, A) \\\\text{wobei gilt: }\\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Die Sprache \\(L(G)\\) aus der Grammatik \\(G\\) beinhaltet alle W\u00f6rter, die in \\(G\\) aus dem Startsymbol \\(A\\) ableitbar sind. $$ L(G)={w\\in\\Sigma^ \\vert A\\overset{ }{\\Rightarrow} w} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei, wenn ein Kellerautomaten dazu gebaut werden kann. Das folgende Beispiel ist eine kontextfreie Grammatik, welche nur balancierte Klammern als Wort erlaubt. Also () , (())() , aber nicht (( . $$ A\\rightarrow (A)\\ A\\rightarrow AA\\ A\\rightarrow \\varepsilon $$ Ableitungsschritt Ein Ableitungsschritt, ist wenn eine Variable mit einer Produktion aufgel\u00f6st wird. Dies wird notiert mit \\(\\Rightarrow\\) Mit der Grammatik von oben, w\u00e4re ein Beispiel: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) Dabei kann man linksseitig Ableiten und rechtsseitig Ableiten . Beim linksseitigen Ableiten wird immer die Variable am meisten links aufgel\u00f6st bis es keine Nichtterminale mehr hat. Beim rechtsseitigen Ableiten wird immer die Variable am meisten rechts abgeleitet bis es keine Nichtterminale mehr hat. Ableitung Eine Ableitung ist eine Folge von Ableitungsschritten. Wenn vom Startsymbol \\(A\\) zum Endwort \\(w\\) abgeleitet wurde, kann dies als \\(A\\overset{*}{\\Rightarrow}w\\) schreiben. Dazu wird auch gesagt, dass \\(A\\) generiert oder erzeugt \\(w\\) . Ein Wort ist ableitbar , wenn es eine Ableitung mit einer Grammatik gibt, welche das Wort ergeben. Ableitungsbaum Der Ableitungsbaum/Parseb\u00e4ume zeigt auf, in welcher Reihenfolge die Ableitungsschritte angewendet wurde. Inh\u00e4rent mehrdeutig Wenn man eine Sprache in mehrere Grammatiken unterteilen kann und es W\u00f6rter gibt, welche von beiden Grammatiken akzeptiert wird. DEA zu kontextfreien Sprache Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol Trick zum Entwurf Komplexe KFG k\u00f6nnen oft in mehrere einfachere KFG aufgeteilt werden Wenn einen endlichen Automaten bereits existiert, kann dieser in eine DEA umgewandlet werden und danach zu einer kontextfreien Sprache umgewandelt werden. Oft erlauben KFG zu viele","title":"Kontextfreie Grammatik"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#kontextfreie-grammatik","text":"Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale (Variabeln)ist , welche mit Produktionen in \\(P\\) aufgel\u00f6st werden k\u00f6nnen \\(\\Sigma\\) das Alphabet der Terminale ist \\(P\\) eine endliche Menge von Produktionen in der Form \\(X \\rightarrow \\beta\\) ist. Dabei ist der Kopf \\(X\\in N\\) und der Rumpf \\(\\beta \\in (N\\cup\\Sigma)^*\\) ) \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) Geschrieben kann es folgendermassen: $$ G_1=({A}, {0, 1}, P, A) \\\\text{wobei gilt: }\\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Die Sprache \\(L(G)\\) aus der Grammatik \\(G\\) beinhaltet alle W\u00f6rter, die in \\(G\\) aus dem Startsymbol \\(A\\) ableitbar sind. $$ L(G)={w\\in\\Sigma^ \\vert A\\overset{ }{\\Rightarrow} w} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei, wenn ein Kellerautomaten dazu gebaut werden kann. Das folgende Beispiel ist eine kontextfreie Grammatik, welche nur balancierte Klammern als Wort erlaubt. Also () , (())() , aber nicht (( . $$ A\\rightarrow (A)\\ A\\rightarrow AA\\ A\\rightarrow \\varepsilon $$","title":"Kontextfreie Grammatik"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#ableitungsschritt","text":"Ein Ableitungsschritt, ist wenn eine Variable mit einer Produktion aufgel\u00f6st wird. Dies wird notiert mit \\(\\Rightarrow\\) Mit der Grammatik von oben, w\u00e4re ein Beispiel: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) Dabei kann man linksseitig Ableiten und rechtsseitig Ableiten . Beim linksseitigen Ableiten wird immer die Variable am meisten links aufgel\u00f6st bis es keine Nichtterminale mehr hat. Beim rechtsseitigen Ableiten wird immer die Variable am meisten rechts abgeleitet bis es keine Nichtterminale mehr hat.","title":"Ableitungsschritt"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#ableitung","text":"Eine Ableitung ist eine Folge von Ableitungsschritten. Wenn vom Startsymbol \\(A\\) zum Endwort \\(w\\) abgeleitet wurde, kann dies als \\(A\\overset{*}{\\Rightarrow}w\\) schreiben. Dazu wird auch gesagt, dass \\(A\\) generiert oder erzeugt \\(w\\) . Ein Wort ist ableitbar , wenn es eine Ableitung mit einer Grammatik gibt, welche das Wort ergeben.","title":"Ableitung"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#ableitungsbaum","text":"Der Ableitungsbaum/Parseb\u00e4ume zeigt auf, in welcher Reihenfolge die Ableitungsschritte angewendet wurde.","title":"Ableitungsbaum"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#inharent-mehrdeutig","text":"Wenn man eine Sprache in mehrere Grammatiken unterteilen kann und es W\u00f6rter gibt, welche von beiden Grammatiken akzeptiert wird.","title":"Inh\u00e4rent mehrdeutig"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#dea-zu-kontextfreien-sprache","text":"Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol","title":"DEA zu kontextfreien Sprache"},{"location":"22FS/THIN/04_Kontextfreie%20Gramatik.html#trick-zum-entwurf","text":"Komplexe KFG k\u00f6nnen oft in mehrere einfachere KFG aufgeteilt werden Wenn einen endlichen Automaten bereits existiert, kann dieser in eine DEA umgewandlet werden und danach zu einer kontextfreien Sprache umgewandelt werden. Oft erlauben KFG zu viele","title":"Trick zum Entwurf"},{"location":"22FS/THIN/05_Keller%20Automaten.html","text":"Keller Automaten Deterministischen Kellerautomaten Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(Q\\) ist die endliche Menge von Zust\u00e4nden \\(\\Sigma\\) ist das Alphabet der Eingabe \\(\\Gamma\\) ist das Alphabet des Kellers (bzw. des Stacks) \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ist die (partielle) \u00dcbergangsfunktion \\(q_0\\) ist der Startzustand \\(\\$\\in \\Gamma\\) ist ein ausgezeichnetes Symbol vom Alphabet des Stacks/Kellers \\(F\\subseteq Q\\) ist die Menge der akzeptierten Zust\u00e4nde Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Das heisst, das leere Wort darf nur benutzt werden, wenn f\u00fcr eine Stackposition kein anderes Symbol definiert ist. Dies stellt sicher, dass der Automat deterministisch ist. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt. Als ein weiteres Beispiel, in welchem \\(*\\) als Platzhalter f\u00fcr ein beliebiges Zeichen steht: Nichtdeterministischen Kellerautomaten Eine NKA ist gleich wie eine KA, nur das die \u00dcbergangsfuntkion den Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) hat. Der R\u00fcckgabetyp ist die Potenzmenge. Somit kann in der NKA ein Eingang mehrere Ausg\u00e4nge haben. Wie auch bei einer NEA kann nun im \\(\\varepsilon\\) (das leere Wort) f\u00fcr \\(\\Sigma\\) in der \u00dcbergangsfunktion. M\u00f6glichkeiten eines Kellerautomaten Anders als bei NDA und NEA, welche das gleiche k\u00f6nnen, gibt es Sprachen, welche nur von nicht deterministischen Kellerautomaten verarbeitet werden k\u00f6nnen. Ebenfalls gibt es kontextfreie Sprachen, welche nicht von einem deterministischen Kellerautomaten erkennt werden k\u00f6nnen. Falls dies aber m\u00f6glich ist, ist die Sprache eindeutig. Berechnungsschritte Die Berechnungssfunktion dazu w\u00e4re: \\(\\delta(q, b, c)=(p, w)\\) Dabei befindet sich der Automaten im Zustand \\(q\\) , list das Symbol \\(b\\) von der Eingabe und wird das Kellersymbol \\(c\\) vom Stack lesen und \\(w\\) zur\u00fcck schreiben. Der n\u00e4chste Zustand wird \\(p\\) sein. Berechnung Eine Berechnung besteht aus mehreren Berechnungsschritte und eine Start- und Endkonfiguration. Beispiel: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)\\) Dies kann auch als \\((q_0, 0011, \\$)\\vdash^*(q2, \\varepsilon, \\$)\\) geschrieben werden. Sprache eines Kellerautomaten In einer Sprache eines Kellerautomaten sind alle W\u00f6rter, welche von diesem Kellerautomaten akzeptiert werden.","title":"Keller Automaten"},{"location":"22FS/THIN/05_Keller%20Automaten.html#keller-automaten","text":"","title":"Keller Automaten"},{"location":"22FS/THIN/05_Keller%20Automaten.html#deterministischen-kellerautomaten","text":"Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(Q\\) ist die endliche Menge von Zust\u00e4nden \\(\\Sigma\\) ist das Alphabet der Eingabe \\(\\Gamma\\) ist das Alphabet des Kellers (bzw. des Stacks) \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ist die (partielle) \u00dcbergangsfunktion \\(q_0\\) ist der Startzustand \\(\\$\\in \\Gamma\\) ist ein ausgezeichnetes Symbol vom Alphabet des Stacks/Kellers \\(F\\subseteq Q\\) ist die Menge der akzeptierten Zust\u00e4nde Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Das heisst, das leere Wort darf nur benutzt werden, wenn f\u00fcr eine Stackposition kein anderes Symbol definiert ist. Dies stellt sicher, dass der Automat deterministisch ist. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt. Als ein weiteres Beispiel, in welchem \\(*\\) als Platzhalter f\u00fcr ein beliebiges Zeichen steht:","title":"Deterministischen Kellerautomaten"},{"location":"22FS/THIN/05_Keller%20Automaten.html#nichtdeterministischen-kellerautomaten","text":"Eine NKA ist gleich wie eine KA, nur das die \u00dcbergangsfuntkion den Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) hat. Der R\u00fcckgabetyp ist die Potenzmenge. Somit kann in der NKA ein Eingang mehrere Ausg\u00e4nge haben. Wie auch bei einer NEA kann nun im \\(\\varepsilon\\) (das leere Wort) f\u00fcr \\(\\Sigma\\) in der \u00dcbergangsfunktion.","title":"Nichtdeterministischen Kellerautomaten"},{"location":"22FS/THIN/05_Keller%20Automaten.html#moglichkeiten-eines-kellerautomaten","text":"Anders als bei NDA und NEA, welche das gleiche k\u00f6nnen, gibt es Sprachen, welche nur von nicht deterministischen Kellerautomaten verarbeitet werden k\u00f6nnen. Ebenfalls gibt es kontextfreie Sprachen, welche nicht von einem deterministischen Kellerautomaten erkennt werden k\u00f6nnen. Falls dies aber m\u00f6glich ist, ist die Sprache eindeutig.","title":"M\u00f6glichkeiten eines Kellerautomaten"},{"location":"22FS/THIN/05_Keller%20Automaten.html#berechnungsschritte","text":"Die Berechnungssfunktion dazu w\u00e4re: \\(\\delta(q, b, c)=(p, w)\\) Dabei befindet sich der Automaten im Zustand \\(q\\) , list das Symbol \\(b\\) von der Eingabe und wird das Kellersymbol \\(c\\) vom Stack lesen und \\(w\\) zur\u00fcck schreiben. Der n\u00e4chste Zustand wird \\(p\\) sein.","title":"Berechnungsschritte"},{"location":"22FS/THIN/05_Keller%20Automaten.html#berechnung","text":"Eine Berechnung besteht aus mehreren Berechnungsschritte und eine Start- und Endkonfiguration. Beispiel: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)\\) Dies kann auch als \\((q_0, 0011, \\$)\\vdash^*(q2, \\varepsilon, \\$)\\) geschrieben werden.","title":"Berechnung"},{"location":"22FS/THIN/05_Keller%20Automaten.html#sprache-eines-kellerautomaten","text":"In einer Sprache eines Kellerautomaten sind alle W\u00f6rter, welche von diesem Kellerautomaten akzeptiert werden.","title":"Sprache eines Kellerautomaten"},{"location":"22FS/THIN/06_Turing%20Machine.html","text":"Turing Maschine Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(Q\\) : die endliche Menge von Zust\u00e4nde \\(\\Sigma\\) : das Eingabe Alphabet \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) : Die \u00dcbergangsfunktion, welche den n\u00e4chsten Zustand, was geschrieben werden soll und ob das Band nach Links (L) oder nach rechts (R) geschoben werden soll \\(\\Gamma\\) : Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) \\(\\textvisiblespace\\) : Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) Das Band hat einzelne Zelle, in welchen ein Zeichen von \\(\\Gamma\\) enhaltet... Informell, ist eine Turing Maschine einen endlichen Automat, welche um ein unendliches Band und um einen Lesen-/Schreibkopf erg\u00e4nzt wurde. Im folgenden Bild wird eine \u00dcbergangsfunktion einer Turing Maschine gezeigt: \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\) Konfiguration Eine Konfiguration einer Turing-Maschine ist: der aktuelle Zustand \\(q \\in Q\\) die Position des Lese-/Schreibkopf \\(i\\) der Bandinhalt \\(X_1,...,X_n \\in \\Gamma\\) Ein Beispiel einer Konfiguration: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\) Die Startkonfiguration ist: \\(q_0X_1X_2...X_n\\) Berechnungsschritten Ein Berechnungsschritt ist der \u00dcbergang von einer Konfiguration zur n\u00e4chsten: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n\\) Berechnungen Eine Berechnung ist eine endliche Menge von Berechnungsschritte: \\(K_1 \\vdash K_2 \\vdash ... \\vdash K_n\\) . Dies kann auch abgek\u00fcrzt als \\(K_1\\vdash^* K_n\\) geschrieben werden. Sprache einer Turing Maschine Rekursiv aufz\u00e4hlbare Sprachen Eine Sprache nennt sich rekursive aufz\u00e4hlbar, wenn sie von einer Turing Maschine akzeptiert wird. Eine rekursive aufz\u00e4hlbar... TODO Turing Maschine mit Speicher Die Turing Maschine wird mit einem Speicher erweitert. Turing Maschine mit mehreren Spuren Die Turing Maschine wird erweitert mit mehrern Spuren, welche sich synchron bewegen. Das Spur-Alphabet ist nun ein Tupel. Wenn so eine Maschine von einer \"normalen\" Turing Maschine simuliert werden soll, ben\u00f6tigt man die Zust\u00e4nde \\(Q=Q_{orignal}\\times\\Gamma_{orginal}\\) Als Beispiel, eine Maschine mit 3 B\u00e4nder h\u00e4tte das Band-Alphabet: \\(\\Gamma_{\\Gamma_1}=\\{0, 1, \\textvisiblespace\\}\\times\\{0, 1, \\textvisiblespace\\}\\times\\{0, 1, \\textvisiblespace\\}\\) . Ein konkreter Wert w\u00e4re: \\((0, 1, 1)\\) . Turing Maschine mit mehreren B\u00e4nder und mehreren Lese-/Schreibk\u00f6pfe Ein Band hat mehrere Spuren. Pro Band gibt es ein Lesekopf. Das heisst eine Maschine mit mehreren Spuren hat nur ein Lese-/Schreibkopf. Eine Maschine mit mehreren B\u00e4nder hat mehrere Lese-/Schreibk\u00f6pfe. Die Turing Maschine kann auch erweitert werden, dass sie zus\u00e4tzlich zu den mehr Spuren auch noch mehr Lese-/Schreibk\u00f6pfe hat. Das heisst, jedes Band kann unabh\u00e4ngig von den anderen B\u00e4nder bewegt werden. Bei der Initialisierung: steht die Eingabe auf dem obersten Band Alle anderen B\u00e4nder sind leer Der Lese-/Schreibkopf des ersten Band ist \u00fcber dem ersten Element des Bandes Bei den anderen Lese-/Schreibk\u00f6pfe ist es irrelevant Damit dies funktioniert, muss die \u00dcbergangsfunktion erweitert werden um: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) , dabei steht \\(k\\) f\u00fcr die Anzahl B\u00e4nder, \\(R\\) f\u00fcr Rechts, \\(S\\) f\u00fcr stehen bleiben und \\(L\\) f\u00fcr Links. Beispiel von einer Maschine mit mehreren B\u00e4nder und mehreren Lese-/Schreibk\u00f6pfe, welche Subtrahieren kann: Nichtdeterministische Turing Maschine (NTM) Die nichtdeterministische Turing Maschine besteht aus dem selben 7-Tupel, wie eine deterministische Turing Maschine. Der einzige Unterschied ist, dass die \u00dcbergangsfunktion \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times D)\\) , wobei \\(D=\\{R, L\\}\\) ist. \\(R\\) steht f\u00fcr Rechts, \\(L\\) f\u00fcr Links. Die \u00dcbergangsfunktion gibt also eine Liste von Tupeln zur\u00fcck. Wie auch nichtdeterministische endlichen Automaten, werden alle M\u00f6glichkeiten durch getestet bis ein Resultat gefunden wurde oder keine ungetestet Werte mehr \u00fcbrigbleiben. Jede Sprache, welcher von einer NTM akzeptiert wird, wird auch von einer deterministischer Turing Maschine (DTM) akzeptiert. Es gibt allerdings kein praktisches Verfahren, wie die Teilmengen Konstruktion bei den Endlichen Maschine. Es folgt der Beweis, dass jede NTM auch als DTM dargestellt werden kann. Ein Beispiel f\u00fcr eine NTM: Turing Maschine mit semi-beschr\u00e4nkten Band Bei einer Turing Maschine mit einem semi-beschr\u00e4nkten Band, geht das Band nur in eine Richtung ins unendliche. Beim Start ist der Lese-/Schreibkopf am Anfang des Bandes. Der Kopf kann dann nur in eine Richtung sich bewegen. Dabei wird jede Sprache, welche von einer Turing Maschine akzeptiert werden kann, kann auch von einer Turing Maschine mit einem semi-beschr\u00e4nkten Band akzeptiert werden. Sie sind also gleichwertig. Die Beweissidee, dass eine Turing Maschine mit semi-beschr\u00e4nkten Band zwei B\u00e4nder hat, das einte Band hat die positiven Slots, das andera Band die negativen Slots. \\(k\\) -Stack Maschine Dies ist ein eine Deterministischen Keller Automaten, welcher aber mehre Stacks haben. Dabei sieht die \u00dcbergansfunktion folgendermassen aus: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) Mit einer 2-Stack Maschine kann eine Turing Maschine simuliert werden, in dem die Slots des \"Bandes\" vom einten Stack in den anderen kopiert werden. Eine 2-Stack Maschine kann demnach, dasselbe, wie eine Turing Maschine. Z\u00e4hler Maschine Eine Z\u00e4hler Maschine, ist eine \\(k\\) -Stack Maschine, welche allerdings Z\u00e4hler haben, anstatt Stacks. Die Z\u00e4hler speichern eine nat\u00fcrliche Zahl (<= 0). Eine 2 Z\u00e4hler-Maschine ist gleichwertig, wie eine Turing Maschine. Wenn etwas auf den \"Stack\" gepushed wird, wird das letzte Resultat weiter verrechnet. Daf\u00fcr wird das letzte Resultat mit den Anzahl Zust\u00e4nden multipliziert. Darauf wird den Zahlwert des Symbols addiert. Um nun vom \"Stack\" zu poppen, wird das letzte Resultat mit der Anzahl Zust\u00e4nde dividiert. Der Rest, welcher \u00fcbrig bleibt, ist der Zahlenwert des Symboles. Um aber einen 2-Stack Maschine zu simulieren, ben\u00f6tigt man 3 Counters: 2 Counters f\u00fcr die Stack und der 3. Counter um zu rechnen. Diese 3-Z\u00e4hler Maschine kann nun von einer 2-Z\u00e4hler Maschinen simuliert werden. Daf\u00fcr werden die Werte \\(i\\) und \\(j\\) und \\(k\\) in der Zahl mit \\(2^i\\cdot3^j\\cdot5^k\\) ( ev. auch eine addition?) . Die Basis zu den Zahlen sind Primzahlen (2, 3, 5, 7, ...). Eine Zahl kann mit einer Primfaktorzerlegung wieder zur\u00fcck rechnen. Im einten Stack werden nun diese Zahlen gespeichert, der andere Stack wird dazu ben\u00f6tigt, zu rechnen. Universelle Turing Maschine (UTM) Eine universelle Turing Maschine kann Turing Maschine simulieren. Daf\u00fcr muss allerdings eine Turing Maschine codiert werden, so dass sie von einer UTM simuliert werden kann. Dies kann folgendermassen bewerkstelligt werden: Die Zust\u00e4nde Q einer TM werden codiert als \\(q_1\\) : der Startzustand \\(q_2\\) : der Endzustand \\(q_3...q_i\\) : f\u00fcr alle weiteren Zustande Die Bandsymbole \\(\\Gamma\\) einer TM wird: \\(X_1\\) : das Symbol 0 \\(X_2\\) : Das Symbol 1 \\(X_3\\) : Das Symbol \\(\\textvisiblespace\\) \\(X_4,...,X_i\\) : f\u00fcr alle weitere Symbole Codierung der Richtung des Lese-Schreibkopfes D \\(D_1\\) : Die Richtung \\(L\\) (Links) \\(D_2\\) Die Richtung \\(R\\) (Rechts) Die \u00dcbergangsfunktionen \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\) kann codiert werden als \\(0^i10^j10^l10^m\\) . Diese sind mit Nullen codiert und getrennt mit 1 . Die Zahl im Subscript wird jeweil als Exponent gebraucht ( \\(X_2\\Rightarrow0^2=00\\) ) Die \u00dcbergansfunktionen werden mit 11 getrennt: \\(C_111C_211...\\) , wobei \\(C_i\\) eine \u00dcbergansfunktion ist. Vor der ersten \u00dcbergansfunktion steht noch ein 1 , dass es als eine Zahl dargestellt werden kann. Die Zahl, welche ein Turing Turing Maschine darstellt, wird auch als G\u00f6delnummer bezeichnet. Es folgt ein Beispiel, wie eine TM codiert werden k\u00f6nnte: Damit die UTM weiss, welches Eingabewort \\(w\\) eingegben werden soll, wird dies nach der Turing Maschine \\(Cod_M\\) getrennt mit 111 dargestellt: \\(Code_m111w\\) .","title":"Turing Maschine"},{"location":"22FS/THIN/06_Turing%20Machine.html#turing-maschine","text":"Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(Q\\) : die endliche Menge von Zust\u00e4nde \\(\\Sigma\\) : das Eingabe Alphabet \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) : Die \u00dcbergangsfunktion, welche den n\u00e4chsten Zustand, was geschrieben werden soll und ob das Band nach Links (L) oder nach rechts (R) geschoben werden soll \\(\\Gamma\\) : Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) \\(\\textvisiblespace\\) : Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) Das Band hat einzelne Zelle, in welchen ein Zeichen von \\(\\Gamma\\) enhaltet... Informell, ist eine Turing Maschine einen endlichen Automat, welche um ein unendliches Band und um einen Lesen-/Schreibkopf erg\u00e4nzt wurde. Im folgenden Bild wird eine \u00dcbergangsfunktion einer Turing Maschine gezeigt: \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\)","title":"Turing Maschine"},{"location":"22FS/THIN/06_Turing%20Machine.html#konfiguration","text":"Eine Konfiguration einer Turing-Maschine ist: der aktuelle Zustand \\(q \\in Q\\) die Position des Lese-/Schreibkopf \\(i\\) der Bandinhalt \\(X_1,...,X_n \\in \\Gamma\\) Ein Beispiel einer Konfiguration: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\) Die Startkonfiguration ist: \\(q_0X_1X_2...X_n\\)","title":"Konfiguration"},{"location":"22FS/THIN/06_Turing%20Machine.html#berechnungsschritten","text":"Ein Berechnungsschritt ist der \u00dcbergang von einer Konfiguration zur n\u00e4chsten: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n\\)","title":"Berechnungsschritten"},{"location":"22FS/THIN/06_Turing%20Machine.html#berechnungen","text":"Eine Berechnung ist eine endliche Menge von Berechnungsschritte: \\(K_1 \\vdash K_2 \\vdash ... \\vdash K_n\\) . Dies kann auch abgek\u00fcrzt als \\(K_1\\vdash^* K_n\\) geschrieben werden.","title":"Berechnungen"},{"location":"22FS/THIN/06_Turing%20Machine.html#sprache-einer-turing-maschine","text":"","title":"Sprache einer Turing Maschine"},{"location":"22FS/THIN/06_Turing%20Machine.html#rekursiv-aufzahlbare-sprachen","text":"Eine Sprache nennt sich rekursive aufz\u00e4hlbar, wenn sie von einer Turing Maschine akzeptiert wird. Eine rekursive aufz\u00e4hlbar... TODO","title":"Rekursiv aufz\u00e4hlbare Sprachen"},{"location":"22FS/THIN/06_Turing%20Machine.html#turing-maschine-mit-speicher","text":"Die Turing Maschine wird mit einem Speicher erweitert.","title":"Turing Maschine mit Speicher"},{"location":"22FS/THIN/06_Turing%20Machine.html#turing-maschine-mit-mehreren-spuren","text":"Die Turing Maschine wird erweitert mit mehrern Spuren, welche sich synchron bewegen. Das Spur-Alphabet ist nun ein Tupel. Wenn so eine Maschine von einer \"normalen\" Turing Maschine simuliert werden soll, ben\u00f6tigt man die Zust\u00e4nde \\(Q=Q_{orignal}\\times\\Gamma_{orginal}\\) Als Beispiel, eine Maschine mit 3 B\u00e4nder h\u00e4tte das Band-Alphabet: \\(\\Gamma_{\\Gamma_1}=\\{0, 1, \\textvisiblespace\\}\\times\\{0, 1, \\textvisiblespace\\}\\times\\{0, 1, \\textvisiblespace\\}\\) . Ein konkreter Wert w\u00e4re: \\((0, 1, 1)\\) .","title":"Turing Maschine mit mehreren Spuren"},{"location":"22FS/THIN/06_Turing%20Machine.html#turing-maschine-mit-mehreren-bander-und-mehreren-lese-schreibkopfe","text":"Ein Band hat mehrere Spuren. Pro Band gibt es ein Lesekopf. Das heisst eine Maschine mit mehreren Spuren hat nur ein Lese-/Schreibkopf. Eine Maschine mit mehreren B\u00e4nder hat mehrere Lese-/Schreibk\u00f6pfe. Die Turing Maschine kann auch erweitert werden, dass sie zus\u00e4tzlich zu den mehr Spuren auch noch mehr Lese-/Schreibk\u00f6pfe hat. Das heisst, jedes Band kann unabh\u00e4ngig von den anderen B\u00e4nder bewegt werden. Bei der Initialisierung: steht die Eingabe auf dem obersten Band Alle anderen B\u00e4nder sind leer Der Lese-/Schreibkopf des ersten Band ist \u00fcber dem ersten Element des Bandes Bei den anderen Lese-/Schreibk\u00f6pfe ist es irrelevant Damit dies funktioniert, muss die \u00dcbergangsfunktion erweitert werden um: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) , dabei steht \\(k\\) f\u00fcr die Anzahl B\u00e4nder, \\(R\\) f\u00fcr Rechts, \\(S\\) f\u00fcr stehen bleiben und \\(L\\) f\u00fcr Links. Beispiel von einer Maschine mit mehreren B\u00e4nder und mehreren Lese-/Schreibk\u00f6pfe, welche Subtrahieren kann:","title":"Turing Maschine mit mehreren B\u00e4nder und mehreren Lese-/Schreibk\u00f6pfe"},{"location":"22FS/THIN/06_Turing%20Machine.html#nichtdeterministische-turing-maschine-ntm","text":"Die nichtdeterministische Turing Maschine besteht aus dem selben 7-Tupel, wie eine deterministische Turing Maschine. Der einzige Unterschied ist, dass die \u00dcbergangsfunktion \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times D)\\) , wobei \\(D=\\{R, L\\}\\) ist. \\(R\\) steht f\u00fcr Rechts, \\(L\\) f\u00fcr Links. Die \u00dcbergangsfunktion gibt also eine Liste von Tupeln zur\u00fcck. Wie auch nichtdeterministische endlichen Automaten, werden alle M\u00f6glichkeiten durch getestet bis ein Resultat gefunden wurde oder keine ungetestet Werte mehr \u00fcbrigbleiben. Jede Sprache, welcher von einer NTM akzeptiert wird, wird auch von einer deterministischer Turing Maschine (DTM) akzeptiert. Es gibt allerdings kein praktisches Verfahren, wie die Teilmengen Konstruktion bei den Endlichen Maschine. Es folgt der Beweis, dass jede NTM auch als DTM dargestellt werden kann. Ein Beispiel f\u00fcr eine NTM:","title":"Nichtdeterministische Turing Maschine (NTM)"},{"location":"22FS/THIN/06_Turing%20Machine.html#turing-maschine-mit-semi-beschrankten-band","text":"Bei einer Turing Maschine mit einem semi-beschr\u00e4nkten Band, geht das Band nur in eine Richtung ins unendliche. Beim Start ist der Lese-/Schreibkopf am Anfang des Bandes. Der Kopf kann dann nur in eine Richtung sich bewegen. Dabei wird jede Sprache, welche von einer Turing Maschine akzeptiert werden kann, kann auch von einer Turing Maschine mit einem semi-beschr\u00e4nkten Band akzeptiert werden. Sie sind also gleichwertig. Die Beweissidee, dass eine Turing Maschine mit semi-beschr\u00e4nkten Band zwei B\u00e4nder hat, das einte Band hat die positiven Slots, das andera Band die negativen Slots.","title":"Turing Maschine mit semi-beschr\u00e4nkten Band"},{"location":"22FS/THIN/06_Turing%20Machine.html#k-stack-maschine","text":"Dies ist ein eine Deterministischen Keller Automaten, welcher aber mehre Stacks haben. Dabei sieht die \u00dcbergansfunktion folgendermassen aus: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) Mit einer 2-Stack Maschine kann eine Turing Maschine simuliert werden, in dem die Slots des \"Bandes\" vom einten Stack in den anderen kopiert werden. Eine 2-Stack Maschine kann demnach, dasselbe, wie eine Turing Maschine.","title":"\\(k\\)-Stack Maschine"},{"location":"22FS/THIN/06_Turing%20Machine.html#zahler-maschine","text":"Eine Z\u00e4hler Maschine, ist eine \\(k\\) -Stack Maschine, welche allerdings Z\u00e4hler haben, anstatt Stacks. Die Z\u00e4hler speichern eine nat\u00fcrliche Zahl (<= 0). Eine 2 Z\u00e4hler-Maschine ist gleichwertig, wie eine Turing Maschine. Wenn etwas auf den \"Stack\" gepushed wird, wird das letzte Resultat weiter verrechnet. Daf\u00fcr wird das letzte Resultat mit den Anzahl Zust\u00e4nden multipliziert. Darauf wird den Zahlwert des Symbols addiert. Um nun vom \"Stack\" zu poppen, wird das letzte Resultat mit der Anzahl Zust\u00e4nde dividiert. Der Rest, welcher \u00fcbrig bleibt, ist der Zahlenwert des Symboles. Um aber einen 2-Stack Maschine zu simulieren, ben\u00f6tigt man 3 Counters: 2 Counters f\u00fcr die Stack und der 3. Counter um zu rechnen. Diese 3-Z\u00e4hler Maschine kann nun von einer 2-Z\u00e4hler Maschinen simuliert werden. Daf\u00fcr werden die Werte \\(i\\) und \\(j\\) und \\(k\\) in der Zahl mit \\(2^i\\cdot3^j\\cdot5^k\\) ( ev. auch eine addition?) . Die Basis zu den Zahlen sind Primzahlen (2, 3, 5, 7, ...). Eine Zahl kann mit einer Primfaktorzerlegung wieder zur\u00fcck rechnen. Im einten Stack werden nun diese Zahlen gespeichert, der andere Stack wird dazu ben\u00f6tigt, zu rechnen.","title":"Z\u00e4hler Maschine"},{"location":"22FS/THIN/06_Turing%20Machine.html#universelle-turing-maschine-utm","text":"Eine universelle Turing Maschine kann Turing Maschine simulieren. Daf\u00fcr muss allerdings eine Turing Maschine codiert werden, so dass sie von einer UTM simuliert werden kann. Dies kann folgendermassen bewerkstelligt werden: Die Zust\u00e4nde Q einer TM werden codiert als \\(q_1\\) : der Startzustand \\(q_2\\) : der Endzustand \\(q_3...q_i\\) : f\u00fcr alle weiteren Zustande Die Bandsymbole \\(\\Gamma\\) einer TM wird: \\(X_1\\) : das Symbol 0 \\(X_2\\) : Das Symbol 1 \\(X_3\\) : Das Symbol \\(\\textvisiblespace\\) \\(X_4,...,X_i\\) : f\u00fcr alle weitere Symbole Codierung der Richtung des Lese-Schreibkopfes D \\(D_1\\) : Die Richtung \\(L\\) (Links) \\(D_2\\) Die Richtung \\(R\\) (Rechts) Die \u00dcbergangsfunktionen \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\) kann codiert werden als \\(0^i10^j10^l10^m\\) . Diese sind mit Nullen codiert und getrennt mit 1 . Die Zahl im Subscript wird jeweil als Exponent gebraucht ( \\(X_2\\Rightarrow0^2=00\\) ) Die \u00dcbergansfunktionen werden mit 11 getrennt: \\(C_111C_211...\\) , wobei \\(C_i\\) eine \u00dcbergansfunktion ist. Vor der ersten \u00dcbergansfunktion steht noch ein 1 , dass es als eine Zahl dargestellt werden kann. Die Zahl, welche ein Turing Turing Maschine darstellt, wird auch als G\u00f6delnummer bezeichnet. Es folgt ein Beispiel, wie eine TM codiert werden k\u00f6nnte: Damit die UTM weiss, welches Eingabewort \\(w\\) eingegben werden soll, wird dies nach der Turing Maschine \\(Cod_M\\) getrennt mit 111 dargestellt: \\(Code_m111w\\) .","title":"Universelle Turing Maschine (UTM)"},{"location":"22FS/THIN/07_Berechnungsmodelle.html","text":"Berechnungsmodelle Church-Turning-These & Gandys These M Intuitive berechenbare Funktion : eine Funktion, welche algorithmisch (durch eine mechanisches Verfahren) berechnet werden kann Turing-berechenbare Funktionen : Funktionen, welche von einer Turing-Maschinen berechnet werden k\u00f6nnen Jede intuitive berechenbare Funktion l\u00e4sst sich mit einer Turingmaschine berechnen. Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist bereits von einer Turing-Maschine berechenbar. Bis jetzt wurde noch kein Gegenbeispiel zu beiden Thesen gefunden worden. Turing-berechenbare Funktion \\(u\\) ist ein Wort. Pfeil noch oben ist nicht teil von \\(\\Gamma\\) . Oder: Wenn es eine Funktion gibt, welche f\u00fcr alle Input Wort anh\u00e4lt. Beispiel wenn zu 1011 1 addiert werden soll, wird so lange von rechts nach links ger\u00fcckt, bis eine 0 gefunden wird. Diese wird zu einem 1 gemacht. Die 1 davor werden zu 0 Loop-Programme Ein LOOP-Programm besteht aus folgendem: Variabeln: \\(x_0\\) , \\(x_1\\) , \\(x_2\\) , ..., \\(x_k\\) Konstante: 0, 1, 2, 3, ... Zuweissungen: \\(x_k=x_j+c\\) oder \\(x_k = x_j - c\\) Wenn die Loop-Variable (x3 in LOOP x3 DO ... END ) im Loop ver\u00e4ndert wird, hat dies keinn Einfluss auf die Anzahl Durchl\u00e4ufe. While-Programme Turing-Vollst\u00e4ndigkeit Auch jede Turing-Maschine kann mit einem While-Programm implementiert werden. GOTO-Programme Primitiv rekursive Funktionen Ackermannfunktion Eine Ackermannfunktion \\(a: \\N^2\\rightarrow N\\) ist durch die Gleichung: $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$ Loop-Interpreter Ein Loop-Interpreter ist eine Funktion \\(I:\\N\\times \\N \\rightarrow \\N\\) , welche als Input den Code und Input eines Loop-Programmes nimmt und den Code mit dem Input ausf\u00fchrt und zur\u00fcck gibt. F\u00fcr einen Loop-Interpreter gelten folgende Eigenschaften: Es gibt genau ein totaler Loop-Interperter Es kein Loop-berechenbare Loop-Interpreter. Es gibt also kein Loop-Programm, was Loop-Programme interpretieren kann","title":"Berechnungsmodelle"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#berechnungsmodelle","text":"","title":"Berechnungsmodelle"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#church-turning-these-gandys-these-m","text":"Intuitive berechenbare Funktion : eine Funktion, welche algorithmisch (durch eine mechanisches Verfahren) berechnet werden kann Turing-berechenbare Funktionen : Funktionen, welche von einer Turing-Maschinen berechnet werden k\u00f6nnen Jede intuitive berechenbare Funktion l\u00e4sst sich mit einer Turingmaschine berechnen. Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist bereits von einer Turing-Maschine berechenbar. Bis jetzt wurde noch kein Gegenbeispiel zu beiden Thesen gefunden worden.","title":"Church-Turning-These &amp; Gandys These M"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#turing-berechenbare-funktion","text":"\\(u\\) ist ein Wort. Pfeil noch oben ist nicht teil von \\(\\Gamma\\) . Oder: Wenn es eine Funktion gibt, welche f\u00fcr alle Input Wort anh\u00e4lt.","title":"Turing-berechenbare Funktion"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#beispiel","text":"wenn zu 1011 1 addiert werden soll, wird so lange von rechts nach links ger\u00fcckt, bis eine 0 gefunden wird. Diese wird zu einem 1 gemacht. Die 1 davor werden zu 0","title":"Beispiel"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#loop-programme","text":"Ein LOOP-Programm besteht aus folgendem: Variabeln: \\(x_0\\) , \\(x_1\\) , \\(x_2\\) , ..., \\(x_k\\) Konstante: 0, 1, 2, 3, ... Zuweissungen: \\(x_k=x_j+c\\) oder \\(x_k = x_j - c\\) Wenn die Loop-Variable (x3 in LOOP x3 DO ... END ) im Loop ver\u00e4ndert wird, hat dies keinn Einfluss auf die Anzahl Durchl\u00e4ufe.","title":"Loop-Programme"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#while-programme","text":"","title":"While-Programme"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#turing-vollstandigkeit","text":"Auch jede Turing-Maschine kann mit einem While-Programm implementiert werden.","title":"Turing-Vollst\u00e4ndigkeit"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#goto-programme","text":"","title":"GOTO-Programme"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#primitiv-rekursive-funktionen","text":"","title":"Primitiv rekursive Funktionen"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#ackermannfunktion","text":"Eine Ackermannfunktion \\(a: \\N^2\\rightarrow N\\) ist durch die Gleichung: $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$","title":"Ackermannfunktion"},{"location":"22FS/THIN/07_Berechnungsmodelle.html#loop-interpreter","text":"Ein Loop-Interpreter ist eine Funktion \\(I:\\N\\times \\N \\rightarrow \\N\\) , welche als Input den Code und Input eines Loop-Programmes nimmt und den Code mit dem Input ausf\u00fchrt und zur\u00fcck gibt. F\u00fcr einen Loop-Interpreter gelten folgende Eigenschaften: Es gibt genau ein totaler Loop-Interperter Es kein Loop-berechenbare Loop-Interpreter. Es gibt also kein Loop-Programm, was Loop-Programme interpretieren kann","title":"Loop-Interpreter"},{"location":"22FS/THIN/08_Entscheidbarkeit.html","text":"Entschheidbarkeit Eine Sprache \\(A \\subset \\Sigma^*\\) heisst entscheidbar ,, wenn eine Turingmaschine \\(T\\) existiert, die das Entscheidungsproblem \\((\\Sigma, A)\\) l\u00f6st (Dabei ist \\(A\\) die Menge aller akzeptierter Zust\u00e4nde). Wenn der Bandinhalt \\(x \\in A\\) ist, h\u00e4lt \\(T\\) nach endlichen vielen Schritten mit dem Bandinhalt 1 and, wenn der Bandinhalt \\(x \\in \\overline A\\) ist, dann h\u00e4lt \\(T\\) nach endlichen vielen Schritten mit dem Bandinhalt 0 an. Wichtig: Egal was f\u00fcr ein Input auf dem Band steht, \\(T\\) muss immer anhalten. Oder anders ausgedr\u00fcckt, es m\u00fcssen alle akzeptierte Inputs \\(A\\) , wie auch alle nicht akzeptiert Inputs \\(\\overline A\\) semi-entscheidbar sein. Eine Sprache wird Semi-Entsheidbarkeit genannt, wenn es eine Turingmachine \\(T\\) gibt, welche bei dem Bandinhalt \\(x \\in A\\) ( \\(A\\) ist die Menge der akzeptierten Inputs) in endlichen vielen Schritten mit dem Bandinhalt 1 f\u00fcr Ja endet. Wenn der Bandihalt \\(x \\in \\Sigma^*\\setminus A\\) (als x nicht ein akzeptierter Zustand ist), h\u00e4lt die Turingmachine \\(T\\) nie an. F\u00fcr jede entscheidbare Sprache kann eine Turningmaschine geschrieben werden, welche semi-entscheidbar ist. \\(\\cup\\) und \\(\\cap\\) Satz Wenn \\(A\\) und \\(B\\) entscheidbar ist, dann ist auch \\(A\\cup B\\) und \\(A\\cap B\\) entscheidbar. Wenn \\(A\\) und \\(B\\) semi-entscheidbar ist, dann ist auch \\(A \\cup B\\) und \\(A\\cap B\\) semi-entscheidbar. Reduktion S\u00e4tze Transitivit\u00e4t : F\u00fcr beliebige Sprachen \\(A, B\\) und \\(C\\) und \\(A \\preceq B\\) und \\(B \\preceq C\\) gilt, dann gilt auch \\(A \\preceq C\\) F\u00fcr beliebige Sprachen \\(A\\) und \\(B\\) , wenn \\(B\\) entscheidbar ist und \\(A \\preceq B\\) gilt, dann ist auch \\(A\\) entscheidbar. F\u00fcr beliebige Sprachen \\(A\\) und \\(B\\) , wenn \\(B\\) semi-entscheidbar ist und \\(A \\preceq B\\) gilt, dann ist auch \\(A\\) semi-entscheidbar. Allgemeine Halteproblem Leeres-Band Halteproblem Spezielle Halteproblem Halteproblem Beweiss Satz von Rice Es gibt eine Menge \\(R\\) , in welcher alle berechenbare Funktion sind. Die Menge \\(S\\subset R\\) ist eine echte, nicht leere Teilmenge von R. Die folgende Sprache ist nun unentscheidbar: $$ C(S)={w\\in{0,1}^*\\mid F_w\\in S} $$","title":"Entschheidbarkeit"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#entschheidbarkeit","text":"Eine Sprache \\(A \\subset \\Sigma^*\\) heisst entscheidbar ,, wenn eine Turingmaschine \\(T\\) existiert, die das Entscheidungsproblem \\((\\Sigma, A)\\) l\u00f6st (Dabei ist \\(A\\) die Menge aller akzeptierter Zust\u00e4nde). Wenn der Bandinhalt \\(x \\in A\\) ist, h\u00e4lt \\(T\\) nach endlichen vielen Schritten mit dem Bandinhalt 1 and, wenn der Bandinhalt \\(x \\in \\overline A\\) ist, dann h\u00e4lt \\(T\\) nach endlichen vielen Schritten mit dem Bandinhalt 0 an. Wichtig: Egal was f\u00fcr ein Input auf dem Band steht, \\(T\\) muss immer anhalten. Oder anders ausgedr\u00fcckt, es m\u00fcssen alle akzeptierte Inputs \\(A\\) , wie auch alle nicht akzeptiert Inputs \\(\\overline A\\) semi-entscheidbar sein. Eine Sprache wird Semi-Entsheidbarkeit genannt, wenn es eine Turingmachine \\(T\\) gibt, welche bei dem Bandinhalt \\(x \\in A\\) ( \\(A\\) ist die Menge der akzeptierten Inputs) in endlichen vielen Schritten mit dem Bandinhalt 1 f\u00fcr Ja endet. Wenn der Bandihalt \\(x \\in \\Sigma^*\\setminus A\\) (als x nicht ein akzeptierter Zustand ist), h\u00e4lt die Turingmachine \\(T\\) nie an. F\u00fcr jede entscheidbare Sprache kann eine Turningmaschine geschrieben werden, welche semi-entscheidbar ist.","title":"Entschheidbarkeit"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#cup-und-cap-satz","text":"Wenn \\(A\\) und \\(B\\) entscheidbar ist, dann ist auch \\(A\\cup B\\) und \\(A\\cap B\\) entscheidbar. Wenn \\(A\\) und \\(B\\) semi-entscheidbar ist, dann ist auch \\(A \\cup B\\) und \\(A\\cap B\\) semi-entscheidbar.","title":"\\(\\cup\\) und \\(\\cap\\) Satz"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#reduktion","text":"","title":"Reduktion"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#satze","text":"Transitivit\u00e4t : F\u00fcr beliebige Sprachen \\(A, B\\) und \\(C\\) und \\(A \\preceq B\\) und \\(B \\preceq C\\) gilt, dann gilt auch \\(A \\preceq C\\) F\u00fcr beliebige Sprachen \\(A\\) und \\(B\\) , wenn \\(B\\) entscheidbar ist und \\(A \\preceq B\\) gilt, dann ist auch \\(A\\) entscheidbar. F\u00fcr beliebige Sprachen \\(A\\) und \\(B\\) , wenn \\(B\\) semi-entscheidbar ist und \\(A \\preceq B\\) gilt, dann ist auch \\(A\\) semi-entscheidbar.","title":"S\u00e4tze"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#allgemeine-halteproblem","text":"","title":"Allgemeine Halteproblem"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#leeres-band-halteproblem","text":"","title":"Leeres-Band Halteproblem"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#spezielle-halteproblem","text":"","title":"Spezielle Halteproblem"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#halteproblem-beweiss","text":"","title":"Halteproblem Beweiss"},{"location":"22FS/THIN/08_Entscheidbarkeit.html#satz-von-rice","text":"Es gibt eine Menge \\(R\\) , in welcher alle berechenbare Funktion sind. Die Menge \\(S\\subset R\\) ist eine echte, nicht leere Teilmenge von R. Die folgende Sprache ist nun unentscheidbar: $$ C(S)={w\\in{0,1}^*\\mid F_w\\in S} $$","title":"Satz von Rice"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html","text":"Komplexit\u00e4tstheorie Es gibt mehrere Arten von Komplexit\u00e4t: Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes Big-O-Notation (Landau Symbol) Im folgende Beispiel gilt: \\(7n+4\\in \\mathcal O(n)\\) f\u00fcr \\(n \\ge 6 = n_0\\) \\(0.5n^2+5n - 4 \\in \\mathcal O(n^2)\\) Bespiel an Turing Maschinen Klassifizierung von Problemen (NP vs P) Polynomzeit Verifizieren Ein Polynomzeit-Verifizierer ist eine Turing-Maschine, welche in polynomen Zeit ( \\(\\mathcal O(n^k)\\) , wobei gilt \\(k \\in \\N\\) ) \u00fcberpr\u00fcft, ob das Resultat einer Berechnung stimmt. Frage: Sind p-Verifizierer und Polynomzeit-Verifizierer das selbe? --> Ja Alle Probleme, welche ein Polynomzeit-Verifizierer haben, sind in der Gruppe \\(NP\\) enthalten. Polynomielle Reduktion Eine Sprache \\(L_1\\) ist polynominell auf \\(L_2\\) reduzierbar ( \\(L_1 \\preceq_p L_2\\) ), wenn eine Turing Maschine gebaut werden kann, welche von \\(L_1\\) zu \\(L_2\\) umwandeln kann. Dies muss in \\(O(n^k)\\) m\u00f6glich sein. NP-Schwer und NP-Vollst\u00e4ndig Ein Problem ist NP-schwer , wenn es auf alle NP-Probleme (Probleme, welche mit einer Nicht-Deterministiersch-Maschine l\u00f6sbar/verifizierbar sind) reduzieren l\u00e4sst. Aus dem geht hervor, dass ein Problem, welches NP-schwer ist, gleich schwer oder schwerer zum l\u00f6sen ist, wie alle NP-Problem einzeln. Ein Problem ist NP-vollst\u00e4ndig , wenn es ein NP-Problem und NP-schwer ist. Ein NP-vollst\u00e4ndiges Problem ist gleich schwer zum l\u00f6sen, wie das am schwierigsten l\u00f6sbaren NP-Problem. \\(P=NP\\) Problem Wenn es jemandem gelingt ein Problem zu finden, welches NP-vollst\u00e4ndig ist und gleichzeitig auch zu P geh\u00f6hrt, dann w\u00fcrde gelten \\(P=NP\\) , da P zu jedem NP-Problem reduziert werden k\u00f6nnte. Bis jetzt wurde kein solches Beispiel gefunden Konjunktive Normalform (KNF) Ein Ausdruck, welcher in der konjuktiver Normalform steht, besteht nur aus \\(\\neg\\) , \\(\\vee\\) , \\(\\wedge\\) , \\(()\\) und Literale. Beispiele: \\(x\\) \\(x_1 \\vee x_2\\) \\(x_1 \\wedge x_2\\) \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) Hingegen \\((x_1 \\wedge x_2) \\vee x_3\\) w\u00e4re nicht in der konjunktive Normalform SAT SAT war das \"erste\" NP-vollst\u00e4ndige Problem. Anhand diesem wurden alle weiteren Beweise f\u00fcr NP-Vollst\u00e4ndigkeit aufgeh\u00e4ngt. Das SAT Problem ist zu einscheiden, ob eine Formel in der KNF erf\u00fcllbar ist. Also es sicherlich eine Belegung gibt, welche 1 zur\u00fcck gibt. Es muss gezeigt werden das: \\(SAT \\in NP\\) : Es ist m\u00f6glich eine Nicht-Deterministische Maschine zu bauen, welche \u00fcberpr\u00fcfen kann, ob eine Formel erf\u00fcllbar ist SAT ist NP-schwer: Das Problem kann zu allen NP-Problemen reduziert werden NP-Vollst\u00e4ndigkeits-Nachweis weiteren Problemen Satz Wenn \\(P1\\) NP-schwer und \\(P2\\) in NP enthalten ist und eine polynomielle Reduktion \\(P1 \\preceq_p P2\\) existiert, dann ist \\(P2\\) NP-vollst\u00e4ndig. Dass heisst, wenn ein Problem in NP enthalten ist und es eine Reduktion zu dem SAT Problem gibt, dann ist es NP-vollst\u00e4ndig.","title":"Komplexit\u00e4tstheorie"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#komplexitatstheorie","text":"Es gibt mehrere Arten von Komplexit\u00e4t: Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes","title":"Komplexit\u00e4tstheorie"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#big-o-notation-landau-symbol","text":"Im folgende Beispiel gilt: \\(7n+4\\in \\mathcal O(n)\\) f\u00fcr \\(n \\ge 6 = n_0\\) \\(0.5n^2+5n - 4 \\in \\mathcal O(n^2)\\)","title":"Big-O-Notation (Landau Symbol)"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#bespiel-an-turing-maschinen","text":"","title":"Bespiel an Turing Maschinen"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#_1","text":"","title":""},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#klassifizierung-von-problemen-np-vs-p","text":"","title":"Klassifizierung von Problemen (NP vs P)"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#polynomzeit-verifizieren","text":"Ein Polynomzeit-Verifizierer ist eine Turing-Maschine, welche in polynomen Zeit ( \\(\\mathcal O(n^k)\\) , wobei gilt \\(k \\in \\N\\) ) \u00fcberpr\u00fcft, ob das Resultat einer Berechnung stimmt. Frage: Sind p-Verifizierer und Polynomzeit-Verifizierer das selbe? --> Ja Alle Probleme, welche ein Polynomzeit-Verifizierer haben, sind in der Gruppe \\(NP\\) enthalten.","title":"Polynomzeit Verifizieren"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#polynomielle-reduktion","text":"Eine Sprache \\(L_1\\) ist polynominell auf \\(L_2\\) reduzierbar ( \\(L_1 \\preceq_p L_2\\) ), wenn eine Turing Maschine gebaut werden kann, welche von \\(L_1\\) zu \\(L_2\\) umwandeln kann. Dies muss in \\(O(n^k)\\) m\u00f6glich sein.","title":"Polynomielle Reduktion"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#np-schwer-und-np-vollstandig","text":"Ein Problem ist NP-schwer , wenn es auf alle NP-Probleme (Probleme, welche mit einer Nicht-Deterministiersch-Maschine l\u00f6sbar/verifizierbar sind) reduzieren l\u00e4sst. Aus dem geht hervor, dass ein Problem, welches NP-schwer ist, gleich schwer oder schwerer zum l\u00f6sen ist, wie alle NP-Problem einzeln. Ein Problem ist NP-vollst\u00e4ndig , wenn es ein NP-Problem und NP-schwer ist. Ein NP-vollst\u00e4ndiges Problem ist gleich schwer zum l\u00f6sen, wie das am schwierigsten l\u00f6sbaren NP-Problem.","title":"NP-Schwer und NP-Vollst\u00e4ndig"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#pnp-problem","text":"Wenn es jemandem gelingt ein Problem zu finden, welches NP-vollst\u00e4ndig ist und gleichzeitig auch zu P geh\u00f6hrt, dann w\u00fcrde gelten \\(P=NP\\) , da P zu jedem NP-Problem reduziert werden k\u00f6nnte. Bis jetzt wurde kein solches Beispiel gefunden","title":"\\(P=NP\\) Problem"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#konjunktive-normalform-knf","text":"Ein Ausdruck, welcher in der konjuktiver Normalform steht, besteht nur aus \\(\\neg\\) , \\(\\vee\\) , \\(\\wedge\\) , \\(()\\) und Literale. Beispiele: \\(x\\) \\(x_1 \\vee x_2\\) \\(x_1 \\wedge x_2\\) \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) Hingegen \\((x_1 \\wedge x_2) \\vee x_3\\) w\u00e4re nicht in der konjunktive Normalform","title":"Konjunktive Normalform (KNF)"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#sat","text":"SAT war das \"erste\" NP-vollst\u00e4ndige Problem. Anhand diesem wurden alle weiteren Beweise f\u00fcr NP-Vollst\u00e4ndigkeit aufgeh\u00e4ngt. Das SAT Problem ist zu einscheiden, ob eine Formel in der KNF erf\u00fcllbar ist. Also es sicherlich eine Belegung gibt, welche 1 zur\u00fcck gibt. Es muss gezeigt werden das: \\(SAT \\in NP\\) : Es ist m\u00f6glich eine Nicht-Deterministische Maschine zu bauen, welche \u00fcberpr\u00fcfen kann, ob eine Formel erf\u00fcllbar ist SAT ist NP-schwer: Das Problem kann zu allen NP-Problemen reduziert werden","title":"SAT"},{"location":"22FS/THIN/09_Komplexit%C3%A4tstheorie.html#np-vollstandigkeits-nachweis-weiteren-problemen","text":"Satz Wenn \\(P1\\) NP-schwer und \\(P2\\) in NP enthalten ist und eine polynomielle Reduktion \\(P1 \\preceq_p P2\\) existiert, dann ist \\(P2\\) NP-vollst\u00e4ndig. Dass heisst, wenn ein Problem in NP enthalten ist und es eine Reduktion zu dem SAT Problem gibt, dann ist es NP-vollst\u00e4ndig.","title":"NP-Vollst\u00e4ndigkeits-Nachweis weiteren Problemen"},{"location":"22FS/THIN/summary%20%28copy%29.html","tags":["summary","THIN"],"text":"Summary Begriff Beschreib Alphabet Endliche, nichtleere Menge von Symbolen ( \\(\\Sigma=\\{a, b, c\\}\\) ) Wort Endliche Folge von Symbolen \\(\\varepsilon\\) Das Leere Wort ( \\(\\vert \\varepsilon\\vert=0\\) ) Sprache Eine Menge von W\u00f6rtern ( \\(L=\\{10, 1100, ...\\}\\) , in Prosa oder \\(L=\\{1^n0^n\\mid n\\in \\N\\}\\) ) \\(\\emptyset\\) Leere Sprache ( \\(\\emptyset \\neq \\{\\varepsilon\\}\\) ) \\(\\vert abca\\vert_a=2\\) H\u00e4ufigkeit von a \\((abc)^R\\) Spiegelwort von \\(abc\\) (echter) Pr\u00e4fix Der Start eines Wortes (echt = Pr\u00e4fix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein (echter) Infix Teilw\u00f6rter (echt = Infix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein (echter) Suffix Das Ende des Wortes (echt = Suffix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein \\(\\Sigma^2\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) mit der L\u00e4nge 2 Kleenesche H\u00fclle \\(\\Sigma^*\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) ( \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) ) Konkatination \\(x\\circ y=xy\\) Zwei W\u00f6rter werden zusammen verketet Wortpotenzen \\((ab)^3=ababab\\) Sprachen-Konkatenation \\(AB=\\{uv\\mid u \\in A \\text{ und } v \\in B\\}\\) Kleenesche H\u00fclle einer Sprache \\(A^*=\\varepsilon \\cup A \\cup AA \\cup AAA \\cup ...\\) Komplement einer Sprache \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\) Chomsky-Hirarchie Typ-0 - rekursive Aufz\u00e4hlbar und Turing-Maschinen Typ-2 - Nicht-deterministische Kellerautomaten / Kontextfreie Gramatik Typ-3 - RegEx / Endliche Automaten (DEA, NEA) Regex \\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts. Beschreibt \\(\\{\\varepsilon\\}\\) \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache * zuerst verarbeiten, danach Konkatenation, danach | verarbeiten (Stern vor Konkatenation vor Strich) Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r Endliche Automaten Deterministische Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein Im folgenden Beispiel sind ist eine Berechnung, bestehended aus Berechnungsschritte (welche aus Konfigurationen bestehen). Die Startkonfiguration ist: \\(\\{q_0\\}\\times \\Sigma^*\\) , die Endkonfiguration: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) $$ (q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)=(q0, a_1a_2a_3)\\vdash_A^ (q4, \\epsilon) $$ Die Sprache * eines endlichen Automaten besteht aus allen W\u00f6rter, welche in einem Endzustand landen ohne verbleibenden Input. Was Beschreibung Der Startzustand Akzeptierter Endzustand Normaler Zustand \u00dcbergangsfunktionen: Vom Zustand \"0.50\" kann zu \"1.50\" gelaufen werden Nicht Deterministische Automaten (NEA) Eine NEA kann es f\u00fcr einen Input und Zustand mehrere \u00dcberg\u00e4nge geben (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) ). Es werden alle M\u00f6glichkeiten von der NEA durchprobiert. Eine NEA akzeptiert ein Wort, wenn eine M\u00f6glichkeit akzeptiert wird. Eine \\(\\varepsilon\\) -NEA ist eine NEA, welche den Zustand wechseln kann, ohne ein Input zu konsumieren (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) ) Um eine \\(\\varepsilon\\) -NEA in eine NEA umzuwandeln, muss \u00fcberlegt werden, was f\u00fcr ein Zeichen als n\u00e4chstes konsumiert werden k\u00f6nnte und diese in den uspr\u00fcnglichen \u00dcbergang aufzunehmen. Teilmengenkonstruktion ( \\(NEA \\to DEA\\) ) Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) (Potenzmenge: \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) ) Die potentielle Startzustand Kandidaten sind alle diese Teilmengen von \\(Q_N\\) , welche \\(q_0\\) enthalten Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Also nie bei einer Eingabe-Spalte auftauchen. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. Wenn \\(\\{q_1\\}\\) in einer Eingabe-Spalte steht, heisst das nur, dass \\(\\{q_1\\}\\) vorhanden ist. \\(\\{q_1, q_2\\}\\) muss immer noch gestrichen werden, wenn es nicht selbst vorkommt Wenn eine Verbindung das leeres Wort nimmt, werden die Zust\u00e4nde, welche man vom leeren Wort Zustand erreichen kann, auch vom urspr\u00fcnglichen Wort als erreichbar angesehen. Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z) DEA \\(\\to\\) RegEX F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen \\[ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0L_{q_1}\\Rightarrow(0|1)^*0L_{q_1}\\Rightarrow(0|1)*01\\\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\\\ L_{q_2}&=\\varepsilon\\\\ \\end{align} \\] Arden'sches Lemma : \\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruch Zustandsklassen: \\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand) Untere Schranke f\u00fcr endliche Automaten Die grunds\u00e4tzliche Idee ist, dass wenn die Worte \\(x\\) und \\(y\\) in derselben Zustandsklasse ist, dann ist \\(zx=zy\\) , wobei \\(z\\) irgend ein Wort ist. Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort, ein Wort ergibt, welches in der Sprache ist und mit dem anderen Wort ein, ein Wort welches nicht in der Sprache ist Wenn dies f\u00fcr jedes Wort von Schritt 2. getan werden kann, dann werden mindestens so viel Zust\u00e4nde ben\u00f6tigt. Da wenn zwei W\u00f6rter mit demselben Wort verbunden wird und diese in unterschiedlichen Sprache sind, die zwei W\u00f6rter in unterschiedlichen Zust\u00e4nde endet. Kontextfreie Gramatik Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale (Variabeln)ist , welche mit Produktionen in \\(P\\) aufgel\u00f6st werden k\u00f6nnen \\(P\\) eine endliche Menge von Produktionen in der Form \\(X \\rightarrow \\beta\\) ist. Dabei ist der Kopf \\(X\\in N\\) und der Rumpf \\(\\beta \\in (N\\cup\\Sigma)^*\\) ) \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) $$ G_1=({A}, {0, 1}, P, A) \\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei , wenn ein Kellerautomaten dazu gebaut werden kann. Mehrere Ableitungsschritte: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) Dies kann auch als: \\(A \\overset*\\Rightarrow w\\) geschrieben werden. Dabei wird das Wort \\(w\\) vom Symbol \\(A\\) erzeugt/generiert. Ein Wort wird ableitbar gennant, wenn es eine Ableitung f\u00fcr dieses Wort gibt. Auf der Rechten Seite sieht ist ein Abbleitungsbaum. Linksseitig Ableiten : Die am meisten linke Variable wird immer zuerst abgeleitet Rechtsseitig Ableiten : Die am meisten rechte Variable wird immer zuerst abgeleitet eindeutige Gramatik : Eine Gramatik, welche nur auf eine Art abgeleitet werden kann DEA zu kontextfreien Sprache Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol Keller Automaten (KA) Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(\\Gamma\\) ist das Alphabet des Kellers (bzw. des Stacks) \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ist die (partielle) \u00dcbergangsfunktion \\(\\$\\in \\Gamma\\) ist ein ausgezeichnetes Symbol vom Alphabet des Stacks/Kellers Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt. Nichtdeterministischen Kellerautomaten (NKA) Eine NKA ist gleich wie eine KA, nur das die \u00dcbergangsfuntkion den Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) hat. Der R\u00fcckgabetyp ist die Potenzmenge. Somit kann in der NKA ein Eingang mehrere Ausg\u00e4nge haben. Wie auch bei einer NEA kann nun im \\(\\varepsilon\\) (das leere Wort) f\u00fcr \\(\\Sigma\\) in der \u00dcbergangsfunktion. Nicht alle NKA k\u00f6nnen in eine KA umgewandlet werden. Auch gibt es kontextfreie Sprachen, welche nicht in eine KA umgewandlet k\u00f6nnen werden. Berechnungen und Berechnungsschritte Die Berechnungssfunktion dazu w\u00e4re: \\(\\delta(q, b, c)=(p, w)\\) Dabei befindet sich der Automaten im Zustand \\(q\\) , list das Symbol \\(b\\) von der Eingabe und wird das Kellersymbol \\(c\\) vom Stack lesen und \\(w\\) zur\u00fcck schreiben. Eine Berechnung besteht aus mehreren Berechnungsschritte und eine Start- und Endkonfiguration. Beispiel: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)\\) Dies kann auch als \\((q_0, 0011, \\$)\\vdash^*(q2, \\varepsilon, \\$)\\) geschrieben werden. Turing Machinen Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) : Die \u00dcbergangsfunktion, welche den n\u00e4chsten Zustand, was geschrieben werden soll und ob das Band nach Links (L) oder nach rechts (R) geschoben werden soll \\(\\Gamma\\) : Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) \\(\\textvisiblespace\\) : Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) Berechnungen werden folgendermassen dargestellt: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n\\) Der aktuelle Zustand ist in der Mitte ( \\(q\\) bzw. \\(p\\) ). Abgek\u00fcrzt wird es als \\(K_1\\vdash^* K_n\\) geschrieben Eine Sprache, welche von einer TM akzeptiert wird, nennt sich rekursiv aufz\u00e4hltbar Im folgenden Bild wird eine \u00dcbergangsfunktion einer Turing Maschine gezeigt: \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\) Modifikationen Mit zus\u00e4tzlichem Speicher Mit mehreren Spuren, welche auf einem Band sind (ein Lese/Schreibkopf) Mit mehreren B\u00e4ndern (mehrere Lese/Schreibk\u00f6pfe) (\u00dcbergangsfunktion: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) ) Nicht deterministische Turning Machine \u00dcberg\u00e4nge m\u00fcssen nicht einzigartig sein (wie bei NEAs) (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times \\{R, L\\})\\) Nicht deterministische TMs sind gleich m\u00e4chtig, wie deterministische TMs. Mit semi-beschr\u00e4nktem Band Das Band ist nur unendlich in eine Richtung. Eine Semi-beschr\u00e4nkte TM ist gleich m\u00e4chtig, wie eine TM. (Beweissidee: Eine semi-beschr\u00e4nkte TM mit zwei b\u00e4nder, eines f\u00fcr die positive und eines f\u00fcr die negative Seite) \\(k\\) -Stack Machine Eine Deterministischer Kellear Automat mit mehreren Stacks (\u00dcbergangsfunktion: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) ) Eine 2-Stack Machine kann ein Band simulieren (Ein Stack f\u00fcr die negative und ein Stack f\u00fcr die positive Seite) und ist demnach gleich m\u00e4chtig, wie eine TM Z\u00e4hler-Machine (Hat Z\u00e4hler einer nat\u00fcrlichen Zahl ( \\(n \\ge 0\\) ) anstatt Stacks) Ein 2-Stack kann mit mit 3-Z\u00e4hler ersetzt werden und daher ist ein Z\u00e4hler-Machine gleich wertig, wie eine TM. Daf\u00fcr wird jedem Symbol des Stacks eine Zahl zugeordnet (1, 2, 3, 4, ...). Der aktuelle Wert wird mit der Anzahl Symbolen multipliziert und mit dem n\u00e4chsten Symbol addiert ( \\(c_{new}=c_{old}\\cdot length + s\\) ). Beim dekodieren wird der Wert durch die Anzahl Symbole geteilt und der Rest ist das aktuelle Symbol. Diese 3-Z\u00e4hler Machine kann mit einer 2-Z\u00e4hler Machine simuliert werden, in dem die 3-Z\u00e4hler mit der Encodierung \\(2^i\\cdot 3^j\\cdot 4^k\\) enkodiert werden und mit einer Primfaktorzerlegung dekodiert werden. Ein Z\u00e4hler wird noch zum Rechnen ben\u00f6tigt. Universelle Turning Maschine (UTM) Eine Turing Maschine, welche andere Turning Maschinen simulieren kann. Alle Zust\u00e4nde werden Un\u00e4r-Kodiert (0 = 1, 00 = 2, 000 = 3, ...) mit dem Trennzeichen 1 Dabei wird folgendes gespeichert: Die \u00dcbergangsfunktion \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\to 0^i10^j10^l10^m\\) . Einzelne \u00dcbergansfunktionen werden mit 11 getrennt. Die Machine wird mit 111 vom Input getrennt. Berechnungsmodelle Intuitive berechenbare Funktion : eine Funktion, welche algorithmisch (durch eine mechanisches Verfahren) berechnet werden kann. Jede intuitive berechenbare Funktion l\u00e4sst sich mit einer TM berechnen. Turing-berechenbare Funktionen : Funktionen, welche von einer Turing-Maschinen berechnet werden k\u00f6nnen Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist bereits von einer Turing-Maschine berechenbar. Bis jetzt wurde noch kein Gegenbeispiel zu beiden Thesen gefunden worden. Turing-Vollst\u00e4ndigkeit : F\u00fcr jede Zahl \\(k \\in \\N\\) und jede Funktion \\(f: \\N^k \\to \\N\\) gibt es eine Turing-Machine und While-Programm Zuweisungen: x = y + c oder x = y - c (wobei c eine Konstante ist!) x0 ist der Output; x1 , x2 , ... sind die Inputs/Variabeln Alle Variabeln k\u00f6nnen nat\u00fcrliche Zahlen ( \\(n \\ge 0\\) ) enthalten ( \\(2-5=0\\) ) Loop-Programme LOOP x DO ... END Der Loop wird x -mall durchgef\u00fchrt. \u00c4ndern von x hat kein Einfluss While-Programme (auch LOOP ist erlaubt) While xi > 0 Do ... End Die einzige erlaubte Bedingung ist xi > 0 While-Programme terminieren nicht immer Jedes Loop-Pgramm ist auch ein WhileProgramm GOTO-Programme : Marker: ( M1: , M2: , ...), Goto Mk , If xi = c Then Goto Mr , Halt (Haltet das Programm an) Primitiv rekursive Funktion (nach dem Muster \\(f: \\N^2 \\to \\N\\) ) Konstante Funktion: \\(c^n_k: \\N^n \\to \\N \\mapsto c^n_k(x_1, ..., x_n)=k\\) Nachfolge Funktion: \\(\\eta: \\N \\to \\N \\mapsto \\eta(x)=x+1\\) Projektion ( \\(1 \\le k \\le n\\) ): \\(\\pi^n_k: \\N^n \\to \\N \\mapsto \\pi^n_k(x_1, ...,x_k,...,x_n)=x_k\\) Wenn \\(f\\) und \\(g_i\\) primitive rekursive Funktionen sind, dann ist \\(h(\\vec x)=f(g_1(\\vec x), ..., g_k(\\vec x))\\) auch eine primitive rekursive Funktion Primitive rekursive Funktionen = LOOP-Programme Ackermann (ist Turing-berechenbar, nicht Loop berechen, bzw. nicht primitive rekursive, ist total): $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$ Entscheidbarkeit Entscheidbar : Es gibt eine Turing-Maschine, welche f\u00fcr alle akzeptierten (wenn ein 1 aufs Band geschrieben wird) und nicht akzeptierten Zust\u00e4nde (wenn ein 0 aufs Band geschrieben wird) endet Semi-Entscheidbar : Es gibt eine Turing-Maschine, welche f\u00fcr alle akzeptierten Zust\u00e4nde h\u00e4lt und f\u00fcr nicht akzeptierte Zust\u00e4nde nie h\u00e4lt. Reduktion Es gibt eine Funktion \\(F: \\Sigma^* \\to \\Gamma^*\\) f\u00fcr die Sprache \\(A \\subset \\Sigma^*\\) und \\(B \\subset \\Gamma^*\\) . Dies wird als \\(A \\preceq B\\) geschrieben Jede entscheidbare Sprache ist auch semi-entscheidbar Wenn eine Sprache \\(A\\) und ihr Komplement \\(\\overline A\\) semi-entscheidbar ist, sind \\(A\\) , wie auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) entscheidbar ist, ist auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) und \\(B\\) (semi-)entscheidbar sind, ist auch \\(A \\cup B\\) und \\(A \\cap B\\) (semi-)entscheidbar \\(A\\) ist rekursive aufz\u00e4hlbar \\(\\Leftrightarrow\\) \\(A\\) ist semi-entscheidbar \\(\\Leftrightarrow\\) \\(A\\) ist der Werte und Definitionsbereich einer berechenbaren Funktion \\(A\\preceq B\\) und \\(B \\preceq C\\) , dann gilt auch \\(A \\preceq C\\) Ist \\(B\\) (semi-)entscheidbar und \\(A \\preceq B\\) , dann ist auch \\(A\\) (semi-)entscheidbar allgemeine Halteproblem : Gibt es eine TM \\(H\\) , welche entscheiden kann, ob ein Program mit einem Input anh\u00e4lt oder nicht immer weiter l\u00e4uft. leere Halteproblem : Ob es eine TM \\(H_0\\) gibt, welche entscheiden kann, ob ein Programm mit einem leeren Band anh\u00e4lt spezielle Halteproblem : Es wird eine TM \\(H_S\\) erstellt, welche \\(H\\) fragt, ob ein Program endet. Wenn ja, loopt \\(H_S\\) , wenn nein, beendet \\(H_S\\) . Wenn \\(H_S\\) das als Input \\((H_S, H_S)\\) bekommt, ist unklar, ob \\(H_S\\) anh\u00e4lt oder weiterl\u00e4uft und daher kann es keine TM \\(H\\) geben. Alle Halteprobleme sind semi-entscheidbar und nicht-entscheidbar. Konsequenzen von Satz von Rice: Unm\u00f6glich im Allgemeinen zu \u00fcberpr\u00fcfen, ob ein Program eine bestimmte Spezifikation erf\u00fcllt frei von \u201cbugs\u201d ist bei jeder Eingabe terminiert und ein anderes Program dieselbe Funktionalit\u00e4t haben Colatz: \\(n \\text{ ist gerade} \\Rightarrow n=\\frac n 2 \\text{ sonst } n=3n + 1\\) Alle positiven Inputs enden in \\(4 \\to 2 \\to 1 \\to 4 \\to 2 \\to 1\\) Komplexit\u00e4tstheorie Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes Obereschranke: \\(f \\in \\mathcal O(g)\\Leftrightarrow f(n) \\le c \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(g\\) und \\(f\\) eine Funktion \\(\\N \\to \\N\\) ist und \\(c\\in \\N\\) eine Konstante) Untereschranke: \\(f \\in \\Omega(g)\\Leftrightarrow f(n) \\ge \\frac 1 d \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(d \\in \\N\\) eine Konstante ist) \\(f\\in \\Theta(g) \\Leftrightarrow f(n)\\in \\mathcal O(g(n))\\wedge f(n)\\in \\Omega(g(n))\\) Komplexit\u00e4t Beispiel \\(\\mathcal O(1)\\) Konstanter Aufwand unabh\u00e4ngig vom Input \\(\\mathcal O(n)\\) Linearer Aufwand: Ein For-Loop Abh\u00e4ngig von \\(n\\) \\(\\mathcal O(\\log n)\\) Logarithmischer Aufwand: Binary-Search/ Mit jeder Iteration wird der Aufwand halbiert \\(\\mathcal O(n^2)\\) Quadratischer Aufwand: Zwei verschachtelte For-Loops abh\u00e4ngig von \\(n\\) \\(\\mathcal O(2^n)\\) Exponentieller Aufwand: Mit jeder Iteration verdoppelt sich der Aufwand NP vs P Polynomzeit l\u00f6sbar (P) : Problem ist teil von \\(\\mathcal O(n^c)\\) , wobei \\(c \\ge 1\\) Nicht deterministische Polynomiell (NP) : Alle Probleme entscheidbar von einer Nicht-deterministische Maschine in polynomzeit Polynomzeit-Verifizierer : Eine TM, welche eine L\u00f6sung in polynomial zeit verifiziert \\(P\\neq NP\\) : Nicht alle Probleme, welche in polynomzeit verifizierbar sind, k\u00f6nnen in polynomzeit gel\u00f6st werden Clique : Eine Menge von Knoten, bei welchen alle Knoten mit allen anderen Knoten (ausser sich selbst) verbunden sind NP-Schwer : Ein Problem, welches sich auf alle NP-Probleme reduzieren l\u00e4sst. Ein NP-Schweres Problem ist gleich schwer oder schwerer also das schwerste NP-Problem NP-Vollst\u00e4dnig : Ein NP-Vollst\u00e4ndiges Problem ist NP-Schwer und ein NP-Problem polynomiell reduzierbar ( \\(\\preceq_p\\) ) : Eine Reduktion in polynomieller Zeit ( \\(L_1 \\preceq_p L_2\\) heisst, dass \\(L_2\\) mindestens so schwer wie \\(L_1\\) ist ) Wenn \\(P_1\\) NP-schwer, \\(P_2\\) in NP enthalten ist und \\(P_1 \\preceq_p P_2\\) gibt, dann ist \\(P_2\\) NP-vollst\u00e4ndig SAT : \"erstes\" NP-volst\u00e4ndige Problem Ob eine Formel in der KNF ( \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) )) erf\u00fcllbar ist TODO : L\u00f6sung von SAT Problem","title":"THIN Summary"},{"location":"22FS/THIN/summary%20%28copy%29.html#summary","text":"Begriff Beschreib Alphabet Endliche, nichtleere Menge von Symbolen ( \\(\\Sigma=\\{a, b, c\\}\\) ) Wort Endliche Folge von Symbolen \\(\\varepsilon\\) Das Leere Wort ( \\(\\vert \\varepsilon\\vert=0\\) ) Sprache Eine Menge von W\u00f6rtern ( \\(L=\\{10, 1100, ...\\}\\) , in Prosa oder \\(L=\\{1^n0^n\\mid n\\in \\N\\}\\) ) \\(\\emptyset\\) Leere Sprache ( \\(\\emptyset \\neq \\{\\varepsilon\\}\\) ) \\(\\vert abca\\vert_a=2\\) H\u00e4ufigkeit von a \\((abc)^R\\) Spiegelwort von \\(abc\\) (echter) Pr\u00e4fix Der Start eines Wortes (echt = Pr\u00e4fix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein (echter) Infix Teilw\u00f6rter (echt = Infix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein (echter) Suffix Das Ende des Wortes (echt = Suffix nicht gleich das Wort) Kann auch \\(\\varepsilon\\) sein \\(\\Sigma^2\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) mit der L\u00e4nge 2 Kleenesche H\u00fclle \\(\\Sigma^*\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) ( \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) ) Konkatination \\(x\\circ y=xy\\) Zwei W\u00f6rter werden zusammen verketet Wortpotenzen \\((ab)^3=ababab\\) Sprachen-Konkatenation \\(AB=\\{uv\\mid u \\in A \\text{ und } v \\in B\\}\\) Kleenesche H\u00fclle einer Sprache \\(A^*=\\varepsilon \\cup A \\cup AA \\cup AAA \\cup ...\\) Komplement einer Sprache \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\)","title":"Summary"},{"location":"22FS/THIN/summary%20%28copy%29.html#chomsky-hirarchie","text":"Typ-0 - rekursive Aufz\u00e4hlbar und Turing-Maschinen Typ-2 - Nicht-deterministische Kellerautomaten / Kontextfreie Gramatik Typ-3 - RegEx / Endliche Automaten (DEA, NEA)","title":"Chomsky-Hirarchie"},{"location":"22FS/THIN/summary%20%28copy%29.html#regex","text":"\\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts. Beschreibt \\(\\{\\varepsilon\\}\\) \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache * zuerst verarbeiten, danach Konkatenation, danach | verarbeiten (Stern vor Konkatenation vor Strich) Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r","title":"Regex"},{"location":"22FS/THIN/summary%20%28copy%29.html#endliche-automaten","text":"Deterministische Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein Im folgenden Beispiel sind ist eine Berechnung, bestehended aus Berechnungsschritte (welche aus Konfigurationen bestehen). Die Startkonfiguration ist: \\(\\{q_0\\}\\times \\Sigma^*\\) , die Endkonfiguration: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) $$ (q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)=(q0, a_1a_2a_3)\\vdash_A^ (q4, \\epsilon) $$ Die Sprache * eines endlichen Automaten besteht aus allen W\u00f6rter, welche in einem Endzustand landen ohne verbleibenden Input. Was Beschreibung Der Startzustand Akzeptierter Endzustand Normaler Zustand \u00dcbergangsfunktionen: Vom Zustand \"0.50\" kann zu \"1.50\" gelaufen werden","title":"Endliche Automaten"},{"location":"22FS/THIN/summary%20%28copy%29.html#nicht-deterministische-automaten-nea","text":"Eine NEA kann es f\u00fcr einen Input und Zustand mehrere \u00dcberg\u00e4nge geben (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) ). Es werden alle M\u00f6glichkeiten von der NEA durchprobiert. Eine NEA akzeptiert ein Wort, wenn eine M\u00f6glichkeit akzeptiert wird. Eine \\(\\varepsilon\\) -NEA ist eine NEA, welche den Zustand wechseln kann, ohne ein Input zu konsumieren (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) ) Um eine \\(\\varepsilon\\) -NEA in eine NEA umzuwandeln, muss \u00fcberlegt werden, was f\u00fcr ein Zeichen als n\u00e4chstes konsumiert werden k\u00f6nnte und diese in den uspr\u00fcnglichen \u00dcbergang aufzunehmen.","title":"Nicht Deterministische Automaten (NEA)"},{"location":"22FS/THIN/summary%20%28copy%29.html#teilmengenkonstruktion-nea-to-dea","text":"Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) (Potenzmenge: \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) ) Die potentielle Startzustand Kandidaten sind alle diese Teilmengen von \\(Q_N\\) , welche \\(q_0\\) enthalten Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Also nie bei einer Eingabe-Spalte auftauchen. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. Wenn \\(\\{q_1\\}\\) in einer Eingabe-Spalte steht, heisst das nur, dass \\(\\{q_1\\}\\) vorhanden ist. \\(\\{q_1, q_2\\}\\) muss immer noch gestrichen werden, wenn es nicht selbst vorkommt Wenn eine Verbindung das leeres Wort nimmt, werden die Zust\u00e4nde, welche man vom leeren Wort Zustand erreichen kann, auch vom urspr\u00fcnglichen Wort als erreichbar angesehen. Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z)","title":"Teilmengenkonstruktion (\\(NEA \\to DEA\\))"},{"location":"22FS/THIN/summary%20%28copy%29.html#dea-to-regex","text":"F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen \\[ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0L_{q_1}\\Rightarrow(0|1)^*0L_{q_1}\\Rightarrow(0|1)*01\\\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\\\ L_{q_2}&=\\varepsilon\\\\ \\end{align} \\] Arden'sches Lemma : \\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruch Zustandsklassen: \\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand)","title":"DEA \\(\\to\\) RegEX"},{"location":"22FS/THIN/summary%20%28copy%29.html#untere-schranke-fur-endliche-automaten","text":"Die grunds\u00e4tzliche Idee ist, dass wenn die Worte \\(x\\) und \\(y\\) in derselben Zustandsklasse ist, dann ist \\(zx=zy\\) , wobei \\(z\\) irgend ein Wort ist. Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort, ein Wort ergibt, welches in der Sprache ist und mit dem anderen Wort ein, ein Wort welches nicht in der Sprache ist Wenn dies f\u00fcr jedes Wort von Schritt 2. getan werden kann, dann werden mindestens so viel Zust\u00e4nde ben\u00f6tigt. Da wenn zwei W\u00f6rter mit demselben Wort verbunden wird und diese in unterschiedlichen Sprache sind, die zwei W\u00f6rter in unterschiedlichen Zust\u00e4nde endet.","title":"Untere Schranke f\u00fcr endliche Automaten"},{"location":"22FS/THIN/summary%20%28copy%29.html#kontextfreie-gramatik","text":"Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale (Variabeln)ist , welche mit Produktionen in \\(P\\) aufgel\u00f6st werden k\u00f6nnen \\(P\\) eine endliche Menge von Produktionen in der Form \\(X \\rightarrow \\beta\\) ist. Dabei ist der Kopf \\(X\\in N\\) und der Rumpf \\(\\beta \\in (N\\cup\\Sigma)^*\\) ) \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) $$ G_1=({A}, {0, 1}, P, A) \\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei , wenn ein Kellerautomaten dazu gebaut werden kann. Mehrere Ableitungsschritte: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) Dies kann auch als: \\(A \\overset*\\Rightarrow w\\) geschrieben werden. Dabei wird das Wort \\(w\\) vom Symbol \\(A\\) erzeugt/generiert. Ein Wort wird ableitbar gennant, wenn es eine Ableitung f\u00fcr dieses Wort gibt. Auf der Rechten Seite sieht ist ein Abbleitungsbaum. Linksseitig Ableiten : Die am meisten linke Variable wird immer zuerst abgeleitet Rechtsseitig Ableiten : Die am meisten rechte Variable wird immer zuerst abgeleitet eindeutige Gramatik : Eine Gramatik, welche nur auf eine Art abgeleitet werden kann","title":"Kontextfreie Gramatik"},{"location":"22FS/THIN/summary%20%28copy%29.html#dea-zu-kontextfreien-sprache","text":"Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol","title":"DEA zu kontextfreien Sprache"},{"location":"22FS/THIN/summary%20%28copy%29.html#keller-automaten-ka","text":"Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(\\Gamma\\) ist das Alphabet des Kellers (bzw. des Stacks) \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ist die (partielle) \u00dcbergangsfunktion \\(\\$\\in \\Gamma\\) ist ein ausgezeichnetes Symbol vom Alphabet des Stacks/Kellers Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt.","title":"Keller Automaten (KA)"},{"location":"22FS/THIN/summary%20%28copy%29.html#nichtdeterministischen-kellerautomaten-nka","text":"Eine NKA ist gleich wie eine KA, nur das die \u00dcbergangsfuntkion den Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) hat. Der R\u00fcckgabetyp ist die Potenzmenge. Somit kann in der NKA ein Eingang mehrere Ausg\u00e4nge haben. Wie auch bei einer NEA kann nun im \\(\\varepsilon\\) (das leere Wort) f\u00fcr \\(\\Sigma\\) in der \u00dcbergangsfunktion. Nicht alle NKA k\u00f6nnen in eine KA umgewandlet werden. Auch gibt es kontextfreie Sprachen, welche nicht in eine KA umgewandlet k\u00f6nnen werden.","title":"Nichtdeterministischen Kellerautomaten (NKA)"},{"location":"22FS/THIN/summary%20%28copy%29.html#berechnungen-und-berechnungsschritte","text":"Die Berechnungssfunktion dazu w\u00e4re: \\(\\delta(q, b, c)=(p, w)\\) Dabei befindet sich der Automaten im Zustand \\(q\\) , list das Symbol \\(b\\) von der Eingabe und wird das Kellersymbol \\(c\\) vom Stack lesen und \\(w\\) zur\u00fcck schreiben. Eine Berechnung besteht aus mehreren Berechnungsschritte und eine Start- und Endkonfiguration. Beispiel: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)\\) Dies kann auch als \\((q_0, 0011, \\$)\\vdash^*(q2, \\varepsilon, \\$)\\) geschrieben werden.","title":"Berechnungen und Berechnungsschritte"},{"location":"22FS/THIN/summary%20%28copy%29.html#turing-machinen","text":"Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) : Die \u00dcbergangsfunktion, welche den n\u00e4chsten Zustand, was geschrieben werden soll und ob das Band nach Links (L) oder nach rechts (R) geschoben werden soll \\(\\Gamma\\) : Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) \\(\\textvisiblespace\\) : Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) Berechnungen werden folgendermassen dargestellt: \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n\\) Der aktuelle Zustand ist in der Mitte ( \\(q\\) bzw. \\(p\\) ). Abgek\u00fcrzt wird es als \\(K_1\\vdash^* K_n\\) geschrieben Eine Sprache, welche von einer TM akzeptiert wird, nennt sich rekursiv aufz\u00e4hltbar Im folgenden Bild wird eine \u00dcbergangsfunktion einer Turing Maschine gezeigt: \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\)","title":"Turing Machinen"},{"location":"22FS/THIN/summary%20%28copy%29.html#modifikationen","text":"Mit zus\u00e4tzlichem Speicher Mit mehreren Spuren, welche auf einem Band sind (ein Lese/Schreibkopf) Mit mehreren B\u00e4ndern (mehrere Lese/Schreibk\u00f6pfe) (\u00dcbergangsfunktion: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) ) Nicht deterministische Turning Machine \u00dcberg\u00e4nge m\u00fcssen nicht einzigartig sein (wie bei NEAs) (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times \\{R, L\\})\\) Nicht deterministische TMs sind gleich m\u00e4chtig, wie deterministische TMs. Mit semi-beschr\u00e4nktem Band Das Band ist nur unendlich in eine Richtung. Eine Semi-beschr\u00e4nkte TM ist gleich m\u00e4chtig, wie eine TM. (Beweissidee: Eine semi-beschr\u00e4nkte TM mit zwei b\u00e4nder, eines f\u00fcr die positive und eines f\u00fcr die negative Seite) \\(k\\) -Stack Machine Eine Deterministischer Kellear Automat mit mehreren Stacks (\u00dcbergangsfunktion: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) ) Eine 2-Stack Machine kann ein Band simulieren (Ein Stack f\u00fcr die negative und ein Stack f\u00fcr die positive Seite) und ist demnach gleich m\u00e4chtig, wie eine TM Z\u00e4hler-Machine (Hat Z\u00e4hler einer nat\u00fcrlichen Zahl ( \\(n \\ge 0\\) ) anstatt Stacks) Ein 2-Stack kann mit mit 3-Z\u00e4hler ersetzt werden und daher ist ein Z\u00e4hler-Machine gleich wertig, wie eine TM. Daf\u00fcr wird jedem Symbol des Stacks eine Zahl zugeordnet (1, 2, 3, 4, ...). Der aktuelle Wert wird mit der Anzahl Symbolen multipliziert und mit dem n\u00e4chsten Symbol addiert ( \\(c_{new}=c_{old}\\cdot length + s\\) ). Beim dekodieren wird der Wert durch die Anzahl Symbole geteilt und der Rest ist das aktuelle Symbol. Diese 3-Z\u00e4hler Machine kann mit einer 2-Z\u00e4hler Machine simuliert werden, in dem die 3-Z\u00e4hler mit der Encodierung \\(2^i\\cdot 3^j\\cdot 4^k\\) enkodiert werden und mit einer Primfaktorzerlegung dekodiert werden. Ein Z\u00e4hler wird noch zum Rechnen ben\u00f6tigt.","title":"Modifikationen"},{"location":"22FS/THIN/summary%20%28copy%29.html#universelle-turning-maschine-utm","text":"Eine Turing Maschine, welche andere Turning Maschinen simulieren kann. Alle Zust\u00e4nde werden Un\u00e4r-Kodiert (0 = 1, 00 = 2, 000 = 3, ...) mit dem Trennzeichen 1 Dabei wird folgendes gespeichert: Die \u00dcbergangsfunktion \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\to 0^i10^j10^l10^m\\) . Einzelne \u00dcbergansfunktionen werden mit 11 getrennt. Die Machine wird mit 111 vom Input getrennt.","title":"Universelle Turning Maschine (UTM)"},{"location":"22FS/THIN/summary%20%28copy%29.html#berechnungsmodelle","text":"Intuitive berechenbare Funktion : eine Funktion, welche algorithmisch (durch eine mechanisches Verfahren) berechnet werden kann. Jede intuitive berechenbare Funktion l\u00e4sst sich mit einer TM berechnen. Turing-berechenbare Funktionen : Funktionen, welche von einer Turing-Maschinen berechnet werden k\u00f6nnen Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist bereits von einer Turing-Maschine berechenbar. Bis jetzt wurde noch kein Gegenbeispiel zu beiden Thesen gefunden worden. Turing-Vollst\u00e4ndigkeit : F\u00fcr jede Zahl \\(k \\in \\N\\) und jede Funktion \\(f: \\N^k \\to \\N\\) gibt es eine Turing-Machine und While-Programm Zuweisungen: x = y + c oder x = y - c (wobei c eine Konstante ist!) x0 ist der Output; x1 , x2 , ... sind die Inputs/Variabeln Alle Variabeln k\u00f6nnen nat\u00fcrliche Zahlen ( \\(n \\ge 0\\) ) enthalten ( \\(2-5=0\\) ) Loop-Programme LOOP x DO ... END Der Loop wird x -mall durchgef\u00fchrt. \u00c4ndern von x hat kein Einfluss While-Programme (auch LOOP ist erlaubt) While xi > 0 Do ... End Die einzige erlaubte Bedingung ist xi > 0 While-Programme terminieren nicht immer Jedes Loop-Pgramm ist auch ein WhileProgramm GOTO-Programme : Marker: ( M1: , M2: , ...), Goto Mk , If xi = c Then Goto Mr , Halt (Haltet das Programm an) Primitiv rekursive Funktion (nach dem Muster \\(f: \\N^2 \\to \\N\\) ) Konstante Funktion: \\(c^n_k: \\N^n \\to \\N \\mapsto c^n_k(x_1, ..., x_n)=k\\) Nachfolge Funktion: \\(\\eta: \\N \\to \\N \\mapsto \\eta(x)=x+1\\) Projektion ( \\(1 \\le k \\le n\\) ): \\(\\pi^n_k: \\N^n \\to \\N \\mapsto \\pi^n_k(x_1, ...,x_k,...,x_n)=x_k\\) Wenn \\(f\\) und \\(g_i\\) primitive rekursive Funktionen sind, dann ist \\(h(\\vec x)=f(g_1(\\vec x), ..., g_k(\\vec x))\\) auch eine primitive rekursive Funktion Primitive rekursive Funktionen = LOOP-Programme Ackermann (ist Turing-berechenbar, nicht Loop berechen, bzw. nicht primitive rekursive, ist total): $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$","title":"Berechnungsmodelle"},{"location":"22FS/THIN/summary%20%28copy%29.html#entscheidbarkeit","text":"Entscheidbar : Es gibt eine Turing-Maschine, welche f\u00fcr alle akzeptierten (wenn ein 1 aufs Band geschrieben wird) und nicht akzeptierten Zust\u00e4nde (wenn ein 0 aufs Band geschrieben wird) endet Semi-Entscheidbar : Es gibt eine Turing-Maschine, welche f\u00fcr alle akzeptierten Zust\u00e4nde h\u00e4lt und f\u00fcr nicht akzeptierte Zust\u00e4nde nie h\u00e4lt. Reduktion Es gibt eine Funktion \\(F: \\Sigma^* \\to \\Gamma^*\\) f\u00fcr die Sprache \\(A \\subset \\Sigma^*\\) und \\(B \\subset \\Gamma^*\\) . Dies wird als \\(A \\preceq B\\) geschrieben Jede entscheidbare Sprache ist auch semi-entscheidbar Wenn eine Sprache \\(A\\) und ihr Komplement \\(\\overline A\\) semi-entscheidbar ist, sind \\(A\\) , wie auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) entscheidbar ist, ist auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) und \\(B\\) (semi-)entscheidbar sind, ist auch \\(A \\cup B\\) und \\(A \\cap B\\) (semi-)entscheidbar \\(A\\) ist rekursive aufz\u00e4hlbar \\(\\Leftrightarrow\\) \\(A\\) ist semi-entscheidbar \\(\\Leftrightarrow\\) \\(A\\) ist der Werte und Definitionsbereich einer berechenbaren Funktion \\(A\\preceq B\\) und \\(B \\preceq C\\) , dann gilt auch \\(A \\preceq C\\) Ist \\(B\\) (semi-)entscheidbar und \\(A \\preceq B\\) , dann ist auch \\(A\\) (semi-)entscheidbar allgemeine Halteproblem : Gibt es eine TM \\(H\\) , welche entscheiden kann, ob ein Program mit einem Input anh\u00e4lt oder nicht immer weiter l\u00e4uft. leere Halteproblem : Ob es eine TM \\(H_0\\) gibt, welche entscheiden kann, ob ein Programm mit einem leeren Band anh\u00e4lt spezielle Halteproblem : Es wird eine TM \\(H_S\\) erstellt, welche \\(H\\) fragt, ob ein Program endet. Wenn ja, loopt \\(H_S\\) , wenn nein, beendet \\(H_S\\) . Wenn \\(H_S\\) das als Input \\((H_S, H_S)\\) bekommt, ist unklar, ob \\(H_S\\) anh\u00e4lt oder weiterl\u00e4uft und daher kann es keine TM \\(H\\) geben. Alle Halteprobleme sind semi-entscheidbar und nicht-entscheidbar. Konsequenzen von Satz von Rice: Unm\u00f6glich im Allgemeinen zu \u00fcberpr\u00fcfen, ob ein Program eine bestimmte Spezifikation erf\u00fcllt frei von \u201cbugs\u201d ist bei jeder Eingabe terminiert und ein anderes Program dieselbe Funktionalit\u00e4t haben Colatz: \\(n \\text{ ist gerade} \\Rightarrow n=\\frac n 2 \\text{ sonst } n=3n + 1\\) Alle positiven Inputs enden in \\(4 \\to 2 \\to 1 \\to 4 \\to 2 \\to 1\\)","title":"Entscheidbarkeit"},{"location":"22FS/THIN/summary%20%28copy%29.html#komplexitatstheorie","text":"Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes Obereschranke: \\(f \\in \\mathcal O(g)\\Leftrightarrow f(n) \\le c \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(g\\) und \\(f\\) eine Funktion \\(\\N \\to \\N\\) ist und \\(c\\in \\N\\) eine Konstante) Untereschranke: \\(f \\in \\Omega(g)\\Leftrightarrow f(n) \\ge \\frac 1 d \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(d \\in \\N\\) eine Konstante ist) \\(f\\in \\Theta(g) \\Leftrightarrow f(n)\\in \\mathcal O(g(n))\\wedge f(n)\\in \\Omega(g(n))\\) Komplexit\u00e4t Beispiel \\(\\mathcal O(1)\\) Konstanter Aufwand unabh\u00e4ngig vom Input \\(\\mathcal O(n)\\) Linearer Aufwand: Ein For-Loop Abh\u00e4ngig von \\(n\\) \\(\\mathcal O(\\log n)\\) Logarithmischer Aufwand: Binary-Search/ Mit jeder Iteration wird der Aufwand halbiert \\(\\mathcal O(n^2)\\) Quadratischer Aufwand: Zwei verschachtelte For-Loops abh\u00e4ngig von \\(n\\) \\(\\mathcal O(2^n)\\) Exponentieller Aufwand: Mit jeder Iteration verdoppelt sich der Aufwand","title":"Komplexit\u00e4tstheorie"},{"location":"22FS/THIN/summary%20%28copy%29.html#np-vs-p","text":"Polynomzeit l\u00f6sbar (P) : Problem ist teil von \\(\\mathcal O(n^c)\\) , wobei \\(c \\ge 1\\) Nicht deterministische Polynomiell (NP) : Alle Probleme entscheidbar von einer Nicht-deterministische Maschine in polynomzeit Polynomzeit-Verifizierer : Eine TM, welche eine L\u00f6sung in polynomial zeit verifiziert \\(P\\neq NP\\) : Nicht alle Probleme, welche in polynomzeit verifizierbar sind, k\u00f6nnen in polynomzeit gel\u00f6st werden Clique : Eine Menge von Knoten, bei welchen alle Knoten mit allen anderen Knoten (ausser sich selbst) verbunden sind NP-Schwer : Ein Problem, welches sich auf alle NP-Probleme reduzieren l\u00e4sst. Ein NP-Schweres Problem ist gleich schwer oder schwerer also das schwerste NP-Problem NP-Vollst\u00e4dnig : Ein NP-Vollst\u00e4ndiges Problem ist NP-Schwer und ein NP-Problem polynomiell reduzierbar ( \\(\\preceq_p\\) ) : Eine Reduktion in polynomieller Zeit ( \\(L_1 \\preceq_p L_2\\) heisst, dass \\(L_2\\) mindestens so schwer wie \\(L_1\\) ist ) Wenn \\(P_1\\) NP-schwer, \\(P_2\\) in NP enthalten ist und \\(P_1 \\preceq_p P_2\\) gibt, dann ist \\(P_2\\) NP-vollst\u00e4ndig SAT : \"erstes\" NP-volst\u00e4ndige Problem Ob eine Formel in der KNF ( \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) )) erf\u00fcllbar ist TODO : L\u00f6sung von SAT Problem","title":"NP vs P"},{"location":"22FS/THIN/summary.html","tags":["summary","THIN"],"text":"Summary Begriff Beschreib Alphabet Endliche, nichtleere Menge von Symbolen ( \\(\\Sigma=\\{a, b, c\\}\\) ) Wort Endliche Folge von Symbolen \\(\\varepsilon\\) Das Leere Wort ( \\(\\vert \\varepsilon\\vert=0\\) ) Sprache Eine Menge von W\u00f6rtern ( \\(L=\\{10, 1100, ...\\}\\) , in Prosa oder \\(L=\\{1^n0^n\\mid n\\in \\N\\}\\) ) \\(\\emptyset\\) Leere Sprache ( \\(\\emptyset \\neq \\{\\varepsilon\\}\\) ) \\(\\vert abca\\vert_a=2\\) H\u00e4ufigkeit von a \\((abc)^R\\) Spiegelwort von \\(abc\\) \\(\\Sigma^2\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) mit der L\u00e4nge 2 Kleenesche H\u00fclle \\(\\Sigma^*\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) ( \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) ) Konkatination \\(x\\circ y=xy\\) Zwei W\u00f6rter werden zusammen verketet Wortpotenzen \\((ab)^3=ababab\\) Sprachen-Konkatenation \\(AB=\\{uv\\mid u \\in A \\text{ und } v \\in B\\}\\) Kleenesche H\u00fclle einer Sprache \\(A^*=\\varepsilon \\cup A \\cup AA \\cup AAA \\cup ...\\) Komplement einer Sprache \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\) Regex \\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts. Beschreibt \\(\\{\\varepsilon\\}\\) \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache * zuerst verarbeiten, danach Konkatenation, danach | verarbeiten (Stern vor Konkatenation vor Strich) Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r Endliche Automaten Deterministische Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein Die Startkonfiguration ist: \\(\\{q_0\\}\\times \\Sigma^*\\) , die Endkonfiguration: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) $(q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)=(q0, a_1a_2a_3)\\vdash_A^*(q4, \\epsilon) $ Was Beschreibung Der Startzustand Akzeptierter Endzustand Normaler Zustand \u00dcbergangsfunktionen Nicht Deterministische Automaten (NEA) \u00dcbergangsfunktion einer NEA: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) . \u00dcbergangsfunktion einer \\(\\varepsilon\\) -NEA (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) ) Teilmengenkonstruktion ( \\(NEA \\to DEA\\) ) Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) (Potenzmenge: \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) und \\(|\\mathcal P(A)|=2^{|A|}\\) ) Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. ( \\(q0\\) ist Startzustand) Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z) DEA \\(\\to\\) RegEX F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen \\[ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0 & L_{q_1}\\Rightarrow(0|1)^*0 & L_{q_1}\\Rightarrow(0|1)*01\\\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\\\ L_{q_2}&=\\varepsilon\\\\ \\end{align} \\] Arden'sches Lemma : \\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruck Zustandsklassen: \\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand) Untere Schranke f\u00fcr endliche Automaten Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort akzeptiert wird und mit dem anderen Wort nicht akzeptiert wird. Kontextfreie Gramatik Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale \\(P\\) eine endliche Menge von Produktionen \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) $$ G_1=({A}, {0, 1}, P, A) \\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei , wenn ein Kellerautomaten dazu gebaut werden kann. Mehrere Ableitungsschritte: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) oder \\(A\\overset * \\Rightarrow ()()\\) Ein Wort wird ableitbar gennant, wenn es eine Ableitung f\u00fcr dieses Wort gibt. Link- & rechtssseitig Ableiten : Die am meisten linke/rechte Variable wird immer zuerst abgeleitet eindeutige Gramatik : Eine Gramatik, welche nur auf eine Art abgeleitet werden kann DEA zu kontextfreien Sprache Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol Keller Automaten (KA) Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(\\Gamma\\) = Alphabet des Stacks; \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ; \\(\\$\\in \\Gamma\\) = Leere Symbol Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt. Nichtdeterministischen Kellerautomaten (NKA) \u00dcbergangsfuntkion Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) Nicht alle NKA und kontextfreie Sprachen k\u00f6nnen in eine KA umgewandlet werden. Berechnungen und Berechnungsschritte \\(\\delta(q, b, c)=(p, w)\\) Vom Zustand \\(q\\) zu \\(p\\) mit dem Input-Symbol \\(b\\) und dem Kellersymbol \\(c\\) . \\(w\\) wird geschrieben Beispiel Berechung: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)=(q_0, 0011, \\$)\\vdash^* (q_2, \\varepsilon, \\$)\\) Turing Machinen Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) ; \\(\\Gamma\\) = Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) ; \\(\\textvisiblespace\\) = Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n=K_1\\vdash^*K_n\\) Eine Sprache, welche von einer TM akzeptiert wird, nennt sich rekursiv aufz\u00e4hlbar \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\) Modifikationen Mit mehreren Spuren, welche auf einem Band sind (ein Lese/Schreibkopf) Mit mehreren B\u00e4ndern (mehrere Lese/Schreibk\u00f6pfe) (\u00dcbergangsfunktion: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) ) Nicht deterministische Turning Machine (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times \\{R, L\\})\\) Mit semi-beschr\u00e4nktem Band Das Band ist nur unendlich in eine Richtung. Eine Semi-beschr\u00e4nkte TM ist gleich m\u00e4chtig, wie eine TM. (Beweissidee: Eine semi-beschr\u00e4nkte TM mit zwei b\u00e4nder, eines f\u00fcr die positive und eines f\u00fcr die negative Seite) \\(k\\) -Stack Machine Eine Deterministischer Kellear Automat mit mehreren Stacks (\u00dcbergangsfunktion: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) ) Eine 2-Stack Machine kann ein Band simulieren und ist demnach gleich m\u00e4chtig, wie eine TM Z\u00e4hler-Machine (Hat Z\u00e4hler einer nat\u00fcrlichen Zahl ( \\(n \\ge 0\\) ) anstatt Stacks) Ein 2-Stack kann mit mit 3-Z\u00e4hler ersetzt werden und daher ist ein Z\u00e4hler-Machine gleich wertig, wie eine TM. Daf\u00fcr wird jedem Symbol des Stacks eine Zahl zugeordnet (1, 2, 3, 4, ...). Der aktuelle Wert wird mit der Anzahl Symbolen multipliziert und mit dem n\u00e4chsten Symbol addiert ( \\(c_{new}=c_{old}\\cdot length + s\\) ). Beim dekodieren wird der Wert durch die Anzahl Symbole geteilt und der Rest ist das aktuelle Symbol. Diese 3-Z\u00e4hler Machine kann mit einer 2-Z\u00e4hler Machine simuliert werden, in dem die 3-Z\u00e4hler mit der Encodierung \\(2^i\\cdot 3^j\\cdot 4^k\\) enkodiert werden und mit einer Primfaktorzerlegung dekodiert werden. Ein Z\u00e4hler wird noch zum Rechnen ben\u00f6tigt. Universelle Turning Maschine (UTM) Eine Turing Maschine, welche andere Turning Maschinen simulieren kann. Alle Zust\u00e4nde werden Un\u00e4r-Kodiert (0 = 1, 00 = 2, 000 = 3, ...) mit dem Trennzeichen 1 . Dabei wird folgendes gespeichert: Die \u00dcbergangsfunktion \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\to 0^i10^j10^l10^m\\) . Einzelne \u00dcbergangsfunktionen werden mit 11 getrennt. Die Maschine wird mit 111 vom Input getrennt. Berechnungsmodelle Intuitive berechenbare Funktion : eine algorithmisch (durch eine mechanisches Verfahren) berechenbare Funktion Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist von einer Turing-Maschine berechenbar Turing-Vollst\u00e4ndigkeit : F\u00fcr jede Zahl \\(k \\in \\N\\) und jede Funktion \\(f: \\N^k \\to \\N\\) gibt es eine Turing-Machine und While-Programm Zuweisungen: x = y + c oder x = y - c (wobei c eine Konstante ist!) x0 ist der Output; x1 , x2 , ... sind die Inputs/Variabeln Alle Variabeln k\u00f6nnen nat\u00fcrliche Zahlen ( \\(n \\ge 0\\) ) enthalten ( \\(2-5=0\\) ) Loop-Programme : LOOP x DO ... END Der Loop wird x -mall durchgef\u00fchrt. \u00c4ndern von x hat kein Einfluss While-Programme (auch LOOP ist erlaubt) While xi > 0 Do ... End Die einzige erlaubte Bedingung ist xi > 0 GOTO-Programme : Marker: ( M1: , M2: , ...), Goto Mk , If xi = c Then Goto Mr , Halt (Haltet das Programm an) Primitiv rekursive Funktion (nach dem Muster \\(f: \\N^2 \\to \\N\\) ) Konstante Funktion: \\(c^n_k: \\N^n \\to \\N \\mapsto c^n_k(x_1, ..., x_n)=k\\) Nachfolge Funktion: \\(\\eta: \\N \\to \\N \\mapsto \\eta(x)=x+1\\) Projektion ( \\(1 \\le k \\le n\\) ): \\(\\pi^n_k: \\N^n \\to \\N \\mapsto \\pi^n_k(x_1, ...,x_k,...,x_n)=x_k\\) Wenn \\(f\\) und \\(g_i\\) primitive rekursive Funktionen sind, dann ist \\(h(\\vec x)=f(g_1(\\vec x), ..., g_k(\\vec x))\\) auch eine primitive rekursive Funktion Primitive rekursive Funktionen = LOOP-Programme Ackermann (ist Turing-berechenbar, nicht Loop berechen, bzw. nicht primitive rekursive, ist total): $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$ Entscheidbarkeit Entscheidbar : Die TM haltet immer Semi-Entscheidbar : Die TM haltet nur bei akzeptierten Zust\u00e4nden Reduktion Es gibt eine Funktion \\(F: \\Sigma^* \\to \\Gamma^*\\) f\u00fcr die Sprache \\(A \\subset \\Sigma^*\\) und \\(B \\subset \\Gamma^*\\) . Dies wird als \\(A \\preceq B\\) geschrieben Jede entscheidbare Sprache ist auch semi-entscheidbar Wenn eine Sprache \\(A\\) und ihr Komplement \\(\\overline A\\) semi-entscheidbar ist, sind \\(A\\) , wie auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) entscheidbar ist, ist auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) und \\(B\\) (semi-)entscheidbar sind, ist auch \\(A \\cup B\\) und \\(A \\cap B\\) (semi-)entscheidbar \\(A\\) ist rekursive aufz\u00e4hlbar \\(\\Leftrightarrow\\) \\(A\\) ist semi-entscheidbar \\(\\Leftrightarrow\\) \\(A\\) ist der Werte und Definitionsbereich einer berechenbaren Funktion \\(A\\preceq B\\) und \\(B \\preceq C\\) , dann gilt auch \\(A \\preceq C\\) Ist \\(B\\) (semi-)entscheidbar und \\(A \\preceq B\\) , dann ist auch \\(A\\) (semi-)entscheidbar Wenn \\(A\\) unentscheidbar ist und \\(A \\preceq B\\) gilt, dann ist B unentscheidbar allgemeine Halteproblem : Gibt es eine TM \\(H\\) , welche entscheiden kann, ob ein Program mit einem Input anh\u00e4lt oder nicht immer weiter l\u00e4uft. leere Halteproblem : Ob es eine TM \\(H_0\\) gibt, welche entscheiden kann, ob ein Programm mit einem leeren Band anh\u00e4lt spezielle Halteproblem : Es wird eine TM \\(H_S\\) erstellt, welche \\(H\\) fragt, ob ein Program endet. Wenn ja, loopt \\(H_S\\) , wenn nein, beendet \\(H_S\\) . Wenn \\(H_S\\) das als Input \\((H_S, H_S)\\) bekommt, ist unklar, ob \\(H_S\\) anh\u00e4lt oder weiterl\u00e4uft und daher kann es keine TM \\(H\\) geben. Alle Halteprobleme sind semi-entscheidbar und nicht-entscheidbar. Konsequenzen von Satz von Rice: Unm\u00f6glich im Allgemeinen zu \u00fcberpr\u00fcfen, ob ein Program eine Spezifikation erf\u00fcllt, frei von bugs ist, bei jeder Eingabe terminiert, eine anderes Program dieselbe Funktionalit\u00e4t hat Colatz: \\(n \\text{ ist gerade} \\Rightarrow n=\\frac n 2 \\text{ sonst } n=3n + 1\\) Alle positiven Inputs enden in \\(4 \\to 2 \\to 1 \\to 4 \\to 2 \\to 1\\) Komplexit\u00e4tstheorie Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes Obereschranke: \\(f \\in \\mathcal O(g)\\Leftrightarrow f(n) \\le c \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(g\\) und \\(f\\) eine Funktion \\(\\N \\to \\N\\) ist und \\(c\\in \\N\\) eine Konstante) Untereschranke: \\(f \\in \\Omega(g)\\Leftrightarrow f(n) \\ge \\frac 1 d \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(d \\in \\N\\) eine Konstante ist) \\(f\\in \\Theta(g) \\Leftrightarrow f(n)\\in \\mathcal O(g(n))\\wedge f(n)\\in \\Omega(g(n))\\) NP vs P Polynomzeit l\u00f6sbar (P) : Problem ist teil von \\(\\mathcal O(n^c)\\) , wobei \\(c \\ge 1\\) mit einer DTM Nicht deterministische Polynomiell (NP) : Alle Probleme entscheidbar von einer Nicht-deterministische Maschine in polynomzeit Polynomzeit-Verifizierer : Eine TM, welche eine L\u00f6sung in polynomial zeit verifiziert \\(P\\neq NP\\) : Nicht alle Probleme, welche in polynomzeit verifizierbar sind, k\u00f6nnen in polynomzeit gel\u00f6st werden Clique : Eine Menge von Knoten, bei welchen alle Knoten mit allen anderen Knoten (ausser sich selbst) verbunden sind NP-Schwer : Ein Problem, welches sich auf alle NP-Probleme reduzieren l\u00e4sst. Ein NP-Schweres Problem ist gleich schwer oder schwerer also das schwerste NP-Problem NP-Vollst\u00e4dnig : Ein NP-Vollst\u00e4ndiges Problem ist NP-Schwer und ein NP-Problem polynomiell reduzierbar ( \\(\\preceq_p\\) ) : Eine Reduktion in polynomieller Zeit ( \\(L_1 \\preceq_p L_2\\) heisst, dass \\(L_2\\) mindestens so schwer wie \\(L_1\\) ist ) Wenn \\(P_1\\) NP-schwer, \\(P_2\\) in NP enthalten ist und \\(P_1 \\preceq_p P_2\\) gibt, dann ist \\(P_2\\) NP-vollst\u00e4ndig SAT : \"erstes\" NP-volst\u00e4ndige Problem Ob eine Formel in der KNF ( \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) )) erf\u00fcllbar ist TODO : L\u00f6sung von SAT Problem","title":"THIN Summary"},{"location":"22FS/THIN/summary.html#summary","text":"Begriff Beschreib Alphabet Endliche, nichtleere Menge von Symbolen ( \\(\\Sigma=\\{a, b, c\\}\\) ) Wort Endliche Folge von Symbolen \\(\\varepsilon\\) Das Leere Wort ( \\(\\vert \\varepsilon\\vert=0\\) ) Sprache Eine Menge von W\u00f6rtern ( \\(L=\\{10, 1100, ...\\}\\) , in Prosa oder \\(L=\\{1^n0^n\\mid n\\in \\N\\}\\) ) \\(\\emptyset\\) Leere Sprache ( \\(\\emptyset \\neq \\{\\varepsilon\\}\\) ) \\(\\vert abca\\vert_a=2\\) H\u00e4ufigkeit von a \\((abc)^R\\) Spiegelwort von \\(abc\\) \\(\\Sigma^2\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) mit der L\u00e4nge 2 Kleenesche H\u00fclle \\(\\Sigma^*\\) Alle W\u00f6rter des Alphabets \\(\\Sigma\\) ( \\(\\Sigma^+=\\Sigma^*\\setminus\\{\\varepsilon\\}\\) ) Konkatination \\(x\\circ y=xy\\) Zwei W\u00f6rter werden zusammen verketet Wortpotenzen \\((ab)^3=ababab\\) Sprachen-Konkatenation \\(AB=\\{uv\\mid u \\in A \\text{ und } v \\in B\\}\\) Kleenesche H\u00fclle einer Sprache \\(A^*=\\varepsilon \\cup A \\cup AA \\cup AAA \\cup ...\\) Komplement einer Sprache \\(\\overline L=\\Sigma^*-L=\\Sigma^*\\setminus L\\)","title":"Summary"},{"location":"22FS/THIN/summary.html#regex","text":"\\(\\epsilon\\) - eine leere Regular-Expression. Diese matcht nichts. Beschreibt \\(\\{\\varepsilon\\}\\) \\([x_1, x_2, ...,x_k]=x_1|x_2|...|x_k\\) \\(\\oslash\\) - eine leere Menge von Regular-Expressions \\(\\O\\) - eine leere Sprache * zuerst verarbeiten, danach Konkatenation, danach | verarbeiten (Stern vor Konkatenation vor Strich) Wenn zwei Sprachen regul\u00e4r sind, ist das Resultat von einem Operator mit diesen Sprachen regul\u00e4r","title":"Regex"},{"location":"22FS/THIN/summary.html#endliche-automaten","text":"Deterministische Endlichen Automat : \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) \\(Q\\) : Alle Zust\u00e4nde des Automaten \\(Q=\\{q_0, q_1, ...,q_n\\}\\) \\(\\Sigma\\) : Eingabealpabet \\(\\delta: Q\\times \\Sigma \\rightarrow Q\\) : \u00dcbergangsfunktionen, welche von einem Zustand und einem Eingabe Symbol zum n\u00e4chsten Zustand f\u00fchrt \\(q_0\\) : Startzustand \\(F\\subseteq Q\\) : Menge der akzeptierten Zust\u00e4nden. Mindestens ein Zustand muss akzeptiert sein Die Startkonfiguration ist: \\(\\{q_0\\}\\times \\Sigma^*\\) , die Endkonfiguration: \\((q, w)\\in Q\\times\\{\\epsilon\\}\\) $(q0, a_1a_2a_3)\\vdash_A(q_1, a_2a_3)\\vdash_A(q_2, a_3)\\vdash_A(q4, \\epsilon)=(q0, a_1a_2a_3)\\vdash_A^*(q4, \\epsilon) $ Was Beschreibung Der Startzustand Akzeptierter Endzustand Normaler Zustand \u00dcbergangsfunktionen","title":"Endliche Automaten"},{"location":"22FS/THIN/summary.html#nicht-deterministische-automaten-nea","text":"\u00dcbergangsfunktion einer NEA: \\(\\delta: Q\\times \\Sigma\\rightarrow \\mathcal P(Q)\\) . \u00dcbergangsfunktion einer \\(\\varepsilon\\) -NEA (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Sigma \\cup \\{\\epsilon\\}\\rightarrow \\mathcal P(Q)\\) )","title":"Nicht Deterministische Automaten (NEA)"},{"location":"22FS/THIN/summary.html#teilmengenkonstruktion-nea-to-dea","text":"Die Zust\u00e4nde sind die Potenzmenge von \\(Q_N\\) (Potenzmenge: \\(\\mathcal P(\\{0, 1\\})=\\{\\emptyset, \\{0\\}, \\{1\\}, \\{0, 1\\}\\}\\) und \\(|\\mathcal P(A)|=2^{|A|}\\) ) Akzeptierte Zust\u00e4nde sind alle Teilmengen, welche ein Element aus \\(F_N\\) besitzen Aus den Zust\u00e4nden und eingaben soll nun eine Tabelle gezeichnet werden. Bei dieser k\u00f6nnen alle Zust\u00e4nde gestrichen werden, welche nicht erreichbar sind. Dies muss solange wiederholt werden, bis nichts gestrichen werden kann. ( \\(q0\\) ist Startzustand) Die noch nicht gestrichenen Resultaten k\u00f6nnen nun Namen verteilt werden (z.B A-Z)","title":"Teilmengenkonstruktion (\\(NEA \\to DEA\\))"},{"location":"22FS/THIN/summary.html#dea-to-regex","text":"F\u00fcr jeden Zustand eine separate Sprache definieren. Diese darf sich selbst referenzieren oder auch andere Sprachen K\u00fcrzen und einsetzen. Meistens ist es am einfachsten von den Endzust\u00e4nden zu k\u00fcrzen zu beginnen \\[ \\begin{align} L_{q_0}&=(0|1)L_{q_0}|0 & L_{q_1}\\Rightarrow(0|1)^*0 & L_{q_1}\\Rightarrow(0|1)*01\\\\ L_{q_1}&=1L_{q_2} \\Rightarrow1\\varepsilon=1\\\\ L_{q_2}&=\\varepsilon\\\\ \\end{align} \\] Arden'sches Lemma : \\(L=UL|V\\Rightarrow L=U^*V\\) , dabei ist \\(L\\) eine Spraceh und \\(U\\) einen andren Ausdruck Zustandsklassen: \\([p]=\\{w \\in \\Sigma^*\\vert M \\text{ endet nach Lesen des Input-Worts } w \\text{ im Zustand } p\\}\\) , dabei ist \\(M\\) einen Automaten, \\(w\\) ein eingabe Wort und \\(p\\) ein Zustand (nicht unbedingt der Endzustand)","title":"DEA \\(\\to\\) RegEX"},{"location":"22FS/THIN/summary.html#untere-schranke-fur-endliche-automaten","text":"Es m\u00fcssen nun die folgende Schritte gefolgt werden: Es wird eine Annahme getroffen, wie viele Zust\u00e4nde eine Maschine ben\u00f6tigt Es m\u00fcssen f\u00fcr jeden Zustand ein Wort gefunden werden, welches in diesem Zustand endet Es wird nun f\u00fcr jede Kombination von W\u00f6rter von Schritt 2. ein Prefix oder Postfix \\(z\\) gefunden werden, welcher kombiniert mit dem einen Wort akzeptiert wird und mit dem anderen Wort nicht akzeptiert wird.","title":"Untere Schranke f\u00fcr endliche Automaten"},{"location":"22FS/THIN/summary.html#kontextfreie-gramatik","text":"Die Kontextfreie Grammatik \\(G\\) ist durch das Tupel \\((N, \\Sigma, P, A)\\) definiert, wobei \\(N\\) das Alphabet der Nichtterminale \\(P\\) eine endliche Menge von Produktionen \\(A\\) das Startsymbol ist und gilt \\(A\\in N\\) $$ G_1=({A}, {0, 1}, P, A) \\ P={A\\rightarrow0A1,A\\rightarrow\\varepsilon} $$ Eine Kontextfreie Grammatik wird mehrdeutig genannt, wenn es f\u00fcr ein Wort mehrere Ableitungsb\u00e4ume gibt. Eine Sprache ist kontextfrei , wenn ein Kellerautomaten dazu gebaut werden kann. Mehrere Ableitungsschritte: \\(A\\Rightarrow AA \\Rightarrow (A)A \\Rightarrow (A)(A)\\Rightarrow()()\\) oder \\(A\\overset * \\Rightarrow ()()\\) Ein Wort wird ableitbar gennant, wenn es eine Ableitung f\u00fcr dieses Wort gibt. Link- & rechtssseitig Ableiten : Die am meisten linke/rechte Variable wird immer zuerst abgeleitet eindeutige Gramatik : Eine Gramatik, welche nur auf eine Art abgeleitet werden kann","title":"Kontextfreie Gramatik"},{"location":"22FS/THIN/summary.html#dea-zu-kontextfreien-sprache","text":"Es gibt eine DEA \\(M=(Q, \\Sigma, \\delta, q_0, F)\\) . Aus dieser kann eine kontextfreie Sprache erstellt werden: F\u00fcr jeden Zustand \\(q_i\\) gibt es ein Nichtterminal \\(Q_i\\) F\u00fcr jede Transition \\(\\delta(q_i, a)=q_j\\) gibt es eine Produktion \\(Q_i\\rightarrow aQ_j\\) F\u00fcr jeden akzeptierten Zustand gibt es eine Produktion \\(Q_i\\rightarrow \\varepsilon\\) Das Nichtterminal \\(Q_0\\) wird das Startsymbol","title":"DEA zu kontextfreien Sprache"},{"location":"22FS/THIN/summary.html#keller-automaten-ka","text":"Ein deterministischer Keller Automaten (KA) wird als 7-Tupel dargestellt: \\((Q, \\Sigma, \\Gamma, \\delta, q_0, \\$, F)\\) ) \\(\\Gamma\\) = Alphabet des Stacks; \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow Q\\times\\Gamma^*\\) ; \\(\\$\\in \\Gamma\\) = Leere Symbol Zu dem gilt f\u00fcr die \u00dcbergangsfunktion \\(\\delta\\) , wenn \\(\\delta(q, b, x)\\) definiert ist, darf \\(\\delta(q, \\varepsilon, x)\\) nicht definiert sein. Zu begin der Ausf\u00fchrung ist im Strack \\(\\$\\) , was ein leerer Stack darstellt.","title":"Keller Automaten (KA)"},{"location":"22FS/THIN/summary.html#nichtdeterministischen-kellerautomaten-nka","text":"\u00dcbergangsfuntkion Typ \\(\\delta: Q\\times (\\Sigma \\cup \\varepsilon) \\times \\Gamma\\rightarrow \\mathcal P (Q\\times\\Gamma^*)\\) Nicht alle NKA und kontextfreie Sprachen k\u00f6nnen in eine KA umgewandlet werden.","title":"Nichtdeterministischen Kellerautomaten (NKA)"},{"location":"22FS/THIN/summary.html#berechnungen-und-berechnungsschritte","text":"\\(\\delta(q, b, c)=(p, w)\\) Vom Zustand \\(q\\) zu \\(p\\) mit dem Input-Symbol \\(b\\) und dem Kellersymbol \\(c\\) . \\(w\\) wird geschrieben Beispiel Berechung: \\((q_0, 0011, \\$) \\vdash (q_0, 011, 0\\$)\\vdash (q_0, 11, 00\\$)\\vdash(q_1, 1, 0\\$)\\vdash(q_1, \\varepsilon, \\$)\\vdash(q2, \\varepsilon, \\$)=(q_0, 0011, \\$)\\vdash^* (q_2, \\varepsilon, \\$)\\)","title":"Berechnungen und Berechnungsschritte"},{"location":"22FS/THIN/summary.html#turing-machinen","text":"Eine (determinischtische) Turing-Maschine (DTM) ist ein 7-Tupel: \\(M=(Q,\\Sigma, \\Gamma, \\delta, \\textvisiblespace, F)\\) \\(\\delta: Q\\times \\Gamma \\rightarrow Q\\times\\Gamma\\times D, D=\\{L, R\\}\\) ; \\(\\Gamma\\) = Das Bandalphabet, dabei muss \\(\\Sigma \\subset \\Gamma\\) ; \\(\\textvisiblespace\\) = Das Leerzeichen, dabei muss \\(\\textvisiblespace \\in \\Gamma\\) und \\(\\textvisiblespace \\not \\in \\Sigma\\) \\(X_1,...X_{i-1}qX_iX_{i+1},...,X_n\\vdash X_1,...X_{i-1}pX_iX_{i+1},...,X_n=K_1\\vdash^*K_n\\) Eine Sprache, welche von einer TM akzeptiert wird, nennt sich rekursiv aufz\u00e4hlbar \\(\\delta(q_1, X)=(q_2, Y, D)\\) , wobei \\(D\\in\\{L, R\\}\\)","title":"Turing Machinen"},{"location":"22FS/THIN/summary.html#modifikationen","text":"Mit mehreren Spuren, welche auf einem Band sind (ein Lese/Schreibkopf) Mit mehreren B\u00e4ndern (mehrere Lese/Schreibk\u00f6pfe) (\u00dcbergangsfunktion: \\(\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times \\Gamma^k \\times \\{R, S, L\\}^k\\) ) Nicht deterministische Turning Machine (\u00dcbergangsfunktion: \\(\\delta: Q\\times \\Gamma \\rightarrow \\mathcal P(Q \\times \\Gamma \\times \\{R, L\\})\\) Mit semi-beschr\u00e4nktem Band Das Band ist nur unendlich in eine Richtung. Eine Semi-beschr\u00e4nkte TM ist gleich m\u00e4chtig, wie eine TM. (Beweissidee: Eine semi-beschr\u00e4nkte TM mit zwei b\u00e4nder, eines f\u00fcr die positive und eines f\u00fcr die negative Seite) \\(k\\) -Stack Machine Eine Deterministischer Kellear Automat mit mehreren Stacks (\u00dcbergangsfunktion: \\(\\delta: Q \\times \\Gamma_1\\times...\\times\\Gamma_n\\rightarrow Q\\times\\Gamma_1^*\\times...\\times \\Gamma^*_k\\) ) Eine 2-Stack Machine kann ein Band simulieren und ist demnach gleich m\u00e4chtig, wie eine TM Z\u00e4hler-Machine (Hat Z\u00e4hler einer nat\u00fcrlichen Zahl ( \\(n \\ge 0\\) ) anstatt Stacks) Ein 2-Stack kann mit mit 3-Z\u00e4hler ersetzt werden und daher ist ein Z\u00e4hler-Machine gleich wertig, wie eine TM. Daf\u00fcr wird jedem Symbol des Stacks eine Zahl zugeordnet (1, 2, 3, 4, ...). Der aktuelle Wert wird mit der Anzahl Symbolen multipliziert und mit dem n\u00e4chsten Symbol addiert ( \\(c_{new}=c_{old}\\cdot length + s\\) ). Beim dekodieren wird der Wert durch die Anzahl Symbole geteilt und der Rest ist das aktuelle Symbol. Diese 3-Z\u00e4hler Machine kann mit einer 2-Z\u00e4hler Machine simuliert werden, in dem die 3-Z\u00e4hler mit der Encodierung \\(2^i\\cdot 3^j\\cdot 4^k\\) enkodiert werden und mit einer Primfaktorzerlegung dekodiert werden. Ein Z\u00e4hler wird noch zum Rechnen ben\u00f6tigt.","title":"Modifikationen"},{"location":"22FS/THIN/summary.html#universelle-turning-maschine-utm","text":"Eine Turing Maschine, welche andere Turning Maschinen simulieren kann. Alle Zust\u00e4nde werden Un\u00e4r-Kodiert (0 = 1, 00 = 2, 000 = 3, ...) mit dem Trennzeichen 1 . Dabei wird folgendes gespeichert: Die \u00dcbergangsfunktion \\(\\delta(q_i, X_j)=(q_k, X_l, D_m)\\to 0^i10^j10^l10^m\\) . Einzelne \u00dcbergangsfunktionen werden mit 11 getrennt. Die Maschine wird mit 111 vom Input getrennt.","title":"Universelle Turning Maschine (UTM)"},{"location":"22FS/THIN/summary.html#berechnungsmodelle","text":"Intuitive berechenbare Funktion : eine algorithmisch (durch eine mechanisches Verfahren) berechenbare Funktion Gandys These M : Alles, was jemals mit einer (endlichen) Maschine/physikalischen Apparatur berechnet werden kann, ist von einer Turing-Maschine berechenbar Turing-Vollst\u00e4ndigkeit : F\u00fcr jede Zahl \\(k \\in \\N\\) und jede Funktion \\(f: \\N^k \\to \\N\\) gibt es eine Turing-Machine und While-Programm Zuweisungen: x = y + c oder x = y - c (wobei c eine Konstante ist!) x0 ist der Output; x1 , x2 , ... sind die Inputs/Variabeln Alle Variabeln k\u00f6nnen nat\u00fcrliche Zahlen ( \\(n \\ge 0\\) ) enthalten ( \\(2-5=0\\) ) Loop-Programme : LOOP x DO ... END Der Loop wird x -mall durchgef\u00fchrt. \u00c4ndern von x hat kein Einfluss While-Programme (auch LOOP ist erlaubt) While xi > 0 Do ... End Die einzige erlaubte Bedingung ist xi > 0 GOTO-Programme : Marker: ( M1: , M2: , ...), Goto Mk , If xi = c Then Goto Mr , Halt (Haltet das Programm an) Primitiv rekursive Funktion (nach dem Muster \\(f: \\N^2 \\to \\N\\) ) Konstante Funktion: \\(c^n_k: \\N^n \\to \\N \\mapsto c^n_k(x_1, ..., x_n)=k\\) Nachfolge Funktion: \\(\\eta: \\N \\to \\N \\mapsto \\eta(x)=x+1\\) Projektion ( \\(1 \\le k \\le n\\) ): \\(\\pi^n_k: \\N^n \\to \\N \\mapsto \\pi^n_k(x_1, ...,x_k,...,x_n)=x_k\\) Wenn \\(f\\) und \\(g_i\\) primitive rekursive Funktionen sind, dann ist \\(h(\\vec x)=f(g_1(\\vec x), ..., g_k(\\vec x))\\) auch eine primitive rekursive Funktion Primitive rekursive Funktionen = LOOP-Programme Ackermann (ist Turing-berechenbar, nicht Loop berechen, bzw. nicht primitive rekursive, ist total): $$ \\begin{align} a(0, m)&= m + 1\\ a(n + 1, 0) &= a(n, 1)\\ a(n + 1, m + 1) &= a(n, a(n + 1, m)) \\end{align} $$","title":"Berechnungsmodelle"},{"location":"22FS/THIN/summary.html#entscheidbarkeit","text":"Entscheidbar : Die TM haltet immer Semi-Entscheidbar : Die TM haltet nur bei akzeptierten Zust\u00e4nden Reduktion Es gibt eine Funktion \\(F: \\Sigma^* \\to \\Gamma^*\\) f\u00fcr die Sprache \\(A \\subset \\Sigma^*\\) und \\(B \\subset \\Gamma^*\\) . Dies wird als \\(A \\preceq B\\) geschrieben Jede entscheidbare Sprache ist auch semi-entscheidbar Wenn eine Sprache \\(A\\) und ihr Komplement \\(\\overline A\\) semi-entscheidbar ist, sind \\(A\\) , wie auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) entscheidbar ist, ist auch \\(\\overline A\\) entscheidbar Wenn \\(A\\) und \\(B\\) (semi-)entscheidbar sind, ist auch \\(A \\cup B\\) und \\(A \\cap B\\) (semi-)entscheidbar \\(A\\) ist rekursive aufz\u00e4hlbar \\(\\Leftrightarrow\\) \\(A\\) ist semi-entscheidbar \\(\\Leftrightarrow\\) \\(A\\) ist der Werte und Definitionsbereich einer berechenbaren Funktion \\(A\\preceq B\\) und \\(B \\preceq C\\) , dann gilt auch \\(A \\preceq C\\) Ist \\(B\\) (semi-)entscheidbar und \\(A \\preceq B\\) , dann ist auch \\(A\\) (semi-)entscheidbar Wenn \\(A\\) unentscheidbar ist und \\(A \\preceq B\\) gilt, dann ist B unentscheidbar allgemeine Halteproblem : Gibt es eine TM \\(H\\) , welche entscheiden kann, ob ein Program mit einem Input anh\u00e4lt oder nicht immer weiter l\u00e4uft. leere Halteproblem : Ob es eine TM \\(H_0\\) gibt, welche entscheiden kann, ob ein Programm mit einem leeren Band anh\u00e4lt spezielle Halteproblem : Es wird eine TM \\(H_S\\) erstellt, welche \\(H\\) fragt, ob ein Program endet. Wenn ja, loopt \\(H_S\\) , wenn nein, beendet \\(H_S\\) . Wenn \\(H_S\\) das als Input \\((H_S, H_S)\\) bekommt, ist unklar, ob \\(H_S\\) anh\u00e4lt oder weiterl\u00e4uft und daher kann es keine TM \\(H\\) geben. Alle Halteprobleme sind semi-entscheidbar und nicht-entscheidbar. Konsequenzen von Satz von Rice: Unm\u00f6glich im Allgemeinen zu \u00fcberpr\u00fcfen, ob ein Program eine Spezifikation erf\u00fcllt, frei von bugs ist, bei jeder Eingabe terminiert, eine anderes Program dieselbe Funktionalit\u00e4t hat Colatz: \\(n \\text{ ist gerade} \\Rightarrow n=\\frac n 2 \\text{ sonst } n=3n + 1\\) Alle positiven Inputs enden in \\(4 \\to 2 \\to 1 \\to 4 \\to 2 \\to 1\\)","title":"Entscheidbarkeit"},{"location":"22FS/THIN/summary.html#komplexitatstheorie","text":"Zeitkomplexit\u00e4t : Laufzeit des besten Programms, welche ein Problem l\u00f6st Platzkomplexit\u00e4t : Speicherbedarf des bestens Programmes Beschreibungskomplexit\u00e4t : L\u00e4nge des k\u00fcrzesten Programmes Obereschranke: \\(f \\in \\mathcal O(g)\\Leftrightarrow f(n) \\le c \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(g\\) und \\(f\\) eine Funktion \\(\\N \\to \\N\\) ist und \\(c\\in \\N\\) eine Konstante) Untereschranke: \\(f \\in \\Omega(g)\\Leftrightarrow f(n) \\ge \\frac 1 d \\cdot g(n)\\) wenn \\(n\\) gr\u00f6sser als \\(n_0\\) ist (Wobei \\(d \\in \\N\\) eine Konstante ist) \\(f\\in \\Theta(g) \\Leftrightarrow f(n)\\in \\mathcal O(g(n))\\wedge f(n)\\in \\Omega(g(n))\\)","title":"Komplexit\u00e4tstheorie"},{"location":"22FS/THIN/summary.html#np-vs-p","text":"Polynomzeit l\u00f6sbar (P) : Problem ist teil von \\(\\mathcal O(n^c)\\) , wobei \\(c \\ge 1\\) mit einer DTM Nicht deterministische Polynomiell (NP) : Alle Probleme entscheidbar von einer Nicht-deterministische Maschine in polynomzeit Polynomzeit-Verifizierer : Eine TM, welche eine L\u00f6sung in polynomial zeit verifiziert \\(P\\neq NP\\) : Nicht alle Probleme, welche in polynomzeit verifizierbar sind, k\u00f6nnen in polynomzeit gel\u00f6st werden Clique : Eine Menge von Knoten, bei welchen alle Knoten mit allen anderen Knoten (ausser sich selbst) verbunden sind NP-Schwer : Ein Problem, welches sich auf alle NP-Probleme reduzieren l\u00e4sst. Ein NP-Schweres Problem ist gleich schwer oder schwerer also das schwerste NP-Problem NP-Vollst\u00e4dnig : Ein NP-Vollst\u00e4ndiges Problem ist NP-Schwer und ein NP-Problem polynomiell reduzierbar ( \\(\\preceq_p\\) ) : Eine Reduktion in polynomieller Zeit ( \\(L_1 \\preceq_p L_2\\) heisst, dass \\(L_2\\) mindestens so schwer wie \\(L_1\\) ist ) Wenn \\(P_1\\) NP-schwer, \\(P_2\\) in NP enthalten ist und \\(P_1 \\preceq_p P_2\\) gibt, dann ist \\(P_2\\) NP-vollst\u00e4ndig SAT : \"erstes\" NP-volst\u00e4ndige Problem Ob eine Formel in der KNF ( \\((x_1 \\vee x_2) \\wedge (x_3 \\vee x_4) \\wedge \\neg x_5\\) )) erf\u00fcllbar ist TODO : L\u00f6sung von SAT Problem","title":"NP vs P"},{"location":"Allgemein/AN/Itegrie-Ableiten-Tabelle.html","text":"","title":"Itegrie Ableiten Tabelle"},{"location":"Allgemein/Haskell/Data%20Classes.html","text":"Data Classes Semi-Group class Semigroup a where ( <> ) :: a -> a -> a A semigroup is a data type which has a associative binary operation (like + ). The operation of a semigroup should be associative ( (a <> b) <> c == a <> (b <> c) ). Every Monoid is a semigroup. Monoid Haskall defines a monoid in the following way: class Semigroup a => Monoid a where mempty :: a mappend :: a -> a -> a mconcat :: [ a ] -> a <> :: a -> a -> a is an alias for mappend A monoid is a thing which has two rules: It has an identity value In algebra for + the identity value is 0 , for multiplication it is 1 $$ 0 + a = a\\ 1 \\cdot a = a $$ It is associative $$ (a+b)+c=a+(b+c)\\ (a\\cdot b)\\cdot c=a\\cdot (b\\cdot c) $$ Here are some examples for monoids: List/String: [a] [] ++ [ 1 , 2 , 3 ] == [ 1 , 2 , 3 ] ([ 1 , 2 ] ++ [ 3 , 4 ]) ++ [ 5 , 6 ] = [ 1 , 2 ] ++ ([ 3 , 4 ] ++ [ 5 , 6 ]) Maybe: Semigroup a => Maybe a Just ( Sum 3 ) ` mappend ` Nothing == Just ( Sum 3 ) mempty :: Maybe ( Sum Int ) == Nothing Numbers: Num a => Sum a / Num a => Product a Sum 3 ` mappend ` Sum 4 == 7 mempty :: Sum Int = 0 Product 3 ` mappend ` Sum 2 == 6 mempty :: Product Int = 0 IO All/Any: -- implements && mempty :: All == Any True All True <> All False == All False All True <> All True == All True -- implement || mempty :: Any == Any False Any True <> Any False == Any True Any False <> Any False == Any False Dual Monoid The Dual a monoid will flip the order of the mappend (aka <> ) operator. For this to work, a has to be a Monoid as well. Dual \"hello\" <> Dual \" \" <> Dual \"world\" -- will return Dual \"world hello\" getDual ( Dual \"hello\" <> Dual \" \" <> Dual \"world\" ) -- will return \"world hello\" Dual [ 4 .. 6 ] <> Dual [ 1 .. 3 ] -- will return Dual [1, 2, 3, 4, 5, 6] Functor A Functor is a data type which can be mapped over. class Functor f where fmap :: ( a -> b ) -> f a -> f b ( <$ ) :: a -> f b -> f a fmap and (<$) are the same function but with diffrent argument ordering. They will map from f a to f b . <$> is a synonym of fmap but as a infix operator. Laws A Functor should follow the following laws: fmap id = id Using the id function with fmap should return the unmodifies object fmap (f . g) == fmap f . fmap g It shouldn't matter if the mapping functions are composed together first and then mapped or the fmap are composed Applicative class Applicative f where {-# MINIMAL pure, ((<*>) | lift2A) #-} pure :: a -> f a ( <*> ) :: f ( a -> b ) -> f a -> f b lift2A :: ( a -> b -> c ) -> f a -> f b -> f c Applicative s are like Functor in that they apply a mapping function to a box value. With a Applicative the function is also a boxed value. This is useful to map functions with more than one argument to a boxed value. If <$> (aka fmap ) is used to apply a value to a function with two parameters, you get the following: (+) <$> Just 5 == Just (+5) . This can be combined with <*> in the following way: ( + ) <$> Just 5 <*> Just 3 -- will return Just 8 lift2A ( + ) ( Just 5 ) ( Just 3 ) -- will return Just 8 An Applicative also defines the function pure which boxes a value. There are also some helper functions: (*>) :: f a -> f b -> f b Discard the first argument (but still \"runs\" it) and only return the value of the second applicative Just 3 *> Just 5 -- will return Just 5 Nothing *> Just 5 -- will return Nothing Just 3 *> Nothing -- will return Nothing <* :: fa -> fb -> fa Discards the second argument (but still \"runs\" it) and only return the value of the first applicative Just 3 <* Just 5 -- will return Just 3 Nothing <* Just 5 -- will return Nothing Just 3 <* Nothing -- will return Nothing liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d Works the same as liftA2 but accepts a function with three paramters. Monad class Applicative m => Monad m where ( >>= ) :: forall a b . m a -> ( a -> m b ) -> m b ( >> ) :: forall a b . m a -> m b -> m b return :: a -> m a A Monad is similar to an Applicative in that it also allows a boxed value to be mapped. The difference is, that the mapping function of a Monad returns a boxed value as a Monad itself. This can be used to return for example a Nothing instance, if the operation failed, leading to short-circuiting. The >>= operator gets used to chain Monads together. The mapping function gets the boxed value of the input Monad as a parameter. But this isn't always wanted (like with putStrLn which returns IO () ). In those cases >> can be used. return is often a synonym to pure of Applicative half :: Int -> Maybe Int half x = if even x then Just ( x ` div ` 2 ) else Nothing Just 3 >>= half -- will return Nothing Just 4 >>= half -- will return Just 2 Just 4 >>= half >>= half -- will return Just 1 Just 4 >>= half >>= half >>= half -- will return Nothing putStrLn \"hello\" >>= ( \\ _ -> putStrLn \"world\" ) putStrLn \"hello\" >> putStrLn \"world\" -- both print: -- hello -- world Monad Transformer class ( forall m . Monad m => Monad ( t m )) => MonadTrans t where lift :: Monad m => m a -> t m a A monad transformer enhances a \"base monad\" m with some functionality. For example the ExceptT type enhances a monad with the Either monad allowing it to short-circuit in case of an error. The lift method can be used to access the base monad. addIfPositive :: Int -> ExceptT String ( State Int ) Int addIfPositive i = do n <- lift get if n >= 0 then lift ( put $ n + 1 ) >> lift get else throwE $ ( show n ) ++ \" is negative\" In the example above addIfPositive will only add the given Int to the internal state if the internal state is positive else an error message is produced and the operation stops (aka. short-circuits). lift get is used to access the state in the do-Block. Monads are usually defined with their monad transformer. The Except monad for example is defined as type Except e a = ExceptT e (Identity a) Foldable class Foldable t where {-# MINIMAL foldMap | foldr #-} foldMap :: Monoid m => ( a -> m ) -> t a -> m foldMap f = foldr ( mappend . f ) mempty foldr :: ( a -> b -> b ) -> b -> t a -> b foldr f z t = appEndo ( foldMap ( Endo #. f ) t ) z -- and a number of optional methods A Foldable is a container type which allows to access its elements in a well-defined order. To instance a Foldable either foldMap or foldr has to be defined, but there are more optional methods. Here are some of the useful methods, which can be used with a Foldable structure: foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m With foldMap a Foldable structure can be folded. For this, the type contained in the Foldable needs to be an instance of Monoid foldMap Product [ 1 .. 4 ] -- will return 24 foldMap Sum [ 1 .. 4 ] -- will return 10 length :: Foldable t => t a -> Int Returns the length of a foldable structure toList :: Foldable t => t a -> [a] Will flatten the Foldable to a list traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f () / for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f () Allows to execute an Applicative for every element. This could be a side-effect. Both traverse_ and for_ do the same thing, but have their arguments flipped traverse_ ( putStrLn . show ) [ 1 .. 3 ] for_ [ 1 .. 3 ] ( putStrLn . show ) -- both will print: -- 1 -- 2 -- 3 sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f () sequenceA_ will execute each Applicative in the Foldable and throw the result away sequenceA_ [ putStrLn \"hello\" , putStrLn \"world\" ] -- will print: -- hello -- world null :: Foldable t => t a -> Bool null checks if the given Foldable is empty null [] -- will return True null [ 1 .. 4 ] -- will return False Traversable class ( Functor t , Foldable t ) => Traversable t where {-# MINIMAL traverse | sequenceA #-} traverse :: Applicative f => ( a -> f b ) -> t a -> f ( t b ) traverse f = sequenceA . fmap f sequenceA :: Applicative f => t ( f a ) -> f ( t a ) sequenceA = traverse id mapM :: Monad m => ( a -> m b ) -> t a -> m ( t b ) mapM = traverse sequence :: Monad m => t ( m a ) -> m ( t a ) sequence = sequenceA An instance of a Traversable alows a data structure to work easily with Applicative s and Monad s The sequenceA function takes a Foldable , which has Applicative s nested (like [Just 1, Just 2, Nothing] ). traverse on the other hand takes a Foldable of elements and a mapping function, which will map the elements to Applicative resulting in a Foldable which has Applicative nested. Example: [1, 2, 3] with the mapping function Just will result in [Just 1, Just 2, Just 3] which would be an valid input for sequenceA . Here are some useful methods, which can be used with a Traversable structure: traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) traverse will apply the given function to every element of the Traversale structure and execute the returned Applicative . The results are returned wrapped in the Applicative traverse print [ 1 , 2 ] -- has the type :: IO [()] -- will print: -- 1 -- 2 -- and will return IO [(), ()] traverse Sum [ 1 , 2 ] -- will return Sum [1, 2] sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) sequenceA executes all Applicative s in a Traversable structure and wraps them in the Applicative sequenceA [ print \"hello\" , print \"world\" ] -- has the type :: IO [()] -- will print: -- hello -- world -- and will return IO [(), ()] sequenceA [ Sum 1 , Sum 5 ] -- will return Sum [1, 5] sequenceA [( + 3 ),( * 2 ),( + 6 )] :: Num a => a -> [ a ] sequenceA [( + 3 ),( * 2 ),( + 6 )] 2 -- will return [5, 4, 8] mapM :: Monad m => (a -> m b) -> t a -> m (t b) An alias for traverse which exists because Applicative wasn't always a super class of Monad sequence :: Monad m => t (m a) -> m (t a) An alias for sequenceA which exists because Applicative wasn't always a super class of Monad","title":"Data Classes"},{"location":"Allgemein/Haskell/Data%20Classes.html#data-classes","text":"","title":"Data Classes"},{"location":"Allgemein/Haskell/Data%20Classes.html#semi-group","text":"class Semigroup a where ( <> ) :: a -> a -> a A semigroup is a data type which has a associative binary operation (like + ). The operation of a semigroup should be associative ( (a <> b) <> c == a <> (b <> c) ). Every Monoid is a semigroup.","title":"Semi-Group"},{"location":"Allgemein/Haskell/Data%20Classes.html#monoid","text":"Haskall defines a monoid in the following way: class Semigroup a => Monoid a where mempty :: a mappend :: a -> a -> a mconcat :: [ a ] -> a <> :: a -> a -> a is an alias for mappend A monoid is a thing which has two rules: It has an identity value In algebra for + the identity value is 0 , for multiplication it is 1 $$ 0 + a = a\\ 1 \\cdot a = a $$ It is associative $$ (a+b)+c=a+(b+c)\\ (a\\cdot b)\\cdot c=a\\cdot (b\\cdot c) $$ Here are some examples for monoids: List/String: [a] [] ++ [ 1 , 2 , 3 ] == [ 1 , 2 , 3 ] ([ 1 , 2 ] ++ [ 3 , 4 ]) ++ [ 5 , 6 ] = [ 1 , 2 ] ++ ([ 3 , 4 ] ++ [ 5 , 6 ]) Maybe: Semigroup a => Maybe a Just ( Sum 3 ) ` mappend ` Nothing == Just ( Sum 3 ) mempty :: Maybe ( Sum Int ) == Nothing Numbers: Num a => Sum a / Num a => Product a Sum 3 ` mappend ` Sum 4 == 7 mempty :: Sum Int = 0 Product 3 ` mappend ` Sum 2 == 6 mempty :: Product Int = 0 IO All/Any: -- implements && mempty :: All == Any True All True <> All False == All False All True <> All True == All True -- implement || mempty :: Any == Any False Any True <> Any False == Any True Any False <> Any False == Any False","title":"Monoid"},{"location":"Allgemein/Haskell/Data%20Classes.html#dual-monoid","text":"The Dual a monoid will flip the order of the mappend (aka <> ) operator. For this to work, a has to be a Monoid as well. Dual \"hello\" <> Dual \" \" <> Dual \"world\" -- will return Dual \"world hello\" getDual ( Dual \"hello\" <> Dual \" \" <> Dual \"world\" ) -- will return \"world hello\" Dual [ 4 .. 6 ] <> Dual [ 1 .. 3 ] -- will return Dual [1, 2, 3, 4, 5, 6]","title":"Dual Monoid"},{"location":"Allgemein/Haskell/Data%20Classes.html#functor","text":"A Functor is a data type which can be mapped over. class Functor f where fmap :: ( a -> b ) -> f a -> f b ( <$ ) :: a -> f b -> f a fmap and (<$) are the same function but with diffrent argument ordering. They will map from f a to f b . <$> is a synonym of fmap but as a infix operator.","title":"Functor"},{"location":"Allgemein/Haskell/Data%20Classes.html#laws","text":"A Functor should follow the following laws: fmap id = id Using the id function with fmap should return the unmodifies object fmap (f . g) == fmap f . fmap g It shouldn't matter if the mapping functions are composed together first and then mapped or the fmap are composed","title":"Laws"},{"location":"Allgemein/Haskell/Data%20Classes.html#applicative","text":"class Applicative f where {-# MINIMAL pure, ((<*>) | lift2A) #-} pure :: a -> f a ( <*> ) :: f ( a -> b ) -> f a -> f b lift2A :: ( a -> b -> c ) -> f a -> f b -> f c Applicative s are like Functor in that they apply a mapping function to a box value. With a Applicative the function is also a boxed value. This is useful to map functions with more than one argument to a boxed value. If <$> (aka fmap ) is used to apply a value to a function with two parameters, you get the following: (+) <$> Just 5 == Just (+5) . This can be combined with <*> in the following way: ( + ) <$> Just 5 <*> Just 3 -- will return Just 8 lift2A ( + ) ( Just 5 ) ( Just 3 ) -- will return Just 8 An Applicative also defines the function pure which boxes a value. There are also some helper functions: (*>) :: f a -> f b -> f b Discard the first argument (but still \"runs\" it) and only return the value of the second applicative Just 3 *> Just 5 -- will return Just 5 Nothing *> Just 5 -- will return Nothing Just 3 *> Nothing -- will return Nothing <* :: fa -> fb -> fa Discards the second argument (but still \"runs\" it) and only return the value of the first applicative Just 3 <* Just 5 -- will return Just 3 Nothing <* Just 5 -- will return Nothing Just 3 <* Nothing -- will return Nothing liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d Works the same as liftA2 but accepts a function with three paramters.","title":"Applicative"},{"location":"Allgemein/Haskell/Data%20Classes.html#monad","text":"class Applicative m => Monad m where ( >>= ) :: forall a b . m a -> ( a -> m b ) -> m b ( >> ) :: forall a b . m a -> m b -> m b return :: a -> m a A Monad is similar to an Applicative in that it also allows a boxed value to be mapped. The difference is, that the mapping function of a Monad returns a boxed value as a Monad itself. This can be used to return for example a Nothing instance, if the operation failed, leading to short-circuiting. The >>= operator gets used to chain Monads together. The mapping function gets the boxed value of the input Monad as a parameter. But this isn't always wanted (like with putStrLn which returns IO () ). In those cases >> can be used. return is often a synonym to pure of Applicative half :: Int -> Maybe Int half x = if even x then Just ( x ` div ` 2 ) else Nothing Just 3 >>= half -- will return Nothing Just 4 >>= half -- will return Just 2 Just 4 >>= half >>= half -- will return Just 1 Just 4 >>= half >>= half >>= half -- will return Nothing putStrLn \"hello\" >>= ( \\ _ -> putStrLn \"world\" ) putStrLn \"hello\" >> putStrLn \"world\" -- both print: -- hello -- world","title":"Monad"},{"location":"Allgemein/Haskell/Data%20Classes.html#monad-transformer","text":"class ( forall m . Monad m => Monad ( t m )) => MonadTrans t where lift :: Monad m => m a -> t m a A monad transformer enhances a \"base monad\" m with some functionality. For example the ExceptT type enhances a monad with the Either monad allowing it to short-circuit in case of an error. The lift method can be used to access the base monad. addIfPositive :: Int -> ExceptT String ( State Int ) Int addIfPositive i = do n <- lift get if n >= 0 then lift ( put $ n + 1 ) >> lift get else throwE $ ( show n ) ++ \" is negative\" In the example above addIfPositive will only add the given Int to the internal state if the internal state is positive else an error message is produced and the operation stops (aka. short-circuits). lift get is used to access the state in the do-Block. Monads are usually defined with their monad transformer. The Except monad for example is defined as type Except e a = ExceptT e (Identity a)","title":"Monad Transformer"},{"location":"Allgemein/Haskell/Data%20Classes.html#foldable","text":"class Foldable t where {-# MINIMAL foldMap | foldr #-} foldMap :: Monoid m => ( a -> m ) -> t a -> m foldMap f = foldr ( mappend . f ) mempty foldr :: ( a -> b -> b ) -> b -> t a -> b foldr f z t = appEndo ( foldMap ( Endo #. f ) t ) z -- and a number of optional methods A Foldable is a container type which allows to access its elements in a well-defined order. To instance a Foldable either foldMap or foldr has to be defined, but there are more optional methods. Here are some of the useful methods, which can be used with a Foldable structure: foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m With foldMap a Foldable structure can be folded. For this, the type contained in the Foldable needs to be an instance of Monoid foldMap Product [ 1 .. 4 ] -- will return 24 foldMap Sum [ 1 .. 4 ] -- will return 10 length :: Foldable t => t a -> Int Returns the length of a foldable structure toList :: Foldable t => t a -> [a] Will flatten the Foldable to a list traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f () / for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f () Allows to execute an Applicative for every element. This could be a side-effect. Both traverse_ and for_ do the same thing, but have their arguments flipped traverse_ ( putStrLn . show ) [ 1 .. 3 ] for_ [ 1 .. 3 ] ( putStrLn . show ) -- both will print: -- 1 -- 2 -- 3 sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f () sequenceA_ will execute each Applicative in the Foldable and throw the result away sequenceA_ [ putStrLn \"hello\" , putStrLn \"world\" ] -- will print: -- hello -- world null :: Foldable t => t a -> Bool null checks if the given Foldable is empty null [] -- will return True null [ 1 .. 4 ] -- will return False","title":"Foldable"},{"location":"Allgemein/Haskell/Data%20Classes.html#traversable","text":"class ( Functor t , Foldable t ) => Traversable t where {-# MINIMAL traverse | sequenceA #-} traverse :: Applicative f => ( a -> f b ) -> t a -> f ( t b ) traverse f = sequenceA . fmap f sequenceA :: Applicative f => t ( f a ) -> f ( t a ) sequenceA = traverse id mapM :: Monad m => ( a -> m b ) -> t a -> m ( t b ) mapM = traverse sequence :: Monad m => t ( m a ) -> m ( t a ) sequence = sequenceA An instance of a Traversable alows a data structure to work easily with Applicative s and Monad s The sequenceA function takes a Foldable , which has Applicative s nested (like [Just 1, Just 2, Nothing] ). traverse on the other hand takes a Foldable of elements and a mapping function, which will map the elements to Applicative resulting in a Foldable which has Applicative nested. Example: [1, 2, 3] with the mapping function Just will result in [Just 1, Just 2, Just 3] which would be an valid input for sequenceA . Here are some useful methods, which can be used with a Traversable structure: traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b) traverse will apply the given function to every element of the Traversale structure and execute the returned Applicative . The results are returned wrapped in the Applicative traverse print [ 1 , 2 ] -- has the type :: IO [()] -- will print: -- 1 -- 2 -- and will return IO [(), ()] traverse Sum [ 1 , 2 ] -- will return Sum [1, 2] sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) sequenceA executes all Applicative s in a Traversable structure and wraps them in the Applicative sequenceA [ print \"hello\" , print \"world\" ] -- has the type :: IO [()] -- will print: -- hello -- world -- and will return IO [(), ()] sequenceA [ Sum 1 , Sum 5 ] -- will return Sum [1, 5] sequenceA [( + 3 ),( * 2 ),( + 6 )] :: Num a => a -> [ a ] sequenceA [( + 3 ),( * 2 ),( + 6 )] 2 -- will return [5, 4, 8] mapM :: Monad m => (a -> m b) -> t a -> m (t b) An alias for traverse which exists because Applicative wasn't always a super class of Monad sequence :: Monad m => t (m a) -> m (t a) An alias for sequenceA which exists because Applicative wasn't always a super class of Monad","title":"Traversable"},{"location":"Allgemein/Haskell/Optics.html","text":"Optics Capabilities In the following table the capabilities of each optics is shown. Lens Traversal Fold Get Single Many Many Set/Modify Single Many Nope Traverse Single Many Nope Operators There is a general patterns applied to most operators in the Optics library. This means that the name of an operator can usually be guessed. Symbol Explenation Example ^ Denotes that the action views/gets something ^. . Denotes the absence of any other modifiers ^. % Denotes an actinon which modifies using a function %~ ~ Denotes that this action updates/sets something %~ , .~ < A prefix for update/set actions, which will return the altered value as well as the whole structure <+~ << A prefix for update/set action, which will return the old value <<+~ Lenses A lens abstracts the getter and setter into one value. A lens can focus a single type and always returns a type (so a lens can't return a from Either a b , because the type could also be b ). Their are two types of lenses: Simple lens: Lens' s a , where s is the structure and a is the focus type. This lens always returns the same type as it gets and it can be created with makeLenses Polymorphic Lens: Lens s t a b , where s is the input structure, t the output structure, a the input focus and b the output focus. This type of lenses can change the types of the structure and focus. data Settings a = Settings { _path :: String , _object :: a } derving ( Show ) path :: Lens' Settings a path = lens getter setter where getter :: Settings a -> String getter = _path setter :: Settings a -> String -> Settings a setter oldSettings newPath = oldSettings { _path = newPath } object :: Lens ( Settings a ) -> ( Settings b ) -> a -> b object = lens getter setter where getter :: Settings a -> a getter = _object setter :: Settings a -> b -> Settings b setter oldSettings newObj = oldSettings { _object = newObj } Lens Laws You get back what you set (set-get) When you set something, you always get the same thing back view myLens ( set myLens newValue structure ) == newValue Setting back what you got doesn't do anything (get-set) When you set what view returned to you, than nothing changes set myLens ( view myLens structure ) structure == structure Setting twice is the same as setting once (set-set) Setting multiple times the same value does always do the same thing set myLens diffrentValue ( set myLens diffrentValue structure ) == set myLens diffrentValue structure Virtual Fields Lenses can be used to provide an abstraction layer above the actual data structure. Virtual Fields can be created by writing custom lens getters and setter. The getter and setter can apply a function to convert the field. This can also be done later, when the underlying data structure changes but the public API shouldn't change. Lenses & Operators The following operators can be used with lenses: view :: Lens' s a -> s -> a Returns the value which the given lens focuses on set :: Lens s t a b -> b -> s -> t or set :: Lens' s a -> a -> s -> s Sets the value of the focus of a lens over :: Lens s t a b -> (a -> b) -> s -> t or over :: Lens' s a -> (a -> a) -> s -> s Fetches the focused value, applies the given function and then uses set t set the focused value There are infix operator which are synonyms to the operators above: Operator Action Type ^. flipped view s -> Lens' s a -> a .~ set Lens s t a b -> b -> s -> t %~ over Lens s t a b -> (a -> b) -> s -> t Some common lenses are : _1 :: Lens (a, other) (b, other) a b Sets the focus on the first element of a tuple _2 :: Lens (other, a) (other, b) a b Sets the focus on the second element of a tuple data Payload = Payload { _weightKilos :: Int , _cargo :: String } deriving ( Show ) makeLenses ''Payload data Ship = Ship { _payload :: Payload } deriving ( Show ) makeLenses ''Ship serenity :: Ship serenity = Ship ( Payload 5000 \"Livestock\" ) -- get >>> view payload . cargo serenity -- > \"Livestock\" >>> serenity ^. payload . cargo -- > \"Livestock\" -- set >>> set ( payload . cargo ) \"Medicine\" serenity >>> serenity & payload . cargo .~ \"Medicine\" >>> serenity & payload . cargo .~ \"Chocolate\" & payload . weightKilos .~ 2310 -- over >>> serenity & payload . weightKilos .% subtract 1000 & payload . cargo .~ \"Chocolate\" Composing Lenses Lenses compose very easily. Imagin each lens being a domino which can be fitted together if the types match. From the expression below, we'll get address :: Lens' Person StreetAddress . The Address type is \"hidden\" in the composition. At the the right end of a domino line, we can use an action to do something, like modifying the focused value. Here an actual Example: wave :: Wool -> Sweater weave Wool = Sweater gameState :: ( Player , Item Wool ) gameState = ( Player Item Wool 5 ) -- crafts a sweater gameState' :: ( Player , Item Sweater ) gameState' = over ( _2 . material ) weave gameState Folds A fold is like a query and can: focus on multiple things can only get, not set data A fold has the data type Fold s a , where the s is the structure on which the query runs and a is the return value. A fold returns zero or more from a A fold, like a lens, doesn't contain data. It is an \"operation\" which knows how to extract zero or more elements from an type. We can create a custom Fold with the function folding :: Foldable f => (s -> f a) -> Fold s a , which takes as an argument a function which transforms the type s into a folding type a . data ShipCrew = ShipCrew { _captain :: String , , _conscripts :: [ String ] } deriving ( Show ) makeLenses ''ShipCrew collectCrewMembers :: ShipCrew -> [ String ] collectCrewMembers crew = ( _captain crew ) : _conscripts crew crewMembers :: Fold ShipCrew String crewMembers = folding collectCrewMembers Operators folded : Foldable f => Fold (f a) With folded an instance of Foldable like a list can be converted into a Fold . A lens can be used to focus in on an element of a fold. This works because every lens has a getter to focus on one element exactly. This fits into the definition of a fold which needs to focus on zero or more elements. data CartItem = CartItem { _name :: String , _count :: Int } makeLenses ''CarItem cart :: [ CartItem ] cart = [ CartItem \"Black Shirt\" 3 , CarItem \"Water Bottle\" 2 ] -- get a list of all items cart ^.. folded -- will return [CartItem \"Black Shirt\" 3, CarItem \"Water Bottle\" 2] toListOf folded cart -- the same as above cart ^.. folded . name -- [\"Black Shirt\", \"Water Bottle\"] toListOf ( folded . name ) cart -- the same as above to :: (s -> a) -> Fold s a Creates a fold which maps from the type s to the folded type a . This function maps 1-to-1. Because of this, it couldn't be used to extract values from Maybe . If a 1-to-many relationship is needed, folding can be used newtype Name = Name { getName :: String } deriving ( Show ) Name \"Hi\" ^. to getName -- will return \"Hi\" Name \"hello world\" ^. to getName . to ( fmap toUpper ) -- will return \"HELLO WORLD\" ( ShipCrew \"Captain Tom\" [ \"Franz\" , \"Max\" ]) ^.. crewMembers . to ( fmap toUpper ) -- will return [\"CAPTAIN TOM\", \"FRANZ\", \"MAX\"] backwards :: Fold s a -> Fold s a Reverses the elements of a fold [ 1 , 2 , 3 ] ^.. backwards folded -- will return [3, 2, 1] [( 1 , 2 ), ( 3 , 4 )] ^.. backwards ( folded . both ) -- will return [4, 3, 2, 1] [( 1 , 2 ), ( 3 , 4 )] ^.. backwards folded . both -- will return [3, 4, 1, 2] only :: Eq a => a -> Prism' a () A helper fold operator which can simplify to only :: Eq a => a -> Fold a () . It return () only if the input is equal to the given a 1 ^? only 1 -- will return Just () 2 ^? only 1 - Actions toListOf :: Fold s a -> s -> [a] / (^..) :: s -> Fold s a -> [a] To use a fold on data the function toListOf can be used. This will take a Fold and a Foldable structure and extracts [a] out of it. A synonym is (^..) :: s -> Fold s a -> [a] elemOf :: Eq a => Fold s a -> a -> s -> Bool Checks if the given a is in the Fold elemOf folded 3 [ 1 .. 4 ] -- will return True elemOf folded 99 [ 1 .. 4 ] -- will return False anyOf :: Fold s a -> (a -> Bool) -> s -> Bool Checks if the predicates returns true for at least one element anyOf folded even [ 1 .. 4 ] -- will return True anyOf folded ( > 100 ) [ 1 .. 4 ] -- will return False allOf :: Fold s a -> (a -> Bool) -> s -> Bool Check if the predicates returns true for all elements allOf folded even [ 1 .. 4 ] -- will return False allOf folded ( < 10 ) [ 1 .. 4 ] -- will return True findOf :: Fold s a -> (a -> Bool) -> s -> Maybe a Tries to find an element for which the predicate returns true findOf folded even [ 1 .. 4 ] -- will return Just 2 findOf folded ( > 10 ) [ 1 .. 4 ] -- will return Nothing has :: Fold s a -> s -> Bool Checks if there is at least one element has folded [] -- will return False has folded [ 1 .. 4 ] -- will return True hasn't :: Fold s a -> s -> Bool Checks if there are no elements hasn't folded [] -- will return True hasn't folded [ 1 .. 4 ] -- will return False lengthOf :: Fold s a -> s -> Int Returns how many elements there are lengthOf folded [ 1 , 2 , 3 , 4 ] -- will return 4 sumOf :: Num n => Fold s n -> s -> n / productOf :: Num n => Fold s n -> s -> n Calculates the sum/product of all elements sumfOf folded [ 1 .. 4 ] -- will return 10 productOf folded [ 1 .. 4 ] -- will return 24 firstOf :: Fold s a -> s -> Maybe a / preview :: Fold s a -> s -> Maybe a / ( ^?) :: s -> Fold s a -> Maybe a / lastOf :: Fold s a -> s -> Maybe a firstOf , preview and (^?) return the first element; lastOf returns the last element firstOf folded [] -- will return Nothing firstOf folded [ 1 .. 4 ] -- will return Just 1 preview folded [ 1 .. 4 ] -- will return Just 1 [ 1 .. 4 ] ^? folded -- will return Just 1 lastOf folded [ 1 .. 4 ] -- will return Just 4 minimumOf :: Ord a => Fold s a -> s -> Maybe a / maximumOf :: Ord a => Fold s a -> s -> Maybe a Returns the minimum or maximum of the elements minimumOf folded [ 1 .. 4 ] -- will return Just 1 maximumOf folded [ 1 .. 4 ] -- will return Just 4 minimumOf folded [] -- will return Nothing maximumOf folded [] -- will return Nothing maximumByOf :: Fold s a -> (a -> a -> Ordering) -> s -> Maybe a / minimumOf :: Fold s a -> (a -> a -> Ordering) -> s -> Maybe a These function return the \"largest\" or \"smallest\" element determinted by the function (a -> a -> Ordering) data Person = Person { _name :: String , _age :: Int } deriving ( Show ) maximumByOf ( folded ) ( comparing _age ) [ Person \"Seb\" 22 , Person \"Marie\" 33 ] -- will return Person \"Marie\" 33 minimumByOf ( folded ) ( comparing _age ) [ Person \"Seb\" 22 , Person \"Marie\" 33 ] -- will return Person \"Seb\" 22 traverseOf_ :: Functor f => Fold s a -> (a -> f r) -> s -> f () / forOf_ :: Functor f => Fold s a -> s -> (a -> f r) -> f () traverseOf_ and forOf_ are used to execute side effects with elements and are the optic equivalents of traverse_ and for_ data Person = Person { _name :: String , _age :: Int } deriving ( Show ) persons = [ Person \"Seb\" 22 , Person \"Ann\" , 34 ] showPerson :: Person -> String showPerson p = _name p <> \": \" <> show ( age p ) traverseOf_ ( folded . to showPerson ) putStrLn persons -- will return: -- Seb: 22 -- Ann: 34 -- example from Optics By Example / page >>> import Control.Monad.State >>> execState ( traverseOf_ folded ( modify . const ( + 1 )) tvShows ) 0 2 foldOf :: Monoid a => Fold s a -> s -> a / foldMapOf :: Monoid r => Fold s a -> (a -> r) -> s -> r foldOf and foldMapOf are function which allows the use of Monoids with folds. foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a / foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r foldByOf and foldMapByOf are similar to foldOf and foldMapOf , but allow the callee to specifiy the append function and identity value. tvShows = [( \"How I Met Your Mother\" , \"Josh Radnor\" ), ( \"How I Met Your Mother\" , \"Alyson Hannigan\" ), ( \"Buffy the Vampire Slayer\" , \"Alyson Hannigan\" )] foldMapByOf ( folded . _2 ) ( M . unionWith ( + )) mempty ( \\ n -> M . singleton n 1 ) tvShows -- will return [(\"Alyson Hannigan\",2),(\"Josh Radnor\",1)] foldrOf :: Fold s a -> (a -> r -> r) -> r -> s -> r / foldlOf :: Fold s a -> (r -> a -> r) -> r -> s -> r foldrOf and foldlOf are functions which are like foldOf and foldMapOf , but the identity value and append function can be set by parameters. They are the equivalence of foldr and foldl . Concat existing Fold s Already existing folds (and lenses) can be combined to one big Fold if the types match. Here's an alternative implementation of crewMembers crewMembers :: Fold ShipCrew String crewMembers = folding ( \\ s -> s ^.. captain <> s ^.. conscripts . folded ) Traversal A traversal can, like a fold, get zero or more elements but also set zero or more elements. Because of this, lenses and folds are valid traversal but not all traversals are lenses and folds. The type Traversal s t a b has the following generics: s - the structure before the action t - the structure after the action a - the focus before the action b - the focus after the action Wenn the type of the focus is changed by a setting operation the operation has to convert all elements. An operation which only focuses on part of the traversal can't change the type of the focus. Like with lenses, there is also a simple traversal: Traversal' s a , where the generic mean: s - the structure before and after the action a - the focus before and after the action Actions When actions are used as a setter, then all values are changed, which would be returned with a getter. With these kind of action only part of the traversal can be updated. This also means that the focused type can't c [ 1 , 2 , 3 , 4 , 5 ] & taking 3 traversed *~ 10 -- will return [10, 20, 30, 4, 5] [ 1 , 2 , 3 , 4 , 5 ] & dropping 3 traversed *~ 10 -- will return [1, 2, 3, 40, 50] [ 1 .. 5 ] & traversed . filtered even *~ 10 -- will return [1, 20, 3, 40, 5] traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b Creates a Traversal which will focus on every element in the data structure. It is more powerfull than folded , but can be used with less types. both: Bitraversable r => Traversal (r a a) (r b b) a b both can be simplified to both: Bitraversable r => Fold (r a a) a and creates a Fold for a tuple with the same types ( (String, Int) wouldn't be valid). But only the last two item of a tuple are actually traversed. ( \"hello\" , \"wolrd\" ) ^.. both -- will return [\"hello\", \"world\"] ( \"hi\" ) ^.. both -- will return [\"hi\"] ( \"hi\" , \"hello\" , \"world\" ) ^.. both -- will return [\"hello\", \"world\"] each :: Each s t a b => Traversal s t a b each can be simplified to each :: Each s s a a => Fold s a . It does almost the same thing as both , but over an arbitrary sized tuple. ( \"hi\" , \"hello\" , \"world\" ) ^.. each -- will return [\"hi\", \"hello\", \"world\"] filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a Filters a fold (or other optics) and can simplify to filtered :: (s -> Bool) -> Fold s s [ 1 .. 10 ] ^.. folded . filtered even -- will return [2,4,6,8,10] filteredBy :: Fold s a -> IndexedTraversal' a s s An alternative to filtered which uses a fold as the predicate. The type signature above is simplified.on taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a This method is the equivalent to take with traversals and folds. dropping :: (Conjoined p, Applicative f) => Int -> Over p (Control.Lens.Internal.Indexed.Indexing f) s t a a -> ver p f s t a a This method is the fold / traversal equivalent to drop [ 1 .. ] ^.. taking 5 folded -- will return [1, 2, 3, 4, 5] [[ 1 , 2 , 3 ], [ 10 , 20 , 30 ], [ 100 , 200 , 300 ]] ^.. folded . taking 2 folded -- will return [1, 2, 10, 20, 100, 200] High-Order actions apply, like other actions, two an element of a fold, not to the fold itself. The following graphic shows the code (\"Albus\", \"Dumbledore\") ^.. both . taking 3 folded takingWhile :: (a -> Bool) -> Fold s a -> Fold s a The traversal/folding equivalent to takeWhile . It accepts a predicate and will return element as long as the predicate returns true droppingWhile :: (a -> Bool) -> Fold s a -> Fold s a The traversal/folding equivalent to dropWhile . It will \"drop\" elements from fold elements until predicate returns false [ 1 .. ] ^.. takingWhile ( < 5 ) folded -- will return [1, 2, 3, 4] [ 1 .. 10 ] ^.. droppingWhile ( < 5 ) folded -- will return [5, 6, 7, 8, 9, 10] worded :: Applicative f => IndexedLensLike' Int f String String Simplifies to worded :: Traversal' String String and will focus on each word in the string lined :: Applicative f => IndexedLensLike' Int f String String Simplifies to lined :: Traversal' String String and will focus on each line in the string \"Hello world\" ^.. worded -- will return [\"Hello\", \"world\"] \"Hello \\n How are you?\" ^.. lined -- will return [\"Hello\",\" How are you?\"] \"Hello world\" & worded %~ \\ s -> \"*\" ++ s ++ \"*\" -- will return \"*Hello* *world*\" beside :: Traversal s t a b -> Traversal s' t' a b -> Traversal (s,s') (t,t') a b beside applies a the first traversal to the first element of the tuple and the second traversal to the second tuple element. ( \"hi\" , \"moin\" ) ^.. beside ( to length ) ( to $ const 200 ) -- will return (2, 200) ( \"hello\" , ( 2 , \"moin\" )) ^.. beside id _2 -- will return (\"hello\", \"moin\") ( \"hello\" , ( 2 , \"moin\" )) & beside id _2 %~ ( ++ \"!\" ) -- will return (\"hello!\", (2, \"moin!\")) element :: Traversable f => Int -> Traversal' (f a) a Focuses on the element with the given index [ 0 .. 4 ] ^? element 2 -- will return Just 2 [ 0 .. 4 ] ^? element 20 -- will return Nothing [ 0 .. 4 ] & element 2 *~ 10 -- will return [0, 1, 20, 3, 4] Operators The operator over (aka. %~ ) and set (aka. .~ ), which are known from lenses, can also be used with traversals. ( \"hello\" , \"moin\" ) & both %~ ( ++ \"!\" ) -- will return (\"hello!\", \"moin!\") over both ( ++ \"!\" ) ( \"hello\" , \"moin\" ) -- will return (\"hello!\", \"moin!\") ( \"hello\" , \"moin\" ) & both %~ length -- will return (5, 4) ( \"hello\" , \"moin\" ) & both .~ \"good morning\" -- will return (\"good morning\", \"good morning\") set both \"good morning\" ( \"hello\" , \"moin\" ) -- will return (\"good morning\", \"good morning\") Effects can be run on Traversals with the method traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t which can be spezialized to traverseOf :: Traversal s t a b -> (a -> f b) -> s -> f . traverseOf works like traverse but with Traversable s traverseOf both readMaybe ( \"1\" , \"2\" ) :: Maybe ( Int , Int ) -- will return (1, 2) traverseOf both readMaybe ( \"hello\" , \"2\" ) :: Maybe ( Int , Int ) -- will return Nothing traverseOf each readMaybe [ \"1\" , \"2\" ] :: Maybe [ Int ] -- will return Just [1, 2] traverse readMaybe [ \"1\" , \"2\" ] :: Maybe [ Int ] -- will return Just [] Each","title":"Optics"},{"location":"Allgemein/Haskell/Optics.html#optics","text":"","title":"Optics"},{"location":"Allgemein/Haskell/Optics.html#capabilities","text":"In the following table the capabilities of each optics is shown. Lens Traversal Fold Get Single Many Many Set/Modify Single Many Nope Traverse Single Many Nope","title":"Capabilities"},{"location":"Allgemein/Haskell/Optics.html#operators","text":"There is a general patterns applied to most operators in the Optics library. This means that the name of an operator can usually be guessed. Symbol Explenation Example ^ Denotes that the action views/gets something ^. . Denotes the absence of any other modifiers ^. % Denotes an actinon which modifies using a function %~ ~ Denotes that this action updates/sets something %~ , .~ < A prefix for update/set actions, which will return the altered value as well as the whole structure <+~ << A prefix for update/set action, which will return the old value <<+~","title":"Operators"},{"location":"Allgemein/Haskell/Optics.html#lenses","text":"A lens abstracts the getter and setter into one value. A lens can focus a single type and always returns a type (so a lens can't return a from Either a b , because the type could also be b ). Their are two types of lenses: Simple lens: Lens' s a , where s is the structure and a is the focus type. This lens always returns the same type as it gets and it can be created with makeLenses Polymorphic Lens: Lens s t a b , where s is the input structure, t the output structure, a the input focus and b the output focus. This type of lenses can change the types of the structure and focus. data Settings a = Settings { _path :: String , _object :: a } derving ( Show ) path :: Lens' Settings a path = lens getter setter where getter :: Settings a -> String getter = _path setter :: Settings a -> String -> Settings a setter oldSettings newPath = oldSettings { _path = newPath } object :: Lens ( Settings a ) -> ( Settings b ) -> a -> b object = lens getter setter where getter :: Settings a -> a getter = _object setter :: Settings a -> b -> Settings b setter oldSettings newObj = oldSettings { _object = newObj }","title":"Lenses"},{"location":"Allgemein/Haskell/Optics.html#lens-laws","text":"You get back what you set (set-get) When you set something, you always get the same thing back view myLens ( set myLens newValue structure ) == newValue Setting back what you got doesn't do anything (get-set) When you set what view returned to you, than nothing changes set myLens ( view myLens structure ) structure == structure Setting twice is the same as setting once (set-set) Setting multiple times the same value does always do the same thing set myLens diffrentValue ( set myLens diffrentValue structure ) == set myLens diffrentValue structure","title":"Lens Laws"},{"location":"Allgemein/Haskell/Optics.html#virtual-fields","text":"Lenses can be used to provide an abstraction layer above the actual data structure. Virtual Fields can be created by writing custom lens getters and setter. The getter and setter can apply a function to convert the field. This can also be done later, when the underlying data structure changes but the public API shouldn't change.","title":"Virtual Fields"},{"location":"Allgemein/Haskell/Optics.html#lenses-operators","text":"The following operators can be used with lenses: view :: Lens' s a -> s -> a Returns the value which the given lens focuses on set :: Lens s t a b -> b -> s -> t or set :: Lens' s a -> a -> s -> s Sets the value of the focus of a lens over :: Lens s t a b -> (a -> b) -> s -> t or over :: Lens' s a -> (a -> a) -> s -> s Fetches the focused value, applies the given function and then uses set t set the focused value There are infix operator which are synonyms to the operators above: Operator Action Type ^. flipped view s -> Lens' s a -> a .~ set Lens s t a b -> b -> s -> t %~ over Lens s t a b -> (a -> b) -> s -> t Some common lenses are : _1 :: Lens (a, other) (b, other) a b Sets the focus on the first element of a tuple _2 :: Lens (other, a) (other, b) a b Sets the focus on the second element of a tuple data Payload = Payload { _weightKilos :: Int , _cargo :: String } deriving ( Show ) makeLenses ''Payload data Ship = Ship { _payload :: Payload } deriving ( Show ) makeLenses ''Ship serenity :: Ship serenity = Ship ( Payload 5000 \"Livestock\" ) -- get >>> view payload . cargo serenity -- > \"Livestock\" >>> serenity ^. payload . cargo -- > \"Livestock\" -- set >>> set ( payload . cargo ) \"Medicine\" serenity >>> serenity & payload . cargo .~ \"Medicine\" >>> serenity & payload . cargo .~ \"Chocolate\" & payload . weightKilos .~ 2310 -- over >>> serenity & payload . weightKilos .% subtract 1000 & payload . cargo .~ \"Chocolate\"","title":"Lenses &amp; Operators"},{"location":"Allgemein/Haskell/Optics.html#composing-lenses","text":"Lenses compose very easily. Imagin each lens being a domino which can be fitted together if the types match. From the expression below, we'll get address :: Lens' Person StreetAddress . The Address type is \"hidden\" in the composition. At the the right end of a domino line, we can use an action to do something, like modifying the focused value. Here an actual Example: wave :: Wool -> Sweater weave Wool = Sweater gameState :: ( Player , Item Wool ) gameState = ( Player Item Wool 5 ) -- crafts a sweater gameState' :: ( Player , Item Sweater ) gameState' = over ( _2 . material ) weave gameState","title":"Composing Lenses"},{"location":"Allgemein/Haskell/Optics.html#folds","text":"A fold is like a query and can: focus on multiple things can only get, not set data A fold has the data type Fold s a , where the s is the structure on which the query runs and a is the return value. A fold returns zero or more from a A fold, like a lens, doesn't contain data. It is an \"operation\" which knows how to extract zero or more elements from an type. We can create a custom Fold with the function folding :: Foldable f => (s -> f a) -> Fold s a , which takes as an argument a function which transforms the type s into a folding type a . data ShipCrew = ShipCrew { _captain :: String , , _conscripts :: [ String ] } deriving ( Show ) makeLenses ''ShipCrew collectCrewMembers :: ShipCrew -> [ String ] collectCrewMembers crew = ( _captain crew ) : _conscripts crew crewMembers :: Fold ShipCrew String crewMembers = folding collectCrewMembers","title":"Folds"},{"location":"Allgemein/Haskell/Optics.html#operators_1","text":"folded : Foldable f => Fold (f a) With folded an instance of Foldable like a list can be converted into a Fold . A lens can be used to focus in on an element of a fold. This works because every lens has a getter to focus on one element exactly. This fits into the definition of a fold which needs to focus on zero or more elements. data CartItem = CartItem { _name :: String , _count :: Int } makeLenses ''CarItem cart :: [ CartItem ] cart = [ CartItem \"Black Shirt\" 3 , CarItem \"Water Bottle\" 2 ] -- get a list of all items cart ^.. folded -- will return [CartItem \"Black Shirt\" 3, CarItem \"Water Bottle\" 2] toListOf folded cart -- the same as above cart ^.. folded . name -- [\"Black Shirt\", \"Water Bottle\"] toListOf ( folded . name ) cart -- the same as above to :: (s -> a) -> Fold s a Creates a fold which maps from the type s to the folded type a . This function maps 1-to-1. Because of this, it couldn't be used to extract values from Maybe . If a 1-to-many relationship is needed, folding can be used newtype Name = Name { getName :: String } deriving ( Show ) Name \"Hi\" ^. to getName -- will return \"Hi\" Name \"hello world\" ^. to getName . to ( fmap toUpper ) -- will return \"HELLO WORLD\" ( ShipCrew \"Captain Tom\" [ \"Franz\" , \"Max\" ]) ^.. crewMembers . to ( fmap toUpper ) -- will return [\"CAPTAIN TOM\", \"FRANZ\", \"MAX\"] backwards :: Fold s a -> Fold s a Reverses the elements of a fold [ 1 , 2 , 3 ] ^.. backwards folded -- will return [3, 2, 1] [( 1 , 2 ), ( 3 , 4 )] ^.. backwards ( folded . both ) -- will return [4, 3, 2, 1] [( 1 , 2 ), ( 3 , 4 )] ^.. backwards folded . both -- will return [3, 4, 1, 2] only :: Eq a => a -> Prism' a () A helper fold operator which can simplify to only :: Eq a => a -> Fold a () . It return () only if the input is equal to the given a 1 ^? only 1 -- will return Just () 2 ^? only 1 -","title":"Operators"},{"location":"Allgemein/Haskell/Optics.html#actions","text":"toListOf :: Fold s a -> s -> [a] / (^..) :: s -> Fold s a -> [a] To use a fold on data the function toListOf can be used. This will take a Fold and a Foldable structure and extracts [a] out of it. A synonym is (^..) :: s -> Fold s a -> [a] elemOf :: Eq a => Fold s a -> a -> s -> Bool Checks if the given a is in the Fold elemOf folded 3 [ 1 .. 4 ] -- will return True elemOf folded 99 [ 1 .. 4 ] -- will return False anyOf :: Fold s a -> (a -> Bool) -> s -> Bool Checks if the predicates returns true for at least one element anyOf folded even [ 1 .. 4 ] -- will return True anyOf folded ( > 100 ) [ 1 .. 4 ] -- will return False allOf :: Fold s a -> (a -> Bool) -> s -> Bool Check if the predicates returns true for all elements allOf folded even [ 1 .. 4 ] -- will return False allOf folded ( < 10 ) [ 1 .. 4 ] -- will return True findOf :: Fold s a -> (a -> Bool) -> s -> Maybe a Tries to find an element for which the predicate returns true findOf folded even [ 1 .. 4 ] -- will return Just 2 findOf folded ( > 10 ) [ 1 .. 4 ] -- will return Nothing has :: Fold s a -> s -> Bool Checks if there is at least one element has folded [] -- will return False has folded [ 1 .. 4 ] -- will return True hasn't :: Fold s a -> s -> Bool Checks if there are no elements hasn't folded [] -- will return True hasn't folded [ 1 .. 4 ] -- will return False lengthOf :: Fold s a -> s -> Int Returns how many elements there are lengthOf folded [ 1 , 2 , 3 , 4 ] -- will return 4 sumOf :: Num n => Fold s n -> s -> n / productOf :: Num n => Fold s n -> s -> n Calculates the sum/product of all elements sumfOf folded [ 1 .. 4 ] -- will return 10 productOf folded [ 1 .. 4 ] -- will return 24 firstOf :: Fold s a -> s -> Maybe a / preview :: Fold s a -> s -> Maybe a / ( ^?) :: s -> Fold s a -> Maybe a / lastOf :: Fold s a -> s -> Maybe a firstOf , preview and (^?) return the first element; lastOf returns the last element firstOf folded [] -- will return Nothing firstOf folded [ 1 .. 4 ] -- will return Just 1 preview folded [ 1 .. 4 ] -- will return Just 1 [ 1 .. 4 ] ^? folded -- will return Just 1 lastOf folded [ 1 .. 4 ] -- will return Just 4 minimumOf :: Ord a => Fold s a -> s -> Maybe a / maximumOf :: Ord a => Fold s a -> s -> Maybe a Returns the minimum or maximum of the elements minimumOf folded [ 1 .. 4 ] -- will return Just 1 maximumOf folded [ 1 .. 4 ] -- will return Just 4 minimumOf folded [] -- will return Nothing maximumOf folded [] -- will return Nothing maximumByOf :: Fold s a -> (a -> a -> Ordering) -> s -> Maybe a / minimumOf :: Fold s a -> (a -> a -> Ordering) -> s -> Maybe a These function return the \"largest\" or \"smallest\" element determinted by the function (a -> a -> Ordering) data Person = Person { _name :: String , _age :: Int } deriving ( Show ) maximumByOf ( folded ) ( comparing _age ) [ Person \"Seb\" 22 , Person \"Marie\" 33 ] -- will return Person \"Marie\" 33 minimumByOf ( folded ) ( comparing _age ) [ Person \"Seb\" 22 , Person \"Marie\" 33 ] -- will return Person \"Seb\" 22 traverseOf_ :: Functor f => Fold s a -> (a -> f r) -> s -> f () / forOf_ :: Functor f => Fold s a -> s -> (a -> f r) -> f () traverseOf_ and forOf_ are used to execute side effects with elements and are the optic equivalents of traverse_ and for_ data Person = Person { _name :: String , _age :: Int } deriving ( Show ) persons = [ Person \"Seb\" 22 , Person \"Ann\" , 34 ] showPerson :: Person -> String showPerson p = _name p <> \": \" <> show ( age p ) traverseOf_ ( folded . to showPerson ) putStrLn persons -- will return: -- Seb: 22 -- Ann: 34 -- example from Optics By Example / page >>> import Control.Monad.State >>> execState ( traverseOf_ folded ( modify . const ( + 1 )) tvShows ) 0 2 foldOf :: Monoid a => Fold s a -> s -> a / foldMapOf :: Monoid r => Fold s a -> (a -> r) -> s -> r foldOf and foldMapOf are function which allows the use of Monoids with folds. foldByOf :: Fold s a -> (a -> a -> a) -> a -> s -> a / foldMapByOf :: Fold s a -> (r -> r -> r) -> r -> (a -> r) -> s -> r foldByOf and foldMapByOf are similar to foldOf and foldMapOf , but allow the callee to specifiy the append function and identity value. tvShows = [( \"How I Met Your Mother\" , \"Josh Radnor\" ), ( \"How I Met Your Mother\" , \"Alyson Hannigan\" ), ( \"Buffy the Vampire Slayer\" , \"Alyson Hannigan\" )] foldMapByOf ( folded . _2 ) ( M . unionWith ( + )) mempty ( \\ n -> M . singleton n 1 ) tvShows -- will return [(\"Alyson Hannigan\",2),(\"Josh Radnor\",1)] foldrOf :: Fold s a -> (a -> r -> r) -> r -> s -> r / foldlOf :: Fold s a -> (r -> a -> r) -> r -> s -> r foldrOf and foldlOf are functions which are like foldOf and foldMapOf , but the identity value and append function can be set by parameters. They are the equivalence of foldr and foldl .","title":"Actions"},{"location":"Allgemein/Haskell/Optics.html#concat-existing-folds","text":"Already existing folds (and lenses) can be combined to one big Fold if the types match. Here's an alternative implementation of crewMembers crewMembers :: Fold ShipCrew String crewMembers = folding ( \\ s -> s ^.. captain <> s ^.. conscripts . folded )","title":"Concat existing Folds"},{"location":"Allgemein/Haskell/Optics.html#traversal","text":"A traversal can, like a fold, get zero or more elements but also set zero or more elements. Because of this, lenses and folds are valid traversal but not all traversals are lenses and folds. The type Traversal s t a b has the following generics: s - the structure before the action t - the structure after the action a - the focus before the action b - the focus after the action Wenn the type of the focus is changed by a setting operation the operation has to convert all elements. An operation which only focuses on part of the traversal can't change the type of the focus. Like with lenses, there is also a simple traversal: Traversal' s a , where the generic mean: s - the structure before and after the action a - the focus before and after the action","title":"Traversal"},{"location":"Allgemein/Haskell/Optics.html#actions_1","text":"When actions are used as a setter, then all values are changed, which would be returned with a getter. With these kind of action only part of the traversal can be updated. This also means that the focused type can't c [ 1 , 2 , 3 , 4 , 5 ] & taking 3 traversed *~ 10 -- will return [10, 20, 30, 4, 5] [ 1 , 2 , 3 , 4 , 5 ] & dropping 3 traversed *~ 10 -- will return [1, 2, 3, 40, 50] [ 1 .. 5 ] & traversed . filtered even *~ 10 -- will return [1, 20, 3, 40, 5] traversed :: Traversable f => IndexedTraversal Int (f a) (f b) a b Creates a Traversal which will focus on every element in the data structure. It is more powerfull than folded , but can be used with less types. both: Bitraversable r => Traversal (r a a) (r b b) a b both can be simplified to both: Bitraversable r => Fold (r a a) a and creates a Fold for a tuple with the same types ( (String, Int) wouldn't be valid). But only the last two item of a tuple are actually traversed. ( \"hello\" , \"wolrd\" ) ^.. both -- will return [\"hello\", \"world\"] ( \"hi\" ) ^.. both -- will return [\"hi\"] ( \"hi\" , \"hello\" , \"world\" ) ^.. both -- will return [\"hello\", \"world\"] each :: Each s t a b => Traversal s t a b each can be simplified to each :: Each s s a a => Fold s a . It does almost the same thing as both , but over an arbitrary sized tuple. ( \"hi\" , \"hello\" , \"world\" ) ^.. each -- will return [\"hi\", \"hello\", \"world\"] filtered :: (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a Filters a fold (or other optics) and can simplify to filtered :: (s -> Bool) -> Fold s s [ 1 .. 10 ] ^.. folded . filtered even -- will return [2,4,6,8,10] filteredBy :: Fold s a -> IndexedTraversal' a s s An alternative to filtered which uses a fold as the predicate. The type signature above is simplified.on taking :: (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a This method is the equivalent to take with traversals and folds. dropping :: (Conjoined p, Applicative f) => Int -> Over p (Control.Lens.Internal.Indexed.Indexing f) s t a a -> ver p f s t a a This method is the fold / traversal equivalent to drop [ 1 .. ] ^.. taking 5 folded -- will return [1, 2, 3, 4, 5] [[ 1 , 2 , 3 ], [ 10 , 20 , 30 ], [ 100 , 200 , 300 ]] ^.. folded . taking 2 folded -- will return [1, 2, 10, 20, 100, 200] High-Order actions apply, like other actions, two an element of a fold, not to the fold itself. The following graphic shows the code (\"Albus\", \"Dumbledore\") ^.. both . taking 3 folded takingWhile :: (a -> Bool) -> Fold s a -> Fold s a The traversal/folding equivalent to takeWhile . It accepts a predicate and will return element as long as the predicate returns true droppingWhile :: (a -> Bool) -> Fold s a -> Fold s a The traversal/folding equivalent to dropWhile . It will \"drop\" elements from fold elements until predicate returns false [ 1 .. ] ^.. takingWhile ( < 5 ) folded -- will return [1, 2, 3, 4] [ 1 .. 10 ] ^.. droppingWhile ( < 5 ) folded -- will return [5, 6, 7, 8, 9, 10] worded :: Applicative f => IndexedLensLike' Int f String String Simplifies to worded :: Traversal' String String and will focus on each word in the string lined :: Applicative f => IndexedLensLike' Int f String String Simplifies to lined :: Traversal' String String and will focus on each line in the string \"Hello world\" ^.. worded -- will return [\"Hello\", \"world\"] \"Hello \\n How are you?\" ^.. lined -- will return [\"Hello\",\" How are you?\"] \"Hello world\" & worded %~ \\ s -> \"*\" ++ s ++ \"*\" -- will return \"*Hello* *world*\" beside :: Traversal s t a b -> Traversal s' t' a b -> Traversal (s,s') (t,t') a b beside applies a the first traversal to the first element of the tuple and the second traversal to the second tuple element. ( \"hi\" , \"moin\" ) ^.. beside ( to length ) ( to $ const 200 ) -- will return (2, 200) ( \"hello\" , ( 2 , \"moin\" )) ^.. beside id _2 -- will return (\"hello\", \"moin\") ( \"hello\" , ( 2 , \"moin\" )) & beside id _2 %~ ( ++ \"!\" ) -- will return (\"hello!\", (2, \"moin!\")) element :: Traversable f => Int -> Traversal' (f a) a Focuses on the element with the given index [ 0 .. 4 ] ^? element 2 -- will return Just 2 [ 0 .. 4 ] ^? element 20 -- will return Nothing [ 0 .. 4 ] & element 2 *~ 10 -- will return [0, 1, 20, 3, 4]","title":"Actions"},{"location":"Allgemein/Haskell/Optics.html#operators_2","text":"The operator over (aka. %~ ) and set (aka. .~ ), which are known from lenses, can also be used with traversals. ( \"hello\" , \"moin\" ) & both %~ ( ++ \"!\" ) -- will return (\"hello!\", \"moin!\") over both ( ++ \"!\" ) ( \"hello\" , \"moin\" ) -- will return (\"hello!\", \"moin!\") ( \"hello\" , \"moin\" ) & both %~ length -- will return (5, 4) ( \"hello\" , \"moin\" ) & both .~ \"good morning\" -- will return (\"good morning\", \"good morning\") set both \"good morning\" ( \"hello\" , \"moin\" ) -- will return (\"good morning\", \"good morning\") Effects can be run on Traversals with the method traverseOf :: LensLike f s t a b -> (a -> f b) -> s -> f t which can be spezialized to traverseOf :: Traversal s t a b -> (a -> f b) -> s -> f . traverseOf works like traverse but with Traversable s traverseOf both readMaybe ( \"1\" , \"2\" ) :: Maybe ( Int , Int ) -- will return (1, 2) traverseOf both readMaybe ( \"hello\" , \"2\" ) :: Maybe ( Int , Int ) -- will return Nothing traverseOf each readMaybe [ \"1\" , \"2\" ] :: Maybe [ Int ] -- will return Just [1, 2] traverse readMaybe [ \"1\" , \"2\" ] :: Maybe [ Int ] -- will return Just []","title":"Operators"},{"location":"Allgemein/Haskell/Optics.html#each","text":"","title":"Each"},{"location":"Allgemein/IP/IP.html","text":"IP Anfoderuungen 20 ECT-Credits (im 2. und 3. Studienjahr f\u00fcr Vollzeitstudium) Wenn an IP angemeldet, wird man automatisch f\u00fcr die notwendigen englische Module eingetragen (Hier eine Liste von Modulen auf Englisch: https://intra.zhaw.ch/fileadmin/user_upload/80_Dept/T_School_of_Engineering/International/International_Profil/Intranet_Angebot_Module_in_Englisch_IP.pdf) ein extra Modul: Intercultural Communication and Management Am Ende des Studiums ben\u00f6tigt man ein C1 Deadline der Anmeldung f\u00fcr IP ist das 2. Semester Deadline f\u00fcr Anmeldung f\u00fcr Auslandsemester . Einige Unis wollen ein Zertifikat (zum Teil sogar ein C1). Das TOEFL iBT mehr als 95 Punkte Englisch Zertifikat ist empfohlen. Link zu Intranet IP: https://intra.zhaw.ch/departemente/school-of-engineering/internationaler-austausch/internationales-profil-ip/","title":"IP"},{"location":"Allgemein/IP/IP.html#ip","text":"","title":"IP"},{"location":"Allgemein/IP/IP.html#anfoderuungen","text":"20 ECT-Credits (im 2. und 3. Studienjahr f\u00fcr Vollzeitstudium) Wenn an IP angemeldet, wird man automatisch f\u00fcr die notwendigen englische Module eingetragen (Hier eine Liste von Modulen auf Englisch: https://intra.zhaw.ch/fileadmin/user_upload/80_Dept/T_School_of_Engineering/International/International_Profil/Intranet_Angebot_Module_in_Englisch_IP.pdf) ein extra Modul: Intercultural Communication and Management Am Ende des Studiums ben\u00f6tigt man ein C1 Deadline der Anmeldung f\u00fcr IP ist das 2. Semester Deadline f\u00fcr Anmeldung f\u00fcr Auslandsemester . Einige Unis wollen ein Zertifikat (zum Teil sogar ein C1). Das TOEFL iBT mehr als 95 Punkte Englisch Zertifikat ist empfohlen. Link zu Intranet IP: https://intra.zhaw.ch/departemente/school-of-engineering/internationaler-austausch/internationales-profil-ip/","title":"Anfoderuungen"},{"location":"Allgemein/Musik/Tonleitern.html","text":"Tonleitern \\[ \\newcommand{\\g}[]{1} \\newcommand{\\h}[]{\\frac 1 2} \\newcommand{\\gh}[]{\\frac 3 2} \\] Dur-Tonleiter Die Dur-Tonleiter hat folgendes Muster: \\(\\g - \\g - \\h - \\g - \\g - \\g -\\h\\) Moll-Tonleitern Es gibt drei verschiedene Moll-Tonleitern: das parallele, harmonische und melodische Moll. In der folgenden Tabelle sind die drei Tonleitern direkt verglichen: Name Muster Beispiel Paralleles Moll \\(\\g - \\h - \\g - \\g - \\h - \\g - \\g\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to Ab \\to B\\flat \\to C\\) Melodisches Moll \\(\\g - \\h - \\g - \\g - \\g -\\g -\\h\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to A \\to H \\to C\\) Harmonisches Moll \\(\\g - \\h - \\g -\\g - \\h - \\gh - \\h\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to A\\flat \\to H \\to C\\) Wie man sieht, sind bis zu der Quinte alle Moll-Tonleitern gleich. Dass heisst, erst wenn einer dieser T\u00f6ne gespielt wird, kann unterschieden werden, welche Tonleiter wirklich gespielt wird. Paralleles Moll/\u00c4olisch Das parallele Moll enth\u00e4lt die selben T\u00f6ne, wie die Dur-Tonleiter, aber um sechs T\u00f6ne gegen oben verschoben. Das Muster ist daher: \\(\\g - \\h - \\g - \\g - \\h - \\g - \\g\\) Aus der Tonleiter \\(C \\to D \\to E \\to F\\to G \\to A \\to H \\to C\\) wird \\(A \\to H \\to C \\to D \\to E\\to F \\to G \\to A\\) E Ein weiteres Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to Ab \\to B\\flat \\to C\\) Es wird auch \u00c4olisch genannt, da es die 6. Stufe von einer Dur-Tonleiter ist. Melodisches Moll Das melodische Moll hat das Muster: \\(\\g - \\h - \\g - \\g - \\g -\\g -\\h\\) Da das melodische Moll ein Halb-Ton von 7. zum 8. Ton hat, m\u00f6chte der 7. Ton sich auf den 8. Ton aufl\u00f6sen. Ein Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to A \\to H \\to C\\) Harmonisches Moll Die dritte Moll Tonleiter ist das harmonische Moll. Diese funktioniert \u00e4hnlich zum melodischen Moll, hat aber ein \\(\\gh\\) -Abstand: \\(\\g - \\h - \\g -\\g - \\h - \\gh - \\h\\) Ein Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to A\\flat \\to H \\to C\\)","title":"Tonleitern"},{"location":"Allgemein/Musik/Tonleitern.html#tonleitern","text":"\\[ \\newcommand{\\g}[]{1} \\newcommand{\\h}[]{\\frac 1 2} \\newcommand{\\gh}[]{\\frac 3 2} \\]","title":"Tonleitern"},{"location":"Allgemein/Musik/Tonleitern.html#dur-tonleiter","text":"Die Dur-Tonleiter hat folgendes Muster: \\(\\g - \\g - \\h - \\g - \\g - \\g -\\h\\)","title":"Dur-Tonleiter"},{"location":"Allgemein/Musik/Tonleitern.html#moll-tonleitern","text":"Es gibt drei verschiedene Moll-Tonleitern: das parallele, harmonische und melodische Moll. In der folgenden Tabelle sind die drei Tonleitern direkt verglichen: Name Muster Beispiel Paralleles Moll \\(\\g - \\h - \\g - \\g - \\h - \\g - \\g\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to Ab \\to B\\flat \\to C\\) Melodisches Moll \\(\\g - \\h - \\g - \\g - \\g -\\g -\\h\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to A \\to H \\to C\\) Harmonisches Moll \\(\\g - \\h - \\g -\\g - \\h - \\gh - \\h\\) \\(C \\to D \\to E\\flat \\to F \\to G \\to A\\flat \\to H \\to C\\) Wie man sieht, sind bis zu der Quinte alle Moll-Tonleitern gleich. Dass heisst, erst wenn einer dieser T\u00f6ne gespielt wird, kann unterschieden werden, welche Tonleiter wirklich gespielt wird.","title":"Moll-Tonleitern"},{"location":"Allgemein/Musik/Tonleitern.html#paralleles-mollaolisch","text":"Das parallele Moll enth\u00e4lt die selben T\u00f6ne, wie die Dur-Tonleiter, aber um sechs T\u00f6ne gegen oben verschoben. Das Muster ist daher: \\(\\g - \\h - \\g - \\g - \\h - \\g - \\g\\) Aus der Tonleiter \\(C \\to D \\to E \\to F\\to G \\to A \\to H \\to C\\) wird \\(A \\to H \\to C \\to D \\to E\\to F \\to G \\to A\\) E Ein weiteres Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to Ab \\to B\\flat \\to C\\) Es wird auch \u00c4olisch genannt, da es die 6. Stufe von einer Dur-Tonleiter ist.","title":"Paralleles Moll/\u00c4olisch"},{"location":"Allgemein/Musik/Tonleitern.html#melodisches-moll","text":"Das melodische Moll hat das Muster: \\(\\g - \\h - \\g - \\g - \\g -\\g -\\h\\) Da das melodische Moll ein Halb-Ton von 7. zum 8. Ton hat, m\u00f6chte der 7. Ton sich auf den 8. Ton aufl\u00f6sen. Ein Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to A \\to H \\to C\\)","title":"Melodisches Moll"},{"location":"Allgemein/Musik/Tonleitern.html#harmonisches-moll","text":"Die dritte Moll Tonleiter ist das harmonische Moll. Diese funktioniert \u00e4hnlich zum melodischen Moll, hat aber ein \\(\\gh\\) -Abstand: \\(\\g - \\h - \\g -\\g - \\h - \\gh - \\h\\) Ein Beispiel w\u00e4re: \\(C \\to D \\to E\\flat \\to F \\to G \\to A\\flat \\to H \\to C\\)","title":"Harmonisches Moll"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html","text":"OOP Takeaways Wieso Getters und Setters Getters und Setters haben mehrere Vorteile: Validation kann sehr einfach eingebaut werden, auch im Nachteil Die interne Struktur kann \u00e4ndern, ohne dass sich die \u00f6ffentliche Schnittstelle \u00e4ndern muss es ist Konvention Demeters Law (source: Law of Demeter - Wikipedia ) Das Law of Demeter besagt folgendes: Jede Einheit sollte nur limitiertes Wissen \u00fcber andere Einheiten haben Eine Einheit spricht nur mit seinen Freunden, nicht Fremde. Zum einen f\u00fchrt dies dazu Klassen nur so viel wiessen, wie umbedingt n\u00f6tig, aber auch zu kleinen Schnittstellen. Anstatt a.getB().getName() w\u00fcrde man die Methode a.getBName() erstellen, welche den Aufruf weiter delegiert. Man sollte also nicht durch andere Methoden \"durch greiffen\" Formaler: Eine Methode m auf dem Objekt a , solte nur auf folgendes zugreiffen: a selbst m 's Parameter Lokale Variabeln von m Attribute von a Folgendes sollte vermiden werden: a.m().n() Vorteile Die Vorteile von Demeters Law sind, dass es zu Relationen kommt, welche nicht auf interne Strukturen anderen Objekte abh\u00e4ngig sind. Dies kommt davon, dass Aufrufe delegiert werden und somit auch abstrahiert. Nachteile Es gibt duplizierten Code, da man zum Teil delegieren muss. Wenn man Demeters Law auf der Klassenebenen anwendet, kann es zu grossen Schnittstellen f\u00fchren, da man eine Klasse um delegierende Methoden erweitern. Wenn man ein Attribute wie a.b().c() ben\u00f6tigt, anstatt a.c() zu hinzuf\u00fcgen, kann man sich auch \u00fcberlegen der Klasse ein Attribute c hinzuzuf\u00fcgen. Damit die Koh\u00e4sion nicht alzufest leidet, k\u00f6nnen auch Methoden umbenannt werden, so dass sie besser zur Klasse passen (Spieler delegiert das Inventar zu einer Rucksackklasse. Die Methode addItem(Item) k\u00f6nnte zu pickUpItem(Item umbenannt werden, was wieder gut zu Player passen w\u00fcrde) Koh\u00e4sion Koh\u00e4sion beschreibt, wie gut eine Methode oder Klasse eine logische Aufgabe oder Einheit abdeckt. Als Beispiel: Wenn eine Calculator Klasse die Methoden add(int, int) , sub(int, int) , showGui(int) hat, dann hat sie eine tiefe Koh\u00e4sion, da showGui(int) wenig mit der Calculator Klasse zu tun hat. Als Hilfe kann man sich immer Fragen: Gibt es ein passenden Klassennamen f\u00fcr diese Klasse? Der Vorteil von einer hohen Koh\u00e4sion ist, dass eine Klasse oder Methode wiederverwendbarer wird, da sie nur etwas macht und es so wahrscheinlicher ist, dass dieselbe Klasse oder Methode mehrmals verwendet werden kann. Koppelung Koppelung beschreibt, wie fest Klassen abh\u00e4ngig von einander sind. Grunds\u00e4tzlich ist eine tiefere Koppelung besser, da so \u00c4nderungen sich nicht durch die ganze Codebasee ziehen. Daf\u00fcr m\u00f6chte man m\u00f6glichst kleine Schnittstellen, da so die Abh\u00e4ngigkeitsm\u00f6glichkeiten von einer Klasse reduziert werden. Der Vorteil von einer loser Kopplung ist, dass sich \u00c4nderungen an einer einzelnen Klasse einfacher durchf\u00fchren lassen, da diese \u00c4nderungen mehr lokale Auswirkungen haben anstatt globale. Polymorphie","title":"OOP Takeaways"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#oop-takeaways","text":"","title":"OOP Takeaways"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#wieso-getters-und-setters","text":"Getters und Setters haben mehrere Vorteile: Validation kann sehr einfach eingebaut werden, auch im Nachteil Die interne Struktur kann \u00e4ndern, ohne dass sich die \u00f6ffentliche Schnittstelle \u00e4ndern muss es ist Konvention","title":"Wieso Getters und Setters"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#demeters-law","text":"(source: Law of Demeter - Wikipedia ) Das Law of Demeter besagt folgendes: Jede Einheit sollte nur limitiertes Wissen \u00fcber andere Einheiten haben Eine Einheit spricht nur mit seinen Freunden, nicht Fremde. Zum einen f\u00fchrt dies dazu Klassen nur so viel wiessen, wie umbedingt n\u00f6tig, aber auch zu kleinen Schnittstellen. Anstatt a.getB().getName() w\u00fcrde man die Methode a.getBName() erstellen, welche den Aufruf weiter delegiert. Man sollte also nicht durch andere Methoden \"durch greiffen\" Formaler: Eine Methode m auf dem Objekt a , solte nur auf folgendes zugreiffen: a selbst m 's Parameter Lokale Variabeln von m Attribute von a Folgendes sollte vermiden werden: a.m().n()","title":"Demeters Law"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#vorteile","text":"Die Vorteile von Demeters Law sind, dass es zu Relationen kommt, welche nicht auf interne Strukturen anderen Objekte abh\u00e4ngig sind. Dies kommt davon, dass Aufrufe delegiert werden und somit auch abstrahiert.","title":"Vorteile"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#nachteile","text":"Es gibt duplizierten Code, da man zum Teil delegieren muss. Wenn man Demeters Law auf der Klassenebenen anwendet, kann es zu grossen Schnittstellen f\u00fchren, da man eine Klasse um delegierende Methoden erweitern. Wenn man ein Attribute wie a.b().c() ben\u00f6tigt, anstatt a.c() zu hinzuf\u00fcgen, kann man sich auch \u00fcberlegen der Klasse ein Attribute c hinzuzuf\u00fcgen. Damit die Koh\u00e4sion nicht alzufest leidet, k\u00f6nnen auch Methoden umbenannt werden, so dass sie besser zur Klasse passen (Spieler delegiert das Inventar zu einer Rucksackklasse. Die Methode addItem(Item) k\u00f6nnte zu pickUpItem(Item umbenannt werden, was wieder gut zu Player passen w\u00fcrde)","title":"Nachteile"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#kohasion","text":"Koh\u00e4sion beschreibt, wie gut eine Methode oder Klasse eine logische Aufgabe oder Einheit abdeckt. Als Beispiel: Wenn eine Calculator Klasse die Methoden add(int, int) , sub(int, int) , showGui(int) hat, dann hat sie eine tiefe Koh\u00e4sion, da showGui(int) wenig mit der Calculator Klasse zu tun hat. Als Hilfe kann man sich immer Fragen: Gibt es ein passenden Klassennamen f\u00fcr diese Klasse? Der Vorteil von einer hohen Koh\u00e4sion ist, dass eine Klasse oder Methode wiederverwendbarer wird, da sie nur etwas macht und es so wahrscheinlicher ist, dass dieselbe Klasse oder Methode mehrmals verwendet werden kann.","title":"Koh\u00e4sion"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#koppelung","text":"Koppelung beschreibt, wie fest Klassen abh\u00e4ngig von einander sind. Grunds\u00e4tzlich ist eine tiefere Koppelung besser, da so \u00c4nderungen sich nicht durch die ganze Codebasee ziehen. Daf\u00fcr m\u00f6chte man m\u00f6glichst kleine Schnittstellen, da so die Abh\u00e4ngigkeitsm\u00f6glichkeiten von einer Klasse reduziert werden. Der Vorteil von einer loser Kopplung ist, dass sich \u00c4nderungen an einer einzelnen Klasse einfacher durchf\u00fchren lassen, da diese \u00c4nderungen mehr lokale Auswirkungen haben anstatt globale.","title":"Koppelung"},{"location":"Allgemein/PROG/2_OOP_Takeaways.html#polymorphie","text":"","title":"Polymorphie"},{"location":"Allgemein/PROG/3_Patterns.html","text":"Patterns Strategy Pattern Beim Strategy Pattern wird ein Algorithmus in eine Strategy-Klasse extrahiert. Dies erleichtert es, einen Algorithmus mit einem anderen zu wechseln. Im folgenden Beispiel wird eine Hirachie einer Ente gezeigt. Dabei hat Ente verschiedene Methoden, welche von verschiedenen Entenarten \u00fcberschrieben werden k\u00f6nnen. Ein Problem, dass bei einer solchen Hirarchie entstehen kann, ist dass es reduntante Implementationen von einzelnen Methoden geben kann. Als Beispiel: Die Stockente und die Reiherente k\u00f6nnen beide fliegen, w\u00e4hrend die Gummiente und Dekoente nicht fliegen k\u00f6nnen. Zwei der Klasse m\u00fcssen immer fliegen() \u00fcberschreiben. Als Alternative kann hier das Strategy-Pattern genutzt werden. Nun hat die Ente-Klasse Referenzen zu Strategy-Implementationen, welche entscheiden, ob eine Ente fliegen oder nicht fliegen kann. So kann duplizierter Code verhindert werden MVC Model : Contains the data with the domain logic, but it has to be independent from the View-Classes. View: The UI components which render the data. The view doesn't call the model directly (usually), but it knows about the types of the model (for example via generics). Controller: The glue between the model and the UI. It listens to events from the UI and calls the model accordingly Decorator A problem which can occur with inheritance is that the amount of classes can explode. Imagine having a Beverage interface which defines a few methods for accessing information. Now for every different beverage type we have to create a new class and implement the methods. Is there a combination with sugar, sure, let\u2019s make another class out of it. The \u201c-WithSugar\u201d and \u201c-WithMilk\u201d class could be omitted by using inheritance but not every beverage has the option of milk or sugar (FruitTee or MilkCoffee comes to mind). A solution to this problem is this: Every type of beverage still has its own class but instead of having a \u201c-WithMilk\u201d and \u201c-WithSugar\u201d class for every type, there is now a WithSugar and a WithMilk class which extends of the Decorator. Every Decorator has a beverage and its goal is to add information to this beverage. You might also notice that the decorator itself is a beverage. This allows this: Beverage tee = new WithSugar ( new WithMilk ( new BlackTee ())); tee . cost (); // this returns the cost of the black tee and the WithSugar and WithMilk add their own cost What happens here is that the tee object consists of a WithSugar object, which has a WithMilk object as its beverage and the WithSugar object will add the price to the returns value of the WithMilk.cost() method. The same thing happens with the WitthMilk and the BlackTee object.","title":"Patterns"},{"location":"Allgemein/PROG/3_Patterns.html#patterns","text":"","title":"Patterns"},{"location":"Allgemein/PROG/3_Patterns.html#strategy-pattern","text":"Beim Strategy Pattern wird ein Algorithmus in eine Strategy-Klasse extrahiert. Dies erleichtert es, einen Algorithmus mit einem anderen zu wechseln. Im folgenden Beispiel wird eine Hirachie einer Ente gezeigt. Dabei hat Ente verschiedene Methoden, welche von verschiedenen Entenarten \u00fcberschrieben werden k\u00f6nnen. Ein Problem, dass bei einer solchen Hirarchie entstehen kann, ist dass es reduntante Implementationen von einzelnen Methoden geben kann. Als Beispiel: Die Stockente und die Reiherente k\u00f6nnen beide fliegen, w\u00e4hrend die Gummiente und Dekoente nicht fliegen k\u00f6nnen. Zwei der Klasse m\u00fcssen immer fliegen() \u00fcberschreiben. Als Alternative kann hier das Strategy-Pattern genutzt werden. Nun hat die Ente-Klasse Referenzen zu Strategy-Implementationen, welche entscheiden, ob eine Ente fliegen oder nicht fliegen kann. So kann duplizierter Code verhindert werden","title":"Strategy Pattern"},{"location":"Allgemein/PROG/3_Patterns.html#mvc","text":"Model : Contains the data with the domain logic, but it has to be independent from the View-Classes. View: The UI components which render the data. The view doesn't call the model directly (usually), but it knows about the types of the model (for example via generics). Controller: The glue between the model and the UI. It listens to events from the UI and calls the model accordingly","title":"MVC"},{"location":"Allgemein/PROG/3_Patterns.html#decorator","text":"A problem which can occur with inheritance is that the amount of classes can explode. Imagine having a Beverage interface which defines a few methods for accessing information. Now for every different beverage type we have to create a new class and implement the methods. Is there a combination with sugar, sure, let\u2019s make another class out of it. The \u201c-WithSugar\u201d and \u201c-WithMilk\u201d class could be omitted by using inheritance but not every beverage has the option of milk or sugar (FruitTee or MilkCoffee comes to mind). A solution to this problem is this: Every type of beverage still has its own class but instead of having a \u201c-WithMilk\u201d and \u201c-WithSugar\u201d class for every type, there is now a WithSugar and a WithMilk class which extends of the Decorator. Every Decorator has a beverage and its goal is to add information to this beverage. You might also notice that the decorator itself is a beverage. This allows this: Beverage tee = new WithSugar ( new WithMilk ( new BlackTee ())); tee . cost (); // this returns the cost of the black tee and the WithSugar and WithMilk add their own cost What happens here is that the tee object consists of a WithSugar object, which has a WithMilk object as its beverage and the WithSugar object will add the price to the returns value of the WithMilk.cost() method. The same thing happens with the WitthMilk and the BlackTee object.","title":"Decorator"},{"location":"Allgemein/PROG/4_Testing.html","text":"Testing \u00c4quivalenzklassen In einer \u00c4quivalenzklassen sind alle m\u00f6glichen Eingabewerte, welche vom Programm gleich verarbeitet werden. Dabei gibt es g\u00fcltige \u00c4quivalenzklassen, welche Werte beinhalten, welche vom Programm verarbeitet werden sollen und es gibt Ung\u00fcltige \u00c4quivalenzklassen, welche vom Programm erkannt und korrekt behandelt werden sollen (Exception, Return-Value, ...) Regeln, wenn \u00c4quivalenzklassen gebildet werden: Wenn g\u00fcltige Eingabewerte ein zusammenh\u00e4ngender Wertebereich bilden, so muss eine g\u00fcltige \u00c4quivalenzklasse und zwei ung\u00fcltige \u00c4quivalenzklassen gebildet werden Wenn Eingabewerte eine Bedinung erf\u00fcllen m\u00fcssen (mit dem Buchstaben ' A' starten), dann muss eine g\u00fcltige und eine ung\u00fcltige \u00c4quivalenzklasse gebildet werden. Aus diesen \u00c4quivalenzklassen k\u00f6nnen nun Testf\u00e4lle abgeileit werden. Dabei kann folgendes beachtet werden: Ein Testfall darf mehrere g\u00fcltige \u00c4quivalenzklassen abdecken Ein Testfall f\u00fcr ung\u00fcltige \u00c4quivalenzklassen sollte nur einen ung\u00fcltigen Wert enhalten Grenzwerte sollten ber\u00fccksichtigt werden FIRST-Regeln Definition of Testing Testing is the process of executing a programm with the intent of finding errors. Principles of Testing Specification of Input and Output For each test case the input and the expected output should be specified. Separation of Creation and Testing The developer of the code shouldn't write the test for their code. Completeness of Tests Code should always be tested for valid inputs and invalid tests. The natural tendency is to test only the valid inputs. Testing is an investement Test cases are reused Error Cluster If an error is found in a section of code, the probability of more errors increases. Error-prone Sections should be well tested. Mock Testing Mock testing is used when a class with dependencies should be tested. The dependencies can be mocked that it implements the minimal of behaviour to function. This allows to only test the class under testing and not its dependencies. Different Mocking Types There are different type of mock classes. Dummy Dummies are objects which are never used. They fill parameter lists of methods, if those methods would throw NullPointerExceptions otherwise. Stubs A stub is the minimal implementation of an interface. Void method usually don't do anything and methods with a return value will usually return a hard coded value. Here is an example. public class EmailStub implements EmailServer { public void sendMail ( String mailTextt ) { // do nothing } public String receiveMail () { return \"Mail received\" ; // a hard coded value } } An EmailDummy would return null in receiveMail() because it is just a dummy. Spies Spies are similar to stubs, but record which members were invoked. This information can be checked in unit tests. Fakes A fake will implement a class similar to the production class but with shortcuts (e.g. an in-memory database) Mock A test double which implements the functions in away which we expect for the test. Depending on how they are implemented, they can function as a dummy, stub, spy or a fake. Mock testing is usually split in multiple phases: Create: The mock object is created Specify: The expected behaviour is specified Use: The mock object is used in a normal unit test Verify behaviour: The mock object is verified public class OrderInteractionTester extends MockObjectTestCase { private static String TALISKER = \"Talisker\" ; public void testFillingRemovesInventoryIfInStock () { // configuration Order order = new Order ( TALISKER , 50 ); Mock warehouseMock = new Mock ( Warehouse . class ); // expectations warehouseMock . expects ( once ()) . method ( \"hasInventory\" ) . with ( eq ( TALISKER ), eq ( 50 )) . will ( returnValue ( true )); warehouseMock . expects ( once ()) . method ( \"remove\" ) . with ( eq ( TALISKER ), eq ( 50 )) . after ( \"hasInventory\" ); //exercise order . fill (( Warehouse ) warehouseMock . proxy ()); //verify warehouseMock . verify (); //verify expected behavior assertTrue ( order . isFilled ()); //verify state } } Blacking-Box vs White-Box Testing In black-box testing (or state testing), only the public interface is known. No assumptions is done about the internal implementaiton. Usually stubbing can be used. In white-box testing (or behaviour testing) the inner working of the class is known and tested. Here, usually mocking can be used. Mockito Create a Mock Either the method mock(Class<?> clazz) is used or the annotation @Mock for which MockitoAnnotations.openMocks() needs to be called in the setu void testHalf ( @Mock Half mockedHalf2 ) { Half mockedHalf = mock ( Half . class ); } Mock Behaviour To mock the return value of methods, the when(<method>).thenReturn(<value1>).thenReturn(<value2>) pattern can be used. When the returned value should have a bit more logic than a constant value, the thenAnswer(Answer<T>) method can be used (see example below). To mock an exception throwing method, the doThrow(<exception>).when(<mockObj>).<method>(<args>) pattern needs to be used. The method must support throwing the exception in case of an checked-exception. There are multiple matchers available, which can match an argument of a mocked method: Any-matchers : anyInt() , anyString() , any(Class<?> clazz) , ... String-matchers : startsWith(String) , endsWith(String) , contains(String) , ... Object-matchers : isNull() , isNotNull() , ... Compare-matchvers : eq(T obj) , ... Custom-matchers : argThat()... , intThat(...) , ... Person mock = mock ( Person . class ); // mock return values when ( mock . getName ()). thenReturn ( \"Hans\" ). thenReturn ( \"Max\" ); doReturn ( 10 ). doReturn ( 20 ). when ( mock ). getAge (); when ( mock . getMessage ( anyString ())). thenAnswer (( InvocationOnMock invocation ) -> \"hello world\" ); // mock exception throwing doThrow ( new IllegalArgumentException ()). when ( mock ). setAge ( - 1 ); When an method isn't mocked, then a value is still returned based on the return value: The return value is an primitive : The \"zero\"-primitive is returned The return value is a primitive wrapper class : Then the \"zero\"-primitive of the wrapper class is returned The return value is a collection : The return value is an empty collection For the toString() method an description of the mock is returned For Comparable#compareTo(T other) returns zero if the references are equal, else a non-zero value Else : null is returned. Verify Behaviour Mockito can verify that a method was invoked. For this, the pattern verify(<mock>).<method>(<args>) can be used. With an additional argument of verify, further conditions can be specified. With verify(<mock>, never()).<method>(<args>) can be checked that the method was never invoked. Other condition includes never() , times(int) , atLeastOnce() , atLeast(int) , atMost(int) , timeout(int milliseconds) (that the method is invoked in the given timeout). These conditions can be combined like timeout(10).times(2) Mockito can also verify the order in which methods were called. For this a InOrder object can be created with inOrder(<mockObj>) . On the InOrder object, the verify(...) method can be used. verify ( mockedHalf ). contractAtrium (); verify ( mockedHalf , times ( 2 )). isAtrioventricularValveOpen (); verify ( mockedList , never ()). add ( \"ZHAW\" ); InOrder inOrder = inOrder ( singleMock ); // Verify the order inOrder . verify ( singleMock ). add ( \"second\" ); inOrder . verify ( singleMock ). add ( \"first\" ); Spies A spy object is created based on a \"real\" object. All methods are delegated to this object, but the behaviour of methods can be selectively changed (similar with mocks) and it can verify than methods were called. It can be created with spy(Object obj) and can be used like a mock. Similar to @Mock the @Spy annotation can be used instead of spy(...) ( MockitoAnnotations.openMocks() needs to be called in the setup method). List list = new LinkedList (); // create a spy on the real object instance List spy = spy ( list ); // stub the size() method when ( spy . size ()). thenReturn ( 100 ); // add() is not stubbed. So it will use the real method spy . add ( \"one\" ); spy . add ( \"two\" ); assertEquals ( \"one\" , spy . get ( 0 )); assertEquals ( 100 , spy . size ());","title":"Testing"},{"location":"Allgemein/PROG/4_Testing.html#testing","text":"","title":"Testing"},{"location":"Allgemein/PROG/4_Testing.html#aquivalenzklassen","text":"In einer \u00c4quivalenzklassen sind alle m\u00f6glichen Eingabewerte, welche vom Programm gleich verarbeitet werden. Dabei gibt es g\u00fcltige \u00c4quivalenzklassen, welche Werte beinhalten, welche vom Programm verarbeitet werden sollen und es gibt Ung\u00fcltige \u00c4quivalenzklassen, welche vom Programm erkannt und korrekt behandelt werden sollen (Exception, Return-Value, ...) Regeln, wenn \u00c4quivalenzklassen gebildet werden: Wenn g\u00fcltige Eingabewerte ein zusammenh\u00e4ngender Wertebereich bilden, so muss eine g\u00fcltige \u00c4quivalenzklasse und zwei ung\u00fcltige \u00c4quivalenzklassen gebildet werden Wenn Eingabewerte eine Bedinung erf\u00fcllen m\u00fcssen (mit dem Buchstaben ' A' starten), dann muss eine g\u00fcltige und eine ung\u00fcltige \u00c4quivalenzklasse gebildet werden. Aus diesen \u00c4quivalenzklassen k\u00f6nnen nun Testf\u00e4lle abgeileit werden. Dabei kann folgendes beachtet werden: Ein Testfall darf mehrere g\u00fcltige \u00c4quivalenzklassen abdecken Ein Testfall f\u00fcr ung\u00fcltige \u00c4quivalenzklassen sollte nur einen ung\u00fcltigen Wert enhalten Grenzwerte sollten ber\u00fccksichtigt werden","title":"\u00c4quivalenzklassen"},{"location":"Allgemein/PROG/4_Testing.html#first-regeln","text":"","title":"FIRST-Regeln"},{"location":"Allgemein/PROG/4_Testing.html#definition-of-testing","text":"Testing is the process of executing a programm with the intent of finding errors.","title":"Definition of Testing"},{"location":"Allgemein/PROG/4_Testing.html#principles-of-testing","text":"Specification of Input and Output For each test case the input and the expected output should be specified. Separation of Creation and Testing The developer of the code shouldn't write the test for their code. Completeness of Tests Code should always be tested for valid inputs and invalid tests. The natural tendency is to test only the valid inputs. Testing is an investement Test cases are reused Error Cluster If an error is found in a section of code, the probability of more errors increases. Error-prone Sections should be well tested.","title":"Principles of Testing"},{"location":"Allgemein/PROG/4_Testing.html#mock-testing","text":"Mock testing is used when a class with dependencies should be tested. The dependencies can be mocked that it implements the minimal of behaviour to function. This allows to only test the class under testing and not its dependencies.","title":"Mock Testing"},{"location":"Allgemein/PROG/4_Testing.html#different-mocking-types","text":"There are different type of mock classes.","title":"Different Mocking Types"},{"location":"Allgemein/PROG/4_Testing.html#dummy","text":"Dummies are objects which are never used. They fill parameter lists of methods, if those methods would throw NullPointerExceptions otherwise.","title":"Dummy"},{"location":"Allgemein/PROG/4_Testing.html#stubs","text":"A stub is the minimal implementation of an interface. Void method usually don't do anything and methods with a return value will usually return a hard coded value. Here is an example. public class EmailStub implements EmailServer { public void sendMail ( String mailTextt ) { // do nothing } public String receiveMail () { return \"Mail received\" ; // a hard coded value } } An EmailDummy would return null in receiveMail() because it is just a dummy.","title":"Stubs"},{"location":"Allgemein/PROG/4_Testing.html#spies","text":"Spies are similar to stubs, but record which members were invoked. This information can be checked in unit tests.","title":"Spies"},{"location":"Allgemein/PROG/4_Testing.html#fakes","text":"A fake will implement a class similar to the production class but with shortcuts (e.g. an in-memory database)","title":"Fakes"},{"location":"Allgemein/PROG/4_Testing.html#mock","text":"A test double which implements the functions in away which we expect for the test. Depending on how they are implemented, they can function as a dummy, stub, spy or a fake. Mock testing is usually split in multiple phases: Create: The mock object is created Specify: The expected behaviour is specified Use: The mock object is used in a normal unit test Verify behaviour: The mock object is verified public class OrderInteractionTester extends MockObjectTestCase { private static String TALISKER = \"Talisker\" ; public void testFillingRemovesInventoryIfInStock () { // configuration Order order = new Order ( TALISKER , 50 ); Mock warehouseMock = new Mock ( Warehouse . class ); // expectations warehouseMock . expects ( once ()) . method ( \"hasInventory\" ) . with ( eq ( TALISKER ), eq ( 50 )) . will ( returnValue ( true )); warehouseMock . expects ( once ()) . method ( \"remove\" ) . with ( eq ( TALISKER ), eq ( 50 )) . after ( \"hasInventory\" ); //exercise order . fill (( Warehouse ) warehouseMock . proxy ()); //verify warehouseMock . verify (); //verify expected behavior assertTrue ( order . isFilled ()); //verify state } }","title":"Mock"},{"location":"Allgemein/PROG/4_Testing.html#blacking-box-vs-white-box-testing","text":"In black-box testing (or state testing), only the public interface is known. No assumptions is done about the internal implementaiton. Usually stubbing can be used. In white-box testing (or behaviour testing) the inner working of the class is known and tested. Here, usually mocking can be used.","title":"Blacking-Box vs White-Box Testing"},{"location":"Allgemein/PROG/4_Testing.html#mockito","text":"","title":"Mockito"},{"location":"Allgemein/PROG/4_Testing.html#create-a-mock","text":"Either the method mock(Class<?> clazz) is used or the annotation @Mock for which MockitoAnnotations.openMocks() needs to be called in the setu void testHalf ( @Mock Half mockedHalf2 ) { Half mockedHalf = mock ( Half . class ); }","title":"Create a Mock"},{"location":"Allgemein/PROG/4_Testing.html#mock-behaviour","text":"To mock the return value of methods, the when(<method>).thenReturn(<value1>).thenReturn(<value2>) pattern can be used. When the returned value should have a bit more logic than a constant value, the thenAnswer(Answer<T>) method can be used (see example below). To mock an exception throwing method, the doThrow(<exception>).when(<mockObj>).<method>(<args>) pattern needs to be used. The method must support throwing the exception in case of an checked-exception. There are multiple matchers available, which can match an argument of a mocked method: Any-matchers : anyInt() , anyString() , any(Class<?> clazz) , ... String-matchers : startsWith(String) , endsWith(String) , contains(String) , ... Object-matchers : isNull() , isNotNull() , ... Compare-matchvers : eq(T obj) , ... Custom-matchers : argThat()... , intThat(...) , ... Person mock = mock ( Person . class ); // mock return values when ( mock . getName ()). thenReturn ( \"Hans\" ). thenReturn ( \"Max\" ); doReturn ( 10 ). doReturn ( 20 ). when ( mock ). getAge (); when ( mock . getMessage ( anyString ())). thenAnswer (( InvocationOnMock invocation ) -> \"hello world\" ); // mock exception throwing doThrow ( new IllegalArgumentException ()). when ( mock ). setAge ( - 1 ); When an method isn't mocked, then a value is still returned based on the return value: The return value is an primitive : The \"zero\"-primitive is returned The return value is a primitive wrapper class : Then the \"zero\"-primitive of the wrapper class is returned The return value is a collection : The return value is an empty collection For the toString() method an description of the mock is returned For Comparable#compareTo(T other) returns zero if the references are equal, else a non-zero value Else : null is returned.","title":"Mock Behaviour"},{"location":"Allgemein/PROG/4_Testing.html#verify-behaviour","text":"Mockito can verify that a method was invoked. For this, the pattern verify(<mock>).<method>(<args>) can be used. With an additional argument of verify, further conditions can be specified. With verify(<mock>, never()).<method>(<args>) can be checked that the method was never invoked. Other condition includes never() , times(int) , atLeastOnce() , atLeast(int) , atMost(int) , timeout(int milliseconds) (that the method is invoked in the given timeout). These conditions can be combined like timeout(10).times(2) Mockito can also verify the order in which methods were called. For this a InOrder object can be created with inOrder(<mockObj>) . On the InOrder object, the verify(...) method can be used. verify ( mockedHalf ). contractAtrium (); verify ( mockedHalf , times ( 2 )). isAtrioventricularValveOpen (); verify ( mockedList , never ()). add ( \"ZHAW\" ); InOrder inOrder = inOrder ( singleMock ); // Verify the order inOrder . verify ( singleMock ). add ( \"second\" ); inOrder . verify ( singleMock ). add ( \"first\" );","title":"Verify Behaviour"},{"location":"Allgemein/PROG/4_Testing.html#spies_1","text":"A spy object is created based on a \"real\" object. All methods are delegated to this object, but the behaviour of methods can be selectively changed (similar with mocks) and it can verify than methods were called. It can be created with spy(Object obj) and can be used like a mock. Similar to @Mock the @Spy annotation can be used instead of spy(...) ( MockitoAnnotations.openMocks() needs to be called in the setup method). List list = new LinkedList (); // create a spy on the real object instance List spy = spy ( list ); // stub the size() method when ( spy . size ()). thenReturn ( 100 ); // add() is not stubbed. So it will use the real method spy . add ( \"one\" ); spy . add ( \"two\" ); assertEquals ( \"one\" , spy . get ( 0 )); assertEquals ( 100 , spy . size ());","title":"Spies"},{"location":"Allgemein/PROG/5_Threads.html","text":"Threads Share Data between Multiple Threads Atomic Use the atomic Synchronized class Account { private int balance ; public synchronized void transferAmount1 ( int amount ) { this . balance += amaount ; } public void transferAmount2 ( int amount ) { synchronized ( this ) { this . balance += amaount ; } } public synchronized static staticLock1 () { //do stuff } public static staticLock1 () { synchronized ( Amount . class ) { // do stuff } } } Never call an other synchronized method which uses a different object. This can cause a dead lock. Monitor A Java object can be used as a locked. class FooBar { private Object monitor ; public void test () { synchronized ( monitor ) { // waits for the monitor to be called with monitor.notify() or monitor.notifyAll() monitor . wait (); } } } Object.wait() blocks until Object.notify() or Object.notifyAll() is invoked on the same monitor object. notify() only wakes up one waiting Thread while notifyAll() will wake up all waiting threads. wait() releases the monitor object . Types of Synchronization Mutual Exclusion Mutual Exclusion means that only only thread can access a shared resource at a time. This usually means, that a section of code needs to be locked (eg. with synchronize) until the thread is done with that code. Conditional Synchronization Conditional synchronization is needed when one thread waits for an event to happen in another thread. This is basicly the Producer-Consumer \"Pattern\". Producer-Consumer The producer produces some data which can be consumed by the consumer. The consumer tries to access the resource. If it is already ready, then it can just continue. If not it will wait() for the producer to notify() its monitor after which it can access the resource. The producer thread might needs to throttle itself to avoid loosing results when no consumer can consume them. Here is an example for a consumer-producer example: The while loop is necessary because when the thread calls wait() it releases the monitor the synchronize block and an other thread can enter the synchronize block and call wait() . Synchronized Queue With a queue the problem of the consumer and producer can be abstracted into a separate class to make it less brittle. Implementing the following becomes trivial: The producer fills the queue with data The consumer retrieves the data from the queue if available The consumer waits only if the queue is empty The producer waits when the queue is full Locks and Condit Problems of lack of Synchronization Lost Update A lost update happens when an write/update was overridden by another thread. Dead Locks TODO: Definition How to avoid Dead Locks Generally avoiding shared resources will avoid dead locks as well. This however isn't always possible. TODO Dining Philosophers There are 5 Philosophers. Each philosophers can either eat or think. For eating a philosopher needs two forks, but there are only 5 forks in total, so not everybody can eat at the same time. A naive solution would first let the philosophers take the right and then the left fork. This would result in everybody holding a fork in the right hand and waiting for a fork to be available resulting in a dead lock . To prevent this cyclic waiting condition the abstract can be change to always take and release two forks as one atomic action. The situation above should never happen. A second solution is to change the behavior of one philosopher to first take the left and then the right fork.","title":"Threads"},{"location":"Allgemein/PROG/5_Threads.html#threads","text":"","title":"Threads"},{"location":"Allgemein/PROG/5_Threads.html#share-data-between-multiple-threads","text":"","title":"Share Data between Multiple Threads"},{"location":"Allgemein/PROG/5_Threads.html#atomic","text":"Use the atomic","title":"Atomic"},{"location":"Allgemein/PROG/5_Threads.html#synchronized","text":"class Account { private int balance ; public synchronized void transferAmount1 ( int amount ) { this . balance += amaount ; } public void transferAmount2 ( int amount ) { synchronized ( this ) { this . balance += amaount ; } } public synchronized static staticLock1 () { //do stuff } public static staticLock1 () { synchronized ( Amount . class ) { // do stuff } } } Never call an other synchronized method which uses a different object. This can cause a dead lock.","title":"Synchronized"},{"location":"Allgemein/PROG/5_Threads.html#monitor","text":"A Java object can be used as a locked. class FooBar { private Object monitor ; public void test () { synchronized ( monitor ) { // waits for the monitor to be called with monitor.notify() or monitor.notifyAll() monitor . wait (); } } } Object.wait() blocks until Object.notify() or Object.notifyAll() is invoked on the same monitor object. notify() only wakes up one waiting Thread while notifyAll() will wake up all waiting threads. wait() releases the monitor object .","title":"Monitor"},{"location":"Allgemein/PROG/5_Threads.html#types-of-synchronization","text":"","title":"Types of Synchronization"},{"location":"Allgemein/PROG/5_Threads.html#mutual-exclusion","text":"Mutual Exclusion means that only only thread can access a shared resource at a time. This usually means, that a section of code needs to be locked (eg. with synchronize) until the thread is done with that code.","title":"Mutual Exclusion"},{"location":"Allgemein/PROG/5_Threads.html#conditional-synchronization","text":"Conditional synchronization is needed when one thread waits for an event to happen in another thread. This is basicly the Producer-Consumer \"Pattern\".","title":"Conditional Synchronization"},{"location":"Allgemein/PROG/5_Threads.html#producer-consumer","text":"The producer produces some data which can be consumed by the consumer. The consumer tries to access the resource. If it is already ready, then it can just continue. If not it will wait() for the producer to notify() its monitor after which it can access the resource. The producer thread might needs to throttle itself to avoid loosing results when no consumer can consume them. Here is an example for a consumer-producer example: The while loop is necessary because when the thread calls wait() it releases the monitor the synchronize block and an other thread can enter the synchronize block and call wait() .","title":"Producer-Consumer"},{"location":"Allgemein/PROG/5_Threads.html#synchronized-queue","text":"With a queue the problem of the consumer and producer can be abstracted into a separate class to make it less brittle. Implementing the following becomes trivial: The producer fills the queue with data The consumer retrieves the data from the queue if available The consumer waits only if the queue is empty The producer waits when the queue is full","title":"Synchronized Queue"},{"location":"Allgemein/PROG/5_Threads.html#locks-and-condit","text":"","title":"Locks and Condit"},{"location":"Allgemein/PROG/5_Threads.html#problems-of-lack-of-synchronization","text":"","title":"Problems of lack of Synchronization"},{"location":"Allgemein/PROG/5_Threads.html#lost-update","text":"A lost update happens when an write/update was overridden by another thread.","title":"Lost Update"},{"location":"Allgemein/PROG/5_Threads.html#dead-locks","text":"TODO: Definition","title":"Dead Locks"},{"location":"Allgemein/PROG/5_Threads.html#how-to-avoid-dead-locks","text":"Generally avoiding shared resources will avoid dead locks as well. This however isn't always possible. TODO","title":"How to avoid Dead Locks"},{"location":"Allgemein/PROG/5_Threads.html#dining-philosophers","text":"There are 5 Philosophers. Each philosophers can either eat or think. For eating a philosopher needs two forks, but there are only 5 forks in total, so not everybody can eat at the same time. A naive solution would first let the philosophers take the right and then the left fork. This would result in everybody holding a fork in the right hand and waiting for a fork to be available resulting in a dead lock . To prevent this cyclic waiting condition the abstract can be change to always take and release two forks as one atomic action. The situation above should never happen. A second solution is to change the behavior of one philosopher to first take the left and then the right fork.","title":"Dining Philosophers"},{"location":"Allgemein/PROG/6_IO.html","text":"IO Serializing In order for an object to be serializable in needs to implement the marker interface Serializable . Fields can be marked with transient ( private transient Date someDate; ) if they shouldn't be serialized. This can be usefull for serializing classes which contain unserializable classes (like dates, file descriptor, network sockets or db connections). Employee harry = new Employee ( \"Dirty Harry\" , 50000 , LocalDate . of ( 1967 , 3 , 11 )); Manager boss = new Manager ( \"Walter Smith\" , 80000 , LocalDate . of ( 1950 , 12 , 4 )); // Manager is extending Employee boss . setAssistant ( harry ); // Save (serialize) two objects to the file empolyee.dat try ( ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( \"employee.dat\" ))) { // objects are written in the given order to the file out . writeObject ( harry ); // write object Dirty Harry out . writeObject ( boss ); // write object Walter Smith out . writeInt ( 12 ); // write value of primitive type int } // Load (deserialize) two objects from the file employee.dat try ( ObjectInputStream in = new ObjectInputStream ( new FileInputStream ( \"employee.dat\" ))) { // number and order of reading the objects must match, also the type must be compatible (match or super class) Employee e1 = ( Employee ) in . readObject (); // object for Dirty Harry Employee e2 = ( Employee ) in . readObject (); // object for Walter Smith // e2.getClass().getName() would return type Manager int count = in . readInt (); // read primitive type int } IO Streams A byte stream can be converted to a char stream with InputStreamReader and OutputStreamWriter respectively. InputStream and Readers usually allow to skip a number of bytes/chars with skip(long n) . However, OutputStream s and Writer s don't allow removing or inserting into a file, only appending ( FileOutputStream(File file, boolean append) ) or replacing is supported. RandomAccessFile Allows reading from anywhere in the file, not just skipping bytes like an InputStream . This can be done with the seek(long pos) or the skipBytes(long n) methods. // create file and write some data into it File f = new File ( \"randomaccessfile.txt\" ); try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( f , true ))) { for ( int i = 2 ; i <= 10 ; i ++ ) { if ( i % 2 == 0 ) { bw . write ( Integer . toString ( i )); bw . newLine (); } } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"rw\" )) { // read-write mode for ( int i = 1 ; i <= 5 ; i ++ ){ randomFile . seek ( randomFile . length ()); // set file pointer to end of file (EOF) randomFile . writeBytes ( Integer . toString ( i )); // append \"1\",\"2\",\"3\",\"4\",\"5\" at EOF } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"r\" )) { // read-only mode int i = ( int ) randomFile . length (); // get length of file in bytes System . out . println ( \"Length: \" + i ); randomFile . seek ( i - 3 ); // set file pointer to EOF-3 bytes for ( int ct = 0 ; ct < 3 ; ct ++ ){ byte b = randomFile . readByte (); // read byte(s) System . out . println (( char ) b ); } } Charset An instance of Charset can be either obtained by Charset.forName(<name>) , Charset.getDefaultCharset() or Charset.getAvailableCharsets() . Alternatively StandardCharsets.UTF_8 can be used. Logger Each Logger instance has a list of Handlers . A Handler can be used by multiple Loggers and handles the storing of the logging messages (like writing it to a file, or displaying in the console). Both the Logger and the Handler have a Level. And each will only forward messages which have a level higher than their configured level. The possible levels are: SEVERE(1000) , WARNING(900) , INFO(800) , CONFIG(700) , FINE(500) , FINER(400) , FINEST(300) . The following properties file is an example logging configuration. ## configure handlers java.util.logging.ConsoleHandler.level = ALL ## File handler configuration ## see https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/FileHandler.html java.util.logging.FileHandler.level = ALL # %g = generation number, %u = unique number to resolve conflicts java.util.logging.FileHandler.pattern = log-%g-%u.log # use SimpleFormatter instead of default XMLFormatter java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.FileHandler.encoding = UTF-8 # max log file size in byte before switching to next generation (=1kB); 0 = unlimited java.util.logging.FileHandler.limit = 1024 # max number of generations (%g) before overwriting (5 -> 0..4) java.util.logging.FileHandler.count = 5 java.util.logging.FileHandler.append = true ## configure Formatter (see SimpleFormatter documentation) java.util.logging.SimpleFormatter.format = [%1$tc] %4$s: %5$s {%2$s}%6$s%n ## configure default log level (for all loggers, if not overwritten below) .level = INFO ## configure root logger \"\" handlers = java.util.logging.ConsoleHandler level = INFO ## Application specific logger configuration # loggers starting with \"ch.zhaw.prog2.io\" -> write to console and file and do not forward to parent handlers ch.zhaw.prog2.io.level = FINE ch.zhaw.prog2.io.handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler ch.zhaw.prog2.io.useParentHandlers = false # logger for class ch.zhaw.prog2.io.LogConfiguration ch.zhaw.prog2.io.LogConfiguration.level = FINEST A log configuration can be loaded anytime and all already existing loggers will be updated. InputStream logConfig = this . getClass (). getClassLoader (). getResourceAsStream ( \"log.properties\" ); LogManager . getLogManager (). readConfiguration ( logConfig );","title":"IO"},{"location":"Allgemein/PROG/6_IO.html#io","text":"","title":"IO"},{"location":"Allgemein/PROG/6_IO.html#serializing","text":"In order for an object to be serializable in needs to implement the marker interface Serializable . Fields can be marked with transient ( private transient Date someDate; ) if they shouldn't be serialized. This can be usefull for serializing classes which contain unserializable classes (like dates, file descriptor, network sockets or db connections). Employee harry = new Employee ( \"Dirty Harry\" , 50000 , LocalDate . of ( 1967 , 3 , 11 )); Manager boss = new Manager ( \"Walter Smith\" , 80000 , LocalDate . of ( 1950 , 12 , 4 )); // Manager is extending Employee boss . setAssistant ( harry ); // Save (serialize) two objects to the file empolyee.dat try ( ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( \"employee.dat\" ))) { // objects are written in the given order to the file out . writeObject ( harry ); // write object Dirty Harry out . writeObject ( boss ); // write object Walter Smith out . writeInt ( 12 ); // write value of primitive type int } // Load (deserialize) two objects from the file employee.dat try ( ObjectInputStream in = new ObjectInputStream ( new FileInputStream ( \"employee.dat\" ))) { // number and order of reading the objects must match, also the type must be compatible (match or super class) Employee e1 = ( Employee ) in . readObject (); // object for Dirty Harry Employee e2 = ( Employee ) in . readObject (); // object for Walter Smith // e2.getClass().getName() would return type Manager int count = in . readInt (); // read primitive type int }","title":"Serializing"},{"location":"Allgemein/PROG/6_IO.html#io-streams","text":"A byte stream can be converted to a char stream with InputStreamReader and OutputStreamWriter respectively. InputStream and Readers usually allow to skip a number of bytes/chars with skip(long n) . However, OutputStream s and Writer s don't allow removing or inserting into a file, only appending ( FileOutputStream(File file, boolean append) ) or replacing is supported.","title":"IO Streams"},{"location":"Allgemein/PROG/6_IO.html#randomaccessfile","text":"Allows reading from anywhere in the file, not just skipping bytes like an InputStream . This can be done with the seek(long pos) or the skipBytes(long n) methods. // create file and write some data into it File f = new File ( \"randomaccessfile.txt\" ); try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( f , true ))) { for ( int i = 2 ; i <= 10 ; i ++ ) { if ( i % 2 == 0 ) { bw . write ( Integer . toString ( i )); bw . newLine (); } } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"rw\" )) { // read-write mode for ( int i = 1 ; i <= 5 ; i ++ ){ randomFile . seek ( randomFile . length ()); // set file pointer to end of file (EOF) randomFile . writeBytes ( Integer . toString ( i )); // append \"1\",\"2\",\"3\",\"4\",\"5\" at EOF } } try ( RandomAccessFile randomFile = new RandomAccessFile ( f , \"r\" )) { // read-only mode int i = ( int ) randomFile . length (); // get length of file in bytes System . out . println ( \"Length: \" + i ); randomFile . seek ( i - 3 ); // set file pointer to EOF-3 bytes for ( int ct = 0 ; ct < 3 ; ct ++ ){ byte b = randomFile . readByte (); // read byte(s) System . out . println (( char ) b ); } }","title":"RandomAccessFile"},{"location":"Allgemein/PROG/6_IO.html#charset","text":"An instance of Charset can be either obtained by Charset.forName(<name>) , Charset.getDefaultCharset() or Charset.getAvailableCharsets() . Alternatively StandardCharsets.UTF_8 can be used.","title":"Charset"},{"location":"Allgemein/PROG/6_IO.html#logger","text":"Each Logger instance has a list of Handlers . A Handler can be used by multiple Loggers and handles the storing of the logging messages (like writing it to a file, or displaying in the console). Both the Logger and the Handler have a Level. And each will only forward messages which have a level higher than their configured level. The possible levels are: SEVERE(1000) , WARNING(900) , INFO(800) , CONFIG(700) , FINE(500) , FINER(400) , FINEST(300) . The following properties file is an example logging configuration. ## configure handlers java.util.logging.ConsoleHandler.level = ALL ## File handler configuration ## see https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/FileHandler.html java.util.logging.FileHandler.level = ALL # %g = generation number, %u = unique number to resolve conflicts java.util.logging.FileHandler.pattern = log-%g-%u.log # use SimpleFormatter instead of default XMLFormatter java.util.logging.FileHandler.formatter = java.util.logging.SimpleFormatter java.util.logging.FileHandler.encoding = UTF-8 # max log file size in byte before switching to next generation (=1kB); 0 = unlimited java.util.logging.FileHandler.limit = 1024 # max number of generations (%g) before overwriting (5 -> 0..4) java.util.logging.FileHandler.count = 5 java.util.logging.FileHandler.append = true ## configure Formatter (see SimpleFormatter documentation) java.util.logging.SimpleFormatter.format = [%1$tc] %4$s: %5$s {%2$s}%6$s%n ## configure default log level (for all loggers, if not overwritten below) .level = INFO ## configure root logger \"\" handlers = java.util.logging.ConsoleHandler level = INFO ## Application specific logger configuration # loggers starting with \"ch.zhaw.prog2.io\" -> write to console and file and do not forward to parent handlers ch.zhaw.prog2.io.level = FINE ch.zhaw.prog2.io.handlers = java.util.logging.FileHandler, java.util.logging.ConsoleHandler ch.zhaw.prog2.io.useParentHandlers = false # logger for class ch.zhaw.prog2.io.LogConfiguration ch.zhaw.prog2.io.LogConfiguration.level = FINEST A log configuration can be loaded anytime and all already existing loggers will be updated. InputStream logConfig = this . getClass (). getClassLoader (). getResourceAsStream ( \"log.properties\" ); LogManager . getLogManager (). readConfiguration ( logConfig );","title":"Logger"},{"location":"Allgemein/PROG/7_Streams.html","text":"Streams Create Streams","title":"Streams"},{"location":"Allgemein/PROG/7_Streams.html#streams","text":"","title":"Streams"},{"location":"Allgemein/PROG/7_Streams.html#create-streams","text":"","title":"Create Streams"}]}